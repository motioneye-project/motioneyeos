Submitted By: Jim Gifford (patches at jg555 dot com)
Date: 2005-08-31
Initial Package Version: 0.97
Origin: OpenSolaris, Joe Ciccone, Jim Gifford
Upstream Status: N/A
Description: Adds support for Forcedeth and other NIC's
	     Fixes for GCC 4.x
	     Removal of bad network drivers
 
diff -Naur grub-0.97.orig/configure grub-0.97/configure
--- grub-0.97.orig/configure	2005-05-08 02:48:12.000000000 +0000
+++ grub-0.97/configure	2005-09-01 00:15:48.000000000 +0000
@@ -872,47 +872,32 @@
   --disable-packet-retransmission
                           turn off packet retransmission
   --enable-pci-direct     access PCI directly instead of using BIOS
-  --enable-3c509          enable 3Com509 driver
-  --enable-3c529          enable 3Com529 driver
   --enable-3c595          enable 3Com595 driver
   --enable-3c90x          enable 3Com90x driver
-  --enable-cs89x0         enable CS89x0 driver
   --enable-davicom        enable Davicom driver
-  --enable-depca          enable DEPCA and EtherWORKS driver
-  --enable-eepro          enable Etherexpress Pro/10 driver
+  --enable-e1000          enable Etherexpress Pro/1000 driver
   --enable-eepro100       enable Etherexpress Pro/100 driver
   --enable-epic100        enable SMC 83c170 EPIC/100 driver
-  --enable-3c507          enable 3Com507 driver
-  --enable-exos205        enable EXOS205 driver
-  --enable-ni5210         enable Racal-Interlan NI5210 driver
-  --enable-lance          enable Lance PCI PCNet/32 driver
-  --enable-ne2100         enable Novell NE2100 driver
-  --enable-ni6510         enable Racal-Interlan NI6510 driver
+  --enable-forcedeth      enable Nvidia Geforce driver
   --enable-natsemi        enable NatSemi DP8381x driver
-  --enable-ni5010         enable Racal-Interlan NI5010 driver
-  --enable-3c503          enable 3Com503 driver
-  --enable-ne             enable NE1000/2000 ISA driver
+  --enable-ns83820        enable NS83820 driver
   --enable-ns8390         enable NE2000 PCI driver
-  --enable-wd             enable WD8003/8013, SMC8216/8416 driver
-  --enable-otulip         enable old Tulip driver
+  --enable-pcnet32        enable AMD Lance/PCI PCNet/32 driver
+  --enable-pnic           enable Bochs Pseudo Nic driver
   --enable-rtl8139        enable Realtek 8139 driver
+  --enable-r8169          enable Realtek 8169 driver
   --enable-sis900         enable SIS 900 and SIS 7016 driver
-  --enable-sk-g16         enable Schneider and Koch G16 driver
-  --enable-smc9000        enable SMC9000 driver
-  --enable-tiara          enable Tiara driver
+  --enable-tg3            enable Broadcom Tigon3 driver
   --enable-tulip          enable Tulip driver
+  --enable-tlan           enable TI ThunderLAN driver
+  --enable-undi           enable PXE UNDI driver
   --enable-via-rhine      enable Rhine-I/II driver
-  --enable-w89c840        enable Winbond W89c840, Compex RL100-ATX driver
-  --enable-3c503-shmem    use 3c503 shared memory mode
-  --enable-3c503-aui      use AUI by default on 3c503 cards
+  --enable-w89c840        enable Winbond W89c840 driver
   --enable-compex-rl2000-fix
                           specify this if you have a Compex RL2000 PCI
-  --enable-smc9000-scan=LIST
-                          probe for SMC9000 I/O addresses using LIST
   --enable-ne-scan=LIST   probe for NE base address using LIST
   --enable-wd-default-mem=MEM
                           set the default memory location for WD/SMC
-  --enable-cs-scan=LIST   probe for CS89x0 base address using LIST
   --enable-diskless       enable diskless support
   --disable-hercules      disable hercules terminal support
   --disable-serial        disable serial terminal support
@@ -5559,7 +5544,7 @@
 
 fi;
 if test "x$enable_packet_retransmission" != xno; then
-  NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DCONGESTED=1"
+  NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DCONGESTED=1 -DCONFIG_PCI"
 fi
 
 # Check whether --enable-pci-direct or --disable-pci-direct was given.
@@ -5571,26 +5556,6 @@
   NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DCONFIG_PCI_DIRECT=1"
 fi
 
-# Check whether --enable-3c509 or --disable-3c509 was given.
-if test "${enable_3c509+set}" = set; then
-  enableval="$enable_3c509"
-
-fi;
-if test "x$enable_3c509" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_3C509"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS 3c509.o"
-fi
-
-# Check whether --enable-3c529 or --disable-3c529 was given.
-if test "${enable_3c529+set}" = set; then
-  enableval="$enable_3c529"
-
-fi;
-if test "x$enable_3c529" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_3C529=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS 3c529.o"
-fi
-
 # Check whether --enable-3c595 or --disable-3c595 was given.
 if test "${enable_3c595+set}" = set; then
   enableval="$enable_3c595"
@@ -5611,16 +5576,6 @@
   NETBOOT_DRIVERS="$NETBOOT_DRIVERS 3c90x.o"
 fi
 
-# Check whether --enable-cs89x0 or --disable-cs89x0 was given.
-if test "${enable_cs89x0+set}" = set; then
-  enableval="$enable_cs89x0"
-
-fi;
-if test "x$enable_cs89x0" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_CS89X0=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS cs89x0.o"
-fi
-
 # Check whether --enable-davicom or --disable-davicom was given.
 if test "${enable_davicom+set}" = set; then
   enableval="$enable_davicom"
@@ -5631,24 +5586,14 @@
   NETBOOT_DRIVERS="$NETBOOT_DRIVERS davicom.o"
 fi
 
-# Check whether --enable-depca or --disable-depca was given.
-if test "${enable_depca+set}" = set; then
-  enableval="$enable_depca"
+# Check whether --enable-e1000 or --disable-e1000 was given.
+if test "${enable_e1000+set}" = set; then
+  enableval="$enable_e1000"
 
 fi;
-if test "x$enable_depca" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_DEPCA=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS depca.o"
-fi
-
-# Check whether --enable-eepro or --disable-eepro was given.
-if test "${enable_eepro+set}" = set; then
-  enableval="$enable_eepro"
-
-fi;
-if test "x$enable_eepro" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_EEPRO=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS eepro.o"
+if test "x$enable_e1000" = xyes; then
+  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_E1000=1"
+  NETBOOT_DRIVERS="$NETBOOT_DRIVERS e1000.o"
 fi
 
 # Check whether --enable-eepro100 or --disable-eepro100 was given.
@@ -5671,64 +5616,14 @@
   NETBOOT_DRIVERS="$NETBOOT_DRIVERS epic100.o"
 fi
 
-# Check whether --enable-3c507 or --disable-3c507 was given.
-if test "${enable_3c507+set}" = set; then
-  enableval="$enable_3c507"
-
-fi;
-if test "x$enable_3c507" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_3C507=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS 3c507.o"
-fi
-
-# Check whether --enable-exos205 or --disable-exos205 was given.
-if test "${enable_exos205+set}" = set; then
-  enableval="$enable_exos205"
-
-fi;
-if test "x$enable_exos205" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_EXOS205=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS exos205.o"
-fi
-
-# Check whether --enable-ni5210 or --disable-ni5210 was given.
-if test "${enable_ni5210+set}" = set; then
-  enableval="$enable_ni5210"
-
-fi;
-if test "x$enable_ni5210" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_NI5210=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS ni5210.o"
-fi
-
-# Check whether --enable-lance or --disable-lance was given.
-if test "${enable_lance+set}" = set; then
-  enableval="$enable_lance"
-
-fi;
-if test "x$enable_lance" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_LANCE=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS lance.o"
-fi
-
-# Check whether --enable-ne2100 or --disable-ne2100 was given.
-if test "${enable_ne2100+set}" = set; then
-  enableval="$enable_ne2100"
-
-fi;
-if test "x$enable_ne2100" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_NE2100=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS ne2100.o"
-fi
-
-# Check whether --enable-ni6510 or --disable-ni6510 was given.
-if test "${enable_ni6510+set}" = set; then
-  enableval="$enable_ni6510"
+# Check whether --enable-forcedeth or --disable-forcedeth was given.
+if test "${enable_forcedeth+set}" = set; then
+  enableval="$enable_forcedeth"
 
 fi;
-if test "x$enable_ni6510" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_NI6510=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS ni6510.o"
+if test "x$enable_forcedeth" = xyes; then
+  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_FORCEDETH=1"
+  NETBOOT_DRIVERS="$NETBOOT_DRIVERS forcedeth.o"
 fi
 
 # Check whether --enable-natsemi or --disable-natsemi was given.
@@ -5741,34 +5636,14 @@
   NETBOOT_DRIVERS="$NETBOOT_DRIVERS natsemi.o"
 fi
 
-# Check whether --enable-ni5010 or --disable-ni5010 was given.
-if test "${enable_ni5010+set}" = set; then
-  enableval="$enable_ni5010"
+# Check whether --enable-ns83820 or --disable-ns83820 was given.
+if test "${enable_ns83820+set}" = set; then
+  enableval="$enable_ns83820"
 
 fi;
-if test "x$enable_ni5010" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_NI5010=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS ni5010.o"
-fi
-
-# Check whether --enable-3c503 or --disable-3c503 was given.
-if test "${enable_3c503+set}" = set; then
-  enableval="$enable_3c503"
-
-fi;
-if test "x$enable_3c503" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_3C503=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS 3c503.o"
-fi
-
-# Check whether --enable-ne or --disable-ne was given.
-if test "${enable_ne+set}" = set; then
-  enableval="$enable_ne"
-
-fi;
-if test "x$enable_ne" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_NE=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS ne.o"
+if test "x$enable_ns83820" = xyes; then
+  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_NS83820=1"
+  NETBOOT_DRIVERS="$NETBOOT_DRIVERS ns83820.o"
 fi
 
 # Check whether --enable-ns8390 or --disable-ns8390 was given.
@@ -5781,24 +5656,24 @@
   NETBOOT_DRIVERS="$NETBOOT_DRIVERS ns8390.o"
 fi
 
-# Check whether --enable-wd or --disable-wd was given.
-if test "${enable_wd+set}" = set; then
-  enableval="$enable_wd"
+# Check whether --enable-pcnet32 or --disable-pcnet32 was given.
+if test "${enable_pcnet32+set}" = set; then
+  enableval="$enable_pcnet32"
 
 fi;
-if test "x$enable_wd" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_WD=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS wd.o"
+if test "x$enable_pcnet32" = xyes; then
+  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_PCNET32=1"
+  NETBOOT_DRIVERS="$NETBOOT_DRIVERS pcnet32.o"
 fi
 
-# Check whether --enable-otulip or --disable-otulip was given.
-if test "${enable_otulip+set}" = set; then
-  enableval="$enable_otulip"
+# Check whether --enable-pnic or --disable-pnic was given.
+if test "${enable_pnic+set}" = set; then
+  enableval="$enable_pnic"
 
 fi;
-if test "x$enable_otulip" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_OTULIP=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS otulip.o"
+if test "x$enable_pnic" = xyes; then
+  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_PNIC=1"
+  NETBOOT_DRIVERS="$NETBOOT_DRIVERS pnic.o"
 fi
 
 # Check whether --enable-rtl8139 or --disable-rtl8139 was given.
@@ -5811,6 +5686,16 @@
   NETBOOT_DRIVERS="$NETBOOT_DRIVERS rtl8139.o"
 fi
 
+# Check whether --enable-r8169 or --disable-r8169 was given.
+if test "${enable_r8169+set}" = set; then
+  enableval="$enable_r8169"
+
+fi;
+if test "x$enable_r8169" = xyes; then
+  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_R8169=1"
+  NETBOOT_DRIVERS="$NETBOOT_DRIVERS r8169.o"
+fi
+
 # Check whether --enable-sis900 or --disable-sis900 was given.
 if test "${enable_sis900+set}" = set; then
   enableval="$enable_sis900"
@@ -5821,34 +5706,14 @@
   NETBOOT_DRIVERS="$NETBOOT_DRIVERS sis900.o"
 fi
 
-# Check whether --enable-sk-g16 or --disable-sk-g16 was given.
-if test "${enable_sk_g16+set}" = set; then
-  enableval="$enable_sk_g16"
-
-fi;
-if test "x$enable_sk_g16" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_SK_G16=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS sk_g16.o"
-fi
-
-# Check whether --enable-smc9000 or --disable-smc9000 was given.
-if test "${enable_smc9000+set}" = set; then
-  enableval="$enable_smc9000"
-
-fi;
-if test "x$enable_smc9000" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_SMC9000=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS smc9000.o"
-fi
-
-# Check whether --enable-tiara or --disable-tiara was given.
-if test "${enable_tiara+set}" = set; then
-  enableval="$enable_tiara"
+# Check whether --enable-tg3 or --disable-tg3 was given.
+if test "${enable_tg3+set}" = set; then
+  enableval="$enable_tg3"
 
 fi;
-if test "x$enable_tiara" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_TIARA=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS tiara.o"
+if test "x$enable_tg3" = xyes; then
+  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_TG3=1"
+  NETBOOT_DRIVERS="$NETBOOT_DRIVERS tg3.o"
 fi
 
 # Check whether --enable-tulip or --disable-tulip was given.
@@ -5861,6 +5726,16 @@
   NETBOOT_DRIVERS="$NETBOOT_DRIVERS tulip.o"
 fi
 
+# Check whether --enable-tlan or --disable-tlan was given.
+if test "${enable_tlan+set}" = set; then
+  enableval="$enable_tlan"
+
+fi;
+if test "x$enable_tlan" = xyes; then
+  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_TLAN=1"
+  NETBOOT_DRIVERS="$NETBOOT_DRIVERS tlan.o"
+fi
+
 # Check whether --enable-via-rhine or --disable-via-rhine was given.
 if test "${enable_via_rhine+set}" = set; then
   enableval="$enable_via_rhine"
@@ -5895,24 +5770,6 @@
   FSYS_CFLAGS="$FSYS_CFLAGS -DFSYS_TFTP=1"
 fi
 
-# Check whether --enable-3c503-shmem or --disable-3c503-shmem was given.
-if test "${enable_3c503_shmem+set}" = set; then
-  enableval="$enable_3c503_shmem"
-
-fi;
-if test "x$enable_3c503_shmem" = xyes; then
-  NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DT503_SHMEM=1"
-fi
-
-# Check whether --enable-3c503-aui or --disable-3c503-aui was given.
-if test "${enable_3c503_aui+set}" = set; then
-  enableval="$enable_3c503_aui"
-
-fi;
-if test "x$enable_3c503_aui" = xyes; then
-  NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DT503_AUI=1"
-fi
-
 # Check whether --enable-compex-rl2000-fix or --disable-compex-rl2000-fix was given.
 if test "${enable_compex_rl2000_fix+set}" = set; then
   enableval="$enable_compex_rl2000_fix"
@@ -5922,12 +5779,6 @@
   NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DCOMPEX_RL2000_FIX=1"
 fi
 
-# Check whether --enable-smc9000-scan or --disable-smc9000-scan was given.
-if test "${enable_smc9000_scan+set}" = set; then
-  enableval="$enable_smc9000_scan"
-  NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DSMC9000_SCAN=$enable_smc9000_scan"
-fi;
-
 # Check whether --enable-ne-scan or --disable-ne-scan was given.
 if test "${enable_ne_scan+set}" = set; then
   enableval="$enable_ne_scan"
@@ -5944,12 +5795,6 @@
   NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DWD_DEFAULT_MEM=0xCC000"
 fi;
 
-# Check whether --enable-cs-scan or --disable-cs-scan was given.
-if test "${enable_cs_scan+set}" = set; then
-  enableval="$enable_cs_scan"
-  NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DCS_SCAN=$enable_cs_scan"
-fi;
-
 # Check whether --enable-diskless or --disable-diskless was given.
 if test "${enable_diskless+set}" = set; then
   enableval="$enable_diskless"
diff -Naur grub-0.97.orig/configure.ac grub-0.97/configure.ac
--- grub-0.97.orig/configure.ac	2005-05-08 02:36:03.000000000 +0000
+++ grub-0.97/configure.ac	2005-09-01 00:16:05.000000000 +0000
@@ -317,7 +317,7 @@
   [  --disable-packet-retransmission
                           turn off packet retransmission])
 if test "x$enable_packet_retransmission" != xno; then
-  NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DCONGESTED=1"
+  NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DCONGESTED=1 -DCONFIG_PCI"
 fi
 
 AC_ARG_ENABLE(pci-direct,
@@ -327,20 +327,6 @@
 fi
 
 dnl Device drivers.
-AC_ARG_ENABLE(3c509,
-  [  --enable-3c509          enable 3Com509 driver])
-if test "x$enable_3c509" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_3C509"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS 3c509.o"
-fi
-
-AC_ARG_ENABLE(3c529,
-  [  --enable-3c529          enable 3Com529 driver])
-if test "x$enable_3c529" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_3C529=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS 3c529.o"
-fi
-
 AC_ARG_ENABLE(3c595,
   [  --enable-3c595          enable 3Com595 driver])
 if test "x$enable_3c595" = xyes; then
@@ -355,13 +341,6 @@
   NETBOOT_DRIVERS="$NETBOOT_DRIVERS 3c90x.o"
 fi
 
-AC_ARG_ENABLE(cs89x0,
-  [  --enable-cs89x0         enable CS89x0 driver])
-if test "x$enable_cs89x0" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_CS89X0=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS cs89x0.o"
-fi
-
 AC_ARG_ENABLE(davicom,
   [  --enable-davicom        enable Davicom driver])
 if test "x$enable_davicom" = xyes; then
@@ -369,18 +348,11 @@
   NETBOOT_DRIVERS="$NETBOOT_DRIVERS davicom.o"
 fi
 
-AC_ARG_ENABLE(depca,
-  [  --enable-depca          enable DEPCA and EtherWORKS driver])
-if test "x$enable_depca" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_DEPCA=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS depca.o"
-fi
-
-AC_ARG_ENABLE(eepro,
-  [  --enable-eepro          enable Etherexpress Pro/10 driver])
-if test "x$enable_eepro" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_EEPRO=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS eepro.o"
+AC_ARG_ENABLE(e1000,
+  [  --enable-e1000          enable Etherexpress Pro/1000 driver])
+if test "x$enable_e1000" = xyes; then
+  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_E1000=1"
+  NETBOOT_DRIVERS="$NETBOOT_DRIVERS e1000.o"
 fi
 
 AC_ARG_ENABLE(eepro100,
@@ -397,46 +369,11 @@
   NETBOOT_DRIVERS="$NETBOOT_DRIVERS epic100.o"
 fi
 
-AC_ARG_ENABLE(3c507,
-  [  --enable-3c507          enable 3Com507 driver])
-if test "x$enable_3c507" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_3C507=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS 3c507.o"
-fi
-
-AC_ARG_ENABLE(exos205,
-  [  --enable-exos205        enable EXOS205 driver])
-if test "x$enable_exos205" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_EXOS205=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS exos205.o"
-fi
-
-AC_ARG_ENABLE(ni5210,
-  [  --enable-ni5210         enable Racal-Interlan NI5210 driver])
-if test "x$enable_ni5210" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_NI5210=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS ni5210.o"
-fi
-
-AC_ARG_ENABLE(lance,
-  [  --enable-lance          enable Lance PCI PCNet/32 driver])
-if test "x$enable_lance" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_LANCE=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS lance.o"
-fi
-
-AC_ARG_ENABLE(ne2100,
-  [  --enable-ne2100         enable Novell NE2100 driver])
-if test "x$enable_ne2100" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_NE2100=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS ne2100.o"
-fi
-
-AC_ARG_ENABLE(ni6510,
-  [  --enable-ni6510         enable Racal-Interlan NI6510 driver])
-if test "x$enable_ni6510" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_NI6510=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS ni6510.o"
+AC_ARG_ENABLE(forcedeth,
+  [  --enable-forcedeth      enable Nvidia Geforce driver])
+if test "x$enable_forcedeth" = xyes; then
+  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_FORCEDETH=1"
+  NETBOOT_DRIVERS="$NETBOOT_DRIVERS forcedeth.o"
 fi
 
 AC_ARG_ENABLE(natsemi,
@@ -446,25 +383,11 @@
   NETBOOT_DRIVERS="$NETBOOT_DRIVERS natsemi.o"
 fi
 
-AC_ARG_ENABLE(ni5010,
-  [  --enable-ni5010         enable Racal-Interlan NI5010 driver])
-if test "x$enable_ni5010" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_NI5010=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS ni5010.o"
-fi
-
-AC_ARG_ENABLE(3c503,
-  [  --enable-3c503          enable 3Com503 driver])
-if test "x$enable_3c503" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_3C503=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS 3c503.o"
-fi
-
-AC_ARG_ENABLE(ne,
-  [  --enable-ne             enable NE1000/2000 ISA driver])
-if test "x$enable_ne" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_NE=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS ne.o"
+AC_ARG_ENABLE(ns83820,
+  [  --enable-ns83820        enable NS83820 driver])
+if test "x$enable_ns83820" = xyes; then
+  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_NS83820=1"
+  NETBOOT_DRIVERS="$NETBOOT_DRIVERS ns83820.o"
 fi
 
 AC_ARG_ENABLE(ns8390,
@@ -474,18 +397,18 @@
   NETBOOT_DRIVERS="$NETBOOT_DRIVERS ns8390.o"
 fi
 
-AC_ARG_ENABLE(wd,
-  [  --enable-wd             enable WD8003/8013, SMC8216/8416 driver])
-if test "x$enable_wd" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_WD=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS wd.o"
+AC_ARG_ENABLE(pcnet32,
+  [  --enable-pcnet32        enable AMD Lance/PCI PCNet/32 driver])
+if test "x$enable_pcnet32" = xyes; then
+  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_PCNET32=1"
+  NETBOOT_DRIVERS="$NETBOOT_DRIVERS pcnet32.o"
 fi
 
-AC_ARG_ENABLE(otulip,
-  [  --enable-otulip         enable old Tulip driver])
-if test "x$enable_otulip" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_OTULIP=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS otulip.o"
+AC_ARG_ENABLE(pnic,
+  [  --enable-pnic           enable Bochs Pseudo Nic driver])
+if test "x$enable_pnic" = xyes; then
+  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_PNIC=1"
+  NETBOOT_DRIVERS="$NETBOOT_DRIVERS pnic.o"
 fi
 
 AC_ARG_ENABLE(rtl8139,
@@ -495,6 +418,13 @@
   NETBOOT_DRIVERS="$NETBOOT_DRIVERS rtl8139.o"
 fi
 
+AC_ARG_ENABLE(r8169,
+  [  --enable-r8169          enable Realtek 8169 driver])
+if test "x$enable_r8169" = xyes; then
+  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_R8169=1"
+  NETBOOT_DRIVERS="$NETBOOT_DRIVERS r8169.o"
+fi
+
 AC_ARG_ENABLE(sis900,
   [  --enable-sis900         enable SIS 900 and SIS 7016 driver])
 if test "x$enable_sis900" = xyes; then
@@ -502,25 +432,11 @@
   NETBOOT_DRIVERS="$NETBOOT_DRIVERS sis900.o"
 fi
 
-AC_ARG_ENABLE(sk-g16,
-  [  --enable-sk-g16         enable Schneider and Koch G16 driver])
-if test "x$enable_sk_g16" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_SK_G16=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS sk_g16.o"
-fi
-
-AC_ARG_ENABLE(smc9000,
-  [  --enable-smc9000        enable SMC9000 driver])
-if test "x$enable_smc9000" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_SMC9000=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS smc9000.o"
-fi
-
-AC_ARG_ENABLE(tiara,
-  [  --enable-tiara          enable Tiara driver])
-if test "x$enable_tiara" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_TIARA=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS tiara.o"
+AC_ARG_ENABLE(tg3,
+  [  --enable-tg3            enable Broadcom Tigon3 driver])
+if test "x$enable_tg3" = xyes; then
+  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_TG3=1"
+  NETBOOT_DRIVERS="$NETBOOT_DRIVERS tg3.o"
 fi
 
 AC_ARG_ENABLE(tulip,
@@ -530,6 +446,13 @@
   NETBOOT_DRIVERS="$NETBOOT_DRIVERS tulip.o"
 fi
 
+AC_ARG_ENABLE(tlan,
+  [  --enable-tlan           enable TI ThunderLAN driver])
+if test "x$enable_tlan" = xyes; then
+  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_TLAN=1"
+  NETBOOT_DRIVERS="$NETBOOT_DRIVERS tlan.o"
+fi
+
 AC_ARG_ENABLE(via-rhine,
   [  --enable-via-rhine      enable Rhine-I/II driver])
 if test "x$enable_via_rhine" = xyes; then
@@ -538,7 +461,7 @@
 fi
 
 AC_ARG_ENABLE(w89c840,
-  [  --enable-w89c840        enable Winbond W89c840, Compex RL100-ATX driver])
+  [  --enable-w89c840        enable Winbond W89c840 driver])
 if test "x$enable_w89c840" = xyes; then
   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_W89C840=1"
   NETBOOT_DRIVERS="$NETBOOT_DRIVERS w89c840.o"
@@ -550,19 +473,7 @@
   FSYS_CFLAGS="$FSYS_CFLAGS -DFSYS_TFTP=1"
 fi
 
-dnl Extra options.
-AC_ARG_ENABLE(3c503-shmem,
-  [  --enable-3c503-shmem    use 3c503 shared memory mode])
-if test "x$enable_3c503_shmem" = xyes; then
-  NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DT503_SHMEM=1"
-fi
-
-AC_ARG_ENABLE(3c503-aui,
-  [  --enable-3c503-aui      use AUI by default on 3c503 cards])
-if test "x$enable_3c503_aui" = xyes; then
-  NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DT503_AUI=1"
-fi
-
+dnl extra flag for ns8390.c
 AC_ARG_ENABLE(compex-rl2000-fix,
   [  --enable-compex-rl2000-fix
                           specify this if you have a Compex RL2000 PCI])
@@ -570,11 +481,6 @@
   NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DCOMPEX_RL2000_FIX=1"
 fi
 
-AC_ARG_ENABLE(smc9000-scan,
-  [  --enable-smc9000-scan=LIST
-                          probe for SMC9000 I/O addresses using LIST],
-  [NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DSMC9000_SCAN=$enable_smc9000_scan"])
-
 AC_ARG_ENABLE(ne-scan,
   [  --enable-ne-scan=LIST   probe for NE base address using LIST],
   [NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DNE_SCAN=$enable_ne_scan"],
@@ -586,10 +492,6 @@
   [NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DWD_DEFAULT_MEM=$enable_wd_default_mem"],
   [NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DWD_DEFAULT_MEM=0xCC000"])
 
-AC_ARG_ENABLE(cs-scan,
-  [  --enable-cs-scan=LIST   probe for CS89x0 base address using LIST],
-  [NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DCS_SCAN=$enable_cs_scan"])
-
 dnl Diskless
 AC_ARG_ENABLE(diskless,
   [  --enable-diskless       enable diskless support])
diff -Naur grub-0.97.orig/netboot/3c509.h grub-0.97/netboot/3c509.h
--- grub-0.97.orig/netboot/3c509.h	2003-07-09 11:45:37.000000000 +0000
+++ grub-0.97/netboot/3c509.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,397 +0,0 @@
-/*
- * Copyright (c) 1993 Herb Peyerl (hpeyerl@novatel.ca) All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met: 1. Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer. 2. The name
- * of the author may not be used to endorse or promote products derived from
- * this software withough specific prior written permission
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
- * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
- * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * if_epreg.h,v 1.4 1994/11/13 10:12:37 gibbs Exp Modified by:
- *
- October 2, 1994
-
- Modified by: Andres Vega Garcia
-
- INRIA - Sophia Antipolis, France
- e-mail: avega@sophia.inria.fr
- finger: avega@pax.inria.fr
-
- */
-
-/*
- * Ethernet software status per interface.
- */
-/*
- * Some global constants
- */
-
-#define TX_INIT_RATE		16
-#define TX_INIT_MAX_RATE	64
-#define RX_INIT_LATENCY		64
-#define RX_INIT_EARLY_THRESH	64
-#define MIN_RX_EARLY_THRESHF	16	/* not less than ether_header */
-#define MIN_RX_EARLY_THRESHL	4
-
-#define EEPROMSIZE	0x40
-#define MAX_EEPROMBUSY	1000
-#define EP_LAST_TAG	0xd7
-#define EP_MAX_BOARDS	16
-#define EP_ID_PORT	0x100
-
-/*
- * some macros to acces long named fields
- */
-#define IS_BASE (eth_nic_base)
-#define BASE	(eth_nic_base)
-
-/*
- * Commands to read/write EEPROM trough EEPROM command register (Window 0,
- * Offset 0xa)
- */
-#define EEPROM_CMD_RD	0x0080	/* Read:  Address required (5 bits) */
-#define EEPROM_CMD_WR	0x0040	/* Write: Address required (5 bits) */
-#define EEPROM_CMD_ERASE 0x00c0	/* Erase: Address required (5 bits) */
-#define EEPROM_CMD_EWEN	0x0030	/* Erase/Write Enable: No data required */
-
-#define EEPROM_BUSY		(1<<15)
-#define EEPROM_TST_MODE		(1<<14)
-
-/*
- * Some short functions, worth to let them be a macro
- */
-#define is_eeprom_busy(b) (inw((b)+EP_W0_EEPROM_COMMAND)&EEPROM_BUSY)
-#define GO_WINDOW(x)	outw(WINDOW_SELECT|(x), BASE+EP_COMMAND)
-
-/**************************************************************************
- *
- * These define the EEPROM data structure.  They are used in the probe
- * function to verify the existance of the adapter after having sent
- * the ID_Sequence.
- *
- * There are others but only the ones we use are defined here.
- *
- **************************************************************************/
-
-#define EEPROM_NODE_ADDR_0	0x0	/* Word */
-#define EEPROM_NODE_ADDR_1	0x1	/* Word */
-#define EEPROM_NODE_ADDR_2	0x2	/* Word */
-#define EEPROM_PROD_ID		0x3	/* 0x9[0-f]50 */
-#define EEPROM_MFG_ID		0x7	/* 0x6d50 */
-#define EEPROM_ADDR_CFG		0x8	/* Base addr */
-#define EEPROM_RESOURCE_CFG	0x9	/* IRQ. Bits 12-15 */
-
-/**************************************************************************
- *
- * These are the registers for the 3Com 3c509 and their bit patterns when
- * applicable.  They have been taken out the the "EtherLink III Parallel
- * Tasking EISA and ISA Technical Reference" "Beta Draft 10/30/92" manual
- * from 3com.
- *
- **************************************************************************/
-
-#define EP_COMMAND		0x0e	/* Write. BASE+0x0e is always a
-					 * command reg. */
-#define EP_STATUS		0x0e	/* Read. BASE+0x0e is always status
-					 * reg. */
-#define EP_WINDOW		0x0f	/* Read. BASE+0x0f is always window
-					 * reg. */
-/*
- * Window 0 registers. Setup.
- */
-/* Write */
-#define EP_W0_EEPROM_DATA	0x0c
-#define EP_W0_EEPROM_COMMAND	0x0a
-#define EP_W0_RESOURCE_CFG	0x08
-#define EP_W0_ADDRESS_CFG	0x06
-#define EP_W0_CONFIG_CTRL	0x04
-/* Read */
-#define EP_W0_PRODUCT_ID	0x02
-#define EP_W0_MFG_ID		0x00
-
-/*
- * Window 1 registers. Operating Set.
- */
-/* Write */
-#define EP_W1_TX_PIO_WR_2	0x02
-#define EP_W1_TX_PIO_WR_1	0x00
-/* Read */
-#define EP_W1_FREE_TX		0x0c
-#define EP_W1_TX_STATUS		0x0b	/* byte */
-#define EP_W1_TIMER		0x0a	/* byte */
-#define EP_W1_RX_STATUS		0x08
-#define EP_W1_RX_PIO_RD_2	0x02
-#define EP_W1_RX_PIO_RD_1	0x00
-
-/*
- * Window 2 registers. Station Address Setup/Read
- */
-/* Read/Write */
-#define EP_W2_ADDR_5		0x05
-#define EP_W2_ADDR_4		0x04
-#define EP_W2_ADDR_3		0x03
-#define EP_W2_ADDR_2		0x02
-#define EP_W2_ADDR_1		0x01
-#define EP_W2_ADDR_0		0x00
-
-/*
- * Window 3 registers.  FIFO Management.
- */
-/* Read */
-#define EP_W3_FREE_TX		0x0c
-#define EP_W3_FREE_RX		0x0a
-
-/*
- * Window 4 registers. Diagnostics.
- */
-/* Read/Write */
-#define EP_W4_MEDIA_TYPE	0x0a
-#define EP_W4_CTRLR_STATUS	0x08
-#define EP_W4_NET_DIAG		0x06
-#define EP_W4_FIFO_DIAG		0x04
-#define EP_W4_HOST_DIAG		0x02
-#define EP_W4_TX_DIAG		0x00
-
-/*
- * Window 5 Registers.  Results and Internal status.
- */
-/* Read */
-#define EP_W5_READ_0_MASK	0x0c
-#define EP_W5_INTR_MASK		0x0a
-#define EP_W5_RX_FILTER		0x08
-#define EP_W5_RX_EARLY_THRESH	0x06
-#define EP_W5_TX_AVAIL_THRESH	0x02
-#define EP_W5_TX_START_THRESH	0x00
-
-/*
- * Window 6 registers. Statistics.
- */
-/* Read/Write */
-#define TX_TOTAL_OK		0x0c
-#define RX_TOTAL_OK		0x0a
-#define TX_DEFERRALS		0x08
-#define RX_FRAMES_OK		0x07
-#define TX_FRAMES_OK		0x06
-#define RX_OVERRUNS		0x05
-#define TX_COLLISIONS		0x04
-#define TX_AFTER_1_COLLISION	0x03
-#define TX_AFTER_X_COLLISIONS	0x02
-#define TX_NO_SQE		0x01
-#define TX_CD_LOST		0x00
-
-/****************************************
- *
- * Register definitions.
- *
- ****************************************/
-
-/*
- * Command register. All windows.
- *
- * 16 bit register.
- *     15-11:  5-bit code for command to be executed.
- *     10-0:   11-bit arg if any. For commands with no args;
- *	      this can be set to anything.
- */
-#define GLOBAL_RESET		(unsigned short) 0x0000	/* Wait at least 1ms
-							 * after issuing */
-#define WINDOW_SELECT		(unsigned short) (0x1<<11)
-#define START_TRANSCEIVER	(unsigned short) (0x2<<11)	/* Read ADDR_CFG reg to
-							 * determine whether
-							 * this is needed. If
-							 * so; wait 800 uSec
-							 * before using trans-
-							 * ceiver. */
-#define RX_DISABLE		(unsigned short) (0x3<<11)	/* state disabled on
-							 * power-up */
-#define RX_ENABLE		(unsigned short) (0x4<<11)
-#define RX_RESET		(unsigned short) (0x5<<11)
-#define RX_DISCARD_TOP_PACK	(unsigned short) (0x8<<11)
-#define TX_ENABLE		(unsigned short) (0x9<<11)
-#define TX_DISABLE		(unsigned short) (0xa<<11)
-#define TX_RESET		(unsigned short) (0xb<<11)
-#define REQ_INTR		(unsigned short) (0xc<<11)
-#define SET_INTR_MASK		(unsigned short) (0xe<<11)
-#define SET_RD_0_MASK		(unsigned short) (0xf<<11)
-#define SET_RX_FILTER		(unsigned short) (0x10<<11)
-#define FIL_INDIVIDUAL	(unsigned short) (0x1)
-#define FIL_GROUP		(unsigned short) (0x2)
-#define FIL_BRDCST	(unsigned short) (0x4)
-#define FIL_ALL		(unsigned short) (0x8)
-#define SET_RX_EARLY_THRESH	(unsigned short) (0x11<<11)
-#define SET_TX_AVAIL_THRESH	(unsigned short) (0x12<<11)
-#define SET_TX_START_THRESH	(unsigned short) (0x13<<11)
-#define STATS_ENABLE		(unsigned short) (0x15<<11)
-#define STATS_DISABLE		(unsigned short) (0x16<<11)
-#define STOP_TRANSCEIVER	(unsigned short) (0x17<<11)
-/*
- * The following C_* acknowledge the various interrupts. Some of them don't
- * do anything.  See the manual.
- */
-#define ACK_INTR		(unsigned short) (0x6800)
-#define C_INTR_LATCH	(unsigned short) (ACK_INTR|0x1)
-#define C_CARD_FAILURE	(unsigned short) (ACK_INTR|0x2)
-#define C_TX_COMPLETE	(unsigned short) (ACK_INTR|0x4)
-#define C_TX_AVAIL	(unsigned short) (ACK_INTR|0x8)
-#define C_RX_COMPLETE	(unsigned short) (ACK_INTR|0x10)
-#define C_RX_EARLY	(unsigned short) (ACK_INTR|0x20)
-#define C_INT_RQD		(unsigned short) (ACK_INTR|0x40)
-#define C_UPD_STATS	(unsigned short) (ACK_INTR|0x80)
-
-/*
- * Status register. All windows.
- *
- *     15-13:  Window number(0-7).
- *     12:     Command_in_progress.
- *     11:     reserved.
- *     10:     reserved.
- *     9:      reserved.
- *     8:      reserved.
- *     7:      Update Statistics.
- *     6:      Interrupt Requested.
- *     5:      RX Early.
- *     4:      RX Complete.
- *     3:      TX Available.
- *     2:      TX Complete.
- *     1:      Adapter Failure.
- *     0:      Interrupt Latch.
- */
-#define S_INTR_LATCH		(unsigned short) (0x1)
-#define S_CARD_FAILURE		(unsigned short) (0x2)
-#define S_TX_COMPLETE		(unsigned short) (0x4)
-#define S_TX_AVAIL		(unsigned short) (0x8)
-#define S_RX_COMPLETE		(unsigned short) (0x10)
-#define S_RX_EARLY		(unsigned short) (0x20)
-#define S_INT_RQD		(unsigned short) (0x40)
-#define S_UPD_STATS		(unsigned short) (0x80)
-#define S_5_INTS		(S_CARD_FAILURE|S_TX_COMPLETE|\
-				 S_TX_AVAIL|S_RX_COMPLETE|S_RX_EARLY)
-#define S_COMMAND_IN_PROGRESS	(unsigned short) (0x1000)
-
-/*
- * FIFO Registers.
- * RX Status. Window 1/Port 08
- *
- *     15:     Incomplete or FIFO empty.
- *     14:     1: Error in RX Packet   0: Incomplete or no error.
- *     13-11:  Type of error.
- *	      1000 = Overrun.
- *	      1011 = Run Packet Error.
- *	      1100 = Alignment Error.
- *	      1101 = CRC Error.
- *	      1001 = Oversize Packet Error (>1514 bytes)
- *	      0010 = Dribble Bits.
- *	      (all other error codes, no errors.)
- *
- *     10-0:   RX Bytes (0-1514)
- */
-#define ERR_RX_INCOMPLETE	(unsigned short) (0x1<<15)
-#define ERR_RX			(unsigned short) (0x1<<14)
-#define ERR_RX_OVERRUN		(unsigned short) (0x8<<11)
-#define ERR_RX_RUN_PKT		(unsigned short) (0xb<<11)
-#define ERR_RX_ALIGN		(unsigned short) (0xc<<11)
-#define ERR_RX_CRC		(unsigned short) (0xd<<11)
-#define ERR_RX_OVERSIZE		(unsigned short) (0x9<<11)
-#define ERR_RX_DRIBBLE		(unsigned short) (0x2<<11)
-
-/*
- * FIFO Registers.
- * TX Status. Window 1/Port 0B
- *
- *   Reports the transmit status of a completed transmission. Writing this
- *   register pops the transmit completion stack.
- *
- *   Window 1/Port 0x0b.
- *
- *     7:      Complete
- *     6:      Interrupt on successful transmission requested.
- *     5:      Jabber Error (TP Only, TX Reset required. )
- *     4:      Underrun (TX Reset required. )
- *     3:      Maximum Collisions.
- *     2:      TX Status Overflow.
- *     1-0:    Undefined.
- *
- */
-#define TXS_COMPLETE		0x80
-#define TXS_SUCCES_INTR_REQ		0x40
-#define TXS_JABBER		0x20
-#define TXS_UNDERRUN		0x10
-#define TXS_MAX_COLLISION	0x8
-#define TXS_STATUS_OVERFLOW	0x4
-
-/*
- * Configuration control register.
- * Window 0/Port 04
- */
-/* Read */
-#define IS_AUI				(1<<13)
-#define IS_BNC				(1<<12)
-#define IS_UTP				(1<<9)
-/* Write */
-#define ENABLE_DRQ_IRQ			0x0001
-#define W0_P4_CMD_RESET_ADAPTER		0x4
-#define W0_P4_CMD_ENABLE_ADAPTER	0x1
-/*
- * Media type and status.
- * Window 4/Port 0A
- */
-#define ENABLE_UTP			0xc0
-#define DISABLE_UTP			0x0
-
-/*
- * Resource control register
- */
-
-#define SET_IRQ(i)	( ((i)<<12) | 0xF00) /* set IRQ i */
-
-/*
- * Receive status register
- */
-
-#define RX_BYTES_MASK			(unsigned short) (0x07ff)
-#define RX_ERROR	0x4000
-#define RX_INCOMPLETE	0x8000
-
-
-/*
- * Misc defines for various things.
- */
-#define ACTIVATE_ADAPTER_TO_CONFIG	0xff /* to the id_port */
-#define MFG_ID				0x6d50 /* in EEPROM and W0 ADDR_CONFIG */
-#define PROD_ID				0x9150
-
-#define AUI				0x1
-#define BNC				0x2
-#define UTP				0x4
-
-#define RX_BYTES_MASK			(unsigned short) (0x07ff)
-
- /* EISA support */
-#define EP_EISA_START			0x1000
-#define EP_EISA_W0			0x0c80
-
-#ifdef	INCLUDE_3C529
- /* MCA support */
-#define MCA_MOTHERBOARD_SETUP_REG	0x94
-#define MCA_ADAPTER_SETUP_REG		0x96
-#define MCA_MAX_SLOT_NR			8
-#define MCA_POS_REG(n)			(0x100+(n))
-#endif
-
-/*
- * Local variables:
- *  c-basic-offset: 8
- * End:
- */
diff -Naur grub-0.97.orig/netboot/3c595.c grub-0.97/netboot/3c595.c
--- grub-0.97.orig/netboot/3c595.c	2003-07-09 11:45:37.000000000 +0000
+++ grub-0.97/netboot/3c595.c	2005-08-31 19:03:35.000000000 +0000
@@ -20,6 +20,7 @@
 *
 *  Copyright (c) 1994 Herb Peyerl <hpeyerl@novatel.ca>
 *
+* timlegge	08-24-2003	Add Multicast Support
 */
 
 /* #define EDEBUG */
@@ -30,7 +31,7 @@
 #include "3c595.h"
 #include "timer.h"
 
-static unsigned short	eth_nic_base, eth_asic_base;
+static unsigned short	eth_nic_base;
 static unsigned short	vx_connector, vx_connectors;
 
 static struct connector_entry {
@@ -57,14 +58,12 @@
 static void vxgetlink(void);
 static void vxsetlink(void);
 
-#define	udelay(n)	waiton_timer2(((n)*TICKS_PER_MS)/1000)
-
 /**************************************************************************
 ETH_RESET - Reset adapter
 ***************************************************************************/
 static void t595_reset(struct nic *nic)
 {
-	int i, j;
+	int i;
 
 	/***********************************************************
 			Reset 3Com 595 card
@@ -133,7 +132,7 @@
 	outw(ACK_INTR | 0xff, BASE + VX_COMMAND);
 
 	outw(SET_RX_FILTER | FIL_INDIVIDUAL |
-	    FIL_BRDCST, BASE + VX_COMMAND);
+	    FIL_BRDCST|FIL_MULTICAST, BASE + VX_COMMAND);
 
 	vxsetlink();
 /*{
@@ -225,10 +224,9 @@
 /**************************************************************************
 ETH_POLL - Wait for a frame
 ***************************************************************************/
-static int t595_poll(struct nic *nic)
+static int t595_poll(struct nic *nic, int retrieve)
 {
 	/* common variables */
-	unsigned short type = 0;	/* used by EDEBUG */
 	/* variables for 3C595 */
 	short status, cst;
 	register short rx_fifo;
@@ -262,6 +260,8 @@
 	if (rx_fifo==0)
 		return 0;
 
+	if ( ! retrieve ) return 1;
+
 		/* read packet */
 #ifdef EDEBUG
 	printf("[l=%d",rx_fifo);
@@ -300,12 +300,15 @@
 	outw(RX_DISCARD_TOP_PACK, BASE + VX_COMMAND);
 	while (inw(BASE + VX_STATUS) & S_COMMAND_IN_PROGRESS);
 #ifdef EDEBUG
+{
+	unsigned short type = 0;	/* used by EDEBUG */
 	type = (nic->packet[12]<<8) | nic->packet[13];
 	if(nic->packet[0]+nic->packet[1]+nic->packet[2]+nic->packet[3]+nic->packet[4]+
 	    nic->packet[5] == 0xFF*ETH_ALEN)
 		printf(",t=%hX,b]",type);
 	else
 		printf(",t=%hX]",type);
+}
 #endif
 	return 1;
 }
@@ -382,9 +385,8 @@
 static void            
 vxsetlink(void)
 {       
-    int i, j, k;
+    int i, j;
     char *reason, *warning;
-    static short prev_flags;
     static char prev_conn = -1;
 
     if (prev_conn == -1) {
@@ -438,28 +440,47 @@
     GO_WINDOW(1); 
 }
 
-static void t595_disable(struct nic *nic)
+static void t595_disable(struct dev *dev)
 {
-    outw(STOP_TRANSCEIVER, BASE + VX_COMMAND);
-    udelay(8000);
-    GO_WINDOW(4);
-    outw(0, BASE + VX_W4_MEDIA_TYPE);
-    GO_WINDOW(1);
+	struct nic *nic = (struct nic *)dev;
+	t595_reset(nic);
+
+	outw(STOP_TRANSCEIVER, BASE + VX_COMMAND);
+	udelay(8000);
+	GO_WINDOW(4);
+	outw(0, BASE + VX_W4_MEDIA_TYPE);
+	GO_WINDOW(1);
+}
+
+static void t595_irq(struct nic *nic __unused, irq_action_t action __unused)
+{
+  switch ( action ) {
+  case DISABLE :
+    break;
+  case ENABLE :
+    break;
+  case FORCE :
+    break;
+  }
 }
 
 /**************************************************************************
 ETH_PROBE - Look for an adapter
 ***************************************************************************/
-struct nic *t595_probe(struct nic *nic, unsigned short *probeaddrs, struct pci_device *pci)
+static int t595_probe(struct dev *dev, struct pci_device *pci)
 {
+	struct nic *nic = (struct nic *)dev;
 	int i;
 	unsigned short *p;
 
-	if (probeaddrs == 0 || probeaddrs[0] == 0)
+	if (pci->ioaddr == 0)
 		return 0;
 /*	eth_nic_base = probeaddrs[0] & ~3; */
 	eth_nic_base = pci->ioaddr;
 
+	nic->irqno  = 0;
+	nic->ioaddr = pci->ioaddr & ~3;
+
 	GO_WINDOW(0);
 	outw(GLOBAL_RESET, BASE + VX_COMMAND);
 	VX_BUSY_WAIT;
@@ -487,14 +508,40 @@
 	printf("Ethernet address: %!\n", nic->node_addr);
 
 	t595_reset(nic);
-	nic->reset = t595_reset;
-	nic->poll = t595_poll;
+	dev->disable  = t595_disable;
+	nic->poll     = t595_poll;
 	nic->transmit = t595_transmit;
-	nic->disable = t595_disable;
-	return nic;
+	nic->irq      = t595_irq;
+	return 1;
 
 }
 
+static struct pci_id t595_nics[] = {
+PCI_ROM(0x10b7, 0x5900, "3c590",           "3Com590"),		/* Vortex 10Mbps */
+PCI_ROM(0x10b7, 0x5950, "3c595",           "3Com595"),		/* Vortex 100baseTx */
+PCI_ROM(0x10b7, 0x5951, "3c595-1",         "3Com595"),		/* Vortex 100baseT4 */
+PCI_ROM(0x10b7, 0x5952, "3c595-2",         "3Com595"),		/* Vortex 100base-MII */
+PCI_ROM(0x10b7, 0x9000, "3c900-tpo",       "3Com900-TPO"),	/* 10 Base TPO */
+PCI_ROM(0x10b7, 0x9001, "3c900-t4",        "3Com900-Combo"),	/* 10/100 T4 */
+PCI_ROM(0x10b7, 0x9004, "3c900b-tpo",      "3Com900B-TPO"),	/* 10 Base TPO */
+PCI_ROM(0x10b7, 0x9005, "3c900b-combo",    "3Com900B-Combo"),	/* 10 Base Combo */
+PCI_ROM(0x10b7, 0x9006, "3c900b-tpb2",     "3Com900B-2/T"),	/* 10 Base TP and Base2 */
+PCI_ROM(0x10b7, 0x900a, "3c900b-fl",       "3Com900B-FL"),	/* 10 Base F */
+PCI_ROM(0x10b7, 0x9800, "3c980-cyclone-1", "3Com980-Cyclone"),	/* Cyclone */
+PCI_ROM(0x10b7, 0x9805, "3c9805-1",        "3Com9805"),		/* Dual Port Server Cyclone */
+PCI_ROM(0x10b7, 0x7646, "3csoho100-tx-1",  "3CSOHO100-TX"),	/* Hurricane */
+PCI_ROM(0x10b7, 0x4500, "3c450-1",         "3Com450 HomePNA Tornado"),
+};
+
+struct pci_driver t595_driver = {
+	.type     = NIC_DRIVER,
+	.name     = "3C595",
+	.probe    = t595_probe,
+	.ids      = t595_nics,
+	.id_count = sizeof(t595_nics)/sizeof(t595_nics[0]),
+	.class    = 0,
+};
+
 /*
  * Local variables:
  *  c-basic-offset: 8
diff -Naur grub-0.97.orig/netboot/3c90x.c grub-0.97/netboot/3c90x.c
--- grub-0.97.orig/netboot/3c90x.c	2003-07-09 11:45:37.000000000 +0000
+++ grub-0.97/netboot/3c90x.c	2005-08-31 19:03:35.000000000 +0000
@@ -1,7 +1,7 @@
 /*
  * 3c90x.c -- This file implements the 3c90x driver for etherboot.  Written
  * by Greg Beeley, Greg.Beeley@LightSys.org.  Modified by Steve Smith,
- * Steve.Smith@Juno.Com
+ * Steve.Smith@Juno.Com. Alignment bug fix Neil Newell (nn@icenoir.net).
  *
  * This program Copyright (C) 1999 LightSys Technology Services, Inc.
  * Portions Copyright (C) 1999 Steve Smith
@@ -31,13 +31,15 @@
  *					Re-wrote poll and transmit for
  *					better error recovery and heavy
  *					network traffic operation
+ * v2.01    5-26-2003 NN Fixed driver alignment issue which
+ *                  caused system lockups if driver structures
+ *                  not 8-byte aligned.
  *
  */
 
 #include "etherboot.h"
 #include "nic.h"
 #include "pci.h"
-#include "cards.h"
 #include "timer.h"
 
 #define	XCVR_MAGIC	(0x5A00)
@@ -47,9 +49,6 @@
  **/
 #define	XMIT_RETRIES	250
 
-#undef	virt_to_bus
-#define	virt_to_bus(x)	((unsigned long)x)
-
 /*** Register definitions for the 3c905 ***/
 enum Registers
     {
@@ -225,7 +224,7 @@
     unsigned int	DataAddr;
     unsigned int	DataLength;
     }
-    TXD;
+    TXD __attribute__ ((aligned(8))); /* 64-bit aligned for bus mastering */
 
 /*** RX descriptor ***/
 typedef struct
@@ -235,7 +234,7 @@
     unsigned int	DataAddr;
     unsigned int	DataLength;
     }
-    RXD;
+    RXD __attribute__ ((aligned(8))); /* 64-bit aligned for bus mastering */
 
 /*** Global variables ***/
 static struct
@@ -311,6 +310,7 @@
     }
 
 
+#if 0
 /*** a3c90x_internal_WriteEepromWord - write a physical word of
  *** data to the onboard serial eeprom (not the BIOS prom, but the
  *** nvram in the card that stores, among other things, the MAC
@@ -344,8 +344,9 @@
 
     return 0;
     }
+#endif
 
-
+#if 0
 /*** a3c90x_internal_WriteEeprom - write data to the serial eeprom,
  *** and re-compute the eeprom checksum.
  ***/
@@ -384,8 +385,7 @@
 
     return 0;
     }
-
-
+#endif
 
 /*** a3c90x_reset: exported function that resets the card to its default
  *** state.  This is so the Linux driver can re-set the card up the way
@@ -393,12 +393,10 @@
  *** not alter the selected transceiver that we used to download the boot
  *** image.
  ***/
-static void
-a3c90x_reset(struct nic *nic)
+static void a3c90x_reset(void)
     {
-    int cfg;
-
 #ifdef	CFG_3C90X_PRESERVE_XCVR
+    int cfg;
     /** Read the current InternalConfig value. **/
     a3c90x_internal_SetWindow(INF_3C90X.IOAddr, winTxRxOptions3);
     cfg = inl(INF_3C90X.IOAddr + regInternalConfig_3_l);
@@ -473,7 +471,7 @@
  *** p - the pointer to the packet data itself.
  ***/
 static void
-a3c90x_transmit(struct nic *nic, const char *d, unsigned int t,
+a3c90x_transmit(struct nic *nic __unused, const char *d, unsigned int t,
                 unsigned int s, const char *p)
     {
 
@@ -553,7 +551,7 @@
 	if (status & 0x02)
 	    {
 	    printf("3C90X: Tx Reclaim Error (%hhX)\n", status);
-	    a3c90x_reset(NULL);
+	    a3c90x_reset();
 	    }
 	else if (status & 0x04)
 	    {
@@ -572,18 +570,18 @@
 	else if (status & 0x10)
 	    {
 	    printf("3C90X: Tx Underrun (%hhX)\n", status);
-	    a3c90x_reset(NULL);
+	    a3c90x_reset();
 	    }
 	else if (status & 0x20)
 	    {
 	    printf("3C90X: Tx Jabber (%hhX)\n", status);
-	    a3c90x_reset(NULL);
+	    a3c90x_reset();
 	    }
 	else if ((status & 0x80) != 0x80)
 	    {
 	    printf("3C90X: Internal Error - Incomplete Transmission (%hhX)\n",
 	           status);
-	    a3c90x_reset(NULL);
+	    a3c90x_reset();
 	    }
 	}
 
@@ -601,7 +599,7 @@
  *** in nic->packetlen.  Return 1 if a packet was found.
  ***/
 static int
-a3c90x_poll(struct nic *nic)
+a3c90x_poll(struct nic *nic, int retrieve)
     {
     int i, errcode;
 
@@ -610,6 +608,8 @@
 	return 0;
 	}
 
+    if ( ! retrieve ) return 1;
+
     /** we don't need to acknowledge rxComplete -- the upload engine
      ** does it for us.
      **/
@@ -663,34 +663,51 @@
  *** [Ken]
  ***/
 static void
-a3c90x_disable(struct nic *nic)
-    {
+a3c90x_disable(struct dev *dev __unused)
+{
+	/* reset and disable merge */
+	a3c90x_reset();
 	/* Disable the receiver and transmitter. */
 	outw(cmdRxDisable, INF_3C90X.IOAddr + regCommandIntStatus_w);
 	outw(cmdTxDisable, INF_3C90X.IOAddr + regCommandIntStatus_w);
-    }
-
+}
 
+static void a3c90x_irq(struct nic *nic __unused, irq_action_t action __unused)
+{
+  switch ( action ) {
+  case DISABLE :
+    break;
+  case ENABLE :
+    break;
+  case FORCE :
+    break;
+  }
+}
 
 /*** a3c90x_probe: exported routine to probe for the 3c905 card and perform
  *** initialization.  If this routine is called, the pci functions did find the
  *** card.  We just have to init it here.
  ***/
-struct nic*
-a3c90x_probe(struct nic *nic, unsigned short *probeaddrs, struct pci_device *pci)
-    {
+static int a3c90x_probe(struct dev *dev, struct pci_device *pci)
+{
+    struct nic *nic = (struct nic *)dev;
     int i, c;
     unsigned short eeprom[0x21];
     unsigned int cfg;
     unsigned int mopt;
+    unsigned int mstat;
     unsigned short linktype;
+#define	HWADDR_OFFSET	10
 
-    if (probeaddrs == 0 || probeaddrs[0] == 0)
+    if (pci->ioaddr == 0)
           return 0;
 
     adjust_pci_device(pci);
 
-    INF_3C90X.IOAddr = probeaddrs[0] & ~3;
+    nic->ioaddr = pci->ioaddr & ~3;
+    nic->irqno = 0;
+
+    INF_3C90X.IOAddr = pci->ioaddr & ~3;
     INF_3C90X.CurrentWindow = 255;
     switch (a3c90x_internal_ReadEeprom(INF_3C90X.IOAddr, 0x03))
 	{
@@ -756,30 +773,45 @@
            "Copyright 1999 LightSys Technology Services, Inc.\n"
            "Portions Copyright 1999 Steve Smith\n");
     printf("Provided with ABSOLUTELY NO WARRANTY.\n");
+#ifdef	CFG_3C90X_BOOTROM_FIX
+    if (INF_3C90X.isBrev)
+        {
+        printf("NOTE: 3c905b bootrom fix enabled; has side "
+	   "effects.  See 3c90x.txt for info.\n");
+	}
+#endif
     printf("-------------------------------------------------------"
            "------------------------\n");
 
     /** Retrieve the Hardware address and print it on the screen. **/
-    INF_3C90X.HWAddr[0] = eeprom[0]>>8;
-    INF_3C90X.HWAddr[1] = eeprom[0]&0xFF;
-    INF_3C90X.HWAddr[2] = eeprom[1]>>8;
-    INF_3C90X.HWAddr[3] = eeprom[1]&0xFF;
-    INF_3C90X.HWAddr[4] = eeprom[2]>>8;
-    INF_3C90X.HWAddr[5] = eeprom[2]&0xFF;
+    INF_3C90X.HWAddr[0] = eeprom[HWADDR_OFFSET + 0]>>8;
+    INF_3C90X.HWAddr[1] = eeprom[HWADDR_OFFSET + 0]&0xFF;
+    INF_3C90X.HWAddr[2] = eeprom[HWADDR_OFFSET + 1]>>8;
+    INF_3C90X.HWAddr[3] = eeprom[HWADDR_OFFSET + 1]&0xFF;
+    INF_3C90X.HWAddr[4] = eeprom[HWADDR_OFFSET + 2]>>8;
+    INF_3C90X.HWAddr[5] = eeprom[HWADDR_OFFSET + 2]&0xFF;
     printf("MAC Address = %!\n", INF_3C90X.HWAddr);
 
+    /* Test if the link is good, if not continue */
+    a3c90x_internal_SetWindow(INF_3C90X.IOAddr, winDiagnostics4);
+    mstat = inw(INF_3C90X.IOAddr + regMediaStatus_4_w);
+    if((mstat & (1<<11)) == 0) {
+	printf("Valid link not established\n");
+	return 0;
+    }
+
     /** Program the MAC address into the station address registers **/
     a3c90x_internal_SetWindow(INF_3C90X.IOAddr, winAddressing2);
-    outw(htons(eeprom[0]), INF_3C90X.IOAddr + regStationAddress_2_3w);
-    outw(htons(eeprom[1]), INF_3C90X.IOAddr + regStationAddress_2_3w+2);
-    outw(htons(eeprom[2]), INF_3C90X.IOAddr + regStationAddress_2_3w+4);
+    outw(htons(eeprom[HWADDR_OFFSET + 0]), INF_3C90X.IOAddr + regStationAddress_2_3w);
+    outw(htons(eeprom[HWADDR_OFFSET + 1]), INF_3C90X.IOAddr + regStationAddress_2_3w+2);
+    outw(htons(eeprom[HWADDR_OFFSET + 2]), INF_3C90X.IOAddr + regStationAddress_2_3w+4);
     outw(0, INF_3C90X.IOAddr + regStationMask_2_3w+0);
     outw(0, INF_3C90X.IOAddr + regStationMask_2_3w+2);
     outw(0, INF_3C90X.IOAddr + regStationMask_2_3w+4);
 
     /** Fill in our entry in the etherboot arp table **/
     for(i=0;i<ETH_ALEN;i++)
-	nic->node_addr[i] = (eeprom[i/2] >> (8*((i&1)^1))) & 0xff;
+	nic->node_addr[i] = (eeprom[HWADDR_OFFSET + i/2] >> (8*((i&1)^1))) & 0xff;
 
     /** Read the media options register, print a message and set default
      ** xcvr.
@@ -903,8 +935,8 @@
     while (inw(INF_3C90X.IOAddr + regCommandIntStatus_w) & INT_CMDINPROGRESS)
 	;
 
-    /** Set the RX filter = receive only individual pkts & bcast. **/
-    a3c90x_internal_IssueCommand(INF_3C90X.IOAddr, cmdSetRxFilter, 0x01 + 0x04);
+    /** Set the RX filter = receive only individual pkts & multicast & bcast. **/
+    a3c90x_internal_IssueCommand(INF_3C90X.IOAddr, cmdSetRxFilter, 0x01 + 0x02 + 0x04);
     a3c90x_internal_IssueCommand(INF_3C90X.IOAddr, cmdRxEnable, 0);
 
 
@@ -918,12 +950,46 @@
                                  cmdAcknowledgeInterrupt, 0x661);
 
     /** Set our exported functions **/
-    nic->reset    = a3c90x_reset;
+    dev->disable  = a3c90x_disable;
     nic->poll     = a3c90x_poll;
     nic->transmit = a3c90x_transmit;
-    nic->disable  = a3c90x_disable;
+    nic->irq      = a3c90x_irq;
 
-    return nic;
-    }
+    return 1;
+}
 
 
+static struct pci_id a3c90x_nics[] = {
+/* Original 90x revisions: */
+PCI_ROM(0x10b7, 0x9000, "3c905-tpo",     "3Com900-TPO"),	/* 10 Base TPO */
+PCI_ROM(0x10b7, 0x9001, "3c905-t4",      "3Com900-Combo"),	/* 10/100 T4 */
+PCI_ROM(0x10b7, 0x9050, "3c905-tpo100",  "3Com905-TX"),		/* 100 Base TX / 10/100 TPO */
+PCI_ROM(0x10b7, 0x9051, "3c905-combo",   "3Com905-T4"),		/* 100 Base T4 / 10 Base Combo */
+/* Newer 90xB revisions: */
+PCI_ROM(0x10b7, 0x9004, "3c905b-tpo",    "3Com900B-TPO"),	/* 10 Base TPO */
+PCI_ROM(0x10b7, 0x9005, "3c905b-combo",  "3Com900B-Combo"),	/* 10 Base Combo */
+PCI_ROM(0x10b7, 0x9006, "3c905b-tpb2",   "3Com900B-2/T"),	/* 10 Base TP and Base2 */
+PCI_ROM(0x10b7, 0x900a, "3c905b-fl",     "3Com900B-FL"),	/* 10 Base FL */
+PCI_ROM(0x10b7, 0x9055, "3c905b-tpo100", "3Com905B-TX"),	/* 10/100 TPO */
+PCI_ROM(0x10b7, 0x9056, "3c905b-t4",     "3Com905B-T4"),	/* 10/100 T4 */
+PCI_ROM(0x10b7, 0x9058, "3c905b-9058",   "3Com905B-9058"),	/* Cyclone 10/100/BNC */
+PCI_ROM(0x10b7, 0x905a, "3c905b-fx",     "3Com905B-FL"),	/* 100 Base FX / 10 Base FX */
+/* Newer 90xC revision: */
+PCI_ROM(0x10b7, 0x9200, "3c905c-tpo",    "3Com905C-TXM"),	/* 10/100 TPO (3C905C-TXM) */
+PCI_ROM(0x10b7, 0x9210, "3c920b-emb-wnm","3Com20B-EMB WNM"),
+PCI_ROM(0x10b7, 0x9800, "3c980",         "3Com980-Cyclone"),	/* Cyclone */
+PCI_ROM(0x10b7, 0x9805, "3c9805",        "3Com9805"),		/* Dual Port Server Cyclone */
+PCI_ROM(0x10b7, 0x7646, "3csoho100-tx",  "3CSOHO100-TX"),	/* Hurricane */
+PCI_ROM(0x10b7, 0x4500, "3c450",         "3Com450 HomePNA Tornado"),
+PCI_ROM(0x10b7, 0x1201, "3c982a",        "3Com982A"),
+PCI_ROM(0x10b7, 0x1202, "3c982b",        "3Com982B"),
+};
+
+struct pci_driver a3c90x_driver = {
+	.type     = NIC_DRIVER,
+	.name     = "3C90X",
+	.probe    = a3c90x_probe,
+	.ids      = a3c90x_nics,
+	.id_count = sizeof(a3c90x_nics)/sizeof(a3c90x_nics[0]),
+	.class    = 0,
+};
diff -Naur grub-0.97.orig/netboot/3c90x.txt grub-0.97/netboot/3c90x.txt
--- grub-0.97.orig/netboot/3c90x.txt	2003-07-09 11:45:37.000000000 +0000
+++ grub-0.97/netboot/3c90x.txt	1970-01-01 00:00:00.000000000 +0000
@@ -1,307 +0,0 @@
-
-	Instructions for use of the 3C90X driver for EtherBoot
-
-		Original 3C905B support by:
-			Greg Beeley (Greg.Beeley@LightSys.org),
-			LightSys Technology Services, Inc.
-			February 11, 1999
-
-		Updates for 3C90X family by:
-			Steve Smith (steve.smith@juno.com)
-			October 1, 1999
-
-		Minor documentation updates by
-			Greg Beeley (Greg.Beeley@LightSys.org)
-			March 29, 2000
-
--------------------------------------------------------------------------------
-
-I   OVERVIEW
-
-    The 3c90X series ethernet cards are a group of high-performance busmaster
-    DMA cards from 3Com.  This particular driver supports both the 3c90x and
-    the 3c90xB revision cards.  3C90xC family support has been tested to some
-    degree but not extensively.
-
-    Here's the licensing information:
-
-    This program Copyright (C) 1999 LightSys Technology Services, Inc.
-    Portions Copyright (C) 1999 Steve Smith.
-
-    This program may be re-distributed in source or binary form, modified,
-    sold, or copied for any purpose, provided that the above copyright message
-    and this text are included with all source copies or derivative works, and
-    provided that the above copyright message and this text are included in the
-    documentation of any binary-only distributions.  This program is
-    distributed WITHOUT ANY WARRANTY, without even the warranty of FITNESS FOR
-    A PARTICULAR PURPOSE or MERCHANTABILITY.  Please read the associated
-    documentation "3c90x.txt" before compiling and using this driver.
-
-
-II  FLASH PROMS
-
-    The 3c90xB cards, according to the 3Com documentation, only accept the
-    following flash memory chips:
-
-	Atmel AT29C512 (64 kilobyte)
-	Atmel AT29C010 (128 kilobyte)
-
-    The 3c90x cards, according to the 3Com documentation, accept the
-    following flash memory chips capacities:
-
-	64  kb (8 kB)
-	128 kb (16 kB)
-	256 kb (32 kB) and
-	512 kb (64 kB)
-
-    Atmel AT29C512 (64 kilobyte) chips are specifically listed for both
-    adapters, but flashing on the 3c905b cards would only be supported
-    through the Atmel parts.  Any device, of the supported size, should
-    be supported when programmed by a dedicated PROM programmer (e.g.
-    not the card).
-
-    To use this driver in such a PROM, visit Atmel's web site and download
-    their .PDF file containing a list of their distributors.  Contact the
-    distributors for pricing information.  The prices are quite reasonable
-    (about $3 US each for the 64 kB part), and are comparable to what one would
-    expect for similarly sized standard EPROMs.  And, the flash chips are much
-    easier to work with, as they don't need to be UV-erased to be reprogrammed.
-    The 3C905B card actually provides a method to program the flash memory
-    while it is resident on board the card itself; if someone would like to
-    write a small DOS program to do the programming, I can provide the
-    information about the registers and so forth.
-
-    A utility program, 3c90xutil, is provided with Etherboot in the 'contrib'
-    directory that allows for the on-board flashing of the ROM while Linux
-    is running.  The program has been successfully used under Linux, but I
-    have heard problem reports of its use under FreeBSD.  Anyone willing to
-    make it work under FreeBSD is more than welcome to do so!
-
-    You also have the option of using EPROM chips - the 3C905B-TX-NM has been
-    successfully tested with 27C256 (32kB) and 27C512 (64kB) chips with a
-    specified access time of 100ns and faster.
-
-
-III GENERAL USE
-
-    Normally, the basic procedure for using this driver is as follows:
-
-	1.  Run the 3c90xcfg program on the driver diskette to enable the
-	boot PROM and set it to 64k or 128k, as appropriate.
-	2.  Build the appropriate 3c90x.fd0 or 3c90x.fd0 floppy image with
-	possibly the value CFG_3C90X_XCVR defined to the transceiver type that
-	you want to use (i.e., 10/100 rj45, AUI, coax, MII).
-	3.  Run the floppy image on the PC to be network booted, to get
-	it configured, and to verify that it will boot properly.
-	4.  Build the 3c90x.rom or 3c90x.lzrom PROM image and program
-	it into the flash or EPROM memory chip.
-	5.  Put the PROM in the ethernet card, boot and enable 'boot from
-	network first' in the system BIOS, save and reboot.
-
-    Here are some issues to be aware of:
-
-	1.  If you experience crashes or different behaviour when using the
-	boot PROM, add the setting CFG_3C90X_BOOTROM_FIX and go through the
-	steps 2-5 above.  This works around a bug in some 3c905B cards (see
-	below), but has some side-effects which may not be desirable.
-        Please note that you have to boot off a floppy (not PROM!) once for
-        this fix to take effect.
-	2.  The possible need to manually set the CFG_3C90X_XCVR value to
-	configure the transceiver type.  Values are listed below.
-	3.  The possible need to define CFG_3C90X_PRESERVE_XCVR for use in
-	operating systems that don't intelligently determine the
-	transceiver type.
-
-    Some things that are on the 'To-Do' list, perhaps for me, but perhaps
-    for any other volunteers out there:
-
-	1.  Extend the driver to fully implement the auto-select
-	algorithm if the card has multiple media ports.
-	2.  Fix any bugs in the code <grin>....
-	3.  Extend the driver to support the 3c905c revision cards
-	"officially".  Right now, the support has been primarily empirical
-	and not based on 3c905C documentation.
-
-    Now for the details....
-
-    This driver has been tested on roughly 300 systems.  The main two
-    configuration issues to contend with are:
-
-	1.  Ensure that PCI Busmastering is enabled for the adapter (configured
-	in the CMOS setup)
-	2.  Some systems don't work properly with the adapter when plug and
-	play OS is enabled; I always set it to "No" or "Disabled" -- this makes
-	it easier and really doesn't adversely affect anything.
-
-    Roughly 95% of the systems worked when configured properly.  A few
-    have issues with booting locally once the boot PROM has been installed
-    (this number has been less than 2%).  Other configuration issues that
-    to check:
-
-	1.  Newer BIOS's actually work correctly with the network boot order.
-	Set the network adapter first.  Most older BIOS's automatically go to
-	the network boot PROM first.
-	2.  For systems where the adapter was already installed and is just
-	having the PROM installed, try setting the "reset configuration data"
-	to yes in the CMOS setup if the BIOS isn't seen at first.  If your BIOS
-	doesn't have this option, remove the card, start the system, shut down,
-	install the card and restart (or switch to a different PCI slot).
-	3.  Make sure the CMOS security settings aren't preventing a boot.
-
-    The 3c905B cards have a significant 'bug' that relates to the flash prom:
-    unless the card is set internally to the MII transceiver, it will only
-    read the first 8k of the PROM image.  Don't ask why -- it seems really
-    obscure, but it has to do with the way they mux'd the address lines
-    from the PCI bus to the ROM.  Unfortunately, most of us are not using
-    MII transceivers, and even the .lzrom image ends up being just a little
-    bit larger than 8k.  Note that the workaround for this is disabled by
-    default, because the Windows NT 4.0 driver does not like it (no packets
-    are transmitted).
-
-    So, the solution that I've used is to internally set the card's nvram
-    configuration to use MII when it boots.  The 3c905b driver does this
-    automatically.  This way, the 16k prom image can be loaded into memory,
-    and then the 3c905b driver can set the temporary configuration of the
-    card to an appropriate value, either configurable by the user or chosen
-    by the driver.
-
-    To enable the 3c905B bugfix, which is necessary for these cards when 
-    booting from the Flash ROM, define -DCFG_3C90X_BOOTROM_FIX when building,
-    create a floppy image and boot it once.
-    Thereafter, the card should accept the larger prom image.
-
-    The driver should choose an appropriate transceiver on the card.  However,
-    if it doesn't on your card or if you need to, for instance, set your
-    card to 10mbps when connected to an unmanaged 10/100 hub, you can specify
-    which transceiver you want to use.  To do this, build the 3c905b.fd0
-    image with -DCFG_3C90X_XCVR=x, where 'x' is one of the following
-    values:
-
-	0	10Base-T
-	1	10mbps AUI
-	3	10Base-2 (thinnet/coax)
-	4	100Base-TX
-	5	100Base-FX
-	6	MII
-	8	Auto-negotiation 10Base-T / 100Base-TX (usually the default)
-	9	MII External MAC Mode
-	255	Allow driver to choose an 'appropriate' media port.
-
-    Then proceed from step 2 in the above 'general use' instructions.  The
-    .rom image can be built with CFG_3C90X_XCVR set to a value, but you
-    normally don't want to do this, since it is easier to change the
-    transceiver type by rebuilding a new floppy, changing the BIOS to floppy
-    boot, booting, and then changing the BIOS back to network boot.  If
-    CFG_3C90X_XCVR is not set in a particular build, it just uses the
-    current configuration (either its 'best guess' or whatever the stored
-    CFG_3C90X_XCVR value was from the last time it was set).
-
-    [[ Note for the more technically inclined:  The CFG_3C90X_XCVR value is
-    programmed into a register in the card's NVRAM that was reserved for
-    LanWorks PROM images to use.  When the driver boots, the card comes
-    up in MII mode, and the driver checks the LanWorks register to find
-    out if the user specified a transceiver type.  If it finds that
-    information, it uses that, otherwise it picks a transceiver that the
-    card has based on the 3c905b's MediaOptions register.  This driver isn't
-    quite smart enough to always determine which media port is actually
-    _connected_; maybe someone else would like to take on that task (it
-    actually involves sending a self-directed packet and seeing if it
-    comes back.  IF it does, that port is connected). ]]
-
-    Another issue to keep in mind is that it is possible that some OS'es
-    might not be happy with the way I've handled the PROM-image hack with
-    setting MII mode on bootup.  Linux 2.0.35 does not have this problem.
-    Behavior of other systems may vary.  The 3com documentation specifically
-    says that, at least with the card that I have, the device driver in the
-    OS should auto-select the media port, so other drivers should work fine
-    with this 'hack'.  However, if yours doesn't seem to, you can try defining
-    CFG_3C90X_PRESERVE_XCVR when building to cause Etherboot to keep the
-    working setting (that allowed the bootp/tftp process) across the eth_reset
-    operation.
-
-
-IV  FOR DEVELOPERS....
-
-    If you would like to fix/extend/etc. this driver, feel free to do so; just
-    be sure you can test the modified version on the 3c905B-TX cards that the
-    driver was originally designed for.  This section of this document gives
-    some information that might be relevant to a programmer.
-
-    A.  Main Entry Point
-
-	a3c90x_probe is the main entry point for this driver.  It is referred
-	to in an array in 'config.c'.
-
-    B.  Other Important Functions
-
-	The functions a3c90x_transmit, a3c90x_poll, a3c90x_reset, and
-	a3c90x_disable are static functions that EtherBoot finds out about
-	as a  result of a3c90x_probe setting entries in the nic structure
-	for them.  The EtherBoot framework does not use interrupts.  It is
-	polled.  All transmit and receive operations are initiated by the
-	etherboot framework, not by an interrupt or by the driver.
-
-    C.  Internal Functions
-
-	The following functions are internal to the driver:
-
-	a3c90x_internal_IssueCommand - sends a command to the 3c905b card.
-	a3c90x_internal_SetWindow - shifts between one of eight register
-	windows onboard the 3c90x.  The bottom 16 bytes of the card's
-	I/O space are multiplexed among 128 bytes, only 16 of which are
-	visible at any one time.  This SetWindow function selects one of
-	the eight sets.
-	a3c90x_internal_ReadEeprom - reads a word (16 bits) from the
-	card's onboard nvram.  This is NOT the BIOS boot rom.  This is
-	where the card stores such things as its hardware address.
-	a3c90x_internal_WriteEeprom - writes a word (16 bits) to the
-	card's nvram, and recomputes the eeprom checksum.
-	a3c90x_internal_WriteEepromWord - writes a word (16 bits) to the
-	card's nvram.  Used by the above routine.
-	a3c90x_internal_WriteEepromWord - writes a word (16 bits) to the
-	card's nvram.  Used by the above routine.
-
-    D.  Globals
-
-	All global variables are inside a global structure named INF_3C90X.
-	So, wherever you see that structure referenced, you know the variable
-	is a global.  Just keeps things a little neater.
-
-    E.  Enumerations
-
-	There are quite a few enumerated type definitions for registers and
-	so forth, many for registers that I didn't even touch in the driver.
-	Register types start with 'reg', window numbers (for SetWindow)
-	start with 'win', and commands (for IssueCommand) start with 'cmd'.
-	Register offsets also include an indication in the name as to the
-	size of the register (_b = byte, _w = word, _l = long), and which
-	window the register is in, if it is windowed (0-7).
-
-    F.  Why the 'a3c90x' name?
-
-	I had to come up with a letter at the beginning of all of the
-	identifiers, since 3com so conveniently had their name start with a
-	number.  Another driver used 't' (for 'three'?); I chose 'a' for
-	no reason at all.
-
-Addendum by Jorge L. deLyra <delyra@latt.if.usp.br>, 22Nov2000 re
-working around the 3C905 hardware bug mentioned above:
-
-Use this floppy to fix any 3COM model 3C905B PCI 10/100 Ethernet cards
-that fail to load and run the boot program the first time around. If
-they have a "Lucent" rather than a "Broadcom" chipset these cards have
-a configuration bug that causes a hang when trying to load the boot
-program from the PROM, if you try to use them right out of the box.
-
-The boot program in this floppy is the file named 3c905b-tpo100.rom
-from Etherboot version 4.6.10, compiled with the bugfix parameter
-
-			CFG_3C90X_BOOTROM_FIX
-
-You have to take the chip off the card and boot the system once using
-this floppy. Once loaded from the floppy, the boot program will access
-the card and change some setting in it, correcting the problem. After
-that you may use either this boot program or the normal one, compiled
-without this bugfix parameter, to boot the machine from the PROM chip.
-
-[Any recent Etherboot version should do, not just 4.6.10 - Ed.]
diff -Naur grub-0.97.orig/netboot/Makefile.am grub-0.97/netboot/Makefile.am
--- grub-0.97.orig/netboot/Makefile.am	2003-07-09 11:45:37.000000000 +0000
+++ grub-0.97/netboot/Makefile.am	2005-08-31 19:03:35.000000000 +0000
@@ -10,58 +10,72 @@
 
 noinst_LIBRARIES = $(LIBDRIVERS)
 
-libdrivers_a_SOURCES = cards.h config.c etherboot.h \
-	fsys_tftp.c linux-asm-io.h linux-asm-string.h \
-	main.c misc.c nic.h osdep.h pci.c pci.h timer.c timer.h
-EXTRA_libdrivers_a_SOURCES = 3c509.c 3c509.h 3c595.c 3c595.h 3c90x.c \
-	cs89x0.c cs89x0.h davicom.c depca.c eepro.c eepro100.c \
-	epic100.c epic100.h fa311.c i82586.c lance.c natsemi.c \
-	ni5010.c ns8390.c ns8390.h otulip.c otulip.h rtl8139.c \
-	sis900.c sis900.h sk_g16.c sk_g16.h smc9000.c smc9000.h \
-	tiara.c tlan.c tulip.c via-rhine.c w89c840.c
+libdrivers_a_SOURCES = big_bswap.h bootp.h byteswap.h config.c cpu.h \
+	dev.h elf.h endian.h etherboot.h fsys_tftp.c grub.h \
+	i386_byteswap.h i386_elf.h i386_endian.h i386_timer.c \
+	if_arp.h if_ether.h igmp.h in.h io.h ip.h isa.h latch.h \
+	little_bswap.h misc.c nic.c nic.h osdep.h pci.c pci.h \
+	pci_ids.h pci_io.c stdint.h tftp.h timer.c timer.h \
+	types.h udp.h mii.h pic8259.c pic8259.h pxe.h basemem.c segoff.h
+EXTRA_libdrivers_a_SOURCES = 3c595.c 3c595.h 3c90x.c davicom.c \
+	e1000.c e1000_hw.h eepro100.c epic100.c epic100.h natsemi.c \
+	ns8390.c ns8390.h pcnet32.c rtl8139.c sis900.c sis900.h \
+	sundance.c tg3.c tg3.h tlan.c tlan.h tulip.c via-rhine.c \
+	w89c840.c r8169.c forcedeth.c ns83820.c pnic.c pnic_api.c \
+	undi.c undi.h
 libdrivers_a_CFLAGS = $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	-DFSYS_TFTP=1 $(NET_CFLAGS) $(NET_EXTRAFLAGS)
 # Filled by configure.
 libdrivers_a_LIBADD = @NETBOOT_DRIVERS@
 libdrivers_a_DEPENDENCIES = $(libdrivers_a_LIBADD)
 
-EXTRA_DIST = README.netboot 3c90x.txt cs89x0.txt sis900.txt tulip.txt
+EXTRA_DIST = README.netboot
 
 # These below are several special rules for the device drivers.
 # We cannot use a simple rule for them...
 
 # What objects are derived from a driver?
-3c509_drivers = 3c509.o 3c529.o
+#3c509_drivers = 3c509.o 3c529.o
 3c595_drivers = 3c595.o
 3c90x_drivers = 3c90x.o
-cs89x0_drivers = cs89x0.o
+#cs89x0_drivers = cs89x0.o
 davicom_drivers = davicom.o
-depca_drivers = depca.o
-eepro_drivers = eepro.o
+#depca_drivers = depca.o
+#eepro_drivers = eepro.o
+e1000_drivers = e1000.o
 eepro100_drivers = eepro100.o
 epic100_drivers = epic100.o
 #fa311_drivers = fa311.o
-i82586_drivers = 3c507.o exos205.o ni5210.o
-lance_drivers = lance.o ne2100.o ni6510.o
+forcedeth_drivers = forcedeth.o
+#i82586_drivers = 3c507.o exos205.o ni5210.o
+#lance_drivers = lance.o ne2100.o ni6510.o
 natsemi_drivers = natsemi.o
-ni5010_drivers = ni5010.o
+#ni5010_drivers = ni5010.o
+ns83820_drivers = ns83820.o
 ns8390_drivers = 3c503.o ne.o ns8390.o wd.o
-otulip_drivers = otulip.o
+#otulip_drivers = otulip.o
+pcnet32_drivers = pcnet32.o
+pnic_drivers = pnic.o
+r8169_drivers = r8169.o
 rtl8139_drivers = rtl8139.o
 sis900_drivers = sis900.o
-sk_g16_drivers = sk_g16.o
-smc9000_drivers = smc9000.o
-tiara_drivers = tiara.o
-#tlan_drivers = tlan.o
+#sk_g16_drivers = sk_g16.o
+sundance_driver = sundance.o
+#smc9000_drivers = smc9000.o
+tg3_drivers = tg3.o
+#tiara_drivers = tiara.o
+tlan_drivers = tlan.o
 tulip_drivers = tulip.o
+undi_drivers = undi.o
 via_rhine_drivers = via_rhine.o
 w89c840_drivers = w89c840.o
 
+
 # Is it really necessary to specify dependecies explicitly?
-$(3c509_drivers): 3c509.c 3c509.h
-$(3c509_drivers): %.o: 3c509.c
-	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
-	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+#$(3c509_drivers): 3c509.c 3c509.h
+#$(3c509_drivers): %.o: 3c509.c
+#	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+#	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
 $(3c595_drivers): 3c595.c 3c595.h
 $(3c595_drivers): %.o: 3c595.c
@@ -73,23 +87,28 @@
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-$(cs89x0_drivers): cs89x0.c cs89x0.h
-$(cs89x0_drivers): %.o: cs89x0.c
-	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
-	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+#$(cs89x0_drivers): cs89x0.c cs89x0.h
+#$(cs89x0_drivers): %.o: cs89x0.c
+#	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+#	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
 $(davicom_drivers): davicom.c
 $(davicom_drivers): %.o: davicom.c
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-$(depca_drivers): depca.c
-$(depca_drivers): %.o: depca.c
-	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
-	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+#$(depca_drivers): depca.c
+#$(depca_drivers): %.o: depca.c
+#	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+#	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+
+#$(eepro_drivers): eepro.c
+#$(eepro_drivers): %.o: eepro.c
+#	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+#	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-$(eepro_drivers): eepro.c
-$(eepro_drivers): %.o: eepro.c
+$(e1000_drivers): e1000.c e1000_hw.h
+$(e1000_drivers): %.o: e1000.c
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
@@ -103,28 +122,38 @@
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
+$(forcedeth_drivers): forcedeth.c
+$(forcedeth_drivers): %.o: forcedeth.c
+	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+
 #$(fa311_drivers): fa311.c
 #$(fa311_drivers): %.o: fa311.c
 #	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-$(i82586_drivers): i82586.c
-$(i82586_drivers): %.o: i82586.c
-	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
-	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+#$(i82586_drivers): i82586.c
+#$(i82586_drivers): %.o: i82586.c
+#	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+#	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-$(lance_drivers): lance.c
-$(lance_drivers): %.o: lance.c
-	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
-	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+#$(lance_drivers): lance.c
+#$(lance_drivers): %.o: lance.c
+#	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+#	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
 $(natsemi_drivers): natsemi.c
 $(natsemi_drivers): %.o: natsemi.c
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-$(ni5010_drivers): ni5010.c
-$(ni5010_drivers): %.o: ni5010.c
+#$(ni5010_drivers): ni5010.c
+#$(ni5010_drivers): %.o: ni5010.c
+#	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+#	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+
+$(ns83820_drivers): ns83820.c
+$(ns83820_drivers): %.o: ns83820.c
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
@@ -133,8 +162,18 @@
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-$(otulip_drivers): otulip.c otulip.h
-$(otulip_drivers): %.o: otulip.c
+#$(otulip_drivers): otulip.c otulip.h
+#$(otulip_drivers): %.o: otulip.c
+#	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+#	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+
+$(pcnet32_drivers): pcnet32.c
+$(pcnet32_drivers): %.o: pcnet32.c
+	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+
+$(pnic_drivers): pnic.c
+$(pnic_drivers): %.o: pnic.c pnic_api.h
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
@@ -143,36 +182,56 @@
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-$(sis900_drivers): sis900.c
-$(sis900_drivers): %.o: sis900.c sis900.h
+$(r8169_drivers): r8169.c
+$(r8169_drivers): %.o: r8169.c
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-$(sk_g16_drivers): sk_g16.c sk_g16.h
-$(sk_g16_drivers): %.o: sk_g16.c
+$(sis900_drivers): sis900.c sis900.h
+$(sis900_drivers): %.o: sis900.c
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-$(smc9000_drivers): smc9000.c smc9000.h
-$(smc9000_drivers): %.o: smc9000.c
+#$(sk_g16_drivers): sk_g16.c sk_g16.h
+#$(sk_g16_drivers): %.o: sk_g16.c
+#	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+#	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+
+#$(smc9000_drivers): smc9000.c smc9000.h
+#$(smc9000_drivers): %.o: smc9000.c
+#	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+#	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+
+$(sundance_drivers): sundance.c
+$(sundance_drivers): %.o: sundance.c
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-$(tiara_drivers): tiara.c
-$(tiara_drivers): %.o: tiara.c
+$(tg3_drivers): tg3.c tg3.h
+$(tg3_drivers): %.o: tg3.c
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-#$(tlan_drivers): tlan.c
-#$(tlan_drivers): %.o: tlan.c
+#$(tiara_drivers): tiara.c
+#$(tiara_drivers): %.o: tiara.c
 #	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
+$(tlan_drivers): tlan.c tlan.h
+$(tlan_drivers): %.o: tlan.c
+	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+
 $(tulip_drivers): tulip.c
 $(tulip_drivers): %.o: tulip.c
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
+$(undi_drivers): undi.c undi.h
+$(undi_drivers): %.o: undi.c
+	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+          $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+
 $(via_rhine_drivers): via-rhine.c
 $(via_rhine_drivers): %.o: via-rhine.c
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
@@ -184,36 +243,45 @@
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
 # Per-object flags.
-3c509_o_CFLAGS = -DINCLUDE_3C509=1
-3c529_o_CFLAGS = -DINCLUDE_3C529=1
+#3c509_o_CFLAGS = -DINCLUDE_3C509=1
+#3c529_o_CFLAGS = -DINCLUDE_3C529=1
 3c595_o_CFLAGS = -DINCLUDE_3C595=1
 3c90x_o_CFLAGS = -DINCLUDE_3C90X=1
-cs89x0_o_CFLAGS = -DINCLUDE_CS89X0=1
+#cs89x0_o_CFLAGS = -DINCLUDE_CS89X0=1
 davicom_o_CFLAGS = -DINCLUDE_DAVICOM=1
-depca_o_CFLAGS = -DINCLUDE_DEPCA=1
-eepro_o_CFLAGS = -DINCLUDE_EEPRO=1
+#depca_o_CFLAGS = -DINCLUDE_DEPCA=1
+#eepro_o_CFLAGS = -DINCLUDE_EEPRO=1
+e1000_o_CFLAGS = -DINCLUDE_E1000=1
 eepro100_o_CFLAGS = -DINCLUDE_EEPRO100=1
 epic100_o_CFLAGS = -DINCLUDE_EPIC100=1
 #fa311_o_CFLAGS = -DINCLUDE_FA311=1
-3c507_o_CFLAGS = -DINCLUDE_3C507=1
-exos205_o_CFLAGS = -DINCLUDE_EXOS205=1
-ni5210_o_CFLAGS = -DINCLUDE_NI5210=1
-lance_o_CFLAGS = -DINCLUDE_LANCE=1
-ne2100_o_CFLAGS = -DINCLUDE_NE2100=1
-ni6510_o_CFLAGS = -DINCLUDE_NI6510=1
+forcedeth_o_CFLAGS = -DINCLUDE_FORCEDETH=1
+#3c507_o_CFLAGS = -DINCLUDE_3C507=1
+#exos205_o_CFLAGS = -DINCLUDE_EXOS205=1
+#ni5210_o_CFLAGS = -DINCLUDE_NI5210=1
+#lance_o_CFLAGS = -DINCLUDE_LANCE=1
+#ne2100_o_CFLAGS = -DINCLUDE_NE2100=1
+#ni6510_o_CFLAGS = -DINCLUDE_NI6510=1
 natsemi_o_CFLAGS = -DINCLUDE_NATSEMI=1
-ni5010_o_CFLAGS = -DINCLUDE_NI5010=1
-3c503_o_CFLAGS = -DINCLUDE_3C503=1
-ne_o_CFLAGS = -DINCLUDE_NE=1
+#ni5010_o_CFLAGS = -DINCLUDE_NI5010=1
+#3c503_o_CFLAGS = -DINCLUDE_3C503=1
+#ne_o_CFLAGS = -DINCLUDE_NE=1
+ns83820_o_CFLAGS = -DINCLUDE_NS83820=1
 ns8390_o_CFLAGS = -DINCLUDE_NS8390=1
-wd_o_CFLAGS = -DINCLUDE_WD=1
-otulip_o_CFLAGS = -DINCLUDE_OTULIP=1
+#wd_o_CFLAGS = -DINCLUDE_WD=1
+#otulip_o_CFLAGS = -DINCLUDE_OTULIP=1
+pcnet32_o_CFLAGS = -DINCLUDE_PCNET32=1
+pnic_o_CFLAGS = -DINCLUDE_PNIC=1
+r8169_o_CFLAGS = -DINCLUDE_R8169=1
 rtl8139_o_CFLAGS = -DINCLUDE_RTL8139=1
 sis900_o_CFLAGS = -DINCLUDE_SIS900=1
-sk_g16_o_CFLAGS = -DINCLUDE_SK_G16=1
-smc9000_o_CFLAGS = -DINCLUDE_SMC9000=1
-tiara_o_CFLAGS = -DINCLUDE_TIARA=1
-#tlan_o_CFLAGS = -DINCLUDE_TLAN=1
+#sk_g16_o_CFLAGS = -DINCLUDE_SK_G16=1
+#smc9000_o_CFLAGS = -DINCLUDE_SMC9000=1
+sundance_o_CFLAGS = -DINCLUDE_SUNDANCE=1
+#tiara_o_CFLAGS = -DINCLUDE_TIARA=1
+tg3_o_CFLAGS = -DINCLUDE_TG3=1
+tlan_o_CFLAGS = -DINCLUDE_TLAN=1
 tulip_o_CFLAGS = -DINCLUDE_TULIP=1
+undi_o_CFLAGS = -DINCLUDE_UNDI=1
 via_rhine_o_CFLAGS = -DINCLUDE_VIA_RHINE=1
 w89c840_o_CFLAGS = -DINCLUDE_W89C840=1
diff -Naur grub-0.97.orig/netboot/Makefile.in grub-0.97/netboot/Makefile.in
--- grub-0.97.orig/netboot/Makefile.in	2005-05-08 02:42:35.000000000 +0000
+++ grub-0.97/netboot/Makefile.in	2005-09-01 00:14:15.000000000 +0000
@@ -48,18 +47,51 @@
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
 CONFIG_HEADER = $(top_builddir)/config.h
 CONFIG_CLEAN_FILES =
-LIBRARIES = $(noinst_LIBRARIES)
 AR = ar
 ARFLAGS = cru
+LIBRARIES = $(noinst_LIBRARIES)
 libdrivers_a_AR = $(AR) $(ARFLAGS)
 am_libdrivers_a_OBJECTS = libdrivers_a-config.$(OBJEXT) \
-	libdrivers_a-fsys_tftp.$(OBJEXT) libdrivers_a-main.$(OBJEXT) \
-	libdrivers_a-misc.$(OBJEXT) libdrivers_a-pci.$(OBJEXT) \
-	libdrivers_a-timer.$(OBJEXT)
+	libdrivers_a-fsys_tftp.$(OBJEXT) \
+	libdrivers_a-i386_timer.$(OBJEXT) libdrivers_a-misc.$(OBJEXT) \
+	libdrivers_a-nic.$(OBJEXT) libdrivers_a-pci.$(OBJEXT) \
+	libdrivers_a-pci_io.$(OBJEXT) libdrivers_a-timer.$(OBJEXT) \
+	libdrivers_a-pic8259.$(OBJEXT) libdrivers_a-basemem.$(OBJEXT)
 libdrivers_a_OBJECTS = $(am_libdrivers_a_OBJECTS)
 DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
+@AMDEP_TRUE@DEP_FILES = ./$(DEPDIR)/libdrivers_a-3c595.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-3c90x.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-basemem.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-config.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-davicom.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-e1000.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-eepro100.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-epic100.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-forcedeth.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-fsys_tftp.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-i386_timer.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-misc.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-natsemi.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-nic.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-ns83820.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-ns8390.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-pci.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-pci_io.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-pcnet32.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-pic8259.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-pnic.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-pnic_api.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-r8169.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-rtl8139.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-sis900.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-tg3.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-timer.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-tlan.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-tulip.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-via-rhine.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-w89c840.Po
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 CCLD = $(CC)
@@ -148,8 +180,6 @@
 am__include = @am__include@
 am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
-am__tar = @am__tar@
-am__untar = @am__untar@
 bindir = @bindir@
 build = @build@
 build_alias = @build_alias@
@@ -186,16 +216,19 @@
 # Don't build the netboot support by default.
 @NETBOOT_SUPPORT_TRUE@LIBDRIVERS = libdrivers.a
 noinst_LIBRARIES = $(LIBDRIVERS)
-libdrivers_a_SOURCES = cards.h config.c etherboot.h \
-	fsys_tftp.c linux-asm-io.h linux-asm-string.h \
-	main.c misc.c nic.h osdep.h pci.c pci.h timer.c timer.h
-
-EXTRA_libdrivers_a_SOURCES = 3c509.c 3c509.h 3c595.c 3c595.h 3c90x.c \
-	cs89x0.c cs89x0.h davicom.c depca.c eepro.c eepro100.c \
-	epic100.c epic100.h fa311.c i82586.c lance.c natsemi.c \
-	ni5010.c ns8390.c ns8390.h otulip.c otulip.h rtl8139.c \
-	sis900.c sis900.h sk_g16.c sk_g16.h smc9000.c smc9000.h \
-	tiara.c tlan.c tulip.c via-rhine.c w89c840.c
+libdrivers_a_SOURCES = big_bswap.h bootp.h byteswap.h config.c cpu.h \
+	dev.h elf.h endian.h etherboot.h fsys_tftp.c grub.h \
+	i386_byteswap.h i386_elf.h i386_endian.h i386_timer.c \
+	if_arp.h if_ether.h igmp.h in.h io.h ip.h isa.h latch.h \
+	little_bswap.h misc.c nic.c nic.h osdep.h pci.c pci.h \
+	pci_ids.h pci_io.c stdint.h tftp.h timer.c timer.h \
+	types.h udp.h mii.h pic8259.c pic8259.h pxe.h basemem.c segoff.h
+
+EXTRA_libdrivers_a_SOURCES = 3c595.c 3c595.h 3c90x.c davicom.c \
+	e1000.c e1000_hw.h eepro100.c epic100.c epic100.h natsemi.c \
+	ns8390.c ns8390.h pcnet32.c rtl8139.c sis900.c sis900.h \
+	tg3.c tg3.h tlan.c tlan.h tulip.c via-rhine.c \
+	w89c840.c r8169.c forcedeth.c ns83820.c pnic.c pnic_api.c 
 
 libdrivers_a_CFLAGS = $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	-DFSYS_TFTP=1 $(NET_CFLAGS) $(NET_EXTRAFLAGS)
@@ -203,69 +236,83 @@
 # Filled by configure.
 libdrivers_a_LIBADD = @NETBOOT_DRIVERS@
 libdrivers_a_DEPENDENCIES = $(libdrivers_a_LIBADD)
-EXTRA_DIST = README.netboot 3c90x.txt cs89x0.txt sis900.txt tulip.txt
+EXTRA_DIST = README.netboot
 
 # These below are several special rules for the device drivers.
 # We cannot use a simple rule for them...
 
 # What objects are derived from a driver?
-3c509_drivers = 3c509.o 3c529.o
+#3c509_drivers = 3c509.o 3c529.o
 3c595_drivers = 3c595.o
 3c90x_drivers = 3c90x.o
-cs89x0_drivers = cs89x0.o
+#cs89x0_drivers = cs89x0.o
 davicom_drivers = davicom.o
-depca_drivers = depca.o
-eepro_drivers = eepro.o
+#depca_drivers = depca.o
+#eepro_drivers = eepro.o
+e1000_drivers = e1000.o
 eepro100_drivers = eepro100.o
 epic100_drivers = epic100.o
 #fa311_drivers = fa311.o
-i82586_drivers = 3c507.o exos205.o ni5210.o
-lance_drivers = lance.o ne2100.o ni6510.o
+forcedeth_drivers = forcedeth.o
+#i82586_drivers = 3c507.o exos205.o ni5210.o
+#lance_drivers = lance.o ne2100.o ni6510.o
 natsemi_drivers = natsemi.o
-ni5010_drivers = ni5010.o
+#ni5010_drivers = ni5010.o
+ns83820_drivers = ns83820.o
 ns8390_drivers = 3c503.o ne.o ns8390.o wd.o
-otulip_drivers = otulip.o
+#otulip_drivers = otulip.o
+pcnet32_drivers = pcnet32.o
+pnic_drivers = pnic.o
+r8169_drivers = r8169.o
 rtl8139_drivers = rtl8139.o
 sis900_drivers = sis900.o
-sk_g16_drivers = sk_g16.o
-smc9000_drivers = smc9000.o
-tiara_drivers = tiara.o
-#tlan_drivers = tlan.o
+#sk_g16_drivers = sk_g16.o
+#smc9000_drivers = smc9000.o
+tg3_drivers = tg3.o
+#tiara_drivers = tiara.o
+tlan_drivers = tlan.o
 tulip_drivers = tulip.o
 via_rhine_drivers = via_rhine.o
 w89c840_drivers = w89c840.o
 
 # Per-object flags.
-3c509_o_CFLAGS = -DINCLUDE_3C509=1
-3c529_o_CFLAGS = -DINCLUDE_3C529=1
+#3c509_o_CFLAGS = -DINCLUDE_3C509=1
+#3c529_o_CFLAGS = -DINCLUDE_3C529=1
 3c595_o_CFLAGS = -DINCLUDE_3C595=1
 3c90x_o_CFLAGS = -DINCLUDE_3C90X=1
-cs89x0_o_CFLAGS = -DINCLUDE_CS89X0=1
+#cs89x0_o_CFLAGS = -DINCLUDE_CS89X0=1
 davicom_o_CFLAGS = -DINCLUDE_DAVICOM=1
-depca_o_CFLAGS = -DINCLUDE_DEPCA=1
-eepro_o_CFLAGS = -DINCLUDE_EEPRO=1
+#depca_o_CFLAGS = -DINCLUDE_DEPCA=1
+#eepro_o_CFLAGS = -DINCLUDE_EEPRO=1
+e1000_o_CFLAGS = -DINCLUDE_E1000=1
 eepro100_o_CFLAGS = -DINCLUDE_EEPRO100=1
 epic100_o_CFLAGS = -DINCLUDE_EPIC100=1
 #fa311_o_CFLAGS = -DINCLUDE_FA311=1
-3c507_o_CFLAGS = -DINCLUDE_3C507=1
-exos205_o_CFLAGS = -DINCLUDE_EXOS205=1
-ni5210_o_CFLAGS = -DINCLUDE_NI5210=1
-lance_o_CFLAGS = -DINCLUDE_LANCE=1
-ne2100_o_CFLAGS = -DINCLUDE_NE2100=1
-ni6510_o_CFLAGS = -DINCLUDE_NI6510=1
+forcedeth_o_CFLAGS = -DINCLUDE_FORCEDETH=1
+#3c507_o_CFLAGS = -DINCLUDE_3C507=1
+#exos205_o_CFLAGS = -DINCLUDE_EXOS205=1
+#ni5210_o_CFLAGS = -DINCLUDE_NI5210=1
+#lance_o_CFLAGS = -DINCLUDE_LANCE=1
+#ne2100_o_CFLAGS = -DINCLUDE_NE2100=1
+#ni6510_o_CFLAGS = -DINCLUDE_NI6510=1
 natsemi_o_CFLAGS = -DINCLUDE_NATSEMI=1
-ni5010_o_CFLAGS = -DINCLUDE_NI5010=1
-3c503_o_CFLAGS = -DINCLUDE_3C503=1
-ne_o_CFLAGS = -DINCLUDE_NE=1
+#ni5010_o_CFLAGS = -DINCLUDE_NI5010=1
+#3c503_o_CFLAGS = -DINCLUDE_3C503=1
+#ne_o_CFLAGS = -DINCLUDE_NE=1
+ns83820_o_CFLAGS = -DINCLUDE_NS83820=1
 ns8390_o_CFLAGS = -DINCLUDE_NS8390=1
-wd_o_CFLAGS = -DINCLUDE_WD=1
-otulip_o_CFLAGS = -DINCLUDE_OTULIP=1
+#wd_o_CFLAGS = -DINCLUDE_WD=1
+#otulip_o_CFLAGS = -DINCLUDE_OTULIP=1
+pcnet32_o_CFLAGS = -DINCLUDE_PCNET32=1
+pnic_o_CFLAGS = -DINCLUDE_PNIC=1
+r8169_o_CFLAGS = -DINCLUDE_R8169=1
 rtl8139_o_CFLAGS = -DINCLUDE_RTL8139=1
 sis900_o_CFLAGS = -DINCLUDE_SIS900=1
-sk_g16_o_CFLAGS = -DINCLUDE_SK_G16=1
-smc9000_o_CFLAGS = -DINCLUDE_SMC9000=1
-tiara_o_CFLAGS = -DINCLUDE_TIARA=1
-#tlan_o_CFLAGS = -DINCLUDE_TLAN=1
+#sk_g16_o_CFLAGS = -DINCLUDE_SK_G16=1
+#smc9000_o_CFLAGS = -DINCLUDE_SMC9000=1
+#tiara_o_CFLAGS = -DINCLUDE_TIARA=1
+tg3_o_CFLAGS = -DINCLUDE_TG3=1
+tlan_o_CFLAGS = -DINCLUDE_TLAN=1
 tulip_o_CFLAGS = -DINCLUDE_TULIP=1
 via_rhine_o_CFLAGS = -DINCLUDE_VIA_RHINE=1
 w89c840_o_CFLAGS = -DINCLUDE_W89C840=1
@@ -316,32 +363,32 @@
 distclean-compile:
 	-rm -f *.tab.c
 
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-3c509.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-3c595.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-3c90x.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-basemem.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-config.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-cs89x0.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-davicom.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-depca.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-eepro.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-e1000.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-eepro100.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-epic100.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-fa311.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-forcedeth.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-fsys_tftp.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-i82586.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-lance.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-main.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-i386_timer.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-misc.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-natsemi.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-ni5010.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-nic.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-ns83820.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-ns8390.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-otulip.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-pci.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-pci_io.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-pcnet32.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-pic8259.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-pnic.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-pnic_api.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-r8169.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-rtl8139.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-sis900.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-sk_g16.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-smc9000.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-tiara.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-tg3.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-timer.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-tlan.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-tulip.Po@am__quote@
@@ -352,450 +399,513 @@
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/$*.Po' tmpdepfile='$(DEPDIR)/$*.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(COMPILE) -c $<
 
 .c.obj:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ `$(CYGPATH_W) '$<'`; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/$*.Po' tmpdepfile='$(DEPDIR)/$*.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
 
 libdrivers_a-config.o: config.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-config.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-config.Tpo" -c -o libdrivers_a-config.o `test -f 'config.c' || echo '$(srcdir)/'`config.c; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-config.Tpo" "$(DEPDIR)/libdrivers_a-config.Po"; else rm -f "$(DEPDIR)/libdrivers_a-config.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='config.c' object='libdrivers_a-config.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-config.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-config.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-config.o `test -f 'config.c' || echo '$(srcdir)/'`config.c
 
 libdrivers_a-config.obj: config.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-config.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-config.Tpo" -c -o libdrivers_a-config.obj `if test -f 'config.c'; then $(CYGPATH_W) 'config.c'; else $(CYGPATH_W) '$(srcdir)/config.c'; fi`; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-config.Tpo" "$(DEPDIR)/libdrivers_a-config.Po"; else rm -f "$(DEPDIR)/libdrivers_a-config.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='config.c' object='libdrivers_a-config.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-config.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-config.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-config.obj `if test -f 'config.c'; then $(CYGPATH_W) 'config.c'; else $(CYGPATH_W) '$(srcdir)/config.c'; fi`
 
 libdrivers_a-fsys_tftp.o: fsys_tftp.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-fsys_tftp.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-fsys_tftp.Tpo" -c -o libdrivers_a-fsys_tftp.o `test -f 'fsys_tftp.c' || echo '$(srcdir)/'`fsys_tftp.c; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-fsys_tftp.Tpo" "$(DEPDIR)/libdrivers_a-fsys_tftp.Po"; else rm -f "$(DEPDIR)/libdrivers_a-fsys_tftp.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='fsys_tftp.c' object='libdrivers_a-fsys_tftp.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-fsys_tftp.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-fsys_tftp.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-fsys_tftp.o `test -f 'fsys_tftp.c' || echo '$(srcdir)/'`fsys_tftp.c
 
 libdrivers_a-fsys_tftp.obj: fsys_tftp.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-fsys_tftp.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-fsys_tftp.Tpo" -c -o libdrivers_a-fsys_tftp.obj `if test -f 'fsys_tftp.c'; then $(CYGPATH_W) 'fsys_tftp.c'; else $(CYGPATH_W) '$(srcdir)/fsys_tftp.c'; fi`; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-fsys_tftp.Tpo" "$(DEPDIR)/libdrivers_a-fsys_tftp.Po"; else rm -f "$(DEPDIR)/libdrivers_a-fsys_tftp.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='fsys_tftp.c' object='libdrivers_a-fsys_tftp.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-fsys_tftp.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-fsys_tftp.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-fsys_tftp.obj `if test -f 'fsys_tftp.c'; then $(CYGPATH_W) 'fsys_tftp.c'; else $(CYGPATH_W) '$(srcdir)/fsys_tftp.c'; fi`
 
-libdrivers_a-main.o: main.c
-@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-main.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-main.Tpo" -c -o libdrivers_a-main.o `test -f 'main.c' || echo '$(srcdir)/'`main.c; \
-@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-main.Tpo" "$(DEPDIR)/libdrivers_a-main.Po"; else rm -f "$(DEPDIR)/libdrivers_a-main.Tpo"; exit 1; fi
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='main.c' object='libdrivers_a-main.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-main.o `test -f 'main.c' || echo '$(srcdir)/'`main.c
-
-libdrivers_a-main.obj: main.c
-@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-main.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-main.Tpo" -c -o libdrivers_a-main.obj `if test -f 'main.c'; then $(CYGPATH_W) 'main.c'; else $(CYGPATH_W) '$(srcdir)/main.c'; fi`; \
-@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-main.Tpo" "$(DEPDIR)/libdrivers_a-main.Po"; else rm -f "$(DEPDIR)/libdrivers_a-main.Tpo"; exit 1; fi
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='main.c' object='libdrivers_a-main.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-main.obj `if test -f 'main.c'; then $(CYGPATH_W) 'main.c'; else $(CYGPATH_W) '$(srcdir)/main.c'; fi`
+libdrivers_a-i386_timer.o: i386_timer.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-i386_timer.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-i386_timer.Tpo" -c -o libdrivers_a-i386_timer.o `test -f 'i386_timer.c' || echo '$(srcdir)/'`i386_timer.c; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-i386_timer.Tpo" "$(DEPDIR)/libdrivers_a-i386_timer.Po"; else rm -f "$(DEPDIR)/libdrivers_a-i386_timer.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='i386_timer.c' object='libdrivers_a-i386_timer.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-i386_timer.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-i386_timer.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-i386_timer.o `test -f 'i386_timer.c' || echo '$(srcdir)/'`i386_timer.c
+
+libdrivers_a-i386_timer.obj: i386_timer.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-i386_timer.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-i386_timer.Tpo" -c -o libdrivers_a-i386_timer.obj `if test -f 'i386_timer.c'; then $(CYGPATH_W) 'i386_timer.c'; else $(CYGPATH_W) '$(srcdir)/i386_timer.c'; fi`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-i386_timer.Tpo" "$(DEPDIR)/libdrivers_a-i386_timer.Po"; else rm -f "$(DEPDIR)/libdrivers_a-i386_timer.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='i386_timer.c' object='libdrivers_a-i386_timer.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-i386_timer.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-i386_timer.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-i386_timer.obj `if test -f 'i386_timer.c'; then $(CYGPATH_W) 'i386_timer.c'; else $(CYGPATH_W) '$(srcdir)/i386_timer.c'; fi`
 
 libdrivers_a-misc.o: misc.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-misc.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-misc.Tpo" -c -o libdrivers_a-misc.o `test -f 'misc.c' || echo '$(srcdir)/'`misc.c; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-misc.Tpo" "$(DEPDIR)/libdrivers_a-misc.Po"; else rm -f "$(DEPDIR)/libdrivers_a-misc.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='misc.c' object='libdrivers_a-misc.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-misc.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-misc.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-misc.o `test -f 'misc.c' || echo '$(srcdir)/'`misc.c
 
 libdrivers_a-misc.obj: misc.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-misc.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-misc.Tpo" -c -o libdrivers_a-misc.obj `if test -f 'misc.c'; then $(CYGPATH_W) 'misc.c'; else $(CYGPATH_W) '$(srcdir)/misc.c'; fi`; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-misc.Tpo" "$(DEPDIR)/libdrivers_a-misc.Po"; else rm -f "$(DEPDIR)/libdrivers_a-misc.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='misc.c' object='libdrivers_a-misc.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-misc.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-misc.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-misc.obj `if test -f 'misc.c'; then $(CYGPATH_W) 'misc.c'; else $(CYGPATH_W) '$(srcdir)/misc.c'; fi`
 
+libdrivers_a-nic.o: nic.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-nic.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-nic.Tpo" -c -o libdrivers_a-nic.o `test -f 'nic.c' || echo '$(srcdir)/'`nic.c; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-nic.Tpo" "$(DEPDIR)/libdrivers_a-nic.Po"; else rm -f "$(DEPDIR)/libdrivers_a-nic.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='nic.c' object='libdrivers_a-nic.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-nic.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-nic.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-nic.o `test -f 'nic.c' || echo '$(srcdir)/'`nic.c
+
+libdrivers_a-nic.obj: nic.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-nic.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-nic.Tpo" -c -o libdrivers_a-nic.obj `if test -f 'nic.c'; then $(CYGPATH_W) 'nic.c'; else $(CYGPATH_W) '$(srcdir)/nic.c'; fi`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-nic.Tpo" "$(DEPDIR)/libdrivers_a-nic.Po"; else rm -f "$(DEPDIR)/libdrivers_a-nic.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='nic.c' object='libdrivers_a-nic.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-nic.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-nic.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-nic.obj `if test -f 'nic.c'; then $(CYGPATH_W) 'nic.c'; else $(CYGPATH_W) '$(srcdir)/nic.c'; fi`
+
 libdrivers_a-pci.o: pci.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-pci.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-pci.Tpo" -c -o libdrivers_a-pci.o `test -f 'pci.c' || echo '$(srcdir)/'`pci.c; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-pci.Tpo" "$(DEPDIR)/libdrivers_a-pci.Po"; else rm -f "$(DEPDIR)/libdrivers_a-pci.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='pci.c' object='libdrivers_a-pci.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-pci.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-pci.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-pci.o `test -f 'pci.c' || echo '$(srcdir)/'`pci.c
 
 libdrivers_a-pci.obj: pci.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-pci.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-pci.Tpo" -c -o libdrivers_a-pci.obj `if test -f 'pci.c'; then $(CYGPATH_W) 'pci.c'; else $(CYGPATH_W) '$(srcdir)/pci.c'; fi`; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-pci.Tpo" "$(DEPDIR)/libdrivers_a-pci.Po"; else rm -f "$(DEPDIR)/libdrivers_a-pci.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='pci.c' object='libdrivers_a-pci.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-pci.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-pci.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-pci.obj `if test -f 'pci.c'; then $(CYGPATH_W) 'pci.c'; else $(CYGPATH_W) '$(srcdir)/pci.c'; fi`
 
+libdrivers_a-pci_io.o: pci_io.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-pci_io.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-pci_io.Tpo" -c -o libdrivers_a-pci_io.o `test -f 'pci_io.c' || echo '$(srcdir)/'`pci_io.c; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-pci_io.Tpo" "$(DEPDIR)/libdrivers_a-pci_io.Po"; else rm -f "$(DEPDIR)/libdrivers_a-pci_io.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='pci_io.c' object='libdrivers_a-pci_io.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-pci_io.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-pci_io.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-pci_io.o `test -f 'pci_io.c' || echo '$(srcdir)/'`pci_io.c
+
+libdrivers_a-pci_io.obj: pci_io.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-pci_io.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-pci_io.Tpo" -c -o libdrivers_a-pci_io.obj `if test -f 'pci_io.c'; then $(CYGPATH_W) 'pci_io.c'; else $(CYGPATH_W) '$(srcdir)/pci_io.c'; fi`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-pci_io.Tpo" "$(DEPDIR)/libdrivers_a-pci_io.Po"; else rm -f "$(DEPDIR)/libdrivers_a-pci_io.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='pci_io.c' object='libdrivers_a-pci_io.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-pci_io.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-pci_io.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-pci_io.obj `if test -f 'pci_io.c'; then $(CYGPATH_W) 'pci_io.c'; else $(CYGPATH_W) '$(srcdir)/pci_io.c'; fi`
+
 libdrivers_a-timer.o: timer.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-timer.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-timer.Tpo" -c -o libdrivers_a-timer.o `test -f 'timer.c' || echo '$(srcdir)/'`timer.c; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-timer.Tpo" "$(DEPDIR)/libdrivers_a-timer.Po"; else rm -f "$(DEPDIR)/libdrivers_a-timer.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='timer.c' object='libdrivers_a-timer.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-timer.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-timer.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-timer.o `test -f 'timer.c' || echo '$(srcdir)/'`timer.c
 
 libdrivers_a-timer.obj: timer.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-timer.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-timer.Tpo" -c -o libdrivers_a-timer.obj `if test -f 'timer.c'; then $(CYGPATH_W) 'timer.c'; else $(CYGPATH_W) '$(srcdir)/timer.c'; fi`; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-timer.Tpo" "$(DEPDIR)/libdrivers_a-timer.Po"; else rm -f "$(DEPDIR)/libdrivers_a-timer.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='timer.c' object='libdrivers_a-timer.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-timer.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-timer.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-timer.obj `if test -f 'timer.c'; then $(CYGPATH_W) 'timer.c'; else $(CYGPATH_W) '$(srcdir)/timer.c'; fi`
 
-libdrivers_a-3c509.o: 3c509.c
-@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-3c509.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-3c509.Tpo" -c -o libdrivers_a-3c509.o `test -f '3c509.c' || echo '$(srcdir)/'`3c509.c; \
-@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-3c509.Tpo" "$(DEPDIR)/libdrivers_a-3c509.Po"; else rm -f "$(DEPDIR)/libdrivers_a-3c509.Tpo"; exit 1; fi
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='3c509.c' object='libdrivers_a-3c509.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-3c509.o `test -f '3c509.c' || echo '$(srcdir)/'`3c509.c
-
-libdrivers_a-3c509.obj: 3c509.c
-@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-3c509.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-3c509.Tpo" -c -o libdrivers_a-3c509.obj `if test -f '3c509.c'; then $(CYGPATH_W) '3c509.c'; else $(CYGPATH_W) '$(srcdir)/3c509.c'; fi`; \
-@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-3c509.Tpo" "$(DEPDIR)/libdrivers_a-3c509.Po"; else rm -f "$(DEPDIR)/libdrivers_a-3c509.Tpo"; exit 1; fi
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='3c509.c' object='libdrivers_a-3c509.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-3c509.obj `if test -f '3c509.c'; then $(CYGPATH_W) '3c509.c'; else $(CYGPATH_W) '$(srcdir)/3c509.c'; fi`
+libdrivers_a-pic8259.o: pic8259.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-pic8259.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-pic8259.Tpo" -c -o libdrivers_a-pic8259.o `test -f 'pic8259.c' || echo '$(srcdir)/'`pic8259.c; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-pic8259.Tpo" "$(DEPDIR)/libdrivers_a-pic8259.Po"; else rm -f "$(DEPDIR)/libdrivers_a-pic8259.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='pic8259.c' object='libdrivers_a-pic8259.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-pic8259.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-pic8259.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-pic8259.o `test -f 'pic8259.c' || echo '$(srcdir)/'`pic8259.c
+
+libdrivers_a-pic8259.obj: pic8259.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-pic8259.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-pic8259.Tpo" -c -o libdrivers_a-pic8259.obj `if test -f 'pic8259.c'; then $(CYGPATH_W) 'pic8259.c'; else $(CYGPATH_W) '$(srcdir)/pic8259.c'; fi`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-pic8259.Tpo" "$(DEPDIR)/libdrivers_a-pic8259.Po"; else rm -f "$(DEPDIR)/libdrivers_a-pic8259.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='pic8259.c' object='libdrivers_a-pic8259.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-pic8259.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-pic8259.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-pic8259.obj `if test -f 'pic8259.c'; then $(CYGPATH_W) 'pic8259.c'; else $(CYGPATH_W) '$(srcdir)/pic8259.c'; fi`
+
+libdrivers_a-basemem.o: basemem.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-basemem.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-basemem.Tpo" -c -o libdrivers_a-basemem.o `test -f 'basemem.c' || echo '$(srcdir)/'`basemem.c; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-basemem.Tpo" "$(DEPDIR)/libdrivers_a-basemem.Po"; else rm -f "$(DEPDIR)/libdrivers_a-basemem.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='basemem.c' object='libdrivers_a-basemem.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-basemem.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-basemem.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-basemem.o `test -f 'basemem.c' || echo '$(srcdir)/'`basemem.c
+
+libdrivers_a-basemem.obj: basemem.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-basemem.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-basemem.Tpo" -c -o libdrivers_a-basemem.obj `if test -f 'basemem.c'; then $(CYGPATH_W) 'basemem.c'; else $(CYGPATH_W) '$(srcdir)/basemem.c'; fi`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-basemem.Tpo" "$(DEPDIR)/libdrivers_a-basemem.Po"; else rm -f "$(DEPDIR)/libdrivers_a-basemem.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='basemem.c' object='libdrivers_a-basemem.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-basemem.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-basemem.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-basemem.obj `if test -f 'basemem.c'; then $(CYGPATH_W) 'basemem.c'; else $(CYGPATH_W) '$(srcdir)/basemem.c'; fi`
 
 libdrivers_a-3c595.o: 3c595.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-3c595.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-3c595.Tpo" -c -o libdrivers_a-3c595.o `test -f '3c595.c' || echo '$(srcdir)/'`3c595.c; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-3c595.Tpo" "$(DEPDIR)/libdrivers_a-3c595.Po"; else rm -f "$(DEPDIR)/libdrivers_a-3c595.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='3c595.c' object='libdrivers_a-3c595.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-3c595.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-3c595.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-3c595.o `test -f '3c595.c' || echo '$(srcdir)/'`3c595.c
 
 libdrivers_a-3c595.obj: 3c595.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-3c595.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-3c595.Tpo" -c -o libdrivers_a-3c595.obj `if test -f '3c595.c'; then $(CYGPATH_W) '3c595.c'; else $(CYGPATH_W) '$(srcdir)/3c595.c'; fi`; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-3c595.Tpo" "$(DEPDIR)/libdrivers_a-3c595.Po"; else rm -f "$(DEPDIR)/libdrivers_a-3c595.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='3c595.c' object='libdrivers_a-3c595.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-3c595.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-3c595.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-3c595.obj `if test -f '3c595.c'; then $(CYGPATH_W) '3c595.c'; else $(CYGPATH_W) '$(srcdir)/3c595.c'; fi`
 
 libdrivers_a-3c90x.o: 3c90x.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-3c90x.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-3c90x.Tpo" -c -o libdrivers_a-3c90x.o `test -f '3c90x.c' || echo '$(srcdir)/'`3c90x.c; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-3c90x.Tpo" "$(DEPDIR)/libdrivers_a-3c90x.Po"; else rm -f "$(DEPDIR)/libdrivers_a-3c90x.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='3c90x.c' object='libdrivers_a-3c90x.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-3c90x.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-3c90x.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-3c90x.o `test -f '3c90x.c' || echo '$(srcdir)/'`3c90x.c
 
 libdrivers_a-3c90x.obj: 3c90x.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-3c90x.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-3c90x.Tpo" -c -o libdrivers_a-3c90x.obj `if test -f '3c90x.c'; then $(CYGPATH_W) '3c90x.c'; else $(CYGPATH_W) '$(srcdir)/3c90x.c'; fi`; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-3c90x.Tpo" "$(DEPDIR)/libdrivers_a-3c90x.Po"; else rm -f "$(DEPDIR)/libdrivers_a-3c90x.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='3c90x.c' object='libdrivers_a-3c90x.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-3c90x.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-3c90x.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-3c90x.obj `if test -f '3c90x.c'; then $(CYGPATH_W) '3c90x.c'; else $(CYGPATH_W) '$(srcdir)/3c90x.c'; fi`
 
-libdrivers_a-cs89x0.o: cs89x0.c
-@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-cs89x0.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-cs89x0.Tpo" -c -o libdrivers_a-cs89x0.o `test -f 'cs89x0.c' || echo '$(srcdir)/'`cs89x0.c; \
-@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-cs89x0.Tpo" "$(DEPDIR)/libdrivers_a-cs89x0.Po"; else rm -f "$(DEPDIR)/libdrivers_a-cs89x0.Tpo"; exit 1; fi
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cs89x0.c' object='libdrivers_a-cs89x0.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-cs89x0.o `test -f 'cs89x0.c' || echo '$(srcdir)/'`cs89x0.c
-
-libdrivers_a-cs89x0.obj: cs89x0.c
-@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-cs89x0.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-cs89x0.Tpo" -c -o libdrivers_a-cs89x0.obj `if test -f 'cs89x0.c'; then $(CYGPATH_W) 'cs89x0.c'; else $(CYGPATH_W) '$(srcdir)/cs89x0.c'; fi`; \
-@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-cs89x0.Tpo" "$(DEPDIR)/libdrivers_a-cs89x0.Po"; else rm -f "$(DEPDIR)/libdrivers_a-cs89x0.Tpo"; exit 1; fi
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cs89x0.c' object='libdrivers_a-cs89x0.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-cs89x0.obj `if test -f 'cs89x0.c'; then $(CYGPATH_W) 'cs89x0.c'; else $(CYGPATH_W) '$(srcdir)/cs89x0.c'; fi`
-
 libdrivers_a-davicom.o: davicom.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-davicom.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-davicom.Tpo" -c -o libdrivers_a-davicom.o `test -f 'davicom.c' || echo '$(srcdir)/'`davicom.c; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-davicom.Tpo" "$(DEPDIR)/libdrivers_a-davicom.Po"; else rm -f "$(DEPDIR)/libdrivers_a-davicom.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='davicom.c' object='libdrivers_a-davicom.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-davicom.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-davicom.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-davicom.o `test -f 'davicom.c' || echo '$(srcdir)/'`davicom.c
 
 libdrivers_a-davicom.obj: davicom.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-davicom.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-davicom.Tpo" -c -o libdrivers_a-davicom.obj `if test -f 'davicom.c'; then $(CYGPATH_W) 'davicom.c'; else $(CYGPATH_W) '$(srcdir)/davicom.c'; fi`; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-davicom.Tpo" "$(DEPDIR)/libdrivers_a-davicom.Po"; else rm -f "$(DEPDIR)/libdrivers_a-davicom.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='davicom.c' object='libdrivers_a-davicom.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-davicom.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-davicom.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-davicom.obj `if test -f 'davicom.c'; then $(CYGPATH_W) 'davicom.c'; else $(CYGPATH_W) '$(srcdir)/davicom.c'; fi`
 
-libdrivers_a-depca.o: depca.c
-@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-depca.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-depca.Tpo" -c -o libdrivers_a-depca.o `test -f 'depca.c' || echo '$(srcdir)/'`depca.c; \
-@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-depca.Tpo" "$(DEPDIR)/libdrivers_a-depca.Po"; else rm -f "$(DEPDIR)/libdrivers_a-depca.Tpo"; exit 1; fi
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='depca.c' object='libdrivers_a-depca.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-depca.o `test -f 'depca.c' || echo '$(srcdir)/'`depca.c
-
-libdrivers_a-depca.obj: depca.c
-@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-depca.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-depca.Tpo" -c -o libdrivers_a-depca.obj `if test -f 'depca.c'; then $(CYGPATH_W) 'depca.c'; else $(CYGPATH_W) '$(srcdir)/depca.c'; fi`; \
-@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-depca.Tpo" "$(DEPDIR)/libdrivers_a-depca.Po"; else rm -f "$(DEPDIR)/libdrivers_a-depca.Tpo"; exit 1; fi
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='depca.c' object='libdrivers_a-depca.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-depca.obj `if test -f 'depca.c'; then $(CYGPATH_W) 'depca.c'; else $(CYGPATH_W) '$(srcdir)/depca.c'; fi`
-
-libdrivers_a-eepro.o: eepro.c
-@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-eepro.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-eepro.Tpo" -c -o libdrivers_a-eepro.o `test -f 'eepro.c' || echo '$(srcdir)/'`eepro.c; \
-@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-eepro.Tpo" "$(DEPDIR)/libdrivers_a-eepro.Po"; else rm -f "$(DEPDIR)/libdrivers_a-eepro.Tpo"; exit 1; fi
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='eepro.c' object='libdrivers_a-eepro.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-eepro.o `test -f 'eepro.c' || echo '$(srcdir)/'`eepro.c
-
-libdrivers_a-eepro.obj: eepro.c
-@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-eepro.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-eepro.Tpo" -c -o libdrivers_a-eepro.obj `if test -f 'eepro.c'; then $(CYGPATH_W) 'eepro.c'; else $(CYGPATH_W) '$(srcdir)/eepro.c'; fi`; \
-@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-eepro.Tpo" "$(DEPDIR)/libdrivers_a-eepro.Po"; else rm -f "$(DEPDIR)/libdrivers_a-eepro.Tpo"; exit 1; fi
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='eepro.c' object='libdrivers_a-eepro.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-eepro.obj `if test -f 'eepro.c'; then $(CYGPATH_W) 'eepro.c'; else $(CYGPATH_W) '$(srcdir)/eepro.c'; fi`
+libdrivers_a-e1000.o: e1000.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-e1000.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-e1000.Tpo" -c -o libdrivers_a-e1000.o `test -f 'e1000.c' || echo '$(srcdir)/'`e1000.c; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-e1000.Tpo" "$(DEPDIR)/libdrivers_a-e1000.Po"; else rm -f "$(DEPDIR)/libdrivers_a-e1000.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='e1000.c' object='libdrivers_a-e1000.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-e1000.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-e1000.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-e1000.o `test -f 'e1000.c' || echo '$(srcdir)/'`e1000.c
+
+libdrivers_a-e1000.obj: e1000.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-e1000.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-e1000.Tpo" -c -o libdrivers_a-e1000.obj `if test -f 'e1000.c'; then $(CYGPATH_W) 'e1000.c'; else $(CYGPATH_W) '$(srcdir)/e1000.c'; fi`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-e1000.Tpo" "$(DEPDIR)/libdrivers_a-e1000.Po"; else rm -f "$(DEPDIR)/libdrivers_a-e1000.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='e1000.c' object='libdrivers_a-e1000.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-e1000.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-e1000.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-e1000.obj `if test -f 'e1000.c'; then $(CYGPATH_W) 'e1000.c'; else $(CYGPATH_W) '$(srcdir)/e1000.c'; fi`
 
 libdrivers_a-eepro100.o: eepro100.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-eepro100.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-eepro100.Tpo" -c -o libdrivers_a-eepro100.o `test -f 'eepro100.c' || echo '$(srcdir)/'`eepro100.c; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-eepro100.Tpo" "$(DEPDIR)/libdrivers_a-eepro100.Po"; else rm -f "$(DEPDIR)/libdrivers_a-eepro100.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='eepro100.c' object='libdrivers_a-eepro100.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-eepro100.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-eepro100.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-eepro100.o `test -f 'eepro100.c' || echo '$(srcdir)/'`eepro100.c
 
 libdrivers_a-eepro100.obj: eepro100.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-eepro100.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-eepro100.Tpo" -c -o libdrivers_a-eepro100.obj `if test -f 'eepro100.c'; then $(CYGPATH_W) 'eepro100.c'; else $(CYGPATH_W) '$(srcdir)/eepro100.c'; fi`; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-eepro100.Tpo" "$(DEPDIR)/libdrivers_a-eepro100.Po"; else rm -f "$(DEPDIR)/libdrivers_a-eepro100.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='eepro100.c' object='libdrivers_a-eepro100.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-eepro100.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-eepro100.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-eepro100.obj `if test -f 'eepro100.c'; then $(CYGPATH_W) 'eepro100.c'; else $(CYGPATH_W) '$(srcdir)/eepro100.c'; fi`
 
 libdrivers_a-epic100.o: epic100.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-epic100.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-epic100.Tpo" -c -o libdrivers_a-epic100.o `test -f 'epic100.c' || echo '$(srcdir)/'`epic100.c; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-epic100.Tpo" "$(DEPDIR)/libdrivers_a-epic100.Po"; else rm -f "$(DEPDIR)/libdrivers_a-epic100.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='epic100.c' object='libdrivers_a-epic100.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-epic100.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-epic100.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-epic100.o `test -f 'epic100.c' || echo '$(srcdir)/'`epic100.c
 
 libdrivers_a-epic100.obj: epic100.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-epic100.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-epic100.Tpo" -c -o libdrivers_a-epic100.obj `if test -f 'epic100.c'; then $(CYGPATH_W) 'epic100.c'; else $(CYGPATH_W) '$(srcdir)/epic100.c'; fi`; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-epic100.Tpo" "$(DEPDIR)/libdrivers_a-epic100.Po"; else rm -f "$(DEPDIR)/libdrivers_a-epic100.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='epic100.c' object='libdrivers_a-epic100.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-epic100.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-epic100.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-epic100.obj `if test -f 'epic100.c'; then $(CYGPATH_W) 'epic100.c'; else $(CYGPATH_W) '$(srcdir)/epic100.c'; fi`
 
-libdrivers_a-fa311.o: fa311.c
-@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-fa311.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-fa311.Tpo" -c -o libdrivers_a-fa311.o `test -f 'fa311.c' || echo '$(srcdir)/'`fa311.c; \
-@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-fa311.Tpo" "$(DEPDIR)/libdrivers_a-fa311.Po"; else rm -f "$(DEPDIR)/libdrivers_a-fa311.Tpo"; exit 1; fi
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='fa311.c' object='libdrivers_a-fa311.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-fa311.o `test -f 'fa311.c' || echo '$(srcdir)/'`fa311.c
-
-libdrivers_a-fa311.obj: fa311.c
-@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-fa311.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-fa311.Tpo" -c -o libdrivers_a-fa311.obj `if test -f 'fa311.c'; then $(CYGPATH_W) 'fa311.c'; else $(CYGPATH_W) '$(srcdir)/fa311.c'; fi`; \
-@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-fa311.Tpo" "$(DEPDIR)/libdrivers_a-fa311.Po"; else rm -f "$(DEPDIR)/libdrivers_a-fa311.Tpo"; exit 1; fi
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='fa311.c' object='libdrivers_a-fa311.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-fa311.obj `if test -f 'fa311.c'; then $(CYGPATH_W) 'fa311.c'; else $(CYGPATH_W) '$(srcdir)/fa311.c'; fi`
-
-libdrivers_a-i82586.o: i82586.c
-@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-i82586.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-i82586.Tpo" -c -o libdrivers_a-i82586.o `test -f 'i82586.c' || echo '$(srcdir)/'`i82586.c; \
-@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-i82586.Tpo" "$(DEPDIR)/libdrivers_a-i82586.Po"; else rm -f "$(DEPDIR)/libdrivers_a-i82586.Tpo"; exit 1; fi
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='i82586.c' object='libdrivers_a-i82586.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-i82586.o `test -f 'i82586.c' || echo '$(srcdir)/'`i82586.c
-
-libdrivers_a-i82586.obj: i82586.c
-@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-i82586.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-i82586.Tpo" -c -o libdrivers_a-i82586.obj `if test -f 'i82586.c'; then $(CYGPATH_W) 'i82586.c'; else $(CYGPATH_W) '$(srcdir)/i82586.c'; fi`; \
-@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-i82586.Tpo" "$(DEPDIR)/libdrivers_a-i82586.Po"; else rm -f "$(DEPDIR)/libdrivers_a-i82586.Tpo"; exit 1; fi
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='i82586.c' object='libdrivers_a-i82586.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-i82586.obj `if test -f 'i82586.c'; then $(CYGPATH_W) 'i82586.c'; else $(CYGPATH_W) '$(srcdir)/i82586.c'; fi`
-
-libdrivers_a-lance.o: lance.c
-@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-lance.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-lance.Tpo" -c -o libdrivers_a-lance.o `test -f 'lance.c' || echo '$(srcdir)/'`lance.c; \
-@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-lance.Tpo" "$(DEPDIR)/libdrivers_a-lance.Po"; else rm -f "$(DEPDIR)/libdrivers_a-lance.Tpo"; exit 1; fi
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='lance.c' object='libdrivers_a-lance.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-lance.o `test -f 'lance.c' || echo '$(srcdir)/'`lance.c
-
-libdrivers_a-lance.obj: lance.c
-@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-lance.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-lance.Tpo" -c -o libdrivers_a-lance.obj `if test -f 'lance.c'; then $(CYGPATH_W) 'lance.c'; else $(CYGPATH_W) '$(srcdir)/lance.c'; fi`; \
-@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-lance.Tpo" "$(DEPDIR)/libdrivers_a-lance.Po"; else rm -f "$(DEPDIR)/libdrivers_a-lance.Tpo"; exit 1; fi
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='lance.c' object='libdrivers_a-lance.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-lance.obj `if test -f 'lance.c'; then $(CYGPATH_W) 'lance.c'; else $(CYGPATH_W) '$(srcdir)/lance.c'; fi`
-
 libdrivers_a-natsemi.o: natsemi.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-natsemi.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-natsemi.Tpo" -c -o libdrivers_a-natsemi.o `test -f 'natsemi.c' || echo '$(srcdir)/'`natsemi.c; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-natsemi.Tpo" "$(DEPDIR)/libdrivers_a-natsemi.Po"; else rm -f "$(DEPDIR)/libdrivers_a-natsemi.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='natsemi.c' object='libdrivers_a-natsemi.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-natsemi.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-natsemi.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-natsemi.o `test -f 'natsemi.c' || echo '$(srcdir)/'`natsemi.c
 
 libdrivers_a-natsemi.obj: natsemi.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-natsemi.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-natsemi.Tpo" -c -o libdrivers_a-natsemi.obj `if test -f 'natsemi.c'; then $(CYGPATH_W) 'natsemi.c'; else $(CYGPATH_W) '$(srcdir)/natsemi.c'; fi`; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-natsemi.Tpo" "$(DEPDIR)/libdrivers_a-natsemi.Po"; else rm -f "$(DEPDIR)/libdrivers_a-natsemi.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='natsemi.c' object='libdrivers_a-natsemi.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-natsemi.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-natsemi.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-natsemi.obj `if test -f 'natsemi.c'; then $(CYGPATH_W) 'natsemi.c'; else $(CYGPATH_W) '$(srcdir)/natsemi.c'; fi`
 
-libdrivers_a-ni5010.o: ni5010.c
-@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-ni5010.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-ni5010.Tpo" -c -o libdrivers_a-ni5010.o `test -f 'ni5010.c' || echo '$(srcdir)/'`ni5010.c; \
-@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-ni5010.Tpo" "$(DEPDIR)/libdrivers_a-ni5010.Po"; else rm -f "$(DEPDIR)/libdrivers_a-ni5010.Tpo"; exit 1; fi
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='ni5010.c' object='libdrivers_a-ni5010.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-ni5010.o `test -f 'ni5010.c' || echo '$(srcdir)/'`ni5010.c
-
-libdrivers_a-ni5010.obj: ni5010.c
-@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-ni5010.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-ni5010.Tpo" -c -o libdrivers_a-ni5010.obj `if test -f 'ni5010.c'; then $(CYGPATH_W) 'ni5010.c'; else $(CYGPATH_W) '$(srcdir)/ni5010.c'; fi`; \
-@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-ni5010.Tpo" "$(DEPDIR)/libdrivers_a-ni5010.Po"; else rm -f "$(DEPDIR)/libdrivers_a-ni5010.Tpo"; exit 1; fi
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='ni5010.c' object='libdrivers_a-ni5010.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-ni5010.obj `if test -f 'ni5010.c'; then $(CYGPATH_W) 'ni5010.c'; else $(CYGPATH_W) '$(srcdir)/ni5010.c'; fi`
-
 libdrivers_a-ns8390.o: ns8390.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-ns8390.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-ns8390.Tpo" -c -o libdrivers_a-ns8390.o `test -f 'ns8390.c' || echo '$(srcdir)/'`ns8390.c; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-ns8390.Tpo" "$(DEPDIR)/libdrivers_a-ns8390.Po"; else rm -f "$(DEPDIR)/libdrivers_a-ns8390.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='ns8390.c' object='libdrivers_a-ns8390.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-ns8390.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-ns8390.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-ns8390.o `test -f 'ns8390.c' || echo '$(srcdir)/'`ns8390.c
 
 libdrivers_a-ns8390.obj: ns8390.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-ns8390.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-ns8390.Tpo" -c -o libdrivers_a-ns8390.obj `if test -f 'ns8390.c'; then $(CYGPATH_W) 'ns8390.c'; else $(CYGPATH_W) '$(srcdir)/ns8390.c'; fi`; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-ns8390.Tpo" "$(DEPDIR)/libdrivers_a-ns8390.Po"; else rm -f "$(DEPDIR)/libdrivers_a-ns8390.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='ns8390.c' object='libdrivers_a-ns8390.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-ns8390.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-ns8390.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-ns8390.obj `if test -f 'ns8390.c'; then $(CYGPATH_W) 'ns8390.c'; else $(CYGPATH_W) '$(srcdir)/ns8390.c'; fi`
 
-libdrivers_a-otulip.o: otulip.c
-@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-otulip.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-otulip.Tpo" -c -o libdrivers_a-otulip.o `test -f 'otulip.c' || echo '$(srcdir)/'`otulip.c; \
-@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-otulip.Tpo" "$(DEPDIR)/libdrivers_a-otulip.Po"; else rm -f "$(DEPDIR)/libdrivers_a-otulip.Tpo"; exit 1; fi
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='otulip.c' object='libdrivers_a-otulip.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-otulip.o `test -f 'otulip.c' || echo '$(srcdir)/'`otulip.c
-
-libdrivers_a-otulip.obj: otulip.c
-@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-otulip.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-otulip.Tpo" -c -o libdrivers_a-otulip.obj `if test -f 'otulip.c'; then $(CYGPATH_W) 'otulip.c'; else $(CYGPATH_W) '$(srcdir)/otulip.c'; fi`; \
-@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-otulip.Tpo" "$(DEPDIR)/libdrivers_a-otulip.Po"; else rm -f "$(DEPDIR)/libdrivers_a-otulip.Tpo"; exit 1; fi
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='otulip.c' object='libdrivers_a-otulip.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-otulip.obj `if test -f 'otulip.c'; then $(CYGPATH_W) 'otulip.c'; else $(CYGPATH_W) '$(srcdir)/otulip.c'; fi`
+libdrivers_a-pcnet32.o: pcnet32.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-pcnet32.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-pcnet32.Tpo" -c -o libdrivers_a-pcnet32.o `test -f 'pcnet32.c' || echo '$(srcdir)/'`pcnet32.c; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-pcnet32.Tpo" "$(DEPDIR)/libdrivers_a-pcnet32.Po"; else rm -f "$(DEPDIR)/libdrivers_a-pcnet32.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='pcnet32.c' object='libdrivers_a-pcnet32.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-pcnet32.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-pcnet32.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-pcnet32.o `test -f 'pcnet32.c' || echo '$(srcdir)/'`pcnet32.c
+
+libdrivers_a-pcnet32.obj: pcnet32.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-pcnet32.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-pcnet32.Tpo" -c -o libdrivers_a-pcnet32.obj `if test -f 'pcnet32.c'; then $(CYGPATH_W) 'pcnet32.c'; else $(CYGPATH_W) '$(srcdir)/pcnet32.c'; fi`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-pcnet32.Tpo" "$(DEPDIR)/libdrivers_a-pcnet32.Po"; else rm -f "$(DEPDIR)/libdrivers_a-pcnet32.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='pcnet32.c' object='libdrivers_a-pcnet32.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-pcnet32.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-pcnet32.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-pcnet32.obj `if test -f 'pcnet32.c'; then $(CYGPATH_W) 'pcnet32.c'; else $(CYGPATH_W) '$(srcdir)/pcnet32.c'; fi`
 
 libdrivers_a-rtl8139.o: rtl8139.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-rtl8139.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-rtl8139.Tpo" -c -o libdrivers_a-rtl8139.o `test -f 'rtl8139.c' || echo '$(srcdir)/'`rtl8139.c; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-rtl8139.Tpo" "$(DEPDIR)/libdrivers_a-rtl8139.Po"; else rm -f "$(DEPDIR)/libdrivers_a-rtl8139.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='rtl8139.c' object='libdrivers_a-rtl8139.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-rtl8139.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-rtl8139.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-rtl8139.o `test -f 'rtl8139.c' || echo '$(srcdir)/'`rtl8139.c
 
 libdrivers_a-rtl8139.obj: rtl8139.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-rtl8139.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-rtl8139.Tpo" -c -o libdrivers_a-rtl8139.obj `if test -f 'rtl8139.c'; then $(CYGPATH_W) 'rtl8139.c'; else $(CYGPATH_W) '$(srcdir)/rtl8139.c'; fi`; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-rtl8139.Tpo" "$(DEPDIR)/libdrivers_a-rtl8139.Po"; else rm -f "$(DEPDIR)/libdrivers_a-rtl8139.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='rtl8139.c' object='libdrivers_a-rtl8139.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-rtl8139.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-rtl8139.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-rtl8139.obj `if test -f 'rtl8139.c'; then $(CYGPATH_W) 'rtl8139.c'; else $(CYGPATH_W) '$(srcdir)/rtl8139.c'; fi`
 
 libdrivers_a-sis900.o: sis900.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-sis900.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-sis900.Tpo" -c -o libdrivers_a-sis900.o `test -f 'sis900.c' || echo '$(srcdir)/'`sis900.c; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-sis900.Tpo" "$(DEPDIR)/libdrivers_a-sis900.Po"; else rm -f "$(DEPDIR)/libdrivers_a-sis900.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='sis900.c' object='libdrivers_a-sis900.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-sis900.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-sis900.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-sis900.o `test -f 'sis900.c' || echo '$(srcdir)/'`sis900.c
 
 libdrivers_a-sis900.obj: sis900.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-sis900.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-sis900.Tpo" -c -o libdrivers_a-sis900.obj `if test -f 'sis900.c'; then $(CYGPATH_W) 'sis900.c'; else $(CYGPATH_W) '$(srcdir)/sis900.c'; fi`; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-sis900.Tpo" "$(DEPDIR)/libdrivers_a-sis900.Po"; else rm -f "$(DEPDIR)/libdrivers_a-sis900.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='sis900.c' object='libdrivers_a-sis900.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-sis900.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-sis900.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-sis900.obj `if test -f 'sis900.c'; then $(CYGPATH_W) 'sis900.c'; else $(CYGPATH_W) '$(srcdir)/sis900.c'; fi`
 
-libdrivers_a-sk_g16.o: sk_g16.c
-@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-sk_g16.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-sk_g16.Tpo" -c -o libdrivers_a-sk_g16.o `test -f 'sk_g16.c' || echo '$(srcdir)/'`sk_g16.c; \
-@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-sk_g16.Tpo" "$(DEPDIR)/libdrivers_a-sk_g16.Po"; else rm -f "$(DEPDIR)/libdrivers_a-sk_g16.Tpo"; exit 1; fi
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='sk_g16.c' object='libdrivers_a-sk_g16.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-sk_g16.o `test -f 'sk_g16.c' || echo '$(srcdir)/'`sk_g16.c
-
-libdrivers_a-sk_g16.obj: sk_g16.c
-@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-sk_g16.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-sk_g16.Tpo" -c -o libdrivers_a-sk_g16.obj `if test -f 'sk_g16.c'; then $(CYGPATH_W) 'sk_g16.c'; else $(CYGPATH_W) '$(srcdir)/sk_g16.c'; fi`; \
-@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-sk_g16.Tpo" "$(DEPDIR)/libdrivers_a-sk_g16.Po"; else rm -f "$(DEPDIR)/libdrivers_a-sk_g16.Tpo"; exit 1; fi
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='sk_g16.c' object='libdrivers_a-sk_g16.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-sk_g16.obj `if test -f 'sk_g16.c'; then $(CYGPATH_W) 'sk_g16.c'; else $(CYGPATH_W) '$(srcdir)/sk_g16.c'; fi`
-
-libdrivers_a-smc9000.o: smc9000.c
-@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-smc9000.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-smc9000.Tpo" -c -o libdrivers_a-smc9000.o `test -f 'smc9000.c' || echo '$(srcdir)/'`smc9000.c; \
-@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-smc9000.Tpo" "$(DEPDIR)/libdrivers_a-smc9000.Po"; else rm -f "$(DEPDIR)/libdrivers_a-smc9000.Tpo"; exit 1; fi
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='smc9000.c' object='libdrivers_a-smc9000.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-smc9000.o `test -f 'smc9000.c' || echo '$(srcdir)/'`smc9000.c
-
-libdrivers_a-smc9000.obj: smc9000.c
-@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-smc9000.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-smc9000.Tpo" -c -o libdrivers_a-smc9000.obj `if test -f 'smc9000.c'; then $(CYGPATH_W) 'smc9000.c'; else $(CYGPATH_W) '$(srcdir)/smc9000.c'; fi`; \
-@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-smc9000.Tpo" "$(DEPDIR)/libdrivers_a-smc9000.Po"; else rm -f "$(DEPDIR)/libdrivers_a-smc9000.Tpo"; exit 1; fi
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='smc9000.c' object='libdrivers_a-smc9000.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-smc9000.obj `if test -f 'smc9000.c'; then $(CYGPATH_W) 'smc9000.c'; else $(CYGPATH_W) '$(srcdir)/smc9000.c'; fi`
-
-libdrivers_a-tiara.o: tiara.c
-@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-tiara.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-tiara.Tpo" -c -o libdrivers_a-tiara.o `test -f 'tiara.c' || echo '$(srcdir)/'`tiara.c; \
-@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-tiara.Tpo" "$(DEPDIR)/libdrivers_a-tiara.Po"; else rm -f "$(DEPDIR)/libdrivers_a-tiara.Tpo"; exit 1; fi
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='tiara.c' object='libdrivers_a-tiara.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-tiara.o `test -f 'tiara.c' || echo '$(srcdir)/'`tiara.c
-
-libdrivers_a-tiara.obj: tiara.c
-@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-tiara.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-tiara.Tpo" -c -o libdrivers_a-tiara.obj `if test -f 'tiara.c'; then $(CYGPATH_W) 'tiara.c'; else $(CYGPATH_W) '$(srcdir)/tiara.c'; fi`; \
-@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-tiara.Tpo" "$(DEPDIR)/libdrivers_a-tiara.Po"; else rm -f "$(DEPDIR)/libdrivers_a-tiara.Tpo"; exit 1; fi
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='tiara.c' object='libdrivers_a-tiara.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-tiara.obj `if test -f 'tiara.c'; then $(CYGPATH_W) 'tiara.c'; else $(CYGPATH_W) '$(srcdir)/tiara.c'; fi`
+libdrivers_a-tg3.o: tg3.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-tg3.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-tg3.Tpo" -c -o libdrivers_a-tg3.o `test -f 'tg3.c' || echo '$(srcdir)/'`tg3.c; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-tg3.Tpo" "$(DEPDIR)/libdrivers_a-tg3.Po"; else rm -f "$(DEPDIR)/libdrivers_a-tg3.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='tg3.c' object='libdrivers_a-tg3.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-tg3.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-tg3.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-tg3.o `test -f 'tg3.c' || echo '$(srcdir)/'`tg3.c
+
+libdrivers_a-tg3.obj: tg3.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-tg3.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-tg3.Tpo" -c -o libdrivers_a-tg3.obj `if test -f 'tg3.c'; then $(CYGPATH_W) 'tg3.c'; else $(CYGPATH_W) '$(srcdir)/tg3.c'; fi`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-tg3.Tpo" "$(DEPDIR)/libdrivers_a-tg3.Po"; else rm -f "$(DEPDIR)/libdrivers_a-tg3.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='tg3.c' object='libdrivers_a-tg3.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-tg3.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-tg3.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-tg3.obj `if test -f 'tg3.c'; then $(CYGPATH_W) 'tg3.c'; else $(CYGPATH_W) '$(srcdir)/tg3.c'; fi`
 
 libdrivers_a-tlan.o: tlan.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-tlan.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-tlan.Tpo" -c -o libdrivers_a-tlan.o `test -f 'tlan.c' || echo '$(srcdir)/'`tlan.c; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-tlan.Tpo" "$(DEPDIR)/libdrivers_a-tlan.Po"; else rm -f "$(DEPDIR)/libdrivers_a-tlan.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='tlan.c' object='libdrivers_a-tlan.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-tlan.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-tlan.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-tlan.o `test -f 'tlan.c' || echo '$(srcdir)/'`tlan.c
 
 libdrivers_a-tlan.obj: tlan.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-tlan.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-tlan.Tpo" -c -o libdrivers_a-tlan.obj `if test -f 'tlan.c'; then $(CYGPATH_W) 'tlan.c'; else $(CYGPATH_W) '$(srcdir)/tlan.c'; fi`; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-tlan.Tpo" "$(DEPDIR)/libdrivers_a-tlan.Po"; else rm -f "$(DEPDIR)/libdrivers_a-tlan.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='tlan.c' object='libdrivers_a-tlan.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-tlan.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-tlan.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-tlan.obj `if test -f 'tlan.c'; then $(CYGPATH_W) 'tlan.c'; else $(CYGPATH_W) '$(srcdir)/tlan.c'; fi`
 
 libdrivers_a-tulip.o: tulip.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-tulip.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-tulip.Tpo" -c -o libdrivers_a-tulip.o `test -f 'tulip.c' || echo '$(srcdir)/'`tulip.c; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-tulip.Tpo" "$(DEPDIR)/libdrivers_a-tulip.Po"; else rm -f "$(DEPDIR)/libdrivers_a-tulip.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='tulip.c' object='libdrivers_a-tulip.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-tulip.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-tulip.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-tulip.o `test -f 'tulip.c' || echo '$(srcdir)/'`tulip.c
 
 libdrivers_a-tulip.obj: tulip.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-tulip.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-tulip.Tpo" -c -o libdrivers_a-tulip.obj `if test -f 'tulip.c'; then $(CYGPATH_W) 'tulip.c'; else $(CYGPATH_W) '$(srcdir)/tulip.c'; fi`; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-tulip.Tpo" "$(DEPDIR)/libdrivers_a-tulip.Po"; else rm -f "$(DEPDIR)/libdrivers_a-tulip.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='tulip.c' object='libdrivers_a-tulip.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-tulip.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-tulip.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-tulip.obj `if test -f 'tulip.c'; then $(CYGPATH_W) 'tulip.c'; else $(CYGPATH_W) '$(srcdir)/tulip.c'; fi`
 
 libdrivers_a-via-rhine.o: via-rhine.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-via-rhine.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-via-rhine.Tpo" -c -o libdrivers_a-via-rhine.o `test -f 'via-rhine.c' || echo '$(srcdir)/'`via-rhine.c; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-via-rhine.Tpo" "$(DEPDIR)/libdrivers_a-via-rhine.Po"; else rm -f "$(DEPDIR)/libdrivers_a-via-rhine.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='via-rhine.c' object='libdrivers_a-via-rhine.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-via-rhine.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-via-rhine.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-via-rhine.o `test -f 'via-rhine.c' || echo '$(srcdir)/'`via-rhine.c
 
 libdrivers_a-via-rhine.obj: via-rhine.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-via-rhine.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-via-rhine.Tpo" -c -o libdrivers_a-via-rhine.obj `if test -f 'via-rhine.c'; then $(CYGPATH_W) 'via-rhine.c'; else $(CYGPATH_W) '$(srcdir)/via-rhine.c'; fi`; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-via-rhine.Tpo" "$(DEPDIR)/libdrivers_a-via-rhine.Po"; else rm -f "$(DEPDIR)/libdrivers_a-via-rhine.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='via-rhine.c' object='libdrivers_a-via-rhine.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-via-rhine.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-via-rhine.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-via-rhine.obj `if test -f 'via-rhine.c'; then $(CYGPATH_W) 'via-rhine.c'; else $(CYGPATH_W) '$(srcdir)/via-rhine.c'; fi`
 
 libdrivers_a-w89c840.o: w89c840.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-w89c840.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-w89c840.Tpo" -c -o libdrivers_a-w89c840.o `test -f 'w89c840.c' || echo '$(srcdir)/'`w89c840.c; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-w89c840.Tpo" "$(DEPDIR)/libdrivers_a-w89c840.Po"; else rm -f "$(DEPDIR)/libdrivers_a-w89c840.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='w89c840.c' object='libdrivers_a-w89c840.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-w89c840.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-w89c840.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-w89c840.o `test -f 'w89c840.c' || echo '$(srcdir)/'`w89c840.c
 
 libdrivers_a-w89c840.obj: w89c840.c
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-w89c840.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-w89c840.Tpo" -c -o libdrivers_a-w89c840.obj `if test -f 'w89c840.c'; then $(CYGPATH_W) 'w89c840.c'; else $(CYGPATH_W) '$(srcdir)/w89c840.c'; fi`; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-w89c840.Tpo" "$(DEPDIR)/libdrivers_a-w89c840.Po"; else rm -f "$(DEPDIR)/libdrivers_a-w89c840.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='w89c840.c' object='libdrivers_a-w89c840.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-w89c840.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-w89c840.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-w89c840.obj `if test -f 'w89c840.c'; then $(CYGPATH_W) 'w89c840.c'; else $(CYGPATH_W) '$(srcdir)/w89c840.c'; fi`
-uninstall-info-am:
+
+libdrivers_a-r8169.o: r8169.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-r8169.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-r8169.Tpo" -c -o libdrivers_a-r8169.o `test -f 'r8169.c' || echo '$(srcdir)/'`r8169.c; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-r8169.Tpo" "$(DEPDIR)/libdrivers_a-r8169.Po"; else rm -f "$(DEPDIR)/libdrivers_a-r8169.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='r8169.c' object='libdrivers_a-r8169.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-r8169.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-r8169.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-r8169.o `test -f 'r8169.c' || echo '$(srcdir)/'`r8169.c
+
+libdrivers_a-r8169.obj: r8169.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-r8169.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-r8169.Tpo" -c -o libdrivers_a-r8169.obj `if test -f 'r8169.c'; then $(CYGPATH_W) 'r8169.c'; else $(CYGPATH_W) '$(srcdir)/r8169.c'; fi`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-r8169.Tpo" "$(DEPDIR)/libdrivers_a-r8169.Po"; else rm -f "$(DEPDIR)/libdrivers_a-r8169.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='r8169.c' object='libdrivers_a-r8169.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-r8169.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-r8169.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-r8169.obj `if test -f 'r8169.c'; then $(CYGPATH_W) 'r8169.c'; else $(CYGPATH_W) '$(srcdir)/r8169.c'; fi`
+
+libdrivers_a-forcedeth.o: forcedeth.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-forcedeth.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-forcedeth.Tpo" -c -o libdrivers_a-forcedeth.o `test -f 'forcedeth.c' || echo '$(srcdir)/'`forcedeth.c; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-forcedeth.Tpo" "$(DEPDIR)/libdrivers_a-forcedeth.Po"; else rm -f "$(DEPDIR)/libdrivers_a-forcedeth.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='forcedeth.c' object='libdrivers_a-forcedeth.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-forcedeth.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-forcedeth.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-forcedeth.o `test -f 'forcedeth.c' || echo '$(srcdir)/'`forcedeth.c
+
+libdrivers_a-forcedeth.obj: forcedeth.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-forcedeth.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-forcedeth.Tpo" -c -o libdrivers_a-forcedeth.obj `if test -f 'forcedeth.c'; then $(CYGPATH_W) 'forcedeth.c'; else $(CYGPATH_W) '$(srcdir)/forcedeth.c'; fi`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-forcedeth.Tpo" "$(DEPDIR)/libdrivers_a-forcedeth.Po"; else rm -f "$(DEPDIR)/libdrivers_a-forcedeth.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='forcedeth.c' object='libdrivers_a-forcedeth.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-forcedeth.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-forcedeth.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-forcedeth.obj `if test -f 'forcedeth.c'; then $(CYGPATH_W) 'forcedeth.c'; else $(CYGPATH_W) '$(srcdir)/forcedeth.c'; fi`
+
+libdrivers_a-ns83820.o: ns83820.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-ns83820.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-ns83820.Tpo" -c -o libdrivers_a-ns83820.o `test -f 'ns83820.c' || echo '$(srcdir)/'`ns83820.c; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-ns83820.Tpo" "$(DEPDIR)/libdrivers_a-ns83820.Po"; else rm -f "$(DEPDIR)/libdrivers_a-ns83820.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='ns83820.c' object='libdrivers_a-ns83820.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-ns83820.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-ns83820.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-ns83820.o `test -f 'ns83820.c' || echo '$(srcdir)/'`ns83820.c
+
+libdrivers_a-ns83820.obj: ns83820.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-ns83820.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-ns83820.Tpo" -c -o libdrivers_a-ns83820.obj `if test -f 'ns83820.c'; then $(CYGPATH_W) 'ns83820.c'; else $(CYGPATH_W) '$(srcdir)/ns83820.c'; fi`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-ns83820.Tpo" "$(DEPDIR)/libdrivers_a-ns83820.Po"; else rm -f "$(DEPDIR)/libdrivers_a-ns83820.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='ns83820.c' object='libdrivers_a-ns83820.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-ns83820.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-ns83820.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-ns83820.obj `if test -f 'ns83820.c'; then $(CYGPATH_W) 'ns83820.c'; else $(CYGPATH_W) '$(srcdir)/ns83820.c'; fi`
+
+libdrivers_a-pnic.o: pnic.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-pnic.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-pnic.Tpo" -c -o libdrivers_a-pnic.o `test -f 'pnic.c' || echo '$(srcdir)/'`pnic.c; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-pnic.Tpo" "$(DEPDIR)/libdrivers_a-pnic.Po"; else rm -f "$(DEPDIR)/libdrivers_a-pnic.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='pnic.c' object='libdrivers_a-pnic.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-pnic.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-pnic.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-pnic.o `test -f 'pnic.c' || echo '$(srcdir)/'`pnic.c
+
+libdrivers_a-pnic.obj: pnic.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-pnic.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-pnic.Tpo" -c -o libdrivers_a-pnic.obj `if test -f 'pnic.c'; then $(CYGPATH_W) 'pnic.c'; else $(CYGPATH_W) '$(srcdir)/pnic.c'; fi`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-pnic.Tpo" "$(DEPDIR)/libdrivers_a-pnic.Po"; else rm -f "$(DEPDIR)/libdrivers_a-pnic.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='pnic.c' object='libdrivers_a-pnic.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-pnic.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-pnic.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-pnic.obj `if test -f 'pnic.c'; then $(CYGPATH_W) 'pnic.c'; else $(CYGPATH_W) '$(srcdir)/pnic.c'; fi`
+
+libdrivers_a-pnic_api.o: pnic_api.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-pnic_api.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-pnic_api.Tpo" -c -o libdrivers_a-pnic_api.o `test -f 'pnic_api.c' || echo '$(srcdir)/'`pnic_api.c; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-pnic_api.Tpo" "$(DEPDIR)/libdrivers_a-pnic_api.Po"; else rm -f "$(DEPDIR)/libdrivers_a-pnic_api.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='pnic_api.c' object='libdrivers_a-pnic_api.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-pnic_api.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-pnic_api.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-pnic_api.o `test -f 'pnic_api.c' || echo '$(srcdir)/'`pnic_api.c
+
+libdrivers_a-pnic_api.obj: pnic_api.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-pnic_api.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-pnic_api.Tpo" -c -o libdrivers_a-pnic_api.obj `if test -f 'pnic_api.c'; then $(CYGPATH_W) 'pnic_api.c'; else $(CYGPATH_W) '$(srcdir)/pnic_api.c'; fi`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/libdrivers_a-pnic_api.Tpo" "$(DEPDIR)/libdrivers_a-pnic_api.Po"; else rm -f "$(DEPDIR)/libdrivers_a-pnic_api.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='pnic_api.c' object='libdrivers_a-pnic_api.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-pnic_api.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-pnic_api.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-pnic_api.obj `if test -f 'pnic_api.c'; then $(CYGPATH_W) 'pnic_api.c'; else $(CYGPATH_W) '$(srcdir)/pnic_api.c'; fi`
 
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
@@ -817,11 +927,9 @@
 	  done | \
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
-	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
-	  test -n "$$unique" || unique=$$empty_fix; \
-	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	    $$tags $$unique; \
-	fi
+	test -z "$(ETAGS_ARGS)$$tags$$unique" \
+	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	     $$tags $$unique
 ctags: CTAGS
 CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
@@ -895,7 +1003,7 @@
 clean-generic:
 
 distclean-generic:
-	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -962,10 +1070,10 @@
 
 
 # Is it really necessary to specify dependecies explicitly?
-$(3c509_drivers): 3c509.c 3c509.h
-$(3c509_drivers): %.o: 3c509.c
-	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
-	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+#$(3c509_drivers): 3c509.c 3c509.h
+#$(3c509_drivers): %.o: 3c509.c
+#	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+#	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
 $(3c595_drivers): 3c595.c 3c595.h
 $(3c595_drivers): %.o: 3c595.c
@@ -977,23 +1085,28 @@
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-$(cs89x0_drivers): cs89x0.c cs89x0.h
-$(cs89x0_drivers): %.o: cs89x0.c
-	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
-	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+#$(cs89x0_drivers): cs89x0.c cs89x0.h
+#$(cs89x0_drivers): %.o: cs89x0.c
+#	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+#	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
 $(davicom_drivers): davicom.c
 $(davicom_drivers): %.o: davicom.c
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-$(depca_drivers): depca.c
-$(depca_drivers): %.o: depca.c
-	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
-	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+#$(depca_drivers): depca.c
+#$(depca_drivers): %.o: depca.c
+#	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+#	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-$(eepro_drivers): eepro.c
-$(eepro_drivers): %.o: eepro.c
+#$(eepro_drivers): eepro.c
+#$(eepro_drivers): %.o: eepro.c
+#	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+#	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+
+$(e1000_drivers): e1000.c e1000_hw.h
+$(e1000_drivers): %.o: e1000.c
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
@@ -1007,28 +1120,38 @@
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
+$(forcedeth_drivers): forcedeth.c
+$(forcedeth_drivers): %.o: forcedeth.c
+	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+
 #$(fa311_drivers): fa311.c
 #$(fa311_drivers): %.o: fa311.c
 #	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-$(i82586_drivers): i82586.c
-$(i82586_drivers): %.o: i82586.c
-	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
-	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+#$(i82586_drivers): i82586.c
+#$(i82586_drivers): %.o: i82586.c
+#	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+#	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-$(lance_drivers): lance.c
-$(lance_drivers): %.o: lance.c
-	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
-	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+#$(lance_drivers): lance.c
+#$(lance_drivers): %.o: lance.c
+#	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+#	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
 $(natsemi_drivers): natsemi.c
 $(natsemi_drivers): %.o: natsemi.c
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-$(ni5010_drivers): ni5010.c
-$(ni5010_drivers): %.o: ni5010.c
+#$(ni5010_drivers): ni5010.c
+#$(ni5010_drivers): %.o: ni5010.c
+#	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+#	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+
+$(ns83820_drivers): ns83820.c
+$(ns83820_drivers): %.o: ns83820.c
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
@@ -1037,41 +1160,62 @@
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-$(otulip_drivers): otulip.c otulip.h
-$(otulip_drivers): %.o: otulip.c
+#$(otulip_drivers): otulip.c otulip.h
+#$(otulip_drivers): %.o: otulip.c
+#	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+#	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+
+$(pcnet32_drivers): pcnet32.c
+$(pcnet32_drivers): %.o: pcnet32.c
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-$(rtl8139_drivers): rtl8139.c
-$(rtl8139_drivers): %.o: rtl8139.c
+$(pnic_drivers): pnic.c
+$(pnic_drivers): %.o: pnic.c pnic_api.h
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-$(sis900_drivers): sis900.c
-$(sis900_drivers): %.o: sis900.c sis900.h
+$(rtl8139_drivers): rtl8139.c
+$(rtl8139_drivers): %.o: rtl8139.c
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-$(sk_g16_drivers): sk_g16.c sk_g16.h
-$(sk_g16_drivers): %.o: sk_g16.c
+$(r8169_drivers): r8169.c
+$(r8169_drivers): %.o: r8169.c
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-$(smc9000_drivers): smc9000.c smc9000.h
-$(smc9000_drivers): %.o: smc9000.c
+$(sis900_drivers): sis900.c sis900.h
+$(sis900_drivers): %.o: sis900.c
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-$(tiara_drivers): tiara.c
-$(tiara_drivers): %.o: tiara.c
+#$(sk_g16_drivers): sk_g16.c sk_g16.h
+#$(sk_g16_drivers): %.o: sk_g16.c
+#	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+#	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+
+#$(smc9000_drivers): smc9000.c smc9000.h
+#$(smc9000_drivers): %.o: smc9000.c
+#	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+#	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+
+
+$(tg3_drivers): tg3.c tg3.h
+$(tg3_drivers): %.o: tg3.c
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-#$(tlan_drivers): tlan.c
-#$(tlan_drivers): %.o: tlan.c
+#$(tiara_drivers): tiara.c
+#$(tiara_drivers): %.o: tiara.c
 #	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
+$(tlan_drivers): tlan.c tlan.h
+$(tlan_drivers): %.o: tlan.c
+	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+
 $(tulip_drivers): tulip.c
 $(tulip_drivers): %.o: tulip.c
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
diff -Naur grub-0.97.orig/netboot/basemem.c grub-0.97/netboot/basemem.c
--- grub-0.97.orig/netboot/basemem.c	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/basemem.c	2005-08-31 19:24:28.000000000 +0000
@@ -0,0 +1,178 @@
+#include "etherboot.h"
+#define DEBUG_BASEMEM
+/* Routines to allocate base memory in a BIOS-compatible way, by
+ * updating the Free Base Memory Size counter at 40:13h.
+ *
+ * Michael Brown <mbrown@fensystems.co.uk> (mcb30)
+ * $Id: grub-0.95-diskless-patch-2-undi.patch,v 1.1.1.1 2005/06/14 08:18:50 wesolows Exp $
+ */
+
+#define fbms ( ( uint16_t * ) phys_to_virt ( 0x413 ) )
+#define BASE_MEMORY_MAX ( 640 )
+#define FREE_BLOCK_MAGIC ( ('!'<<0) + ('F'<<8) + ('R'<<16) + ('E'<<24) )
+
+typedef struct free_base_memory_block {
+	uint32_t	magic;
+	uint16_t	size_kb;
+} free_base_memory_block_t;
+
+/* Return amount of free base memory in bytes
+ */
+
+uint32_t get_free_base_memory ( void ) {
+	return *fbms << 10;
+}
+
+/* Adjust the real mode stack pointer.  We keep the real mode stack at
+ * the top of free base memory, rather than allocating space for it.
+ */
+
+inline void adjust_real_mode_stack ( void ) {
+/*  	real_mode_stack = ( *fbms << 10 ); */
+}
+
+/* Allocate N bytes of base memory.  Amount allocated will be rounded
+ * up to the nearest kB, since that's the granularity of the BIOS FBMS
+ * counter.  Returns NULL if memory cannot be allocated.
+ */
+
+void * allot_base_memory ( size_t size ) {
+	uint16_t size_kb = ( size + 1023 ) >> 10;
+	void *ptr = NULL;
+
+#ifdef DEBUG_BASEMEM
+	printf ( "Trying to allocate %d kB of base memory, %d kB free\n",
+		 size_kb, *fbms );
+#endif
+
+	/* Free up any unused memory before we start */
+	free_unused_base_memory();
+
+	/* Check available base memory */
+	if ( size_kb > *fbms ) { return NULL; }
+
+	/* Reduce available base memory */
+	*fbms -= size_kb;
+
+	/* Calculate address of memory allocated */
+	ptr = phys_to_virt ( *fbms << 10 );
+
+#ifdef DEBUG_BASEMEM
+	/* Zero out memory.  We do this so that allocation of
+	 * already-used space will show up in the form of a crash as
+	 * soon as possible.
+	 */
+	memset ( ptr, 0, size_kb << 10 );
+#endif
+
+	/* Adjust real mode stack pointer */
+	adjust_real_mode_stack ();
+
+	return ptr;
+}
+
+/* Free base memory allocated by allot_base_memory.  The BIOS provides
+ * nothing better than a LIFO mechanism for freeing memory (i.e. it
+ * just has the single "total free memory" counter), but we improve
+ * upon this slightly; as long as you free all the allotted blocks, it
+ * doesn't matter what order you free them in.  (This will only work
+ * for blocks that are freed via forget_base_memory()).
+ *
+ * Yes, it's annoying that you have to remember the size of the blocks
+ * you've allotted.  However, since our granularity of allocation is
+ * 1K, the alternative is to risk wasting the occasional kB of base
+ * memory, which is a Bad Thing.  Really, you should be using as
+ * little base memory as possible, so consider the awkwardness of the
+ * API to be a feature! :-)
+ */
+
+void forget_base_memory ( void *ptr, size_t size ) {
+	uint16_t remainder = virt_to_phys(ptr) & 1023;
+	uint16_t size_kb = ( size + remainder + 1023 ) >> 10;
+	free_base_memory_block_t *free_block =
+		( free_base_memory_block_t * ) ( ptr - remainder );
+	
+	if ( ( ptr == NULL ) || ( size == 0 ) ) { return; }
+
+#ifdef DEBUG_BASEMEM
+	printf ( "Trying to free %d bytes base memory at 0x%x\n",
+		 size, virt_to_phys ( ptr ) );
+	if ( remainder > 0 ) {
+		printf ( "WARNING: destructively expanding free block "
+			 "downwards to 0x%x\n",
+			 virt_to_phys ( ptr - remainder ) );
+	}
+#endif
+
+	/* Mark every kilobyte within this block as free.  This is
+	 * overkill for normal purposes, but helps when something has
+	 * allocated base memory with a granularity finer than the
+	 * BIOS granularity of 1kB.  PXE ROMs tend to do this when
+	 * they allocate their own memory.  This method allows us to
+	 * free their blocks (admittedly in a rather dangerous,
+	 * tread-on-anything-either-side sort of way, but there's no
+	 * other way to do it).
+	 *
+	 * Since we're marking every kB as free, there's actually no
+	 * need for recording the size of the blocks.  However, we
+	 * keep this in so that debug messages are friendlier.  It
+	 * probably adds around 8 bytes to the overall code size.
+	 */
+	while ( size_kb > 0 ) {
+		/* Mark this block as unused */
+		free_block->magic = FREE_BLOCK_MAGIC;
+		free_block->size_kb = size_kb;
+		/* Move up by 1 kB */
+		(void *)(free_block += ( 1 << 10 ));
+		size_kb--;
+	}
+
+	/* Free up unused base memory */
+	free_unused_base_memory();
+}
+
+/* Do the actual freeing of memory.  This is split out from
+ * forget_base_memory() so that it may be called separately.  It
+ * should be called whenever base memory is deallocated by an external
+ * entity (if we can detect that it has done so) so that we get the
+ * chance to free up our own blocks.
+ */
+void free_unused_base_memory ( void ) {
+	free_base_memory_block_t *free_block = NULL;
+
+	/* Try to release memory back to the BIOS.  Free all
+	 * consecutive blocks marked as free.
+	 */
+	while ( 1 ) {
+		/* Calculate address of next potential free block */
+		free_block = ( free_base_memory_block_t * )
+			phys_to_virt ( *fbms << 10 );
+		
+		/* Stop processing if we're all the way up to 640K or
+		 * if this is not a free block
+		 */
+		if ( ( *fbms == BASE_MEMORY_MAX ) ||
+		     ( free_block->magic != FREE_BLOCK_MAGIC ) ) {
+			break;
+		}
+
+		/* Return memory to BIOS */
+		*fbms += free_block->size_kb;
+
+#ifdef DEBUG_BASEMEM
+		printf ( "Freed %d kB base memory, %d kB now free\n",
+			 free_block->size_kb, *fbms );
+		
+		/* Zero out freed block.  We do this in case
+		 * the block contained any structures that
+		 * might be located by scanning through
+		 * memory.
+		 */
+		memset ( free_block, 0, free_block->size_kb << 10 );
+#endif			
+	}
+
+	/* Adjust real mode stack pointer */
+	adjust_real_mode_stack ();
+}
+
diff -Naur grub-0.97.orig/netboot/big_bswap.h grub-0.97/netboot/big_bswap.h
--- grub-0.97.orig/netboot/big_bswap.h	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/big_bswap.h	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,17 @@
+#ifndef ETHERBOOT_BIG_BSWAP_H
+#define ETHERBOOT_BIG_BSWAP_H
+
+#define ntohl(x) 	(x)
+#define htonl(x) 	(x)
+#define ntohs(x) 	(x)
+#define htons(x) 	(x)
+#define cpu_to_le32(x)	__bswap_32(x)
+#define cpu_to_le16(x)	__bswap_16(x)
+#define cpu_to_be32(x)	(x)
+#define cpu_to_be16(x)	(x)
+#define le32_to_cpu(x)	__bswap_32(x)
+#define le16_to_cpu(x)	__bswap_16(x)
+#define be32_to_cpu(x)	(x)
+#define be16_to_cpu(x)	(x)
+
+#endif /* ETHERBOOT_BIG_BSWAP_H */
diff -Naur grub-0.97.orig/netboot/bootp.h grub-0.97/netboot/bootp.h
--- grub-0.97.orig/netboot/bootp.h	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/bootp.h	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,182 @@
+#ifndef	_BOOTP_H
+#define	_BOOTP_H
+
+#include "if_ether.h"
+#include "ip.h"
+#include "udp.h"
+
+#ifndef	MAX_BOOTP_RETRIES
+#define MAX_BOOTP_RETRIES	20
+#endif
+
+#ifdef	ALTERNATE_DHCP_PORTS_1067_1068
+#undef	NON_STANDARD_BOOTP_SERVER
+#define	NON_STANDARD_BOOTP_SERVER	1067
+#undef	NON_STANDARD_BOOTP_CLIENT
+#define	NON_STANDARD_BOOTP_CLIENT	1068
+#endif
+
+#ifdef	NON_STANDARD_BOOTP_SERVER
+#define	BOOTP_SERVER	NON_STANDARD_BOOTP_SERVER
+#else
+#define BOOTP_SERVER	67
+#endif
+#ifdef	NON_STANDARD_BOOTP_CLIENT
+#define	BOOTP_CLIENT	NON_STANDARD_BOOTP_CLIENT
+#else
+#define BOOTP_CLIENT	68
+#endif
+
+#define BOOTP_REQUEST	1
+#define BOOTP_REPLY	2
+
+#define TAG_LEN(p)		(*((p)+1))
+#define RFC1533_COOKIE		99, 130, 83, 99
+#define RFC1533_PAD		0
+#define RFC1533_NETMASK		1
+#define RFC1533_TIMEOFFSET	2
+#define RFC1533_GATEWAY		3
+#define RFC1533_TIMESERVER	4
+#define RFC1533_IEN116NS	5
+#define RFC1533_DNS		6
+#define RFC1533_LOGSERVER	7
+#define RFC1533_COOKIESERVER	8
+#define RFC1533_LPRSERVER	9
+#define RFC1533_IMPRESSSERVER	10
+#define RFC1533_RESOURCESERVER	11
+#define RFC1533_HOSTNAME	12
+#define RFC1533_BOOTFILESIZE	13
+#define RFC1533_MERITDUMPFILE	14
+#define RFC1533_DOMAINNAME	15
+#define RFC1533_SWAPSERVER	16
+#define RFC1533_ROOTPATH	17
+#define RFC1533_EXTENSIONPATH	18
+#define RFC1533_IPFORWARDING	19
+#define RFC1533_IPSOURCEROUTING	20
+#define RFC1533_IPPOLICYFILTER	21
+#define RFC1533_IPMAXREASSEMBLY	22
+#define RFC1533_IPTTL		23
+#define RFC1533_IPMTU		24
+#define RFC1533_IPMTUPLATEAU	25
+#define RFC1533_INTMTU		26
+#define RFC1533_INTLOCALSUBNETS	27
+#define RFC1533_INTBROADCAST	28
+#define RFC1533_INTICMPDISCOVER	29
+#define RFC1533_INTICMPRESPOND	30
+#define RFC1533_INTROUTEDISCOVER 31
+#define RFC1533_INTROUTESOLICIT	32
+#define RFC1533_INTSTATICROUTES	33
+#define RFC1533_LLTRAILERENCAP	34
+#define RFC1533_LLARPCACHETMO	35
+#define RFC1533_LLETHERNETENCAP	36
+#define RFC1533_TCPTTL		37
+#define RFC1533_TCPKEEPALIVETMO	38
+#define RFC1533_TCPKEEPALIVEGB	39
+#define RFC1533_NISDOMAIN	40
+#define RFC1533_NISSERVER	41
+#define RFC1533_NTPSERVER	42
+#define RFC1533_VENDOR		43
+#define RFC1533_NBNS		44
+#define RFC1533_NBDD		45
+#define RFC1533_NBNT		46
+#define RFC1533_NBSCOPE		47
+#define RFC1533_XFS		48
+#define RFC1533_XDM		49
+#ifndef	NO_DHCP_SUPPORT
+#define RFC2132_REQ_ADDR	50
+#define RFC2132_MSG_TYPE	53
+#define RFC2132_SRV_ID		54
+#define RFC2132_PARAM_LIST	55
+#define RFC2132_MAX_SIZE	57
+#define	RFC2132_VENDOR_CLASS_ID	60
+
+#define DHCPDISCOVER		1
+#define DHCPOFFER		2
+#define DHCPREQUEST		3
+#define DHCPACK			5
+#endif	/* NO_DHCP_SUPPORT */
+
+#define RFC1533_VENDOR_MAJOR	0
+#define RFC1533_VENDOR_MINOR	0
+
+#define RFC1533_VENDOR_MAGIC	128
+#define RFC1533_VENDOR_ADDPARM	129
+#define	RFC1533_VENDOR_ETHDEV	130
+#ifdef	IMAGE_FREEBSD
+#define RFC1533_VENDOR_HOWTO    132
+#define RFC1533_VENDOR_KERNEL_ENV    133
+#endif
+#define RFC1533_VENDOR_ETHERBOOT_ENCAP 150
+#define RFC1533_VENDOR_MNUOPTS	160
+#define RFC1533_VENDOR_NIC_DEV_ID 175
+#define RFC1533_VENDOR_SELECTION 176
+#define RFC1533_VENDOR_ARCH     177
+#define RFC1533_VENDOR_MOTD	184
+#define RFC1533_VENDOR_NUMOFMOTD 8
+#define RFC1533_VENDOR_IMG	192
+#define RFC1533_VENDOR_NUMOFIMG	16
+
+#define RFC1533_VENDOR_CONFIGFILE 150
+
+#define RFC1533_END		255
+
+#define BOOTP_VENDOR_LEN	64
+
+#define DHCP_OPT_LEN		312
+
+/* Format of a bootp packet */
+struct bootp_t {
+	uint8_t  bp_op;
+	uint8_t  bp_htype;
+	uint8_t  bp_hlen;
+	uint8_t  bp_hops;
+	uint32_t bp_xid;
+	uint16_t bp_secs;
+	uint16_t unused;
+	in_addr bp_ciaddr;
+	in_addr bp_yiaddr;
+	in_addr bp_siaddr;
+	in_addr bp_giaddr;
+	uint8_t  bp_hwaddr[16];
+	uint8_t  bp_sname[64];
+	char     bp_file[128];
+	uint8_t  bp_vend[BOOTP_VENDOR_LEN];
+};
+
+struct dhcp_t {
+	uint8_t  bp_op;
+	uint8_t  bp_htype;
+	uint8_t  bp_hlen;
+	uint8_t  bp_hops;
+	uint32_t bp_xid;
+	uint16_t bp_secs;
+	uint16_t bp_flag;
+	in_addr bp_ciaddr;
+	in_addr bp_yiaddr;
+	in_addr bp_siaddr;
+	in_addr bp_giaddr;
+	uint8_t  bp_hwaddr[16];
+	uint8_t  bp_sname[64];
+	char     bp_file[128];
+	uint8_t  bp_vend[DHCP_OPT_LEN];
+};
+
+/* Format of a bootp IP packet */
+struct bootpip_t
+{
+	struct iphdr ip;
+	struct udphdr udp;
+	struct bootp_t bp;
+};
+struct dhcpip_t
+{
+	struct iphdr ip;
+	struct udphdr udp;
+	struct dhcp_t bp;
+};
+
+#define MAX_RFC1533_VENDLEN (ETH_MAX_MTU - sizeof(struct bootpip_t) + BOOTP_VENDOR_LEN)
+
+#define BOOTP_DATA_ADDR (&bootp_data)
+
+#endif	/* _BOOTP_H */
diff -Naur grub-0.97.orig/netboot/byteswap.h grub-0.97/netboot/byteswap.h
--- grub-0.97.orig/netboot/byteswap.h	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/byteswap.h	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,20 @@
+#ifndef ETHERBOOT_BYTESWAP_H
+#define ETHERBOOT_BYTESWAP_H
+
+#include "endian.h"
+#include "i386_byteswap.h"
+
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+#include "little_bswap.h"
+#endif
+#if __BYTE_ORDER == __BIG_ENDIAN
+#include "big_bswap.h"
+#endif
+
+/* Make routines available to all */
+#define swap32(x)	__bswap_32(x)
+#define swap16(x)	__bswap_16(x)
+#define bswap_32(x)	__bswap_32(x)
+#define bswap_16(x)	__bswap_16(x)
+	
+#endif /* ETHERBOOT_BYTESWAP_H */
diff -Naur grub-0.97.orig/netboot/cards.h grub-0.97/netboot/cards.h
--- grub-0.97.orig/netboot/cards.h	2003-07-09 11:45:37.000000000 +0000
+++ grub-0.97/netboot/cards.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,183 +0,0 @@
-#ifndef	CARDS_H
-#define CARDS_H
-
-/*
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2, or (at
- * your option) any later version.
- */
-
-#include "nic.h"
-
-/* OK, this is how the PCI support hack works:  if pci.h is included before
- * this file is included, assume that the driver supports PCI.  This means that
- * this file is usually included last.  */
-
-#ifdef	PCI_H
-#define PCI_ARG(x) ,x
-#else
-#define PCI_ARG(x)
-#endif
-
-#ifdef	INCLUDE_WD
-extern struct nic	*wd_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_3C503
-extern struct nic	*t503_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_VIA_RHINE
-extern struct nic	*rhine_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_NE
-extern struct nic	*ne_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_NS8390
-extern struct nic	*nepci_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_3C509
-extern struct nic	*t509_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_3C529
-extern struct nic	*t529_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_3C595
-extern struct nic	*t595_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_3C90X
-extern struct nic	*a3c90x_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_EEPRO
-extern struct nic	*eepro_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_EEPRO100
-extern struct nic	*eepro100_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_EPIC100
-extern struct nic	*epic100_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_OTULIP
-extern struct nic	*otulip_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_TULIP
-extern struct nic	*tulip_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_DAVICOM
-extern struct nic	*davicom_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_CS89X0
-extern struct nic	*cs89x0_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_LANCE
-extern struct nic	*lancepci_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_NE2100
-extern struct nic	*ne2100_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_NI6510
-extern struct nic	*ni6510_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_SK_G16
-extern struct nic	*SK_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_3C507
-extern struct nic	*t507_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_NI5010
-extern struct nic	*ni5010_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_NI5210
-extern struct nic	*ni5210_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_EXOS205
-extern struct nic	*exos205_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_SMC9000
-extern struct nic	*smc9000_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_TIARA
-extern struct nic	*tiara_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_DEPCA
-extern struct nic	*depca_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_RTL8139
-extern struct nic	*rtl8139_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_W89C840
-extern struct nic	*w89c840_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_SIS900
-extern struct nic	*sis900_probe(struct nic *, unsigned short *
-        PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_NATSEMI
-extern struct nic	*natsemi_probe(struct nic *, unsigned short *
-        PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_TLAN
-extern struct nic	*tlan_probe(struct nic *, unsigned short *
-        PCI_ARG(struct pci_device *));
-#endif
-
-#endif	/* CARDS_H */
diff -Naur grub-0.97.orig/netboot/config.c grub-0.97/netboot/config.c
--- grub-0.97.orig/netboot/config.c	2003-07-09 11:45:37.000000000 +0000
+++ grub-0.97/netboot/config.c	2005-08-31 19:03:35.000000000 +0000
@@ -1,598 +1,165 @@
 /*
- *  GRUB  --  GRand Unified Bootloader
- *  Copyright (C) 2001,2002  Free Software Foundation, Inc.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-/* Based on "src/config.c" in etherboot-5.0.5.  */
-
-/*
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
  * published by the Free Software Foundation; either version 2, or (at
  * your option) any later version.
  */
 
-#define GRUB	1
-#include <etherboot.h>
-#include <nic.h>
+#include	"grub.h"
+#include	"pci.h"
+#include	"isa.h"
+#include	"nic.h"
 
-#undef	INCLUDE_PCI
-#if	defined(INCLUDE_NS8390) || defined(INCLUDE_EEPRO100) || defined(INCLUDE_LANCE) || defined(INCLUDE_EPIC100) || defined(INCLUDE_TULIP) || defined(INCLUDE_OTULIP) || defined(INCLUDE_3C90X) ||  defined(INCLUDE_3C595) || defined(INCLUDE_RTL8139) || defined(INCLUDE_VIA_RHINE) || defined(INCLUDE_W89C840) || defined(INCLUDE_DAVICOM) || defined(INCLUDE_SIS900) || defined(INCLUDE_NATSEMI) || defined(INCLUDE_TLAN)
-	/* || others later */
-# define INCLUDE_PCI
-# include <pci.h>
-static unsigned short pci_ioaddrs[16];
-
-static struct pci_device pci_nic_list[] =
+#ifdef CONFIG_PCI
+static int pci_probe(struct dev *dev, const char *type_name)
 {
-#ifdef	INCLUDE_NS8390
-  { PCI_VENDOR_ID_REALTEK,	PCI_DEVICE_ID_REALTEK_8029,
-    "Realtek 8029", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_WINBOND2,	PCI_DEVICE_ID_WINBOND2_89C940,
-    "Winbond NE2000-PCI", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_COMPEX,	PCI_DEVICE_ID_COMPEX_RL2000,
-    "Compex ReadyLink 2000", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_KTI,		PCI_DEVICE_ID_KTI_ET32P2,
-    "KTI ET32P2", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_NETVIN,	PCI_DEVICE_ID_NETVIN_NV5000SC,
-    "NetVin NV5000SC", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_HOLTEK,	PCI_DEVICE_ID_HOLTEK_HT80232,
-    "Holtek HT80232", 0, 0, 0, 0},
-#endif
-#ifdef	INCLUDE_3C90X
-  { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C900TPO,
-    "3Com900-TPO", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C900COMBO,
-    "3Com900-Combo", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C905TX,
-    "3Com905-TX", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C905T4,
-    "3Com905-T4", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		0x9004,
-    "3Com900B-TPO", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		0x9005,
-    "3Com900B-Combo", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		0x9006,
-    "3Com900B-2/T", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		0x900A,
-    "3Com900B-FL", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C905B_TX,
-    "3Com905B-TX", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		0x9056,
-    "3Com905B-T4", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		0x905A,
-    "3Com905B-FL", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C905C_TXM,
-    "3Com905C-TXM", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		0x9800,
-    "3Com980-Cyclone", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		0x9805,
-    "3Com9805", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		0x7646,
-    "3CSOHO100-TX", 0, 0, 0, 0},
-#endif
-#ifdef	INCLUDE_3C595
-  { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C590,
-    "3Com590", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C595,
-    "3Com595", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C595_1,
-    "3Com595", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C595_2,
-    "3Com595", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C900TPO,
-    "3Com900-TPO", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C900COMBO,
-    "3Com900-Combo", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		0x9004,
-    "3Com900B-TPO", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		0x9005,
-    "3Com900B-Combo", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		0x9006,
-    "3Com900B-2/T", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		0x900A,
-    "3Com900B-FL", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		0x9800,
-    "3Com980-Cyclone", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		0x9805,
-    "3Com9805", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		0x7646,
-    "3CSOHO100-TX", 0, 0, 0, 0},
-#endif
-#ifdef	INCLUDE_EEPRO100
-  { PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82557,
-    "Intel EtherExpressPro100", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82559ER,
-    "Intel EtherExpressPro100 82559ER", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_ID1029,
-    "Intel EtherExpressPro100 ID1029", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_ID1030,
-    "Intel Corporation 82559 InBusiness 10/100", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82562,
-    "Intel EtherExpressPro100 82562EM", 0, 0, 0, 0},
-#endif
-#ifdef	INCLUDE_EPIC100
-  { PCI_VENDOR_ID_SMC,		PCI_DEVICE_ID_SMC_EPIC100,
-    "SMC EtherPowerII", 0, 0, 0, 0},
-#endif
-#ifdef	INCLUDE_LANCE
-  { PCI_VENDOR_ID_AMD,		PCI_DEVICE_ID_AMD_LANCE,
-    "AMD Lance/PCI", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_AMD_HOMEPNA,	PCI_DEVICE_ID_AMD_HOMEPNA,
-    "AMD Lance/HomePNA", 0, 0, 0, 0},
-#endif
-#ifdef	INCLUDE_RTL8139
-  { PCI_VENDOR_ID_REALTEK,	PCI_DEVICE_ID_REALTEK_8139,
-    "Realtek 8139", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_DLINK,	PCI_DEVICE_ID_DFE530TXP,
-    "DFE530TX+/DFE538TX", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_SMC_1211,	PCI_DEVICE_ID_SMC_1211,
-    "SMC EZ10/100", 0, 0, 0, 0},
-#endif
-#ifdef	INCLUDE_OTULIP
-  { PCI_VENDOR_ID_DEC,		PCI_DEVICE_ID_DEC_TULIP,
-    "Digital Tulip", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_DEC,		PCI_DEVICE_ID_DEC_TULIP_FAST,
-    "Digital Tulip Fast", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_DEC,		PCI_DEVICE_ID_DEC_TULIP_PLUS,
-    "Digital Tulip+", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_DEC,		PCI_DEVICE_ID_DEC_21142,
-    "Digital Tulip 21142", 0, 0, 0, 0},
-#endif
-#ifdef	INCLUDE_TULIP
-  { PCI_VENDOR_ID_DEC,		PCI_DEVICE_ID_DEC_TULIP,
-    "Digital Tulip", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_DEC,		PCI_DEVICE_ID_DEC_TULIP_FAST,
-    "Digital Tulip Fast", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_DEC,		PCI_DEVICE_ID_DEC_TULIP_PLUS,
-    "Digital Tulip+", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_DEC,		PCI_DEVICE_ID_DEC_21142,
-    "Digital Tulip 21142", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_MACRONIX,	PCI_DEVICE_ID_MX987x5,
-    "Macronix MX987x5", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_LINKSYS,	PCI_DEVICE_ID_LC82C115,
-    "LinkSys LNE100TX", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_LINKSYS,	PCI_DEVICE_ID_DEC_TULIP,
-    "Netgear FA310TX", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_DAVICOM,	PCI_DEVICE_ID_DM9102,
-    "Davicom 9102", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_DAVICOM,	PCI_DEVICE_ID_DM9009,
-    "Davicom 9009", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_ADMTEK,	PCI_DEVICE_ID_ADMTEK_0985,
-    "ADMtek Centaur-P", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_ADMTEK,	0x0981,
-    "ADMtek AN981 Comet", 0, 0, 0, 0},
-  { 0x125B,			0x1400,
-    "ASIX AX88140", 0, 0, 0, 0 },
-  { 0x11F6,			0x9881,
-    "Compex RL100-TX", 0, 0, 0, 0 },
-#endif
-#ifdef	INCLUDE_DAVICOM
-  { PCI_VENDOR_ID_DAVICOM,	PCI_DEVICE_ID_DM9102,
-    "Davicom 9102", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_DAVICOM,	PCI_DEVICE_ID_DM9009,
-    "Davicom 9009", 0, 0, 0, 0},
-#endif
-#ifdef	INCLUDE_VIA_RHINE
-  { PCI_VENDOR_ID_VIATEC,	PCI_DEVICE_ID_VIA_VT6102,
-    "VIA 6102", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_VIATEC,	PCI_DEVICE_ID_VIA_RHINE_I,
-    "VIA 3043", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_VIATEC,	PCI_DEVICE_ID_VIA_86C100A,
-    "VIA 86C100A", 0, 0, 0, 0},
-#endif
-#ifdef	INCLUDE_W89C840
-  { PCI_VENDOR_ID_WINBOND2,	PCI_DEVICE_ID_WINBOND2_89C840,
-    "Winbond W89C840F", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_COMPEX,	PCI_DEVICE_ID_COMPEX_RL100ATX,
-    "Compex RL100ATX", 0, 0, 0, 0},
-#endif
-#ifdef INCLUDE_SIS900
-  { PCI_VENDOR_ID_SIS,     	PCI_DEVICE_ID_SIS900,
-    "SIS900", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_SIS,     	PCI_DEVICE_ID_SIS7016,
-    "SIS7016", 0, 0, 0, 0},
-#endif
-  
-#ifdef INCLUDE_NATSEMI
-  { PCI_VENDOR_ID_NS,	     	PCI_DEVICE_ID_DP83815,
-    "DP83815", 0, 0, 0, 0},
-#endif
-  
-#ifdef INCLUDE_TLAN
-  { PCI_VENDOR_ID_OLICOM,	PCI_DEVICE_ID_OLICOM_OC2326,
-    "OC2326", 0, 0, 0, 0},
+/*
+ *	NIC probing is in pci device order, followed by the 
+ *      link order of the drivers.  A driver that matches 
+ *      on vendor and device id will supersede a driver
+ *      that matches on pci class.
+ *
+ *	If you want to probe for another device behind the same pci
+ *      device just increment index.  And the previous probe call
+ *      will be repeated.
+ */
+	struct pci_probe_state *state = &dev->state.pci;
+	printf("Probing pci %s...\n", type_name);
+	if (dev->how_probe == PROBE_FIRST) {
+		state->advance    = 1;
+		state->dev.driver = 0;
+		state->dev.bus    = 0;
+		state->dev.devfn  = 0;
+		dev->index        = -1;
+	}
+	for(;;) {
+		if ((dev->how_probe != PROBE_AWAKE) && state->advance) {
+			find_pci(dev->type, &state->dev);
+			dev->index = -1;
+		}
+		state->advance = 1;
+		
+		if (state->dev.driver == 0)
+			break;
+		
+#if 0
+		/* FIXME the romaddr code needs a total rethought to be useful */
+		if (state->dev.romaddr != ((unsigned long) rom.rom_segment << 4)) {
+			continue;
+		}
+#endif
+		if (dev->how_probe != PROBE_AWAKE) {
+			dev->type_index++;
+		}
+		dev->devid.bus_type = PCI_BUS_TYPE;
+		dev->devid.vendor_id = htons(state->dev.vendor);
+		dev->devid.device_id = htons(state->dev.dev_id);
+		/* FIXME how do I handle dev->index + PROBE_AGAIN?? */
+		
+		printf("[%s]", state->dev.name);
+		if (state->dev.driver->probe(dev, &state->dev)) {
+			state->advance = (dev->index == -1);
+			return PROBE_WORKED;
+		}
+		putchar('\n');
+	}
+	return PROBE_FAILED;
+}
 #endif
 
-  /* other PCI NICs go here */
-  {0, 0, NULL, 0, 0, 0, 0}
-};
-#endif	/* INCLUDE_*PCI */
-
-#include <cards.h>
-
-#ifdef INCLUDE_PCI
-struct pci_dispatch_table
+#ifdef CONFIG_ISA
+static int isa_probe(struct dev *dev, const char *type_name)
 {
-  unsigned short vendor;
-  unsigned short dev_id;
-  struct nic *(*eth_probe) (struct nic *, unsigned short *,
-			    struct pci_device *);
-};
-
-static struct pci_dispatch_table PCI_NIC[] =
-{
-# ifdef INCLUDE_NS8390
-  { PCI_VENDOR_ID_REALTEK,  PCI_DEVICE_ID_REALTEK_8029,    nepci_probe },
-  { PCI_VENDOR_ID_WINBOND2, PCI_DEVICE_ID_WINBOND2_89C940, nepci_probe },
-  { PCI_VENDOR_ID_COMPEX,   PCI_DEVICE_ID_COMPEX_RL2000,   nepci_probe },
-  { PCI_VENDOR_ID_KTI,      PCI_DEVICE_ID_KTI_ET32P2,      nepci_probe },
-  { PCI_VENDOR_ID_NETVIN,   PCI_DEVICE_ID_NETVIN_NV5000SC, nepci_probe },
-  { PCI_VENDOR_ID_HOLTEK,   PCI_DEVICE_ID_HOLTEK_HT80232,  nepci_probe },
-# endif /* INCLUDE_NS8390 */
-# ifdef INCLUDE_3C90X
-  { PCI_VENDOR_ID_3COM,	    PCI_DEVICE_ID_3COM_3C900TPO,   a3c90x_probe },
-  { PCI_VENDOR_ID_3COM,     PCI_DEVICE_ID_3COM_3C900COMBO, a3c90x_probe },
-  { PCI_VENDOR_ID_3COM,     PCI_DEVICE_ID_3COM_3C905TX,    a3c90x_probe },
-  { PCI_VENDOR_ID_3COM,     PCI_DEVICE_ID_3COM_3C905T4,    a3c90x_probe },
-  { PCI_VENDOR_ID_3COM,     0x9004,                        a3c90x_probe },
-  { PCI_VENDOR_ID_3COM,     0x9005,                        a3c90x_probe },
-  { PCI_VENDOR_ID_3COM,     0x9006,                        a3c90x_probe },
-  { PCI_VENDOR_ID_3COM,     0x900A,                        a3c90x_probe },
-  { PCI_VENDOR_ID_3COM,     PCI_DEVICE_ID_3COM_3C905B_TX,  a3c90x_probe },
-  { PCI_VENDOR_ID_3COM,     0x9056,                        a3c90x_probe },
-  { PCI_VENDOR_ID_3COM,     0x905A,                        a3c90x_probe },
-  { PCI_VENDOR_ID_3COM,     PCI_DEVICE_ID_3COM_3C905C_TXM, a3c90x_probe },
-  { PCI_VENDOR_ID_3COM,     0x9800,                        a3c90x_probe },
-  { PCI_VENDOR_ID_3COM,     0x9805,                        a3c90x_probe },
-  { PCI_VENDOR_ID_3COM,     0x7646,                        a3c90x_probe },
-# endif /* INCLUDE_3C90X */
-# ifdef	INCLUDE_3C595
-  { PCI_VENDOR_ID_3COM,     PCI_DEVICE_ID_3COM_3C590,      t595_probe },
-  { PCI_VENDOR_ID_3COM,     PCI_DEVICE_ID_3COM_3C595,      t595_probe },
-  { PCI_VENDOR_ID_3COM,     PCI_DEVICE_ID_3COM_3C595_1,    t595_probe },
-  { PCI_VENDOR_ID_3COM,     PCI_DEVICE_ID_3COM_3C595_2,    t595_probe },
-  { PCI_VENDOR_ID_3COM,     PCI_DEVICE_ID_3COM_3C900TPO,   t595_probe },
-  { PCI_VENDOR_ID_3COM,     PCI_DEVICE_ID_3COM_3C900COMBO, t595_probe },
-  { PCI_VENDOR_ID_3COM,     0x9004,                        t595_probe },
-  { PCI_VENDOR_ID_3COM,     0x9005,                        t595_probe },
-  { PCI_VENDOR_ID_3COM,     0x9006,                        t595_probe },
-  { PCI_VENDOR_ID_3COM,     0x900A,                        t595_probe },
-  { PCI_VENDOR_ID_3COM,     0x9800,                        t595_probe },
-  { PCI_VENDOR_ID_3COM,     0x9805,                        t595_probe },
-  { PCI_VENDOR_ID_3COM,     0x7646,                        t595_probe },
-# endif /* INCLUDE_3C595 */
-# ifdef	INCLUDE_EEPRO100
-  { PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82557,     eepro100_probe },
-  { PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82559ER,   eepro100_probe },
-  { PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_ID1029,    eepro100_probe },
-  { PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_ID1030,    eepro100_probe },
-  { PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82562,     eepro100_probe },
-# endif /* INCLUDE_EEPRO100 */
-# ifdef	INCLUDE_EPIC100
-  { PCI_VENDOR_ID_SMC,      PCI_DEVICE_ID_SMC_EPIC100,     epic100_probe },
-# endif /* INCLUDE_EPIC100 */
-# ifdef	INCLUDE_LANCE
-  { PCI_VENDOR_ID_AMD,      PCI_DEVICE_ID_AMD_LANCE,       lancepci_probe },
-  { PCI_VENDOR_ID_AMD_HOMEPNA, PCI_DEVICE_ID_AMD_HOMEPNA,  lancepci_probe },
-# endif /* INCLUDE_LANCE */
-# ifdef	INCLUDE_RTL8139
-  { PCI_VENDOR_ID_REALTEK,  PCI_DEVICE_ID_REALTEK_8139,    rtl8139_probe },
-  { PCI_VENDOR_ID_DLINK,    PCI_DEVICE_ID_DFE530TXP,       rtl8139_probe },
-  { PCI_VENDOR_ID_SMC_1211, PCI_DEVICE_ID_SMC_1211,        rtl8139_probe },
-# endif /* INCLUDE_RTL8139 */
-# ifdef	INCLUDE_OTULIP
-  { PCI_VENDOR_ID_DEC,      PCI_DEVICE_ID_DEC_TULIP,       otulip_probe },
-  { PCI_VENDOR_ID_DEC,      PCI_DEVICE_ID_DEC_TULIP_FAST,  otulip_probe },
-  { PCI_VENDOR_ID_DEC,      PCI_DEVICE_ID_DEC_TULIP_PLUS,  otulip_probe },
-  { PCI_VENDOR_ID_DEC,      PCI_DEVICE_ID_DEC_21142,       otulip_probe },
-# endif /* INCLUDE_OTULIP */
-# ifdef	INCLUDE_TULIP
-  { PCI_VENDOR_ID_DEC,      PCI_DEVICE_ID_DEC_TULIP,       tulip_probe },
-  { PCI_VENDOR_ID_DEC,      PCI_DEVICE_ID_DEC_TULIP_FAST,  tulip_probe },
-  { PCI_VENDOR_ID_DEC,      PCI_DEVICE_ID_DEC_TULIP_PLUS,  tulip_probe },
-  { PCI_VENDOR_ID_DEC,      PCI_DEVICE_ID_DEC_21142,       tulip_probe },
-  { PCI_VENDOR_ID_MACRONIX, PCI_DEVICE_ID_MX987x5,         tulip_probe },
-  { PCI_VENDOR_ID_LINKSYS,  PCI_DEVICE_ID_LC82C115,        tulip_probe },
-  { PCI_VENDOR_ID_LINKSYS,  PCI_DEVICE_ID_DEC_TULIP,       tulip_probe },
-  { PCI_VENDOR_ID_DAVICOM,  PCI_DEVICE_ID_DM9102,          tulip_probe },
-  { PCI_VENDOR_ID_DAVICOM,  PCI_DEVICE_ID_DM9009,          tulip_probe },
-  { PCI_VENDOR_ID_ADMTEK,   PCI_DEVICE_ID_ADMTEK_0985,     tulip_probe },
-  { PCI_VENDOR_ID_ADMTEK,   0x0981,                        tulip_probe },
-  { 0x125B,                 0x1400,                        tulip_probe },
-  { 0x11F6,                 0x9881,                        tulip_probe },
-# endif /* INCLUDE_TULIP */
-# ifdef INCLUDE_DAVICOM
-  { PCI_VENDOR_ID_DAVICOM,   PCI_DEVICE_ID_DM9102,           davicom_probe },
-  { PCI_VENDOR_ID_DAVICOM,   PCI_DEVICE_ID_DM9009,           davicom_probe },
-# endif /* INCLUDE_DAVICOM */
-# ifdef	INCLUDE_VIA_RHINE
-  { PCI_VENDOR_ID_VIATEC,   PCI_DEVICE_ID_VIA_VT6102,      rhine_probe },
-  { PCI_VENDOR_ID_VIATEC,   PCI_DEVICE_ID_VIA_RHINE_I,     rhine_probe },
-  { PCI_VENDOR_ID_VIATEC,   PCI_DEVICE_ID_VIA_86C100A,     rhine_probe },
-# endif /* INCLUDE_VIA_RHINE */
-# ifdef INCLUDE_W89C840
-  { PCI_VENDOR_ID_WINBOND2, PCI_DEVICE_ID_WINBOND2_89C840, w89c840_probe },
-  { PCI_VENDOR_ID_COMPEX,   PCI_DEVICE_ID_COMPEX_RL100ATX, w89c840_probe },
-# endif /* INCLUDE_W89C840 */
-# ifdef INCLUDE_SIS900
-  { PCI_VENDOR_ID_SIS,      PCI_DEVICE_ID_SIS900,          sis900_probe },
-  { PCI_VENDOR_ID_SIS,      PCI_DEVICE_ID_SIS7016,         sis900_probe },
-# endif /* INCLUDE_SIS900 */
-# ifdef INCLUDE_NATSEMI
-  { PCI_VENDOR_ID_NS,       PCI_DEVICE_ID_DP83815,         natsemi_probe },
-# endif /* INCLUDE_NATSEMI */
-# ifdef INCLUDE_TLAN
-  { PCI_VENDOR_ID_OLICOM,   PCI_DEVICE_ID_OLICOM_OC2326,   tlan_probe },
-# endif /* INCLUDE_TLAN */
-  { 0,                      0,                             0 }
-};
-#endif /* GRUB && INCLUDE_PCI */
-
-struct dispatch_table
-{
-  const char	*nic_name;
-#ifdef	INCLUDE_PCI
-  struct nic	*(*eth_probe) (struct nic *, unsigned short *,
-			       struct pci_device *);
-#else
-  struct nic	*(*eth_probe) (struct nic *, unsigned short *);
-#endif	/* INCLUDE_PCI */
-  unsigned short	*probe_ioaddrs;		/* for probe overrides */
-};
-
 /*
- *	NIC probing is in order of appearance in this table.
+ *	NIC probing is in the order the drivers were linked togeter.
  *	If for some reason you want to change the order,
- *	just rearrange the entries (bracketed by the #ifdef/#endif)
+ *	just change the order you list the drivers in.
  */
-static struct dispatch_table	NIC[] =
-{
-#ifdef	INCLUDE_RTL8139
-  { "RTL8139", rtl8139_probe, pci_ioaddrs },
-#endif
-#ifdef INCLUDE_SIS900
-  { "SIS900", sis900_probe, pci_ioaddrs },	
-#endif
-#ifdef INCLUDE_NATSEMI
-  { "NATSEMI", natsemi_probe, pci_ioaddrs },	
-#endif
-#ifdef	INCLUDE_WD
-  { "WD", wd_probe, 0 },
-#endif
-#ifdef	INCLUDE_3C503
-  { "3C503", t503_probe, 0 },
-#endif
-#ifdef	INCLUDE_NE
-  { "NE*000", ne_probe, 0 },
-#endif
-#ifdef	INCLUDE_3C509
-  { "3C5x9", t509_probe, 0 },
-#endif
-#ifdef	INCLUDE_3C529
-  { "3C5x9", t529_probe, 0 },
-#endif
-#ifdef	INCLUDE_3C595
-  { "3C595", t595_probe, pci_ioaddrs },
-#endif
-#ifdef	INCLUDE_3C90X
-  { "3C90X", a3c90x_probe, pci_ioaddrs },
-#endif
-#ifdef	INCLUDE_EEPRO
-  { "EEPRO", eepro_probe, 0 },
-#endif
-#ifdef	INCLUDE_EEPRO100
-  { "EEPRO100", eepro100_probe, pci_ioaddrs },
-#endif
-#ifdef	INCLUDE_EPIC100
-  { "EPIC100", epic100_probe, pci_ioaddrs },
-#endif
-#ifdef	INCLUDE_OTULIP
-  { "OTulip", otulip_probe, pci_ioaddrs },
-#endif
-#ifdef	INCLUDE_TULIP
-  { "Tulip", tulip_probe, pci_ioaddrs },
-#endif
-#ifdef	INCLUDE_DAVICOM
-  { "DAVICOM", davicom_probe, pci_ioaddrs },
-#endif
-#ifdef	INCLUDE_CS89X0
-  { "CS89x0", cs89x0_probe, 0 },
-#endif
-#ifdef	INCLUDE_NE2100
-  { "NE2100", ne2100_probe, 0 },
-#endif
-#ifdef	INCLUDE_NI6510
-  { "NI6510", ni6510_probe, 0 },
-#endif
-#ifdef	INCLUDE_SK_G16
-  { "SK_G16", SK_probe, 0 },
-#endif
-#ifdef	INCLUDE_3C507
-  { "3C507", t507_probe, 0 },
-#endif
-#ifdef	INCLUDE_NI5010
-  { "NI5010", ni5010_probe, 0 },
-#endif
-#ifdef	INCLUDE_NI5210
-  { "NI5210", ni5210_probe, 0 },
-#endif
-#ifdef	INCLUDE_EXOS205
-  { "EXOS205", exos205_probe, 0 },
-#endif
-#ifdef	INCLUDE_SMC9000
-  { "SMC9000", smc9000_probe, 0 },
-#endif
-#ifdef	INCLUDE_TIARA
-  { "TIARA", tiara_probe, 0 },
-#endif
-#ifdef	INCLUDE_DEPCA
-  { "DEPCA", depca_probe, 0 },
-#endif
-#ifdef	INCLUDE_NS8390
-  { "NE2000/PCI", nepci_probe, pci_ioaddrs },
-#endif
-#ifdef	INCLUDE_LANCE
-  { "LANCE/PCI", lancepci_probe, pci_ioaddrs },
-#endif
-#ifdef	INCLUDE_VIA_RHINE
-  { "VIA 86C100", rhine_probe, pci_ioaddrs },
-#endif
-#ifdef	INCLUDE_W89C840
-  { "W89C840F", w89c840_probe, pci_ioaddrs },
-#endif
-#ifdef	INCLUDE_TLAN
-  { "Olicom 2326", tlan_probe, pci_ioaddrs },
-#endif
-  /* this entry must always be last to mark the end of list */
-  { 0, 0, 0 }
-};
-
-#define	NIC_TABLE_SIZE	(sizeof (NIC) / sizeof (NIC[0]))
-
-static int
-eth_dummy (struct nic *dummy)
-{
-  return 0;
+	struct isa_probe_state *state = &dev->state.isa;
+	printf("Probing isa %s...\n", type_name);
+	if (dev->how_probe == PROBE_FIRST) {
+		state->advance = 0;
+		state->driver  = isa_drivers;
+		dev->index     = -1;
+	}
+	for(;;)
+	{
+		if ((dev->how_probe != PROBE_AWAKE) && state->advance) {
+			state->driver++;
+			dev->index = -1;
+		}
+		state->advance = 1;
+		
+		if (state->driver >= isa_drivers_end)
+			break;
+
+		if (state->driver->type != dev->type)
+			continue;
+
+		if (dev->how_probe != PROBE_AWAKE) {
+			dev->type_index++;
+		}
+		printf("[%s]", state->driver->name);
+		dev->devid.bus_type = ISA_BUS_TYPE;
+		/* FIXME how do I handle dev->index + PROBE_AGAIN?? */
+		/* driver will fill in vendor and device IDs */
+		if (state->driver->probe(dev, state->driver->ioaddrs)) {
+			state->advance = (dev->index == -1);
+			return PROBE_WORKED;
+		}
+		putchar('\n');
+	}
+	return PROBE_FAILED;
 }
-
-static char	packet[ETH_FRAME_LEN];
-
-struct nic	nic =
-{
-  (void (*) (struct nic *)) eth_dummy,	/* reset */
-  eth_dummy,				/* poll */
-  (void (*) (struct nic *, const char *,
-	     unsigned int, unsigned int,
-	     const char *)) eth_dummy,	/* transmit */
-  (void (*) (struct nic *)) eth_dummy,	/* disable */
-#ifdef	T503_AUI
-  1,					/* aui */
 #else
-  0,					/* no aui */
+#define isa_probe(d,tn) (PROBE_FAILED)
 #endif
-  &rom,					/* rom_info */
-  arptable[ARP_CLIENT].node,		/* node_addr */
-  packet,				/* packet */
-  0,				/* packetlen */
-  0,				/* priv_data */
+static const char *driver_name[] = {
+	"nic", 
+	"disk", 
+	"floppy",
 };
-
-void
-eth_reset (void)
+int probe(struct dev *dev)
 {
-  (*nic.reset) (&nic);
-}
+	const char *type_name;
 
-int
-eth_probe (void)
-{
-  struct pci_device	*p;
-  const struct dispatch_table	*t;
-  static int probed = 0;
+	EnterFunction("probe");
 
-  /* If already probed, don't try to probe it any longer.  */
-  if (probed)
-    return 1;
-  
-  /* Clear the ready flag.  */
-  network_ready = 0;
-  /* Clear the ARP table.  */
-  grub_memset ((char *) arptable, 0,
-	       MAX_ARP * sizeof (struct arptable_t));
-  
-  p = 0;
-  
-#ifdef	INCLUDE_PCI
-  /* In GRUB, the ROM info is initialized here.  */
-  rom = *((struct rom_info *) ROM_INFO_LOCATION);
-  
-  eth_pci_init(pci_nic_list);
-  pci_ioaddrs[0] = 0;
-  pci_ioaddrs[1] = 0;
-  /* at this point we have a list of possible PCI candidates
-     we just pick the first one with a non-zero ioaddr */
-  for (p = pci_nic_list; p->vendor != 0; ++p)
-    {
-      if (p->ioaddr != 0)
-	{
-	  pci_ioaddrs[0] = p->ioaddr;
-	  break;
+	type_name = "";
+	if ((dev->type >= 0) && 
+		(dev->type < sizeof(driver_name)/sizeof(driver_name[0]))) {
+		type_name = driver_name[dev->type];
 	}
-    }
-#endif
-  
-  etherboot_printf("Probing...");
-	
-#ifdef INCLUDE_PCI
-  if (p->vendor)
-    {
-      struct pci_dispatch_table *pt;
-      
-      for (pt = PCI_NIC; pt->eth_probe != 0; pt++)
-	if (p->vendor == pt->vendor && p->dev_id == pt->dev_id)
-	  {
-	    etherboot_printf ("[%s]", p->name);
-	    if ((pt->eth_probe) (&nic, pci_ioaddrs, p))
-	      {
-		probed = 1;
-		return 1;
-	      }
-	  }
-    }
-#endif /* INCLUDE_PCI */
-	
-  for (t = NIC; t->nic_name != 0; ++t)
-    {
-      etherboot_printf("[%s]", t->nic_name);
-#ifdef	INCLUDE_PCI
-      if ((*t->eth_probe) (&nic, t->probe_ioaddrs, p))
-	{
-	  probed = 1;
-	  return 1;
+	if (dev->how_probe == PROBE_FIRST) {
+		dev->to_probe = PROBE_PCI;
+		memset(&dev->state, 0, sizeof(dev->state));
 	}
-#else
-      if ((*t->eth_probe) (&nic, t->probe_ioaddrs))
-	{
-	  probed = 1;
-	  return 1;
+	if (dev->to_probe == PROBE_PCI) {
+		dev->how_probe = pci_probe(dev, type_name);
+		if (dev->how_probe == PROBE_FAILED) {
+			dev->to_probe = PROBE_ISA;
+		}
+	}
+	if (dev->to_probe == PROBE_ISA) {
+		dev->how_probe = isa_probe(dev, type_name);
+		if (dev->how_probe == PROBE_FAILED) {
+			dev->to_probe = PROBE_NONE;
+		}
+	}
+	if ((dev->to_probe != PROBE_PCI) &&
+		(dev->to_probe != PROBE_ISA)) {
+		dev->how_probe = PROBE_FAILED;
+		
 	}
-#endif	/* INCLUDE_PCI */
-    }
-  
-  return 0;
-}
-
-int
-eth_poll (void)
-{
-  return ((*nic.poll) (&nic));
-}
 
-void
-eth_transmit (const char *d, unsigned int t, unsigned int s, const void *p)
-{
-  (*nic.transmit) (&nic, d, t, s, p);
-  if (t == IP)
-    twiddle ();
+	LeaveFunction("probe");
+	return dev->how_probe;
 }
 
-void
-eth_disable (void)
+void disable(struct dev *dev)
 {
-  (*nic.disable) (&nic);
+	if (dev->disable) {
+		dev->disable(dev);
+		dev->disable = 0;
+	}
 }
diff -Naur grub-0.97.orig/netboot/cpu.h grub-0.97/netboot/cpu.h
--- grub-0.97.orig/netboot/cpu.h	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/cpu.h	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,243 @@
+#ifndef I386_BITS_CPU_H
+#define I386_BITS_CPU_H
+
+
+/* Sample usage: CPU_FEATURE_P(cpu.x86_capability, FPU) */
+#define CPU_FEATURE_P(CAP, FEATURE) \
+	(!!(CAP[(X86_FEATURE_##FEATURE)/32] & ((X86_FEATURE_##FEATURE) & 0x1f)))
+
+#define NCAPINTS	4	/* Currently we have 4 32-bit words worth of info */
+
+/* Intel-defined CPU features, CPUID level 0x00000001, word 0 */
+#define X86_FEATURE_FPU		(0*32+ 0) /* Onboard FPU */
+#define X86_FEATURE_VME		(0*32+ 1) /* Virtual Mode Extensions */
+#define X86_FEATURE_DE		(0*32+ 2) /* Debugging Extensions */
+#define X86_FEATURE_PSE 	(0*32+ 3) /* Page Size Extensions */
+#define X86_FEATURE_TSC		(0*32+ 4) /* Time Stamp Counter */
+#define X86_FEATURE_MSR		(0*32+ 5) /* Model-Specific Registers, RDMSR, WRMSR */
+#define X86_FEATURE_PAE		(0*32+ 6) /* Physical Address Extensions */
+#define X86_FEATURE_MCE		(0*32+ 7) /* Machine Check Architecture */
+#define X86_FEATURE_CX8		(0*32+ 8) /* CMPXCHG8 instruction */
+#define X86_FEATURE_APIC	(0*32+ 9) /* Onboard APIC */
+#define X86_FEATURE_SEP		(0*32+11) /* SYSENTER/SYSEXIT */
+#define X86_FEATURE_MTRR	(0*32+12) /* Memory Type Range Registers */
+#define X86_FEATURE_PGE		(0*32+13) /* Page Global Enable */
+#define X86_FEATURE_MCA		(0*32+14) /* Machine Check Architecture */
+#define X86_FEATURE_CMOV	(0*32+15) /* CMOV instruction (FCMOVCC and FCOMI too if FPU present) */
+#define X86_FEATURE_PAT		(0*32+16) /* Page Attribute Table */
+#define X86_FEATURE_PSE36	(0*32+17) /* 36-bit PSEs */
+#define X86_FEATURE_PN		(0*32+18) /* Processor serial number */
+#define X86_FEATURE_CLFLSH	(0*32+19) /* Supports the CLFLUSH instruction */
+#define X86_FEATURE_DTES	(0*32+21) /* Debug Trace Store */
+#define X86_FEATURE_ACPI	(0*32+22) /* ACPI via MSR */
+#define X86_FEATURE_MMX		(0*32+23) /* Multimedia Extensions */
+#define X86_FEATURE_FXSR	(0*32+24) /* FXSAVE and FXRSTOR instructions (fast save and restore */
+				          /* of FPU context), and CR4.OSFXSR available */
+#define X86_FEATURE_XMM		(0*32+25) /* Streaming SIMD Extensions */
+#define X86_FEATURE_XMM2	(0*32+26) /* Streaming SIMD Extensions-2 */
+#define X86_FEATURE_SELFSNOOP	(0*32+27) /* CPU self snoop */
+#define X86_FEATURE_HT		(0*32+28) /* Hyper-Threading */
+#define X86_FEATURE_ACC		(0*32+29) /* Automatic clock control */
+#define X86_FEATURE_IA64	(0*32+30) /* IA-64 processor */
+
+/* AMD-defined CPU features, CPUID level 0x80000001, word 1 */
+/* Don't duplicate feature flags which are redundant with Intel! */
+#define X86_FEATURE_SYSCALL	(1*32+11) /* SYSCALL/SYSRET */
+#define X86_FEATURE_MMXEXT	(1*32+22) /* AMD MMX extensions */
+#define X86_FEATURE_LM		(1*32+29) /* Long Mode (x86-64) */
+#define X86_FEATURE_3DNOWEXT	(1*32+30) /* AMD 3DNow! extensions */
+#define X86_FEATURE_3DNOW	(1*32+31) /* 3DNow! */
+
+/* Transmeta-defined CPU features, CPUID level 0x80860001, word 2 */
+#define X86_FEATURE_RECOVERY	(2*32+ 0) /* CPU in recovery mode */
+#define X86_FEATURE_LONGRUN	(2*32+ 1) /* Longrun power control */
+#define X86_FEATURE_LRTI	(2*32+ 3) /* LongRun table interface */
+
+/* Other features, Linux-defined mapping, word 3 */
+/* This range is used for feature bits which conflict or are synthesized */
+#define X86_FEATURE_CXMMX	(3*32+ 0) /* Cyrix MMX extensions */
+#define X86_FEATURE_K6_MTRR	(3*32+ 1) /* AMD K6 nonstandard MTRRs */
+#define X86_FEATURE_CYRIX_ARR	(3*32+ 2) /* Cyrix ARRs (= MTRRs) */
+#define X86_FEATURE_CENTAUR_MCR	(3*32+ 3) /* Centaur MCRs (= MTRRs) */
+
+#define MAX_X86_VENDOR_ID 16
+struct cpuinfo_x86 {
+	uint8_t	 x86;		/* CPU family */
+	uint8_t	 x86_model;
+	uint8_t	 x86_mask;
+
+       	int	 cpuid_level;	/* Maximum supported CPUID level, -1=no CPUID */
+	unsigned x86_capability[NCAPINTS];
+	char	 x86_vendor_id[MAX_X86_VENDOR_ID];
+};
+
+
+#define X86_VENDOR_INTEL 0
+#define X86_VENDOR_CYRIX 1
+#define X86_VENDOR_AMD 2
+#define X86_VENDOR_UMC 3
+#define X86_VENDOR_NEXGEN 4
+#define X86_VENDOR_CENTAUR 5
+#define X86_VENDOR_RISE 6
+#define X86_VENDOR_TRANSMETA 7
+#define X86_VENDOR_NSC 8
+#define X86_VENDOR_UNKNOWN 0xff
+
+/*
+ * EFLAGS bits
+ */
+#define X86_EFLAGS_CF	0x00000001 /* Carry Flag */
+#define X86_EFLAGS_PF	0x00000004 /* Parity Flag */
+#define X86_EFLAGS_AF	0x00000010 /* Auxillary carry Flag */
+#define X86_EFLAGS_ZF	0x00000040 /* Zero Flag */
+#define X86_EFLAGS_SF	0x00000080 /* Sign Flag */
+#define X86_EFLAGS_TF	0x00000100 /* Trap Flag */
+#define X86_EFLAGS_IF	0x00000200 /* Interrupt Flag */
+#define X86_EFLAGS_DF	0x00000400 /* Direction Flag */
+#define X86_EFLAGS_OF	0x00000800 /* Overflow Flag */
+#define X86_EFLAGS_IOPL	0x00003000 /* IOPL mask */
+#define X86_EFLAGS_NT	0x00004000 /* Nested Task */
+#define X86_EFLAGS_RF	0x00010000 /* Resume Flag */
+#define X86_EFLAGS_VM	0x00020000 /* Virtual Mode */
+#define X86_EFLAGS_AC	0x00040000 /* Alignment Check */
+#define X86_EFLAGS_VIF	0x00080000 /* Virtual Interrupt Flag */
+#define X86_EFLAGS_VIP	0x00100000 /* Virtual Interrupt Pending */
+#define X86_EFLAGS_ID	0x00200000 /* CPUID detection flag */
+
+/*
+ * Generic CPUID function
+ */
+static inline void cpuid(int op, 
+	unsigned int *eax, unsigned int *ebx, unsigned int *ecx, unsigned int *edx)
+{
+	__asm__("cpuid"
+		: "=a" (*eax),
+		  "=b" (*ebx),
+		  "=c" (*ecx),
+		  "=d" (*edx)
+		: "0" (op));
+}
+
+/*
+ * CPUID functions returning a single datum
+ */
+static inline unsigned int cpuid_eax(unsigned int op)
+{
+	unsigned int eax;
+
+	__asm__("cpuid"
+		: "=a" (eax)
+		: "0" (op)
+		: "bx", "cx", "dx");
+	return eax;
+}
+static inline unsigned int cpuid_ebx(unsigned int op)
+{
+	unsigned int eax, ebx;
+
+	__asm__("cpuid"
+		: "=a" (eax), "=b" (ebx)
+		: "0" (op)
+		: "cx", "dx" );
+	return ebx;
+}
+static inline unsigned int cpuid_ecx(unsigned int op)
+{
+	unsigned int eax, ecx;
+
+	__asm__("cpuid"
+		: "=a" (eax), "=c" (ecx)
+		: "0" (op)
+		: "bx", "dx" );
+	return ecx;
+}
+static inline unsigned int cpuid_edx(unsigned int op)
+{
+	unsigned int eax, edx;
+
+	__asm__("cpuid"
+		: "=a" (eax), "=d" (edx)
+		: "0" (op)
+		: "bx", "cx");
+	return edx;
+}
+
+/*
+ * Intel CPU features in CR4
+ */
+#define X86_CR4_VME		0x0001	/* enable vm86 extensions */
+#define X86_CR4_PVI		0x0002	/* virtual interrupts flag enable */
+#define X86_CR4_TSD		0x0004	/* disable time stamp at ipl 3 */
+#define X86_CR4_DE		0x0008	/* enable debugging extensions */
+#define X86_CR4_PSE		0x0010	/* enable page size extensions */
+#define X86_CR4_PAE		0x0020	/* enable physical address extensions */
+#define X86_CR4_MCE		0x0040	/* Machine check enable */
+#define X86_CR4_PGE		0x0080	/* enable global pages */
+#define X86_CR4_PCE		0x0100	/* enable performance counters at ipl 3 */
+#define X86_CR4_OSFXSR		0x0200	/* enable fast FPU save and restore */
+#define X86_CR4_OSXMMEXCPT	0x0400	/* enable unmasked SSE exceptions */
+
+
+#define MSR_K6_EFER			0xC0000080
+/* EFER bits: */ 
+#define _EFER_SCE 0  /* SYSCALL/SYSRET */
+#define _EFER_LME 8  /* Long mode enable */
+#define _EFER_LMA 10 /* Long mode active (read-only) */
+#define _EFER_NX 11  /* No execute enable */
+
+#define EFER_SCE (1<<_EFER_SCE)
+#define EFER_LME (1<<EFER_LME)
+#define EFER_LMA (1<<EFER_LMA)
+#define EFER_NX (1<<_EFER_NX)
+
+#define rdmsr(msr,val1,val2) \
+     __asm__ __volatile__("rdmsr" \
+			  : "=a" (val1), "=d" (val2) \
+			  : "c" (msr))
+
+#define wrmsr(msr,val1,val2) \
+     __asm__ __volatile__("wrmsr" \
+			  : /* no outputs */ \
+			  : "c" (msr), "a" (val1), "d" (val2))
+
+
+#define read_cr0()	({ \
+	unsigned int __dummy; \
+	__asm__( \
+		"movl %%cr0, %0\n\t" \
+		:"=r" (__dummy)); \
+	__dummy; \
+})
+#define write_cr0(x) \
+	__asm__("movl %0,%%cr0": :"r" (x));
+
+#define read_cr3()	({ \
+	unsigned int __dummy; \
+	__asm__( \
+		"movl %%cr3, %0\n\t" \
+		:"=r" (__dummy)); \
+	__dummy; \
+})
+#define write_cr3x(x) \
+	__asm__("movl %0,%%cr3": :"r" (x));
+
+
+#define read_cr4()	({ \
+	unsigned int __dummy; \
+	__asm__( \
+		"movl %%cr4, %0\n\t" \
+		:"=r" (__dummy)); \
+	__dummy; \
+})
+#define write_cr4x(x) \
+	__asm__("movl %0,%%cr4": :"r" (x));
+
+
+extern struct cpuinfo_x86 cpu_info;
+#ifdef CONFIG_X86_64
+extern void cpu_setup(void);
+#else
+#define cpu_setup() do {} while(0)
+#endif
+
+#endif /* I386_BITS_CPU_H */
diff -Naur grub-0.97.orig/netboot/cs89x0.c grub-0.97/netboot/cs89x0.c
--- grub-0.97.orig/netboot/cs89x0.c	2003-07-09 11:45:37.000000000 +0000
+++ grub-0.97/netboot/cs89x0.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,659 +0,0 @@
-/* cs89x0.c: A Crystal Semiconductor CS89[02]0 driver for etherboot. */
-/*
-  Permission is granted to distribute the enclosed cs89x0.[ch] driver
-  only in conjunction with the Etherboot package.  The code is
-  ordinarily distributed under the GPL.
-  
-  Russ Nelson, January 2000
-
-  ChangeLog:
-
-  Thu Dec 6 22:40:00 1996  Markus Gutschke  <gutschk@math.uni-muenster.de>
-
-  * disabled all "advanced" features; this should make the code more reliable
-
-  * reorganized the reset function
-
-  * always reset the address port, so that autoprobing will continue working
-
-  * some cosmetic changes
-
-  * 2.5
-
-  Thu Dec 5 21:00:00 1996  Markus Gutschke  <gutschk@math.uni-muenster.de>
-
-  * tested the code against a CS8900 card
-
-  * lots of minor bug fixes and adjustments
-
-  * this is the first release, that actually works! it still requires some
-    changes in order to be more tolerant to different environments
-
-  * 4
-
-  Fri Nov 22 23:00:00 1996  Markus Gutschke  <gutschk@math.uni-muenster.de>
-
-  * read the manuals for the CS89x0 chipsets and took note of all the
-    changes that will be neccessary in order to adapt Russel Nelson's code
-    to the requirements of a BOOT-Prom
-
-  * 6
-
-  Thu Nov 19 22:00:00 1996  Markus Gutschke  <gutschk@math.uni-muenster.de>
-
-  * Synched with Russel Nelson's current code (v1.00)
-
-  * 2
-
-  Thu Nov 12 18:00:00 1996  Markus Gutschke  <gutschk@math.uni-muenster.de>
-
-  * Cleaned up some of the code and tried to optimize the code size.
-
-  * 1.5
-
-  Sun Nov 10 16:30:00 1996  Markus Gutschke  <gutschk@math.uni-muenster.de>
-
-  * First experimental release. This code compiles fine, but I
-  have no way of testing whether it actually works.
-
-  * I did not (yet) bother to make the code 16bit aware, so for
-  the time being, it will only work for Etherboot/32.
-
-  * 12
-
-  */
-
-#include "etherboot.h"
-#include "nic.h"
-#include "cards.h"
-#include "cs89x0.h"
-
-static unsigned short	eth_nic_base;
-static unsigned long    eth_mem_start;
-static unsigned short   eth_irq;
-static unsigned short   eth_cs_type;	/* one of: CS8900, CS8920, CS8920M  */
-static unsigned short   eth_auto_neg_cnf;
-static unsigned short   eth_adapter_cnf;
-static unsigned short	eth_linectl;
-
-/*************************************************************************
-	CS89x0 - specific routines
-**************************************************************************/
-
-static inline int readreg(int portno)
-{
-	outw(portno, eth_nic_base + ADD_PORT);
-	return inw(eth_nic_base + DATA_PORT);
-}
-
-static inline void writereg(int portno, int value)
-{
-	outw(portno, eth_nic_base + ADD_PORT);
-	outw(value, eth_nic_base + DATA_PORT);
-	return;
-}
-
-/*************************************************************************
-EEPROM access
-**************************************************************************/
-
-static int wait_eeprom_ready(void)
-{
-	unsigned long tmo = currticks() + 4*TICKS_PER_SEC;
-
-	/* check to see if the EEPROM is ready, a timeout is used -
-	   just in case EEPROM is ready when SI_BUSY in the
-	   PP_SelfST is clear */
-	while(readreg(PP_SelfST) & SI_BUSY) {
-		if (currticks() >= tmo)
-			return -1; }
-	return 0;
-}
-
-static int get_eeprom_data(int off, int len, unsigned short *buffer)
-{
-	int i;
-
-#ifdef	EDEBUG
-	printf("\ncs: EEPROM data from %hX for %hX:",off,len);
-#endif
-	for (i = 0; i < len; i++) {
-		if (wait_eeprom_ready() < 0)
-			return -1;
-		/* Now send the EEPROM read command and EEPROM location
-		   to read */
-		writereg(PP_EECMD, (off + i) | EEPROM_READ_CMD);
-		if (wait_eeprom_ready() < 0)
-			return -1;
-		buffer[i] = readreg(PP_EEData);
-#ifdef	EDEBUG
-		if (!(i%10))
-			printf("\ncs: ");
-		printf("%hX ", buffer[i]);
-#endif
-	}
-#ifdef	EDEBUG
-	putchar('\n');
-#endif
-
-	return(0);
-}
-
-static int get_eeprom_chksum(int off, int len, unsigned short *buffer)
-{
-	int  i, cksum;
-
-	cksum = 0;
-	for (i = 0; i < len; i++)
-		cksum += buffer[i];
-	cksum &= 0xffff;
-	if (cksum == 0)
-		return 0;
-	return -1;
-}
-
-/*************************************************************************
-Activate all of the available media and probe for network
-**************************************************************************/
-
-static void clrline(void)
-{
-	int i;
-
-	putchar('\r');
-	for (i = 79; i--; ) putchar(' ');
-	printf("\rcs: ");
-	return;
-}
-
-static void control_dc_dc(int on_not_off)
-{
-	unsigned int selfcontrol;
-	unsigned long tmo = currticks() + TICKS_PER_SEC;
-
-	/* control the DC to DC convertor in the SelfControl register.  */
-	selfcontrol = HCB1_ENBL; /* Enable the HCB1 bit as an output */
-	if (((eth_adapter_cnf & A_CNF_DC_DC_POLARITY) != 0) ^ on_not_off)
-		selfcontrol |= HCB1;
-	else
-		selfcontrol &= ~HCB1;
-	writereg(PP_SelfCTL, selfcontrol);
-
-	/* Wait for the DC/DC converter to power up - 1000ms */
-	while (currticks() < tmo);
-
-	return;
-}
-
-static int detect_tp(void)
-{
-	unsigned long tmo;
-
-	/* Turn on the chip auto detection of 10BT/ AUI */
-
-	clrline(); printf("attempting %s:","TP");
-
-        /* If connected to another full duplex capable 10-Base-T card
-	   the link pulses seem to be lost when the auto detect bit in
-	   the LineCTL is set.  To overcome this the auto detect bit
-	   will be cleared whilst testing the 10-Base-T interface.
-	   This would not be necessary for the sparrow chip but is
-	   simpler to do it anyway. */
-	writereg(PP_LineCTL, eth_linectl &~ AUI_ONLY);
-	control_dc_dc(0);
-
-        /* Delay for the hardware to work out if the TP cable is
-	   present - 150ms */
-	for (tmo = currticks() + 4; currticks() < tmo; );
-
-	if ((readreg(PP_LineST) & LINK_OK) == 0)
-		return 0;
-
-	if (eth_cs_type != CS8900) {
-
-		writereg(PP_AutoNegCTL, eth_auto_neg_cnf & AUTO_NEG_MASK);
-
-		if ((eth_auto_neg_cnf & AUTO_NEG_BITS) == AUTO_NEG_ENABLE) {
-			printf(" negotiating duplex... ");
-			while (readreg(PP_AutoNegST) & AUTO_NEG_BUSY) {
-				if (currticks() - tmo > 40*TICKS_PER_SEC) {
-					printf("time out ");
-					break;
-				}
-			}
-		}
-		if (readreg(PP_AutoNegST) & FDX_ACTIVE)
-			printf("using full duplex");
-		else
-			printf("using half duplex");
-	}
-
-	return A_CNF_MEDIA_10B_T;
-}
-
-/* send a test packet - return true if carrier bits are ok */
-static int send_test_pkt(struct nic *nic)
-{
-	static unsigned char testpacket[] = { 0,0,0,0,0,0, 0,0,0,0,0,0,
-				     0, 46, /*A 46 in network order       */
-				     0, 0,  /*DSAP=0 & SSAP=0 fields      */
-				     0xf3,0 /*Control (Test Req+P bit set)*/ };
-	unsigned long tmo;
-
-	writereg(PP_LineCTL, readreg(PP_LineCTL) | SERIAL_TX_ON);
-
-	memcpy(testpacket, nic->node_addr, ETH_ALEN);
-	memcpy(testpacket+ETH_ALEN, nic->node_addr, ETH_ALEN);
-
-	outw(TX_AFTER_ALL, eth_nic_base + TX_CMD_PORT);
-	outw(ETH_ZLEN, eth_nic_base + TX_LEN_PORT);
-
-	/* Test to see if the chip has allocated memory for the packet */
-	for (tmo = currticks() + 2;
-	     (readreg(PP_BusST) & READY_FOR_TX_NOW) == 0; )
-		if (currticks() >= tmo)
-			return(0);
-
-	/* Write the contents of the packet */
-	outsw(eth_nic_base + TX_FRAME_PORT, testpacket,
-	      (ETH_ZLEN+1)>>1);
-
-	printf(" sending test packet ");
-	/* wait a couple of timer ticks for packet to be received */
-	for (tmo = currticks() + 2; currticks() < tmo; );
-
-	if ((readreg(PP_TxEvent) & TX_SEND_OK_BITS) == TX_OK) {
-			printf("succeeded");
-			return 1;
-	}
-	printf("failed");
-	return 0;
-}
-
-
-static int detect_aui(struct nic *nic)
-{
-	clrline(); printf("attempting %s:","AUI");
-	control_dc_dc(0);
-
-	writereg(PP_LineCTL, (eth_linectl & ~AUTO_AUI_10BASET) | AUI_ONLY);
-
-	if (send_test_pkt(nic)) {
-		return A_CNF_MEDIA_AUI; }
-	else
-		return 0;
-}
-
-static int detect_bnc(struct nic *nic)
-{
-	clrline(); printf("attempting %s:","BNC");
-	control_dc_dc(1);
-
-	writereg(PP_LineCTL, (eth_linectl & ~AUTO_AUI_10BASET) | AUI_ONLY);
-
-	if (send_test_pkt(nic)) {
-		return A_CNF_MEDIA_10B_2; }
-	else
-		return 0;
-}
-
-/**************************************************************************
-ETH_RESET - Reset adapter
-***************************************************************************/
-
-static void cs89x0_reset(struct nic *nic)
-{
-	int  i;
-	unsigned long reset_tmo;
-
-	writereg(PP_SelfCTL, readreg(PP_SelfCTL) | POWER_ON_RESET);
-
-	/* wait for two ticks; that is 2*55ms */
-	for (reset_tmo = currticks() + 2; currticks() < reset_tmo; );
-
-	if (eth_cs_type != CS8900) {
-		/* Hardware problem requires PNP registers to be reconfigured
-		   after a reset */
-		if (eth_irq != 0xFFFF) {
-			outw(PP_CS8920_ISAINT, eth_nic_base + ADD_PORT);
-			outb(eth_irq, eth_nic_base + DATA_PORT);
-			outb(0, eth_nic_base + DATA_PORT + 1); }
-
-		if (eth_mem_start) {
-			outw(PP_CS8920_ISAMemB, eth_nic_base + ADD_PORT);
-			outb((eth_mem_start >> 8) & 0xff, eth_nic_base + DATA_PORT);
-			outb((eth_mem_start >> 24) & 0xff, eth_nic_base + DATA_PORT + 1); } }
-
-	/* Wait until the chip is reset */
-	for (reset_tmo = currticks() + 2;
-	     (readreg(PP_SelfST) & INIT_DONE) == 0 &&
-		     currticks() < reset_tmo; );
-
-	/* disable interrupts and memory accesses */
-	writereg(PP_BusCTL, 0);
-
-	/* set the ethernet address */
-	for (i=0; i < ETH_ALEN/2; i++)
-		writereg(PP_IA+i*2,
-			 nic->node_addr[i*2] |
-			 (nic->node_addr[i*2+1] << 8));
-
-	/* receive only error free packets addressed to this card */
-	writereg(PP_RxCTL, DEF_RX_ACCEPT);
-
-	/* do not generate any interrupts on receive operations */
-	writereg(PP_RxCFG, 0);
-
-	/* do not generate any interrupts on transmit operations */
-	writereg(PP_TxCFG, 0);
-
-	/* do not generate any interrupts on buffer operations */
-	writereg(PP_BufCFG, 0);
-
-	/* reset address port, so that autoprobing will keep working */
-	outw(PP_ChipID, eth_nic_base + ADD_PORT);
-
-	return;
-}
-
-/**************************************************************************
-ETH_TRANSMIT - Transmit a frame
-***************************************************************************/
-
-static void cs89x0_transmit(
-	struct nic *nic,
-	const char *d,			/* Destination */
-	unsigned int t,			/* Type */
-	unsigned int s,			/* size */
-	const char *p)			/* Packet */
-{
-	unsigned long tmo;
-	int           sr;
-
-	/* does this size have to be rounded??? please,
-	   somebody have a look in the specs */
-	if ((sr = ((s + ETH_HLEN + 1)&~1)) < ETH_ZLEN)
-		sr = ETH_ZLEN;
-
-retry:
-	/* initiate a transmit sequence */
-	outw(TX_AFTER_ALL, eth_nic_base + TX_CMD_PORT);
-	outw(sr, eth_nic_base + TX_LEN_PORT);
-
-	/* Test to see if the chip has allocated memory for the packet */
-	if ((readreg(PP_BusST) & READY_FOR_TX_NOW) == 0) {
-		/* Oops... this should not happen! */
-		printf("cs: unable to send packet; retrying...\n");
-		for (tmo = currticks() + 5*TICKS_PER_SEC; currticks() < tmo; );
-		cs89x0_reset(nic);
-		goto retry; }
-
-	/* Write the contents of the packet */
-	outsw(eth_nic_base + TX_FRAME_PORT, d, ETH_ALEN/2);
-	outsw(eth_nic_base + TX_FRAME_PORT, nic->node_addr,
-	      ETH_ALEN/2);
-	outw(((t >> 8)&0xFF)|(t << 8), eth_nic_base + TX_FRAME_PORT);
-	outsw(eth_nic_base + TX_FRAME_PORT, p, (s+1)/2);
-	for (sr = sr/2 - (s+1)/2 - ETH_ALEN - 1; sr-- > 0;
-	     outw(0, eth_nic_base + TX_FRAME_PORT));
-
-	/* wait for transfer to succeed */
-	for (tmo = currticks()+5*TICKS_PER_SEC;
-	     (s = readreg(PP_TxEvent)&~0x1F) == 0 && currticks() < tmo;)
-		/* nothing */ ;
-	if ((s & TX_SEND_OK_BITS) != TX_OK) {
-		printf("\ntransmission error %#hX\n", s);
-	}
-
-	return;
-}
-
-/**************************************************************************
-ETH_POLL - Wait for a frame
-***************************************************************************/
-
-static int cs89x0_poll(struct nic *nic)
-{
-	int status;
-
-	status = readreg(PP_RxEvent);
-
-	if ((status & RX_OK) == 0)
-		return(0);
-
-	status = inw(eth_nic_base + RX_FRAME_PORT);
-	nic->packetlen = inw(eth_nic_base + RX_FRAME_PORT);
-	insw(eth_nic_base + RX_FRAME_PORT, nic->packet, nic->packetlen >> 1);
-	if (nic->packetlen & 1)
-		nic->packet[nic->packetlen-1] = inw(eth_nic_base + RX_FRAME_PORT);
-	return 1;
-}
-
-static void cs89x0_disable(struct nic *nic)
-{
-	cs89x0_reset(nic);
-}
-
-/**************************************************************************
-ETH_PROBE - Look for an adapter
-***************************************************************************/
-
-struct nic *cs89x0_probe(struct nic *nic, unsigned short *probe_addrs)
-{
-	static const unsigned int netcard_portlist[] = {
-#ifdef	CS_SCAN
-		CS_SCAN,
-#else	/* use "conservative" default values for autoprobing */
-		0x300,0x320,0x340,0x200,0x220,0x240,
-		0x260,0x280,0x2a0,0x2c0,0x2e0,
-	/* if that did not work, then be more aggressive */
-		0x301,0x321,0x341,0x201,0x221,0x241,
-		0x261,0x281,0x2a1,0x2c1,0x2e1,
-#endif
-		0};
-
-	int      i, result = -1;
-	unsigned rev_type = 0, ioaddr, ioidx, isa_cnf, cs_revision;
-	unsigned short eeprom_buff[CHKSUM_LEN];
-
-
-	for (ioidx = 0; (ioaddr=netcard_portlist[ioidx++]) != 0; ) {
-		/* if they give us an odd I/O address, then do ONE write to
-		   the address port, to get it back to address zero, where we
-		   expect to find the EISA signature word. */
-		if (ioaddr & 1) {
-			ioaddr &= ~1;
-			if ((inw(ioaddr + ADD_PORT) & ADD_MASK) != ADD_SIG)
-				continue;
-			outw(PP_ChipID, ioaddr + ADD_PORT);
-		}
-
-		if (inw(ioaddr + DATA_PORT) != CHIP_EISA_ID_SIG)
-			continue;
-		eth_nic_base = ioaddr;
-
-		/* get the chip type */
-		rev_type = readreg(PRODUCT_ID_ADD);
-		eth_cs_type = rev_type &~ REVISON_BITS;
-		cs_revision = ((rev_type & REVISON_BITS) >> 8) + 'A';
-
-		printf("\ncs: cs89%c0%s rev %c, base %#hX",
-		       eth_cs_type==CS8900?'0':'2',
-		       eth_cs_type==CS8920M?"M":"",
-		       cs_revision,
-		       eth_nic_base);
-
-		/* First check to see if an EEPROM is attached*/
-		if ((readreg(PP_SelfST) & EEPROM_PRESENT) == 0) {
-			printf("\ncs: no EEPROM...\n");
-			outw(PP_ChipID, eth_nic_base + ADD_PORT);
-			continue; }
-		else if (get_eeprom_data(START_EEPROM_DATA,CHKSUM_LEN,
-					 eeprom_buff) < 0) {
-			printf("\ncs: EEPROM read failed...\n");
-			outw(PP_ChipID, eth_nic_base + ADD_PORT);
-			continue; }
-		else if (get_eeprom_chksum(START_EEPROM_DATA,CHKSUM_LEN,
-					   eeprom_buff) < 0) {
-			printf("\ncs: EEPROM checksum bad...\n");
-			outw(PP_ChipID, eth_nic_base + ADD_PORT);
-			continue; }
-
-		/* get transmission control word but keep the
-		   autonegotiation bits */
-		eth_auto_neg_cnf = eeprom_buff[AUTO_NEG_CNF_OFFSET/2];
-		/* Store adapter configuration */
-		eth_adapter_cnf = eeprom_buff[ADAPTER_CNF_OFFSET/2];
-		/* Store ISA configuration */
-		isa_cnf = eeprom_buff[ISA_CNF_OFFSET/2];
-
-		/* store the initial memory base address */
-		eth_mem_start = eeprom_buff[PACKET_PAGE_OFFSET/2] << 8;
-
-		printf("%s%s%s, addr ",
-		       (eth_adapter_cnf & A_CNF_10B_T)?", RJ-45":"",
-		       (eth_adapter_cnf & A_CNF_AUI)?", AUI":"",
-		       (eth_adapter_cnf & A_CNF_10B_2)?", BNC":"");
-
-		/* If this is a CS8900 then no pnp soft */
-		if (eth_cs_type != CS8900 &&
-		    /* Check if the ISA IRQ has been set  */
-		    (i = readreg(PP_CS8920_ISAINT) & 0xff,
-		     (i != 0 && i < CS8920_NO_INTS)))
-			eth_irq = i;
-		else {
-			i = isa_cnf & INT_NO_MASK;
-			if (eth_cs_type == CS8900) {
-				/* the table that follows is dependent
-				   upon how you wired up your cs8900
-				   in your system.  The table is the
-				   same as the cs8900 engineering demo
-				   board.  irq_map also depends on the
-				   contents of the table.  Also see
-				   write_irq, which is the reverse
-				   mapping of the table below. */
-				if (i < 4) i = "\012\013\014\005"[i];
-				else printf("\ncs: BUG: isa_config is %d\n", i); }
-			eth_irq = i; }
-
-		/* Retrieve and print the ethernet address. */
-		for (i=0; i<ETH_ALEN; i++) {
-			nic->node_addr[i] = ((unsigned char *)eeprom_buff)[i];
-		}
-		printf("%!\n", nic->node_addr);
-
-		/* Set the LineCTL quintuplet based on adapter
-		   configuration read from EEPROM */
-		if ((eth_adapter_cnf & A_CNF_EXTND_10B_2) &&
-		    (eth_adapter_cnf & A_CNF_LOW_RX_SQUELCH))
-			eth_linectl = LOW_RX_SQUELCH;
-		else
-			eth_linectl = 0;
-
-		/* check to make sure that they have the "right"
-		   hardware available */
-		switch(eth_adapter_cnf & A_CNF_MEDIA_TYPE) {
-		case A_CNF_MEDIA_10B_T: result = eth_adapter_cnf & A_CNF_10B_T;
-			break;
-		case A_CNF_MEDIA_AUI:   result = eth_adapter_cnf & A_CNF_AUI;
-			break;
-		case A_CNF_MEDIA_10B_2: result = eth_adapter_cnf & A_CNF_10B_2;
-			break;
-		default: result = eth_adapter_cnf & (A_CNF_10B_T | A_CNF_AUI |
-						     A_CNF_10B_2);
-		}
-		if (!result) {
-			printf("cs: EEPROM is configured for unavailable media\n");
-		error:
-			writereg(PP_LineCTL, readreg(PP_LineCTL) &
-				 ~(SERIAL_TX_ON | SERIAL_RX_ON));
-			outw(PP_ChipID, eth_nic_base + ADD_PORT);
-			continue;
-		}
-
-		/* Initialize the card for probing of the attached media */
-		cs89x0_reset(nic);
-
-		/* set the hardware to the configured choice */
-		switch(eth_adapter_cnf & A_CNF_MEDIA_TYPE) {
-		case A_CNF_MEDIA_10B_T:
-			result = detect_tp();
-			if (!result) {
-				clrline();
-				printf("10Base-T (RJ-45%s",
-				       ") has no cable\n"); }
-			/* check "ignore missing media" bit */
-			if (eth_auto_neg_cnf & IMM_BIT)
-				/* Yes! I don't care if I see a link pulse */
-				result = A_CNF_MEDIA_10B_T;
-			break;
-		case A_CNF_MEDIA_AUI:
-			result = detect_aui(nic);
-			if (!result) {
-				clrline();
-				printf("10Base-5 (AUI%s",
-				       ") has no cable\n"); }
-			/* check "ignore missing media" bit */
-			if (eth_auto_neg_cnf & IMM_BIT)
-				/* Yes! I don't care if I see a carrrier */
-				result = A_CNF_MEDIA_AUI;
-			break;
-		case A_CNF_MEDIA_10B_2:
-			result = detect_bnc(nic);
-			if (!result) {
-				clrline();
-				printf("10Base-2 (BNC%s",
-				       ") has no cable\n"); }
-			/* check "ignore missing media" bit */
-			if (eth_auto_neg_cnf & IMM_BIT)
-				/* Yes! I don't care if I can xmit a packet */
-				result = A_CNF_MEDIA_10B_2;
-			break;
-		case A_CNF_MEDIA_AUTO:
-			writereg(PP_LineCTL, eth_linectl | AUTO_AUI_10BASET);
-			if (eth_adapter_cnf & A_CNF_10B_T)
-				if ((result = detect_tp()) != 0)
-					break;
-			if (eth_adapter_cnf & A_CNF_AUI)
-				if ((result = detect_aui(nic)) != 0)
-					break;
-			if (eth_adapter_cnf & A_CNF_10B_2)
-				if ((result = detect_bnc(nic)) != 0)
-					break;
-			clrline(); printf("no media detected\n");
-			goto error;
-		}
-		clrline();
-		switch(result) {
-		case 0:                 printf("no network cable attached to configured media\n");
-			goto error;
-		case A_CNF_MEDIA_10B_T: printf("using 10Base-T (RJ-45)\n");
-			break;
-		case A_CNF_MEDIA_AUI:   printf("using 10Base-5 (AUI)\n");
-			break;
-		case A_CNF_MEDIA_10B_2: printf("using 10Base-2 (BNC)\n");
-			break;
-		}
-
-		/* Turn on both receive and transmit operations */
-		writereg(PP_LineCTL, readreg(PP_LineCTL) | SERIAL_RX_ON |
-			 SERIAL_TX_ON);
-
-		break;
-	}
-
-	if (ioaddr == 0)
-		return (0);
-	nic->reset = cs89x0_reset;
-	nic->poll = cs89x0_poll;
-	nic->transmit = cs89x0_transmit;
-	nic->disable = cs89x0_disable;
-	return (nic);
-}
-
-/*
- * Local variables:
- *  c-basic-offset: 8
- * End:
- */
-
diff -Naur grub-0.97.orig/netboot/cs89x0.h grub-0.97/netboot/cs89x0.h
--- grub-0.97.orig/netboot/cs89x0.h	2003-07-09 11:45:37.000000000 +0000
+++ grub-0.97/netboot/cs89x0.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,461 +0,0 @@
-/*  Copyright, 1988-1992, Russell Nelson, Crynwr Software
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, version 1.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
-
-#define PP_ChipID 0x0000	/* offset   0h -> Corp -ID              */
-				/* offset   2h -> Model/Product Number  */
-				/* offset   3h -> Chip Revision Number  */
-
-#define PP_ISAIOB 0x0020	/*  IO base address */
-#define PP_CS8900_ISAINT 0x0022	/*  ISA interrupt select */
-#define PP_CS8920_ISAINT 0x0370	/*  ISA interrupt select */
-#define PP_CS8900_ISADMA 0x0024	/*  ISA Rec DMA channel */
-#define PP_CS8920_ISADMA 0x0374	/*  ISA Rec DMA channel */
-#define PP_ISASOF 0x0026	/*  ISA DMA offset */
-#define PP_DmaFrameCnt 0x0028	/*  ISA DMA Frame count */
-#define PP_DmaByteCnt 0x002A	/*  ISA DMA Byte count */
-#define PP_CS8900_ISAMemB 0x002C	/*  Memory base */
-#define PP_CS8920_ISAMemB 0x0348 /*  */
-
-#define PP_ISABootBase 0x0030	/*  Boot Prom base  */
-#define PP_ISABootMask 0x0034	/*  Boot Prom Mask */
-
-/* EEPROM data and command registers */
-#define PP_EECMD 0x0040		/*  NVR Interface Command register */
-#define PP_EEData 0x0042	/*  NVR Interface Data Register */
-#define PP_DebugReg 0x0044	/*  Debug Register */
-
-#define PP_RxCFG 0x0102		/*  Rx Bus config */
-#define PP_RxCTL 0x0104		/*  Receive Control Register */
-#define PP_TxCFG 0x0106		/*  Transmit Config Register */
-#define PP_TxCMD 0x0108		/*  Transmit Command Register */
-#define PP_BufCFG 0x010A	/*  Bus configuration Register */
-#define PP_LineCTL 0x0112	/*  Line Config Register */
-#define PP_SelfCTL 0x0114	/*  Self Command Register */
-#define PP_BusCTL 0x0116	/*  ISA bus control Register */
-#define PP_TestCTL 0x0118	/*  Test Register */
-#define PP_AutoNegCTL 0x011C	/*  Auto Negotiation Ctrl */
-
-#define PP_ISQ 0x0120		/*  Interrupt Status */
-#define PP_RxEvent 0x0124	/*  Rx Event Register */
-#define PP_TxEvent 0x0128	/*  Tx Event Register */
-#define PP_BufEvent 0x012C	/*  Bus Event Register */
-#define PP_RxMiss 0x0130	/*  Receive Miss Count */
-#define PP_TxCol 0x0132		/*  Transmit Collision Count */
-#define PP_LineST 0x0134	/*  Line State Register */
-#define PP_SelfST 0x0136	/*  Self State register */
-#define PP_BusST 0x0138		/*  Bus Status */
-#define PP_TDR 0x013C		/*  Time Domain Reflectometry */
-#define PP_AutoNegST 0x013E	/*  Auto Neg Status */
-#define PP_TxCommand 0x0144	/*  Tx Command */
-#define PP_TxLength 0x0146	/*  Tx Length */
-#define PP_LAF 0x0150		/*  Hash Table */
-#define PP_IA 0x0158		/*  Physical Address Register */
-
-#define PP_RxStatus 0x0400	/*  Receive start of frame */
-#define PP_RxLength 0x0402	/*  Receive Length of frame */
-#define PP_RxFrame 0x0404	/*  Receive frame pointer */
-#define PP_TxFrame 0x0A00	/*  Transmit frame pointer */
-
-/*  Primary I/O Base Address. If no I/O base is supplied by the user, then this */
-/*  can be used as the default I/O base to access the PacketPage Area. */
-#define DEFAULTIOBASE 0x0300
-#define FIRST_IO 0x020C		/*  First I/O port to check */
-#define LAST_IO 0x037C		/*  Last I/O port to check (+10h) */
-#define ADD_MASK 0x3000		/*  Mask it use of the ADD_PORT register */
-#define ADD_SIG 0x3000		/*  Expected ID signature */
-
-#define CHIP_EISA_ID_SIG 0x630E   /*  Product ID Code for Crystal Chip (CS8900 spec 4.3) */
-
-#ifdef	IBMEIPKT
-#define EISA_ID_SIG 0x4D24	/*  IBM */
-#define PART_NO_SIG 0x1010	/*  IBM */
-#define MONGOOSE_BIT 0x0000	/*  IBM */
-#else
-#define EISA_ID_SIG 0x630E	/*  PnP Vendor ID (same as chip id for Crystal board) */
-#define PART_NO_SIG 0x4000	/*  ID code CS8920 board (PnP Vendor Product code) */
-#define MONGOOSE_BIT 0x2000	/*  PART_NO_SIG + MONGOOSE_BUT => ID of mongoose */
-#endif
-
-#define PRODUCT_ID_ADD 0x0002   /*  Address of product ID */
-
-/*  Mask to find out the types of  registers */
-#define REG_TYPE_MASK 0x001F
-
-/*  Eeprom Commands */
-#define ERSE_WR_ENBL 0x00F0
-#define ERSE_WR_DISABLE 0x0000
-
-/*  Defines Control/Config register quintuplet numbers */
-#define RX_BUF_CFG 0x0003
-#define RX_CONTROL 0x0005
-#define TX_CFG 0x0007
-#define TX_COMMAND 0x0009
-#define BUF_CFG 0x000B
-#define LINE_CONTROL 0x0013
-#define SELF_CONTROL 0x0015
-#define BUS_CONTROL 0x0017
-#define TEST_CONTROL 0x0019
-
-/*  Defines Status/Count registers quintuplet numbers */
-#define RX_EVENT 0x0004
-#define TX_EVENT 0x0008
-#define BUF_EVENT 0x000C
-#define RX_MISS_COUNT 0x0010
-#define TX_COL_COUNT 0x0012
-#define LINE_STATUS 0x0014
-#define SELF_STATUS 0x0016
-#define BUS_STATUS 0x0018
-#define TDR 0x001C
-
-/* PP_RxCFG - Receive  Configuration and Interrupt Mask bit definition -  Read/write */
-#define SKIP_1 0x0040
-#define RX_STREAM_ENBL 0x0080
-#define RX_OK_ENBL 0x0100
-#define RX_DMA_ONLY 0x0200
-#define AUTO_RX_DMA 0x0400
-#define BUFFER_CRC 0x0800
-#define RX_CRC_ERROR_ENBL 0x1000
-#define RX_RUNT_ENBL 0x2000
-#define RX_EXTRA_DATA_ENBL 0x4000
-
-/* PP_RxCTL - Receive Control bit definition - Read/write */
-#define RX_IA_HASH_ACCEPT 0x0040
-#define RX_PROM_ACCEPT 0x0080
-#define RX_OK_ACCEPT 0x0100
-#define RX_MULTCAST_ACCEPT 0x0200
-#define RX_IA_ACCEPT 0x0400
-#define RX_BROADCAST_ACCEPT 0x0800
-#define RX_BAD_CRC_ACCEPT 0x1000
-#define RX_RUNT_ACCEPT 0x2000
-#define RX_EXTRA_DATA_ACCEPT 0x4000
-#define RX_ALL_ACCEPT (RX_PROM_ACCEPT|RX_BAD_CRC_ACCEPT|RX_RUNT_ACCEPT|RX_EXTRA_DATA_ACCEPT)
-/*  Default receive mode - individually addressed, broadcast, and error free */
-#define DEF_RX_ACCEPT (RX_IA_ACCEPT | RX_BROADCAST_ACCEPT | RX_OK_ACCEPT)
-
-/* PP_TxCFG - Transmit Configuration Interrupt Mask bit definition - Read/write */
-#define TX_LOST_CRS_ENBL 0x0040
-#define TX_SQE_ERROR_ENBL 0x0080
-#define TX_OK_ENBL 0x0100
-#define TX_LATE_COL_ENBL 0x0200
-#define TX_JBR_ENBL 0x0400
-#define TX_ANY_COL_ENBL 0x0800
-#define TX_16_COL_ENBL 0x8000
-
-/* PP_TxCMD - Transmit Command bit definition - Read-only */
-#define TX_START_4_BYTES 0x0000
-#define TX_START_64_BYTES 0x0040
-#define TX_START_128_BYTES 0x0080
-#define TX_START_ALL_BYTES 0x00C0
-#define TX_FORCE 0x0100
-#define TX_ONE_COL 0x0200
-#define TX_TWO_PART_DEFF_DISABLE 0x0400
-#define TX_NO_CRC 0x1000
-#define TX_RUNT 0x2000
-
-/* PP_BufCFG - Buffer Configuration Interrupt Mask bit definition - Read/write */
-#define GENERATE_SW_INTERRUPT 0x0040
-#define RX_DMA_ENBL 0x0080
-#define READY_FOR_TX_ENBL 0x0100
-#define TX_UNDERRUN_ENBL 0x0200
-#define RX_MISS_ENBL 0x0400
-#define RX_128_BYTE_ENBL 0x0800
-#define TX_COL_COUNT_OVRFLOW_ENBL 0x1000
-#define RX_MISS_COUNT_OVRFLOW_ENBL 0x2000
-#define RX_DEST_MATCH_ENBL 0x8000
-
-/* PP_LineCTL - Line Control bit definition - Read/write */
-#define SERIAL_RX_ON 0x0040
-#define SERIAL_TX_ON 0x0080
-#define AUI_ONLY 0x0100
-#define AUTO_AUI_10BASET 0x0200
-#define MODIFIED_BACKOFF 0x0800
-#define NO_AUTO_POLARITY 0x1000
-#define TWO_PART_DEFDIS 0x2000
-#define LOW_RX_SQUELCH 0x4000
-
-/* PP_SelfCTL - Software Self Control bit definition - Read/write */
-#define POWER_ON_RESET 0x0040
-#define SW_STOP 0x0100
-#define SLEEP_ON 0x0200
-#define AUTO_WAKEUP 0x0400
-#define HCB0_ENBL 0x1000
-#define HCB1_ENBL 0x2000
-#define HCB0 0x4000
-#define HCB1 0x8000
-
-/* PP_BusCTL - ISA Bus Control bit definition - Read/write */
-#define RESET_RX_DMA 0x0040
-#define MEMORY_ON 0x0400
-#define DMA_BURST_MODE 0x0800
-#define IO_CHANNEL_READY_ON 0x1000
-#define RX_DMA_SIZE_64K 0x2000
-#define ENABLE_IRQ 0x8000
-
-/* PP_TestCTL - Test Control bit definition - Read/write */
-#define LINK_OFF 0x0080
-#define ENDEC_LOOPBACK 0x0200
-#define AUI_LOOPBACK 0x0400
-#define BACKOFF_OFF 0x0800
-#define FAST_TEST 0x8000
-
-/* PP_RxEvent - Receive Event Bit definition - Read-only */
-#define RX_IA_HASHED 0x0040
-#define RX_DRIBBLE 0x0080
-#define RX_OK 0x0100
-#define RX_HASHED 0x0200
-#define RX_IA 0x0400
-#define RX_BROADCAST 0x0800
-#define RX_CRC_ERROR 0x1000
-#define RX_RUNT 0x2000
-#define RX_EXTRA_DATA 0x4000
-
-#define HASH_INDEX_MASK 0x0FC00
-
-/* PP_TxEvent - Transmit Event Bit definition - Read-only */
-#define TX_LOST_CRS 0x0040
-#define TX_SQE_ERROR 0x0080
-#define TX_OK 0x0100
-#define TX_LATE_COL 0x0200
-#define TX_JBR 0x0400
-#define TX_16_COL 0x8000
-#define TX_SEND_OK_BITS (TX_OK|TX_LOST_CRS)
-#define TX_COL_COUNT_MASK 0x7800
-
-/* PP_BufEvent - Buffer Event Bit definition - Read-only */
-#define SW_INTERRUPT 0x0040
-#define RX_DMA 0x0080
-#define READY_FOR_TX 0x0100
-#define TX_UNDERRUN 0x0200
-#define RX_MISS 0x0400
-#define RX_128_BYTE 0x0800
-#define TX_COL_OVRFLW 0x1000
-#define RX_MISS_OVRFLW 0x2000
-#define RX_DEST_MATCH 0x8000
-
-/* PP_LineST - Ethernet Line Status bit definition - Read-only */
-#define LINK_OK 0x0080
-#define AUI_ON 0x0100
-#define TENBASET_ON 0x0200
-#define POLARITY_OK 0x1000
-#define CRS_OK 0x4000
-
-/* PP_SelfST - Chip Software Status bit definition */
-#define ACTIVE_33V 0x0040
-#define INIT_DONE 0x0080
-#define SI_BUSY 0x0100
-#define EEPROM_PRESENT 0x0200
-#define EEPROM_OK 0x0400
-#define EL_PRESENT 0x0800
-#define EE_SIZE_64 0x1000
-
-/* PP_BusST - ISA Bus Status bit definition */
-#define TX_BID_ERROR 0x0080
-#define READY_FOR_TX_NOW 0x0100
-
-/* PP_AutoNegCTL - Auto Negotiation Control bit definition */
-#define RE_NEG_NOW 0x0040
-#define ALLOW_FDX 0x0080
-#define AUTO_NEG_ENABLE 0x0100
-#define NLP_ENABLE 0x0200
-#define FORCE_FDX 0x8000
-#define AUTO_NEG_BITS (FORCE_FDX|NLP_ENABLE|AUTO_NEG_ENABLE)
-#define AUTO_NEG_MASK (FORCE_FDX|NLP_ENABLE|AUTO_NEG_ENABLE|ALLOW_FDX|RE_NEG_NOW)
-
-/* PP_AutoNegST - Auto Negotiation Status bit definition */
-#define AUTO_NEG_BUSY 0x0080
-#define FLP_LINK 0x0100
-#define FLP_LINK_GOOD 0x0800
-#define LINK_FAULT 0x1000
-#define HDX_ACTIVE 0x4000
-#define FDX_ACTIVE 0x8000
-
-/*  The following block defines the ISQ event types */
-#define ISQ_RECEIVER_EVENT 0x04
-#define ISQ_TRANSMITTER_EVENT 0x08
-#define ISQ_BUFFER_EVENT 0x0c
-#define ISQ_RX_MISS_EVENT 0x10
-#define ISQ_TX_COL_EVENT 0x12
-
-#define ISQ_EVENT_MASK 0x003F   /*  ISQ mask to find out type of event */
-#define ISQ_HIST 16		/*  small history buffer */
-#define AUTOINCREMENT 0x8000	/*  Bit mask to set bit-15 for autoincrement */
-
-#define TXRXBUFSIZE 0x0600
-#define RXDMABUFSIZE 0x8000
-#define RXDMASIZE 0x4000
-#define TXRX_LENGTH_MASK 0x07FF
-
-/*  rx options bits */
-#define RCV_WITH_RXON	1       /*  Set SerRx ON */
-#define RCV_COUNTS	2       /*  Use Framecnt1 */
-#define RCV_PONG	4       /*  Pong respondent */
-#define RCV_DONG	8       /*  Dong operation */
-#define RCV_POLLING	0x10	/*  Poll RxEvent */
-#define RCV_ISQ		0x20	/*  Use ISQ, int */
-#define RCV_AUTO_DMA	0x100	/*  Set AutoRxDMAE */
-#define RCV_DMA		0x200	/*  Set RxDMA only */
-#define RCV_DMA_ALL	0x400	/*  Copy all DMA'ed */
-#define RCV_FIXED_DATA	0x800	/*  Every frame same */
-#define RCV_IO		0x1000	/*  Use ISA IO only */
-#define RCV_MEMORY	0x2000	/*  Use ISA Memory */
-
-#define RAM_SIZE	0x1000       /*  The card has 4k bytes or RAM */
-#define PKT_START PP_TxFrame  /*  Start of packet RAM */
-
-#define RX_FRAME_PORT	0x0000
-#define TX_FRAME_PORT RX_FRAME_PORT
-#define TX_CMD_PORT	0x0004
-#define TX_NOW		0x0000       /*  Tx packet after   5 bytes copied */
-#define TX_AFTER_381	0x0020       /*  Tx packet after 381 bytes copied */
-#define TX_AFTER_ALL	0x0060       /*  Tx packet after all bytes copied */
-#define TX_LEN_PORT	0x0006
-#define ISQ_PORT	0x0008
-#define ADD_PORT	0x000A
-#define DATA_PORT	0x000C
-
-#define EEPROM_WRITE_EN		0x00F0
-#define EEPROM_WRITE_DIS	0x0000
-#define EEPROM_WRITE_CMD	0x0100
-#define EEPROM_READ_CMD		0x0200
-
-/*  Receive Header */
-/*  Description of header of each packet in receive area of memory */
-#define RBUF_EVENT_LOW	0   /*  Low byte of RxEvent - status of received frame */
-#define RBUF_EVENT_HIGH	1   /*  High byte of RxEvent - status of received frame */
-#define RBUF_LEN_LOW	2   /*  Length of received data - low byte */
-#define RBUF_LEN_HI	3   /*  Length of received data - high byte */
-#define RBUF_HEAD_LEN	4   /*  Length of this header */
-
-#define CHIP_READ 0x1   /*  Used to mark state of the repins code (chip or dma) */
-#define DMA_READ 0x2   /*  Used to mark state of the repins code (chip or dma) */
-
-/*  for bios scan */
-/*  */
-#ifdef	CSDEBUG
-/*  use these values for debugging bios scan */
-#define BIOS_START_SEG 0x00000
-#define BIOS_OFFSET_INC 0x0010
-#else
-#define BIOS_START_SEG 0x0c000
-#define BIOS_OFFSET_INC 0x0200
-#endif
-
-#define BIOS_LAST_OFFSET 0x0fc00
-
-/*  Byte offsets into the EEPROM configuration buffer */
-#define ISA_CNF_OFFSET 0x6
-#define TX_CTL_OFFSET (ISA_CNF_OFFSET + 8)			/*  8900 eeprom */
-#define AUTO_NEG_CNF_OFFSET (ISA_CNF_OFFSET + 8)		/*  8920 eeprom */
-
-  /*  the assumption here is that the bits in the eeprom are generally  */
-  /*  in the same position as those in the autonegctl register. */
-  /*  Of course the IMM bit is not in that register so it must be  */
-  /*  masked out */
-#define EE_FORCE_FDX  0x8000
-#define EE_NLP_ENABLE 0x0200
-#define EE_AUTO_NEG_ENABLE 0x0100
-#define EE_ALLOW_FDX 0x0080
-#define EE_AUTO_NEG_CNF_MASK (EE_FORCE_FDX|EE_NLP_ENABLE|EE_AUTO_NEG_ENABLE|EE_ALLOW_FDX)
-
-#define IMM_BIT 0x0040		/*  ignore missing media */
-
-#define ADAPTER_CNF_OFFSET (AUTO_NEG_CNF_OFFSET + 2)
-#define A_CNF_10B_T 0x0001
-#define A_CNF_AUI 0x0002
-#define A_CNF_10B_2 0x0004
-#define A_CNF_MEDIA_TYPE 0x0060
-#define A_CNF_MEDIA_AUTO 0x0000
-#define A_CNF_MEDIA_10B_T 0x0020
-#define A_CNF_MEDIA_AUI 0x0040
-#define A_CNF_MEDIA_10B_2 0x0060
-#define A_CNF_DC_DC_POLARITY 0x0080
-#define A_CNF_NO_AUTO_POLARITY 0x2000
-#define A_CNF_LOW_RX_SQUELCH 0x4000
-#define A_CNF_EXTND_10B_2 0x8000
-
-#define PACKET_PAGE_OFFSET 0x8
-
-/*  Bit definitions for the ISA configuration word from the EEPROM */
-#define INT_NO_MASK 0x000F
-#define DMA_NO_MASK 0x0070
-#define ISA_DMA_SIZE 0x0200
-#define ISA_AUTO_RxDMA 0x0400
-#define ISA_RxDMA 0x0800
-#define DMA_BURST 0x1000
-#define STREAM_TRANSFER 0x2000
-#define ANY_ISA_DMA (ISA_AUTO_RxDMA | ISA_RxDMA)
-
-/*  DMA controller registers */
-#define DMA_BASE 0x00     /*  DMA controller base */
-#define DMA_BASE_2 0x0C0    /*  DMA controller base */
-
-#define DMA_STAT 0x0D0    /*  DMA controller status register */
-#define DMA_MASK 0x0D4    /*  DMA controller mask register */
-#define DMA_MODE 0x0D6    /*  DMA controller mode register */
-#define DMA_RESETFF 0x0D8    /*  DMA controller first/last flip flop */
-
-/*  DMA data */
-#define DMA_DISABLE 0x04     /*  Disable channel n */
-#define DMA_ENABLE 0x00     /*  Enable channel n */
-/*  Demand transfers, incr. address, auto init, writes, ch. n */
-#define DMA_RX_MODE 0x14
-/*  Demand transfers, incr. address, auto init, reads, ch. n */
-#define DMA_TX_MODE 0x18
-
-#define DMA_SIZE (16*1024) /*  Size of dma buffer - 16k */
-
-#define CS8900 0x0000
-#define CS8920 0x4000
-#define CS8920M 0x6000
-#define REVISON_BITS 0x1F00
-#define EEVER_NUMBER 0x12
-#define CHKSUM_LEN 0x14
-#define CHKSUM_VAL 0x0000
-#define START_EEPROM_DATA 0x001c /*  Offset into eeprom for start of data */
-#define IRQ_MAP_EEPROM_DATA 0x0046 /*  Offset into eeprom for the IRQ map */
-#define IRQ_MAP_LEN 0x0004 /*  No of bytes to read for the IRQ map */
-#define PNP_IRQ_FRMT 0x0022 /*  PNP small item IRQ format */
-#define CS8900_IRQ_MAP 0x1c20 /*  This IRQ map is fixed */
-
-#define CS8920_NO_INTS 0x0F   /*  Max CS8920 interrupt select # */
-
-#define PNP_ADD_PORT 0x0279
-#define PNP_WRITE_PORT 0x0A79
-
-#define GET_PNP_ISA_STRUCT 0x40
-#define PNP_ISA_STRUCT_LEN 0x06
-#define PNP_CSN_CNT_OFF 0x01
-#define PNP_RD_PORT_OFF 0x02
-#define PNP_FUNCTION_OK 0x00
-#define PNP_WAKE 0x03
-#define PNP_RSRC_DATA 0x04
-#define PNP_RSRC_READY 0x01
-#define PNP_STATUS 0x05
-#define PNP_ACTIVATE 0x30
-#define PNP_CNF_IO_H 0x60
-#define PNP_CNF_IO_L 0x61
-#define PNP_CNF_INT 0x70
-#define PNP_CNF_DMA 0x74
-#define PNP_CNF_MEM 0x48
-
-#define BIT0 1
-#define BIT15 0x8000
-
-/*
- * Local variables:
- *  c-basic-offset: 8
- * End:
- */
-
diff -Naur grub-0.97.orig/netboot/cs89x0.txt grub-0.97/netboot/cs89x0.txt
--- grub-0.97.orig/netboot/cs89x0.txt	2003-07-09 11:45:37.000000000 +0000
+++ grub-0.97/netboot/cs89x0.txt	1970-01-01 00:00:00.000000000 +0000
@@ -1,26 +0,0 @@
-Permission is granted to distribute the enclosed cs89x0.[ch] driver
-only in conjunction with the Etherboot package.  The code is
-ordinarily distributed under the GPL.
-
-Russ Nelson, January 2000
-
-CREDITS
-
-I want to thank
-
-  Mike Cruse <mcruse@cti-ltd.com>
-     for providing an evaluation NIC and for sponsoring the
-     development of this driver.
-
-  Randall Sears <sears@crystal.cirrus.com>
-  Deva Bodas <bodas@crystal.cirrus.com>
-  Andreas Kraemer <akraemer@crystal.cirrus.com>
-  Wolfgang Krause <100303.2673@compuserve.com>
-     for excellent technical support and for providing the required
-     programming information. I appreciate Crystal Semiconductor's
-     commitment towards free software.
-
-  Russell Nelson <nelson@crynwr.com>
-     for writing the Linux device driver for the CS89x0
-     chipset. Russel's code is very well designed and simplified my
-     job a lot.
diff -Naur grub-0.97.orig/netboot/davicom.c grub-0.97/netboot/davicom.c
--- grub-0.97.orig/netboot/davicom.c	2003-07-09 11:45:37.000000000 +0000
+++ grub-0.97/netboot/davicom.c	2005-08-31 19:03:35.000000000 +0000
@@ -1,12 +1,12 @@
+#ifdef ALLMULTI
+#error multicast support is not yet implemented
+#endif
 /*  
     DAVICOM DM9009/DM9102/DM9102A Etherboot Driver	V1.00
 
-    This driver was ported from Marty Conner's Tulip Etherboot driver. 
-    Thanks Marty Connor (mdc@thinguin.org) 
-    You can get Tulip driver source file from this URL:
+    This driver was ported from Marty Connor's Tulip Etherboot driver. 
+    Thanks Marty Connor (mdc@etherboot.org) 
 
-    "http://etherboot.sourceforge..net/#Distribution"
-    
     This davicom etherboot driver supports DM9009/DM9102/DM9102A/
     DM9102A+DM9801/DM9102A+DM9802 NICs.
 
@@ -36,7 +36,6 @@
 			register(CR6)
 */
 
-
 /*********************************************************************/
 /* Declarations                                                      */
 /*********************************************************************/
@@ -44,7 +43,6 @@
 #include "etherboot.h"
 #include "nic.h"
 #include "pci.h"
-#include "cards.h"
 
 #undef DAVICOM_DEBUG
 #undef DAVICOM_DEBUG_WHERE
@@ -99,8 +97,10 @@
 #define eeprom_delay()  inl(ee_addr)
 
 /* helpful macro if on a big_endian machine for changing byte order.
-   not strictly needed on Intel */
+   not strictly needed on Intel
+   Already defined in Etherboot includes
 #define le16_to_cpu(val) (val)
+*/
 
 /* transmit and receive descriptor format */
 struct txdesc {
@@ -138,20 +138,12 @@
 /* transmit descriptor and buffer */
 #define NTXD 2
 static struct txdesc txd[NTXD] __attribute__ ((aligned(4)));
-#ifdef	USE_LOWMEM_BUFFER
-#define txb ((char *)0x10000 - BUFLEN)
-#else
 static unsigned char txb[BUFLEN] __attribute__ ((aligned(4)));
-#endif
 
 /* receive descriptor(s) and buffer(s) */
 #define NRXD 4
 static struct rxdesc rxd[NRXD] __attribute__ ((aligned(4)));
-#ifdef	USE_LOWMEM_BUFFER
-#define rxb ((char *)0x10000 - NRXD * BUFLEN - BUFLEN)
-#else
 static unsigned char rxb[NRXD * BUFLEN] __attribute__ ((aligned(4)));
-#endif
 static int rxd_tail;
 static int TxPtr;
 
@@ -161,15 +153,13 @@
 /*********************************************************************/
 static void whereami(const char *str);
 static int read_eeprom(unsigned long ioaddr, int location, int addr_len);
-struct nic *davicom_probe(struct nic *nic, unsigned short *io_addrs,
-			struct pci_device *pci);
+static int davicom_probe(struct dev *dev, struct pci_device *pci);
 static void davicom_init_chain(struct nic *nic);	/* Sten 10/9 */
 static void davicom_reset(struct nic *nic);
 static void davicom_transmit(struct nic *nic, const char *d, unsigned int t,
 			   unsigned int s, const char *p);
-static int davicom_poll(struct nic *nic);
-static void davicom_disable(struct nic *nic);
-static void whereami (const char *str);
+static int davicom_poll(struct nic *nic, int retrieve);
+static void davicom_disable(struct dev *dev);
 #ifdef	DAVICOM_DEBUG
 static void davicom_more(void);
 #endif /* DAVICOM_DEBUG */
@@ -184,13 +174,10 @@
 /*********************************************************************/
 /* Utility Routines                                                  */
 /*********************************************************************/
-
-static inline void whereami (const char *str)
+static inline void whereami(const char *str)
 {
-#ifdef	DAVICOM_DEBUG_WHERE
   printf("%s\n", str);
   /* sleep(2); */
-#endif
 }
 
 #ifdef	DAVICOM_DEBUG
@@ -360,7 +347,7 @@
 /*
   Sense media mode and set CR6
 */
-static void davicom_media_chk(struct nic * nic)
+static void davicom_media_chk(struct nic * nic __unused)
 {
   unsigned long to, csr6;
 
@@ -446,8 +433,8 @@
   /* Sten: Set 2 TX descriptor but use one TX buffer because
 	   it transmit a packet and wait complete every time. */
   for (i=0; i<NTXD; i++) {
-    txd[i].buf1addr = &txb[0];		/* Used same TX buffer */
-    txd[i].buf2addr = (unsigned char *)&txd[i+1]; /*  Point to Next TX desc */
+    txd[i].buf1addr = (void *)virt_to_bus(&txb[0]);	/* Used same TX buffer */
+    txd[i].buf2addr = (void *)virt_to_bus(&txd[i+1]);	/*  Point to Next TX desc */
     txd[i].buf1sz   = 0;
     txd[i].buf2sz   = 0;
     txd[i].control  = 0x184;           /* Begin/End/Chain */
@@ -466,8 +453,8 @@
 
   /* setup receive descriptor */
   for (i=0; i<NRXD; i++) {
-    rxd[i].buf1addr = &rxb[i * BUFLEN];
-    rxd[i].buf2addr = (unsigned char *)&rxd[i+1]; /* Point to Next RX desc */
+    rxd[i].buf1addr = (void *)virt_to_bus(&rxb[i * BUFLEN]);
+    rxd[i].buf2addr = (void *)virt_to_bus(&rxd[i+1]); /* Point to Next RX desc */
     rxd[i].buf1sz   = BUFLEN;
     rxd[i].buf2sz   = 0;        /* not used */
     rxd[i].control  = 0x4;		/* Chain Structure */
@@ -475,8 +462,8 @@
   }
 
   /* Chain the last descriptor to first */
-  txd[NTXD - 1].buf2addr = (unsigned char *)&txd[0];
-  rxd[NRXD - 1].buf2addr = (unsigned char *)&rxd[0];
+  txd[NTXD - 1].buf2addr = (void *)virt_to_bus(&txd[0]);
+  rxd[NRXD - 1].buf2addr = (void *)virt_to_bus(&rxd[0]);
   TxPtr = 0;
   rxd_tail = 0;
 }
@@ -488,7 +475,6 @@
 static void davicom_reset(struct nic *nic)
 {
   unsigned long to;
-  u32 addr_low, addr_high;
 
   whereami("davicom_reset\n");
 
@@ -507,8 +493,8 @@
   davicom_init_chain(nic);	/* Sten 10/9 */
 
   /* Point to receive descriptor */
-  outl((unsigned long)&rxd[0], ioaddr + CSR3);
-  outl((unsigned long)&txd[0], ioaddr + CSR4);	/* Sten 10/9 */
+  outl(virt_to_bus(&rxd[0]), ioaddr + CSR3);
+  outl(virt_to_bus(&txd[0]), ioaddr + CSR4);	/* Sten 10/9 */
 
   /* According phyxcer media mode to set CR6,
      DM9102/A phyxcer can auto-detect media mode */
@@ -591,13 +577,15 @@
 /*********************************************************************/
 /* eth_poll - Wait for a frame                                       */
 /*********************************************************************/
-static int davicom_poll(struct nic *nic)
+static int davicom_poll(struct nic *nic, int retrieve)
 {
   whereami("davicom_poll\n");
 
   if (rxd[rxd_tail].status & 0x80000000)
     return 0;
 
+  if ( ! retrieve ) return 1;
+
   whereami("davicom_poll got one\n");
 
   nic->packetlen = (rxd[rxd_tail].status & 0x3FFF0000) >> 16;
@@ -627,10 +615,13 @@
 /*********************************************************************/
 /* eth_disable - Disable the interface                               */
 /*********************************************************************/
-static void davicom_disable(struct nic *nic)
+static void davicom_disable(struct dev *dev)
 {
+  struct nic *nic = (struct nic *)dev;
   whereami("davicom_disable\n");
 
+  davicom_reset(nic);
+
   /* disable interrupts */
   outl(0x00000000, ioaddr + CSR7);
 
@@ -640,24 +631,43 @@
   /* Clear the missed-packet counter. */
   (volatile unsigned long)inl(ioaddr + CSR8);
 }
+
+
+/*********************************************************************/
+/* eth_irq - enable, disable and force interrupts                    */
+/*********************************************************************/
+static void davicom_irq(struct nic *nic __unused, irq_action_t action __unused)
+{
+  switch ( action ) {
+  case DISABLE :
+    break;
+  case ENABLE :
+    break;
+  case FORCE :
+    break;
+  }
+}
+
 
 /*********************************************************************/
 /* eth_probe - Look for an adapter                                   */
 /*********************************************************************/
-struct nic *davicom_probe(struct nic *nic, unsigned short *io_addrs,
-                          struct pci_device *pci)
+static int davicom_probe(struct dev *dev, struct pci_device *pci)
 {
+  struct nic *nic = (struct nic *)dev;
   unsigned int i;
-  u32 l1, l2;
 
   whereami("davicom_probe\n");
 
-  if (io_addrs == 0 || *io_addrs == 0)
+  if (pci->ioaddr == 0)
     return 0;
 
   vendor  = pci->vendor;
   dev_id  = pci->dev_id;
-  ioaddr  = *io_addrs;
+  ioaddr  = pci->ioaddr & ~3;
+
+  nic->irqno  = 0;
+  nic->ioaddr = pci->ioaddr & ~3;
 
   /* wakeup chip */
   pcibios_write_config_dword(pci->bus, pci->devfn, 0x40, 0x00000000);
@@ -683,10 +693,26 @@
   /* initialize device */
   davicom_reset(nic);
 
-  nic->reset    = davicom_reset;
+  dev->disable  = davicom_disable;
   nic->poll     = davicom_poll;
   nic->transmit = davicom_transmit;
-  nic->disable  = davicom_disable;
+  nic->irq      = davicom_irq;
 
-  return nic;
+  return 1;
 }
+
+static struct pci_id davicom_nics[] = {
+PCI_ROM(0x1282, 0x9100, "davicom9100", "Davicom 9100"),
+PCI_ROM(0x1282, 0x9102, "davicom9102", "Davicom 9102"),
+PCI_ROM(0x1282, 0x9009, "davicom9009", "Davicom 9009"),
+PCI_ROM(0x1282, 0x9132, "davicom9132", "Davicom 9132"),	/* Needs probably some fixing */
+};
+
+struct pci_driver davicom_driver = {
+	.type     = NIC_DRIVER,
+	.name     = "DAVICOM",
+	.probe    = davicom_probe,
+	.ids      = davicom_nics,
+	.id_count = sizeof(davicom_nics)/sizeof(davicom_nics[0]),
+	.class    = 0,
+};
diff -Naur grub-0.97.orig/netboot/depca.c grub-0.97/netboot/depca.c
--- grub-0.97.orig/netboot/depca.c	2003-07-09 11:45:37.000000000 +0000
+++ grub-0.97/netboot/depca.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,752 +0,0 @@
-/* Etherboot: depca.h merged, comments from Linux driver retained */
-/*  depca.c: A DIGITAL DEPCA  & EtherWORKS ethernet driver for linux.
-
-    Written 1994, 1995 by David C. Davies.
-
-
-                      Copyright 1994 David C. Davies
-		                   and 
-			 United States Government
-	 (as represented by the Director, National Security Agency).  
-
-               Copyright 1995  Digital Equipment Corporation.
-
-
-    This software may be used and distributed according to the terms of
-    the GNU Public License, incorporated herein by reference.
-
-    This driver is written for the Digital Equipment Corporation series
-    of DEPCA and EtherWORKS ethernet cards:
-
-        DEPCA       (the original)
-    	DE100
-    	DE101
-	DE200 Turbo
-	DE201 Turbo
-	DE202 Turbo (TP BNC)
-	DE210
-	DE422       (EISA)
-
-    The  driver has been tested on DE100, DE200 and DE202 cards  in  a
-    relatively busy network. The DE422 has been tested a little.
-
-    This  driver will NOT work   for the DE203,  DE204  and DE205 series  of
-    cards,  since they have  a  new custom ASIC in   place of the AMD  LANCE
-    chip.  See the 'ewrk3.c'   driver in the  Linux  source tree for running
-    those cards.
-
-    I have benchmarked the driver with a  DE100 at 595kB/s to (542kB/s from)
-    a DECstation 5000/200.
-
-    The author may be reached at davies@maniac.ultranet.com
-
-    =========================================================================
-
-    The  driver was originally based  on   the 'lance.c' driver from  Donald
-    Becker   which  is included with  the  standard  driver distribution for
-    linux.  V0.4  is  a complete  re-write  with only  the kernel  interface
-    remaining from the original code.
-
-    1) Lance.c code in /linux/drivers/net/
-    2) "Ethernet/IEEE 802.3 Family. 1992 World Network Data Book/Handbook",
-       AMD, 1992 [(800) 222-9323].
-    3) "Am79C90 CMOS Local Area Network Controller for Ethernet (C-LANCE)",
-       AMD, Pub. #17881, May 1993.
-    4) "Am79C960 PCnet-ISA(tm), Single-Chip Ethernet Controller for ISA",
-       AMD, Pub. #16907, May 1992
-    5) "DEC EtherWORKS LC Ethernet Controller Owners Manual",
-       Digital Equipment corporation, 1990, Pub. #EK-DE100-OM.003
-    6) "DEC EtherWORKS Turbo Ethernet Controller Owners Manual",
-       Digital Equipment corporation, 1990, Pub. #EK-DE200-OM.003
-    7) "DEPCA Hardware Reference Manual", Pub. #EK-DEPCA-PR
-       Digital Equipment Corporation, 1989
-    8) "DEC EtherWORKS Turbo_(TP BNC) Ethernet Controller Owners Manual",
-       Digital Equipment corporation, 1991, Pub. #EK-DE202-OM.001
-    
-
-    Peter Bauer's depca.c (V0.5) was referred to when debugging V0.1 of this
-    driver.
-
-    The original DEPCA  card requires that the  ethernet ROM address counter
-    be enabled to count and has an 8 bit NICSR.  The ROM counter enabling is
-    only  done when a  0x08 is read as the  first address octet (to minimise
-    the chances  of writing over some  other hardware's  I/O register).  The
-    NICSR accesses   have been changed  to  byte accesses  for all the cards
-    supported by this driver, since there is only one  useful bit in the MSB
-    (remote boot timeout) and it  is not used.  Also, there  is a maximum of
-    only 48kB network  RAM for this  card.  My thanks  to Torbjorn Lindh for
-    help debugging all this (and holding my feet to  the fire until I got it
-    right).
-
-    The DE200  series  boards have  on-board 64kB  RAM for  use  as a shared
-    memory network  buffer. Only the DE100  cards make use  of a  2kB buffer
-    mode which has not  been implemented in  this driver (only the 32kB  and
-    64kB modes are supported [16kB/48kB for the original DEPCA]).
-
-    At the most only 2 DEPCA cards can  be supported on  the ISA bus because
-    there is only provision  for two I/O base addresses  on each card (0x300
-    and 0x200). The I/O address is detected by searching for a byte sequence
-    in the Ethernet station address PROM at the expected I/O address for the
-    Ethernet  PROM.   The shared memory  base   address  is 'autoprobed'  by
-    looking  for the self  test PROM  and detecting the  card name.   When a
-    second  DEPCA is  detected,  information  is   placed in the   base_addr
-    variable of the  next device structure (which  is created if necessary),
-    thus  enabling ethif_probe  initialization  for the device.  More than 2
-    EISA cards can  be  supported, but  care will  be  needed assigning  the
-    shared memory to ensure that each slot has the  correct IRQ, I/O address
-    and shared memory address assigned.
-
-    ************************************************************************
-
-    NOTE: If you are using two  ISA DEPCAs, it is  important that you assign
-    the base memory addresses correctly.   The  driver autoprobes I/O  0x300
-    then 0x200.  The  base memory address for  the first device must be less
-    than that of the second so that the auto probe will correctly assign the
-    I/O and memory addresses on the same card.  I can't think of a way to do
-    this unambiguously at the moment, since there is nothing on the cards to
-    tie I/O and memory information together.
-
-    I am unable  to  test  2 cards   together for now,    so this  code   is
-    unchecked. All reports, good or bad, are welcome.
-
-    ************************************************************************
-
-    The board IRQ   setting must be  at an  unused IRQ which  is auto-probed
-    using Donald Becker's autoprobe routines. DEPCA and DE100 board IRQs are
-    {2,3,4,5,7}, whereas the  DE200 is at {5,9,10,11,15}.  Note that IRQ2 is
-    really IRQ9 in machines with 16 IRQ lines.
-
-    No 16MB memory  limitation should exist with this  driver as DMA is  not
-    used and the common memory area is in low memory on the network card (my
-    current system has 20MB and I've not had problems yet).
-
-    The ability to load this driver as a loadable module has been added. To
-    utilise this ability, you have to do <8 things:
-
-    0) have a copy of the loadable modules code installed on your system.
-    1) copy depca.c from the  /linux/drivers/net directory to your favourite
-    temporary directory.
-    2) if you wish, edit the  source code near  line 1530 to reflect the I/O
-    address and IRQ you're using (see also 5).
-    3) compile  depca.c, but include -DMODULE in  the command line to ensure
-    that the correct bits are compiled (see end of source code).
-    4) if you are wanting to add a new  card, goto 5. Otherwise, recompile a
-    kernel with the depca configuration turned off and reboot.
-    5) insmod depca.o [irq=7] [io=0x200] [mem=0xd0000] [adapter_name=DE100]
-       [Alan Cox: Changed the code to allow command line irq/io assignments]
-       [Dave Davies: Changed the code to allow command line mem/name
-                                                                assignments]
-    6) run the net startup bits for your eth?? interface manually 
-    (usually /etc/rc.inet[12] at boot time). 
-    7) enjoy!
-
-    Note that autoprobing is not allowed in loadable modules - the system is
-    already up and running and you're messing with interrupts.
-
-    To unload a module, turn off the associated interface 
-    'ifconfig eth?? down' then 'rmmod depca'.
-
-    To assign a base memory address for the shared memory  when running as a
-    loadable module, see 5 above.  To include the adapter  name (if you have
-    no PROM  but know the card name)  also see 5  above. Note that this last
-    option  will not work  with kernel  built-in  depca's. 
-
-    The shared memory assignment for a loadable module  makes sense to avoid
-    the 'memory autoprobe' picking the wrong shared memory  (for the case of
-    2 depca's in a PC).
-
-    ************************************************************************
-    Support for MCA EtherWORKS cards added 11-3-98.
-    Verified to work with up to 2 DE212 cards in a system (although not
-      fully stress-tested).  
-
-    Currently known bugs/limitations:
-
-    Note:  with the MCA stuff as a module, it trusts the MCA configuration,
-           not the command line for IRQ and memory address.  You can
-           specify them if you want, but it will throw your values out.
-           You still have to pass the IO address it was configured as
-           though.
-
-    ************************************************************************
-    TO DO:
-    ------
-
-
-    Revision History
-    ----------------
-
-    Version   Date        Description
-  
-      0.1     25-jan-94   Initial writing.
-      0.2     27-jan-94   Added LANCE TX hardware buffer chaining.
-      0.3      1-feb-94   Added multiple DEPCA support.
-      0.31     4-feb-94   Added DE202 recognition.
-      0.32    19-feb-94   Tidy up. Improve multi-DEPCA support.
-      0.33    25-feb-94   Fix DEPCA ethernet ROM counter enable.
-                          Add jabber packet fix from murf@perftech.com
-			  and becker@super.org
-      0.34     7-mar-94   Fix DEPCA max network memory RAM & NICSR access.
-      0.35     8-mar-94   Added DE201 recognition. Tidied up.
-      0.351   30-apr-94   Added EISA support. Added DE422 recognition.
-      0.36    16-may-94   DE422 fix released.
-      0.37    22-jul-94   Added MODULE support
-      0.38    15-aug-94   Added DBR ROM switch in depca_close(). 
-                          Multi DEPCA bug fix.
-      0.38axp 15-sep-94   Special version for Alpha AXP Linux V1.0.
-      0.381   12-dec-94   Added DE101 recognition, fix multicast bug.
-      0.382    9-feb-95   Fix recognition bug reported by <bkm@star.rl.ac.uk>.
-      0.383   22-feb-95   Fix for conflict with VESA SCSI reported by
-                          <stromain@alf.dec.com>
-      0.384   17-mar-95   Fix a ring full bug reported by <bkm@star.rl.ac.uk>
-      0.385    3-apr-95   Fix a recognition bug reported by 
-                                                <ryan.niemi@lastfrontier.com>
-      0.386   21-apr-95   Fix the last fix...sorry, must be galloping senility
-      0.40    25-May-95   Rewrite for portability & updated.
-                          ALPHA support from <jestabro@amt.tay1.dec.com>
-      0.41    26-Jun-95   Added verify_area() calls in depca_ioctl() from
-                          suggestion by <heiko@colossus.escape.de>
-      0.42    27-Dec-95   Add 'mem' shared memory assignment for loadable 
-                          modules.
-                          Add 'adapter_name' for loadable modules when no PROM.
-			  Both above from a suggestion by 
-			  <pchen@woodruffs121.residence.gatech.edu>.
-			  Add new multicasting code.
-      0.421   22-Apr-96	  Fix alloc_device() bug <jari@markkus2.fimr.fi>
-      0.422   29-Apr-96	  Fix depca_hw_init() bug <jari@markkus2.fimr.fi>
-      0.423    7-Jun-96   Fix module load bug <kmg@barco.be>
-      0.43    16-Aug-96   Update alloc_device() to conform to de4x5.c
-      0.44     1-Sep-97   Fix *_probe() to test check_region() first - bug
-                           reported by <mmogilvi@elbert.uccs.edu>
-      0.45     3-Nov-98   Added support for MCA EtherWORKS (DE210/DE212) cards
-                           by <tymm@computer.org> 
-      0.451    5-Nov-98   Fixed mca stuff cuz I'm a dummy. <tymm@computer.org>
-      0.5     14-Nov-98   Re-spin for 2.1.x kernels.
-      0.51    27-Jun-99   Correct received packet length for CRC from
-                           report by <worm@dkik.dk>
-
-    =========================================================================
-*/
-
-#include "etherboot.h"
-#include "nic.h"
-#include "cards.h"
-
-/*
-** I/O addresses. Note that the 2k buffer option is not supported in
-** this driver.
-*/
-#define DEPCA_NICSR ioaddr+0x00   /* Network interface CSR */
-#define DEPCA_RBI   ioaddr+0x02   /* RAM buffer index (2k buffer mode) */
-#define DEPCA_DATA  ioaddr+0x04   /* LANCE registers' data port */
-#define DEPCA_ADDR  ioaddr+0x06   /* LANCE registers' address port */
-#define DEPCA_HBASE ioaddr+0x08   /* EISA high memory base address reg. */
-#define DEPCA_PROM  ioaddr+0x0c   /* Ethernet address ROM data port */
-#define DEPCA_CNFG  ioaddr+0x0c   /* EISA Configuration port */
-#define DEPCA_RBSA  ioaddr+0x0e   /* RAM buffer starting address (2k buff.) */
-
-/*
-** These are LANCE registers addressable through DEPCA_ADDR 
-*/
-#define CSR0       0
-#define CSR1       1
-#define CSR2       2
-#define CSR3       3
-
-/* 
-** NETWORK INTERFACE CSR (NI_CSR) bit definitions 
-*/
- 
-#define TO       	0x0100	/* Time Out for remote boot */
-#define SHE      	0x0080  /* SHadow memory Enable */
-#define BS       	0x0040  /* Bank Select */
-#define BUF      	0x0020	/* BUFfer size (1->32k, 0->64k) */
-#define RBE      	0x0010	/* Remote Boot Enable (1->net boot) */
-#define AAC      	0x0008  /* Address ROM Address Counter (1->enable) */
-#define _128KB      	0x0008  /* 128kB Network RAM (1->enable) */
-#define IM       	0x0004	/* Interrupt Mask (1->mask) */
-#define IEN      	0x0002	/* Interrupt tristate ENable (1->enable) */
-#define LED      	0x0001	/* LED control */
-
-/* 
-** Control and Status Register 0 (CSR0) bit definitions 
-*/
-
-#define ERR     	0x8000 	/* Error summary */
-#define BABL    	0x4000 	/* Babble transmitter timeout error  */
-#define CERR    	0x2000 	/* Collision Error */
-#define MISS    	0x1000 	/* Missed packet */
-#define MERR    	0x0800 	/* Memory Error */
-#define RINT    	0x0400 	/* Receiver Interrupt */
-#define TINT    	0x0200 	/* Transmit Interrupt */
-#define IDON    	0x0100 	/* Initialization Done */
-#define INTR    	0x0080 	/* Interrupt Flag */
-#define INEA    	0x0040 	/* Interrupt Enable */
-#define RXON    	0x0020 	/* Receiver on */
-#define TXON    	0x0010 	/* Transmitter on */
-#define TDMD    	0x0008 	/* Transmit Demand */
-#define STOP    	0x0004 	/* Stop */
-#define STRT    	0x0002 	/* Start */
-#define INIT    	0x0001 	/* Initialize */
-#define INTM            0xff00  /* Interrupt Mask */
-#define INTE            0xfff0  /* Interrupt Enable */
-
-/*
-** CONTROL AND STATUS REGISTER 3 (CSR3)
-*/
-
-#define BSWP    	0x0004	/* Byte SWaP */
-#define ACON    	0x0002	/* ALE control */
-#define BCON    	0x0001	/* Byte CONtrol */
-
-/*
-** Initialization Block Mode Register 
-*/
-
-#define PROM       	0x8000 	/* Promiscuous Mode */
-#define EMBA       	0x0080	/* Enable Modified Back-off Algorithm */
-#define INTL       	0x0040 	/* Internal Loopback */
-#define DRTY       	0x0020 	/* Disable Retry */
-#define COLL       	0x0010 	/* Force Collision */
-#define DTCR       	0x0008 	/* Disable Transmit CRC */
-#define LOOP       	0x0004 	/* Loopback */
-#define DTX        	0x0002 	/* Disable the Transmitter */
-#define DRX        	0x0001 	/* Disable the Receiver */
-
-/*
-** Receive Message Descriptor 1 (RMD1) bit definitions. 
-*/
-
-#define R_OWN       0x80000000 	/* Owner bit 0 = host, 1 = lance */
-#define R_ERR     	0x4000 	/* Error Summary */
-#define R_FRAM    	0x2000 	/* Framing Error */
-#define R_OFLO    	0x1000 	/* Overflow Error */
-#define R_CRC     	0x0800 	/* CRC Error */
-#define R_BUFF    	0x0400 	/* Buffer Error */
-#define R_STP     	0x0200 	/* Start of Packet */
-#define R_ENP     	0x0100 	/* End of Packet */
-
-/*
-** Transmit Message Descriptor 1 (TMD1) bit definitions. 
-*/
-
-#define T_OWN       0x80000000 	/* Owner bit 0 = host, 1 = lance */
-#define T_ERR     	0x4000 	/* Error Summary */
-#define T_ADD_FCS 	0x2000 	/* More the 1 retry needed to Xmit */
-#define T_MORE    	0x1000	/* >1 retry to transmit packet */
-#define T_ONE     	0x0800 	/* 1 try needed to transmit the packet */
-#define T_DEF     	0x0400 	/* Deferred */
-#define T_STP       0x02000000 	/* Start of Packet */
-#define T_ENP       0x01000000	/* End of Packet */
-#define T_FLAGS     0xff000000  /* TX Flags Field */
-
-/*
-** Transmit Message Descriptor 3 (TMD3) bit definitions.
-*/
-
-#define TMD3_BUFF    0x8000	/* BUFFer error */
-#define TMD3_UFLO    0x4000	/* UnderFLOw error */
-#define TMD3_RES     0x2000	/* REServed */
-#define TMD3_LCOL    0x1000	/* Late COLlision */
-#define TMD3_LCAR    0x0800	/* Loss of CARrier */
-#define TMD3_RTRY    0x0400	/* ReTRY error */
-
-/*
-** Ethernet PROM defines
-*/
-#define PROBE_LENGTH    32
-
-/*
-** Set the number of Tx and Rx buffers. Ensure that the memory requested
-** here is <= to the amount of shared memory set up by the board switches.
-** The number of descriptors MUST BE A POWER OF 2.
-**
-** total_memory = NUM_RX_DESC*(8+RX_BUFF_SZ) + NUM_TX_DESC*(8+TX_BUFF_SZ)
-*/
-#define NUM_RX_DESC     2               /* Number of RX descriptors */
-#define NUM_TX_DESC     2               /* Number of TX descriptors */
-#define RX_BUFF_SZ	1536            /* Buffer size for each Rx buffer */
-#define TX_BUFF_SZ	1536            /* Buffer size for each Tx buffer */
-
-/*
-** ISA Bus defines
-*/
-#define DEPCA_IO_PORTS	{0x300, 0x200, 0}
-
-#ifndef	DEPCA_MODEL
-#define	DEPCA_MODEL	DEPCA
-#endif
-
-static enum {
-	DEPCA, DE100, DE101, DE200, DE201, DE202, DE210, DE212, DE422, unknown
-} adapter = DEPCA_MODEL;
-
-/*
-** Name <-> Adapter mapping
-*/
-
-static char *adapter_name[] = {
-	"DEPCA",
-	"DE100","DE101",
-	"DE200","DE201","DE202",
-	"DE210","DE212",
-	"DE422",
-	""
-};
-
-#ifndef	DEPCA_RAM_BASE
-#define DEPCA_RAM_BASE	0xd0000
-#endif
-
-/*
-** Memory Alignment. Each descriptor is 4 longwords long. To force a
-** particular alignment on the TX descriptor, adjust DESC_SKIP_LEN and
-** DESC_ALIGN. ALIGN aligns the start address of the private memory area
-** and hence the RX descriptor ring's first entry. 
-*/
-#define ALIGN4      ((u32)4 - 1)       /* 1 longword align */
-#define ALIGN8      ((u32)8 - 1)       /* 2 longword (quadword) align */
-#define ALIGN         ALIGN8              /* Keep the LANCE happy... */
-
-typedef	long		s32;
-typedef	unsigned long	u32;
-typedef	short		s16;
-typedef	unsigned short	u16;
-typedef	char		s8;
-typedef	unsigned char	u8;
-
-/*
-** The DEPCA Rx and Tx ring descriptors. 
-*/
-struct depca_rx_desc {
-    volatile s32 base;
-    s16 buf_length;		/* This length is negative 2's complement! */
-    s16 msg_length;		/* This length is "normal". */
-};
-
-struct depca_tx_desc {
-    volatile s32 base;
-    s16 length;		        /* This length is negative 2's complement! */
-    s16 misc;                   /* Errors and TDR info */
-};
-
-#define LA_MASK 0x0000ffff      /* LANCE address mask for mapping network RAM
-				   to LANCE memory address space */
-
-/*
-** The Lance initialization block, described in databook, in common memory.
-*/
-struct depca_init {
-    u16 mode;	                /* Mode register */
-    u8  phys_addr[ETH_ALEN];	/* Physical ethernet address */
-    u8  mcast_table[8];	        /* Multicast Hash Table. */
-    u32 rx_ring;     	        /* Rx ring base pointer & ring length */
-    u32 tx_ring;	        /* Tx ring base pointer & ring length */
-};
-
-struct depca_private {
-	struct depca_rx_desc	*rx_ring;
-	struct depca_tx_desc	*tx_ring;
-	struct depca_init	init_block;	/* Shadow init block */
-	char			*rx_memcpy[NUM_RX_DESC];
-	char			*tx_memcpy[NUM_TX_DESC];
-	u32			bus_offset;	/* ISA bus address offset */
-	u32			sh_mem;		/* address of shared mem */
-	u32			dma_buffs;	/* Rx & Tx buffer start */
-	int			rx_cur, tx_cur;	/* Next free ring entry */
-	int			txRingMask, rxRingMask;
-	s32			rx_rlen, tx_rlen;
-	/* log2([rt]xRingMask+1) for the descriptors */
-};
-
-static Address		mem_start = DEPCA_RAM_BASE;
-static Address		mem_len, offset;
-static unsigned short	ioaddr = 0;
-static struct depca_private	lp;
-
-/*
-** Miscellaneous defines...
-*/
-#define STOP_DEPCA \
-    outw(CSR0, DEPCA_ADDR);\
-    outw(STOP, DEPCA_DATA)
-
-/* Initialize the lance Rx and Tx descriptor rings. */
-static void depca_init_ring(struct nic *nic)
-{
-	int	i;
-	u32	p;
-
-	lp.rx_cur = lp.tx_cur = 0;
-	/* Initialize the base addresses and length of each buffer in the ring */
-	for (i = 0; i <= lp.rxRingMask; i++) {
-		writel((p = lp.dma_buffs + i * RX_BUFF_SZ) | R_OWN, &lp.rx_ring[i].base);
-		writew(-RX_BUFF_SZ, &lp.rx_ring[i].buf_length);
-		lp.rx_memcpy[i] = (char *) (p + lp.bus_offset);
-	}
-	for (i = 0; i <= lp.txRingMask; i++) {
-		writel((p = lp.dma_buffs + (i + lp.txRingMask + 1) * TX_BUFF_SZ) & 0x00ffffff, &lp.tx_ring[i].base);
-		lp.tx_memcpy[i] = (char *) (p + lp.bus_offset);
-	}
-
-	/* Set up the initialization block */
-	lp.init_block.rx_ring = ((u32) ((u32) lp.rx_ring) & LA_MASK) | lp.rx_rlen;
-	lp.init_block.tx_ring = ((u32) ((u32) lp.tx_ring) & LA_MASK) | lp.tx_rlen;
-	for (i = 0; i < ETH_ALEN; i++)
-		lp.init_block.phys_addr[i] = nic->node_addr[i];
-	lp.init_block.mode = 0x0000;	/* Enable the Tx and Rx */
-	memset(lp.init_block.mcast_table, 0, sizeof(lp.init_block.mcast_table));
-}
-
-static void LoadCSRs(void)
-{
-	outw(CSR1, DEPCA_ADDR);	/* initialisation block address LSW */
-	outw((u16) (lp.sh_mem & LA_MASK), DEPCA_DATA);
-	outw(CSR2, DEPCA_ADDR);	/* initialisation block address MSW */
-	outw((u16) ((lp.sh_mem & LA_MASK) >> 16), DEPCA_DATA);
-	outw(CSR3, DEPCA_ADDR);	/* ALE control */
-	outw(ACON, DEPCA_DATA);
-	outw(CSR0, DEPCA_ADDR);	/* Point back to CSR0 */
-}
-
-static int InitRestartDepca(void)
-{
-	int		i;
-
-	/* Copy the shadow init_block to shared memory */
-	memcpy_toio((char *)lp.sh_mem, &lp.init_block, sizeof(struct depca_init));
-	outw(CSR0, DEPCA_ADDR);		/* point back to CSR0 */
-	outw(INIT, DEPCA_DATA);		/* initialise DEPCA */
-
-	for (i = 0; i < 100 && !(inw(DEPCA_DATA) & IDON); i++)
-		;
-	if (i < 100) {
-		/* clear IDON by writing a 1, and start LANCE */
-		outw(IDON | STRT, DEPCA_DATA);
-	} else {
-		printf("DEPCA not initialised\n");
-		return (1);
-	}
-	return (0);
-}
-
-/**************************************************************************
-RESET - Reset adapter
-***************************************************************************/
-static void depca_reset(struct nic *nic)
-{
-	s16	nicsr;
-	int	i, j;
-
-	STOP_DEPCA;
-	nicsr = inb(DEPCA_NICSR);
-	nicsr = ((nicsr & ~SHE & ~RBE & ~IEN) | IM);
-	outb(nicsr, DEPCA_NICSR);
-	if (inw(DEPCA_DATA) != STOP)
-	{
-		printf("depca: Cannot stop NIC\n");
-		return;
-	}
-
-	/* Initialisation block */
-	lp.sh_mem = mem_start;
-	mem_start += sizeof(struct depca_init);
-	/* Tx & Rx descriptors (aligned to a quadword boundary) */
-	mem_start = (mem_start + ALIGN) & ~ALIGN;
-	lp.rx_ring = (struct depca_rx_desc *) mem_start;
-	mem_start += (sizeof(struct depca_rx_desc) * NUM_RX_DESC);
-	lp.tx_ring = (struct depca_tx_desc *) mem_start;
-	mem_start += (sizeof(struct depca_tx_desc) * NUM_TX_DESC);
-
-	lp.bus_offset = mem_start & 0x00ff0000;
-	/* LANCE re-mapped start address */
-	lp.dma_buffs = mem_start & LA_MASK;
-
-	/* Finish initialising the ring information. */
-	lp.rxRingMask = NUM_RX_DESC - 1;
-	lp.txRingMask = NUM_TX_DESC - 1;
-
-	/* Calculate Tx/Rx RLEN size for the descriptors. */
-	for (i = 0, j = lp.rxRingMask; j > 0; i++) {
-		j >>= 1;
-	}
-	lp.rx_rlen = (s32) (i << 29);
-	for (i = 0, j = lp.txRingMask; j > 0; i++) {
-		j >>= 1;
-	}
-	lp.tx_rlen = (s32) (i << 29);
-
-	/* Load the initialisation block */
-	depca_init_ring(nic);
-	LoadCSRs();
-	InitRestartDepca();
-}
-
-/**************************************************************************
-POLL - Wait for a frame
-***************************************************************************/
-static int depca_poll(struct nic *nic)
-{
-	int		entry;
-	u32		status;
-
-	entry = lp.rx_cur;
-	if ((status = readl(&lp.rx_ring[entry].base) & R_OWN))
-		return (0);
-	memcpy(nic->packet, lp.rx_memcpy[entry], nic->packetlen = lp.rx_ring[entry].msg_length);
-	lp.rx_ring[entry].base |= R_OWN;
-	lp.rx_cur = (++lp.rx_cur) & lp.rxRingMask;
-	return (1);
-}
-
-/**************************************************************************
-TRANSMIT - Transmit a frame
-***************************************************************************/
-static void depca_transmit(
-	struct nic *nic,
-	const char *d,			/* Destination */
-	unsigned int t,			/* Type */
-	unsigned int s,			/* size */
-	const char *p)			/* Packet */
-{
-	int		entry, len;
-	char		*mem;
-
-	/* send the packet to destination */
-	/*
-	** Caution: the right order is important here... dont
-	** setup the ownership rights until all the other
-	** information is in place
-	*/
-	mem = lp.tx_memcpy[entry = lp.tx_cur];
-	memcpy_toio(mem, d, ETH_ALEN);
-	memcpy_toio(mem + ETH_ALEN, nic->node_addr, ETH_ALEN);
-	mem[ETH_ALEN * 2] = t >> 8;
-	mem[ETH_ALEN * 2 + 1] = t;
-	memcpy_toio(mem + ETH_HLEN, p, s);
-	s += ETH_HLEN;
-	len = (s < ETH_ZLEN ? ETH_ZLEN : s);
-	/* clean out flags */
-	writel(readl(&lp.tx_ring[entry].base) & ~T_FLAGS, &lp.tx_ring[entry].base);
-	/* clears other error flags */
-	writew(0x0000, &lp.tx_ring[entry].misc);
-	/* packet length in buffer */
-	writew(-len, &lp.tx_ring[entry].length);
-	/* start and end of packet, ownership */
-	writel(readl(&lp.tx_ring[entry].base) | (T_STP|T_ENP|T_OWN), &lp.tx_ring[entry].base);
-	/* update current pointers */
-	lp.tx_cur = (++lp.tx_cur) & lp.txRingMask;
-}
-
-/**************************************************************************
-DISABLE - Turn off ethernet interface
-***************************************************************************/
-static void depca_disable(struct nic *nic)
-{
-	STOP_DEPCA;
-}
-
-/*
-** Look for a special sequence in the Ethernet station address PROM that
-** is common across all DEPCA products. Note that the original DEPCA needs
-** its ROM address counter to be initialized and enabled. Only enable
-** if the first address octet is a 0x08 - this minimises the chances of
-** messing around with some other hardware, but it assumes that this DEPCA
-** card initialized itself correctly.
-**
-** Search the Ethernet address ROM for the signature. Since the ROM address
-** counter can start at an arbitrary point, the search must include the entire
-** probe sequence length plus the (length_of_the_signature - 1).
-** Stop the search IMMEDIATELY after the signature is found so that the
-** PROM address counter is correctly positioned at the start of the
-** ethernet address for later read out.
-*/
-static int depca_probe1(struct nic *nic)
-{
-	u8	data, nicsr;
-	/* This is only correct for little endian machines, but then
-	   Etherboot doesn't work on anything but a PC */
-	u8	sig[] = { 0xFF, 0x00, 0x55, 0xAA, 0xFF, 0x00, 0x55, 0xAA };
-	int	i, j;
-	long	sum, chksum;
-
-	data = inb(DEPCA_PROM);		/* clear counter on DEPCA */
-	data = inb(DEPCA_PROM);		/* read data */
-	if (data == 0x8) {
-		nicsr = inb(DEPCA_NICSR);
-		nicsr |= AAC;
-		outb(nicsr, DEPCA_NICSR);
-	}
-	for (i = 0, j = 0; j < (int)sizeof(sig) && i < PROBE_LENGTH+((int)sizeof(sig))-1; ++i) {
-		data = inb(DEPCA_PROM);
-		if (data == sig[j])		/* track signature */
-			++j;
-		else
-			j = (data == sig[0]) ? 1 : 0;
-	}
-	if (j != sizeof(sig))
-		return (0);
-	/* put the card in its initial state */
-	STOP_DEPCA;
-	nicsr = ((inb(DEPCA_NICSR) & ~SHE & ~RBE & ~IEN) | IM);
-	outb(nicsr, DEPCA_NICSR);
-	if (inw(DEPCA_DATA) != STOP)
-		return (0);
-	memcpy((char *)mem_start, sig, sizeof(sig));
-	if (memcmp((char *)mem_start, sig, sizeof(sig)) != 0)
-		return (0);
-	for (i = 0, j = 0, sum = 0; j < 3; j++) {
-		sum <<= 1;
-		if (sum > 0xFFFF)
-			sum -= 0xFFFF;
-		sum += (u8)(nic->node_addr[i++] = inb(DEPCA_PROM));
-		sum += (u16)((nic->node_addr[i++] = inb(DEPCA_PROM)) << 8);
-		if (sum > 0xFFFF)
-			sum -= 0xFFFF;
-	}
-	if (sum == 0xFFFF)
-		sum = 0;
-	chksum = (u8)inb(DEPCA_PROM);
-	chksum |= (u16)(inb(DEPCA_PROM) << 8);
-	mem_len = (adapter == DEPCA) ? (48 << 10) : (64 << 10);
-	offset = 0;
-	if (nicsr & BUF) {
-		offset = 0x8000;
-		nicsr &= ~BS;
-		mem_len -= (32 << 10);
-	}
-	if (adapter != DEPCA)	/* enable shadow RAM */
-		outb(nicsr |= SHE, DEPCA_NICSR);
-	printf("%s base %#hX, memory [%#hX-%#hX], addr %!",
-		adapter_name[adapter], ioaddr, mem_start, mem_start + mem_len,
-		nic->node_addr);
-	if (sum != chksum)
-		printf(" (bad checksum)");
-	putchar('\n');
-	return (1);
-}
-
-/**************************************************************************
-PROBE - Look for an adapter, this routine's visible to the outside
-***************************************************************************/
-struct nic *depca_probe(struct nic *nic, unsigned short *probe_addrs)
-{
-	static unsigned short	base[] = DEPCA_IO_PORTS;
-	int			i;
-
-	if (probe_addrs == 0 || probe_addrs[0] == 0)
-		probe_addrs = base;	/* Use defaults */
-	for (i = 0; (ioaddr = base[i]) != 0; ++i) {
-		if (depca_probe1(nic))
-			break;
-	}
-	if (ioaddr == 0)
-		return (0);
-	depca_reset(nic);
-	/* point to NIC specific routines */
-	nic->reset = depca_reset;
-	nic->poll = depca_poll;
-	nic->transmit = depca_transmit;
-	nic->disable = depca_disable;
-	return (nic);
-}
diff -Naur grub-0.97.orig/netboot/dev.h grub-0.97/netboot/dev.h
--- grub-0.97.orig/netboot/dev.h	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/dev.h	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,83 @@
+#ifndef _DEV_H
+#define _DEV_H
+
+#include "isa.h"
+#include "pci.h"
+
+/* Need to check the packing of this struct if Etherboot is ported */
+struct dev_id
+{
+	unsigned short	vendor_id;
+	unsigned short	device_id;
+	unsigned char	bus_type;
+#define	PCI_BUS_TYPE	1
+#define	ISA_BUS_TYPE	2
+};
+
+/* Dont use sizeof, that will include the padding */
+#define	DEV_ID_SIZE	8
+
+
+struct pci_probe_state 
+{
+#ifdef CONFIG_PCI
+	struct pci_device dev;
+	int advance;
+#else
+	int dummy;
+#endif
+};
+struct isa_probe_state
+{
+#ifdef CONFIG_ISA
+	const struct isa_driver *driver;
+	int advance;
+#else
+	int dummy;
+#endif
+};
+
+union probe_state
+{
+	struct pci_probe_state pci;
+	struct isa_probe_state isa;
+};
+
+struct dev
+{
+	void		(*disable)P((struct dev *));
+	struct dev_id	devid;	/* device ID string (sent to DHCP server) */
+	int		index;  /* Index of next device on this controller to probe */
+	int		type;		/* Type of device I am probing for */
+	int		how_probe;	/* First, next or awake */
+	int 		to_probe;	/* Flavor of device I am probing */
+	int		failsafe;	/* Failsafe probe requested */
+	int		type_index;	/* Index of this device (within type) */
+#define	PROBE_NONE 0
+#define PROBE_PCI  1
+#define PROBE_ISA  2
+	union probe_state state;
+};
+
+
+#define NIC_DRIVER    0
+#define DISK_DRIVER   1
+#define FLOPPY_DRIVER 2
+
+#define BRIDGE_DRIVER 1000
+
+#define PROBE_FIRST  (-1)
+#define PROBE_NEXT   0
+#define PROBE_AWAKE  1		/* After calling disable bring up the same device */
+
+/* The probe result codes are selected
+ * to allow them to be fed back into the probe
+ * routine and get a successful probe.
+ */
+#define PROBE_FAILED PROBE_FIRST
+#define PROBE_WORKED  PROBE_NEXT
+
+extern int probe(struct dev *dev);
+extern void disable(struct dev *dev);
+
+#endif /* _DEV_H */
diff -Naur grub-0.97.orig/netboot/e1000.c grub-0.97/netboot/e1000.c
--- grub-0.97.orig/netboot/e1000.c	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/e1000.c	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,3682 @@
+/**************************************************************************
+Etherboot -  BOOTP/TFTP Bootstrap Program
+Inter Pro 1000 for Etherboot
+Drivers are port from Intel's Linux driver e1000-4.3.15
+
+***************************************************************************/
+/*******************************************************************************
+
+  
+  Copyright(c) 1999 - 2003 Intel Corporation. All rights reserved.
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  Linux NICS <linux.nics@intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+
+*******************************************************************************/
+/*
+ *  Copyright (C) Archway Digital Solutions.
+ *
+ *  written by Chrsitopher Li <cli at arcyway dot com> or <chrisl at gnuchina dot org>
+ *  2/9/2002
+ *
+ *  Copyright (C) Linux Networx.
+ *  Massive upgrade to work with the new intel gigabit NICs.
+ *  <ebiederman at lnxi dot com>
+ *
+ *  Support for 82541ei & 82547ei chips from Intel's Linux driver 5.1.13 added by
+ *  Georg Baum <gbaum@users.sf.net>, sponsored by PetaMem GmbH and linkLINE Communications, Inc.
+ *
+ *  01/2004: Updated to Linux driver 5.2.22 by Georg Baum <gbaum@users.sf.net>
+ */
+
+/* to get some global routines like printf */
+#include "etherboot.h"
+/* to get the interface to the body of the program */
+#include "nic.h"
+/* to get the PCI support functions, if this is a PCI NIC */
+#include "pci.h"
+#include "timer.h"
+
+typedef unsigned char *dma_addr_t;
+
+typedef enum {
+	FALSE = 0,
+	TRUE = 1
+} boolean_t;
+
+#define DEBUG 0
+
+
+/* Some pieces of code are disabled with #if 0 ... #endif.
+ * They are not deleted to show where the etherboot driver differs
+ * from the linux driver below the function level.
+ * Some member variables of the hw struct have been eliminated
+ * and the corresponding inplace checks inserted instead.
+ * Pieces such as LED handling that we definitely don't need are deleted.
+ *
+ * The following defines should not be needed normally,
+ * but may be helpful for debugging purposes. */
+
+/* Define this if you want to program the transmission control register
+ * the way the Linux driver does it. */
+#undef LINUX_DRIVER_TCTL
+
+/* Define this to behave more like the Linux driver. */
+#undef LINUX_DRIVER
+
+#include "e1000_hw.h"
+
+/* NIC specific static variables go here */
+static struct e1000_hw hw;
+static char tx_pool[128 + 16];
+static char rx_pool[128 + 16];
+static char packet[2096];
+
+static struct e1000_tx_desc *tx_base;
+static struct e1000_rx_desc *rx_base;
+
+static int tx_tail;
+static int rx_tail, rx_last;
+
+/* Function forward declarations */
+static int e1000_setup_link(struct e1000_hw *hw);
+static int e1000_setup_fiber_serdes_link(struct e1000_hw *hw);
+static int e1000_setup_copper_link(struct e1000_hw *hw);
+static int e1000_phy_setup_autoneg(struct e1000_hw *hw);
+static void e1000_config_collision_dist(struct e1000_hw *hw);
+static int e1000_config_mac_to_phy(struct e1000_hw *hw);
+static int e1000_config_fc_after_link_up(struct e1000_hw *hw);
+static int e1000_check_for_link(struct e1000_hw *hw);
+static int e1000_wait_autoneg(struct e1000_hw *hw);
+static void e1000_get_speed_and_duplex(struct e1000_hw *hw, uint16_t *speed, uint16_t *duplex);
+static int e1000_read_phy_reg(struct e1000_hw *hw, uint32_t reg_addr, uint16_t *phy_data);
+static int e1000_read_phy_reg_ex(struct e1000_hw *hw, uint32_t reg_addr, uint16_t *phy_data);
+static int e1000_write_phy_reg(struct e1000_hw *hw, uint32_t reg_addr, uint16_t phy_data);
+static int e1000_write_phy_reg_ex(struct e1000_hw *hw, uint32_t reg_addr, uint16_t phy_data);
+static void e1000_phy_hw_reset(struct e1000_hw *hw);
+static int e1000_phy_reset(struct e1000_hw *hw);
+static int e1000_detect_gig_phy(struct e1000_hw *hw);
+
+/* Printing macros... */
+
+#define E1000_ERR(args...) printf("e1000: " args)
+
+#if DEBUG >= 3
+#define E1000_DBG(args...) printf("e1000: " args)
+#else
+#define E1000_DBG(args...)
+#endif
+
+#define MSGOUT(S, A, B)     printk(S "\n", A, B)
+#if DEBUG >= 2
+#define DEBUGFUNC(F)        DEBUGOUT(F "\n");
+#else
+#define DEBUGFUNC(F)
+#endif
+#if DEBUG >= 1
+#define DEBUGOUT(S) printf(S)
+#define DEBUGOUT1(S,A) printf(S,A)
+#define DEBUGOUT2(S,A,B) printf(S,A,B)
+#define DEBUGOUT3(S,A,B,C) printf(S,A,B,C)
+#define DEBUGOUT7(S,A,B,C,D,E,F,G) printf(S,A,B,C,D,E,F,G)
+#else
+#define DEBUGOUT(S)
+#define DEBUGOUT1(S,A)
+#define DEBUGOUT2(S,A,B)
+#define DEBUGOUT3(S,A,B,C)
+#define DEBUGOUT7(S,A,B,C,D,E,F,G)
+#endif
+
+#define E1000_WRITE_REG(a, reg, value) ( \
+    ((a)->mac_type >= e1000_82543) ? \
+        (writel((value), ((a)->hw_addr + E1000_##reg))) : \
+        (writel((value), ((a)->hw_addr + E1000_82542_##reg))))
+
+#define E1000_READ_REG(a, reg) ( \
+    ((a)->mac_type >= e1000_82543) ? \
+        readl((a)->hw_addr + E1000_##reg) : \
+        readl((a)->hw_addr + E1000_82542_##reg))
+
+#define E1000_WRITE_REG_ARRAY(a, reg, offset, value) ( \
+    ((a)->mac_type >= e1000_82543) ? \
+        writel((value), ((a)->hw_addr + E1000_##reg + ((offset) << 2))) : \
+        writel((value), ((a)->hw_addr + E1000_82542_##reg + ((offset) << 2))))
+
+#define E1000_READ_REG_ARRAY(a, reg, offset) ( \
+    ((a)->mac_type >= e1000_82543) ? \
+        readl((a)->hw_addr + E1000_##reg + ((offset) << 2)) : \
+        readl((a)->hw_addr + E1000_82542_##reg + ((offset) << 2)))
+
+#define E1000_WRITE_FLUSH(a) {uint32_t x; x = E1000_READ_REG(a, STATUS);}
+
+uint32_t
+e1000_io_read(struct e1000_hw *hw __unused, uint32_t port)
+{
+        return inl(port);
+}
+
+void
+e1000_io_write(struct e1000_hw *hw __unused, uint32_t port, uint32_t value)
+{
+        outl(value, port);
+}
+
+static inline void e1000_pci_set_mwi(struct e1000_hw *hw)
+{
+	pci_write_config_word(hw->pdev, PCI_COMMAND, hw->pci_cmd_word);
+}
+
+static inline void e1000_pci_clear_mwi(struct e1000_hw *hw)
+{
+	pci_write_config_word(hw->pdev, PCI_COMMAND,
+			      hw->pci_cmd_word & ~PCI_COMMAND_INVALIDATE);
+}
+
+/******************************************************************************
+ * Raises the EEPROM's clock input.
+ *
+ * hw - Struct containing variables accessed by shared code
+ * eecd - EECD's current value
+ *****************************************************************************/
+static void
+e1000_raise_ee_clk(struct e1000_hw *hw,
+                   uint32_t *eecd)
+{
+	/* Raise the clock input to the EEPROM (by setting the SK bit), and then
+	 * wait <delay> microseconds.
+	 */
+	*eecd = *eecd | E1000_EECD_SK;
+	E1000_WRITE_REG(hw, EECD, *eecd);
+	E1000_WRITE_FLUSH(hw);
+	udelay(hw->eeprom.delay_usec);
+}
+
+/******************************************************************************
+ * Lowers the EEPROM's clock input.
+ *
+ * hw - Struct containing variables accessed by shared code 
+ * eecd - EECD's current value
+ *****************************************************************************/
+static void
+e1000_lower_ee_clk(struct e1000_hw *hw,
+                   uint32_t *eecd)
+{
+	/* Lower the clock input to the EEPROM (by clearing the SK bit), and then 
+	 * wait 50 microseconds. 
+	 */
+	*eecd = *eecd & ~E1000_EECD_SK;
+	E1000_WRITE_REG(hw, EECD, *eecd);
+	E1000_WRITE_FLUSH(hw);
+	udelay(hw->eeprom.delay_usec);
+}
+
+/******************************************************************************
+ * Shift data bits out to the EEPROM.
+ *
+ * hw - Struct containing variables accessed by shared code
+ * data - data to send to the EEPROM
+ * count - number of bits to shift out
+ *****************************************************************************/
+static void
+e1000_shift_out_ee_bits(struct e1000_hw *hw,
+                        uint16_t data,
+                        uint16_t count)
+{
+	struct e1000_eeprom_info *eeprom = &hw->eeprom;
+	uint32_t eecd;
+	uint32_t mask;
+	
+	/* We need to shift "count" bits out to the EEPROM. So, value in the
+	 * "data" parameter will be shifted out to the EEPROM one bit at a time.
+	 * In order to do this, "data" must be broken down into bits. 
+	 */
+	mask = 0x01 << (count - 1);
+	eecd = E1000_READ_REG(hw, EECD);
+	if (eeprom->type == e1000_eeprom_microwire) {
+		eecd &= ~E1000_EECD_DO;
+	} else if (eeprom->type == e1000_eeprom_spi) {
+		eecd |= E1000_EECD_DO;
+	}
+	do {
+		/* A "1" is shifted out to the EEPROM by setting bit "DI" to a "1",
+		 * and then raising and then lowering the clock (the SK bit controls
+		 * the clock input to the EEPROM).  A "0" is shifted out to the EEPROM
+		 * by setting "DI" to "0" and then raising and then lowering the clock.
+		 */
+		eecd &= ~E1000_EECD_DI;
+		
+		if(data & mask)
+			eecd |= E1000_EECD_DI;
+		
+		E1000_WRITE_REG(hw, EECD, eecd);
+		E1000_WRITE_FLUSH(hw);
+		
+		udelay(eeprom->delay_usec);
+		
+		e1000_raise_ee_clk(hw, &eecd);
+		e1000_lower_ee_clk(hw, &eecd);
+		
+		mask = mask >> 1;
+		
+	} while(mask);
+
+	/* We leave the "DI" bit set to "0" when we leave this routine. */
+	eecd &= ~E1000_EECD_DI;
+	E1000_WRITE_REG(hw, EECD, eecd);
+}
+
+/******************************************************************************
+ * Shift data bits in from the EEPROM
+ *
+ * hw - Struct containing variables accessed by shared code
+ *****************************************************************************/
+static uint16_t
+e1000_shift_in_ee_bits(struct e1000_hw *hw,
+                       uint16_t count)
+{
+	uint32_t eecd;
+	uint32_t i;
+	uint16_t data;
+	
+	/* In order to read a register from the EEPROM, we need to shift 'count' 
+	 * bits in from the EEPROM. Bits are "shifted in" by raising the clock
+	 * input to the EEPROM (setting the SK bit), and then reading the value of
+	 * the "DO" bit.  During this "shifting in" process the "DI" bit should
+	 * always be clear.
+	 */
+	
+	eecd = E1000_READ_REG(hw, EECD);
+	
+	eecd &= ~(E1000_EECD_DO | E1000_EECD_DI);
+	data = 0;
+	
+	for(i = 0; i < count; i++) {
+		data = data << 1;
+		e1000_raise_ee_clk(hw, &eecd);
+		
+		eecd = E1000_READ_REG(hw, EECD);
+		
+		eecd &= ~(E1000_EECD_DI);
+		if(eecd & E1000_EECD_DO)
+			data |= 1;
+		
+		e1000_lower_ee_clk(hw, &eecd);
+	}
+	
+	return data;
+}
+
+/******************************************************************************
+ * Prepares EEPROM for access
+ *
+ * hw - Struct containing variables accessed by shared code
+ *
+ * Lowers EEPROM clock. Clears input pin. Sets the chip select pin. This 
+ * function should be called before issuing a command to the EEPROM.
+ *****************************************************************************/
+static int32_t
+e1000_acquire_eeprom(struct e1000_hw *hw)
+{
+	struct e1000_eeprom_info *eeprom = &hw->eeprom;
+	uint32_t eecd, i=0;
+
+	eecd = E1000_READ_REG(hw, EECD);
+
+	/* Request EEPROM Access */
+	if(hw->mac_type > e1000_82544) {
+		eecd |= E1000_EECD_REQ;
+		E1000_WRITE_REG(hw, EECD, eecd);
+		eecd = E1000_READ_REG(hw, EECD);
+		while((!(eecd & E1000_EECD_GNT)) &&
+		      (i < E1000_EEPROM_GRANT_ATTEMPTS)) {
+			i++;
+			udelay(5);
+			eecd = E1000_READ_REG(hw, EECD);
+		}
+		if(!(eecd & E1000_EECD_GNT)) {
+			eecd &= ~E1000_EECD_REQ;
+			E1000_WRITE_REG(hw, EECD, eecd);
+			DEBUGOUT("Could not acquire EEPROM grant\n");
+			return -E1000_ERR_EEPROM;
+		}
+	}
+
+	/* Setup EEPROM for Read/Write */
+
+	if (eeprom->type == e1000_eeprom_microwire) {
+		/* Clear SK and DI */
+		eecd &= ~(E1000_EECD_DI | E1000_EECD_SK);
+		E1000_WRITE_REG(hw, EECD, eecd);
+
+		/* Set CS */
+		eecd |= E1000_EECD_CS;
+		E1000_WRITE_REG(hw, EECD, eecd);
+	} else if (eeprom->type == e1000_eeprom_spi) {
+		/* Clear SK and CS */
+		eecd &= ~(E1000_EECD_CS | E1000_EECD_SK);
+		E1000_WRITE_REG(hw, EECD, eecd);
+		udelay(1);
+	}
+
+	return E1000_SUCCESS;
+}
+
+/******************************************************************************
+ * Returns EEPROM to a "standby" state
+ * 
+ * hw - Struct containing variables accessed by shared code
+ *****************************************************************************/
+static void
+e1000_standby_eeprom(struct e1000_hw *hw)
+{
+	struct e1000_eeprom_info *eeprom = &hw->eeprom;
+	uint32_t eecd;
+	
+	eecd = E1000_READ_REG(hw, EECD);
+
+	if(eeprom->type == e1000_eeprom_microwire) {
+
+		/* Deselect EEPROM */
+		eecd &= ~(E1000_EECD_CS | E1000_EECD_SK);
+		E1000_WRITE_REG(hw, EECD, eecd);
+		E1000_WRITE_FLUSH(hw);
+		udelay(eeprom->delay_usec);
+	
+		/* Clock high */
+		eecd |= E1000_EECD_SK;
+		E1000_WRITE_REG(hw, EECD, eecd);
+		E1000_WRITE_FLUSH(hw);
+		udelay(eeprom->delay_usec);
+	
+		/* Select EEPROM */
+		eecd |= E1000_EECD_CS;
+		E1000_WRITE_REG(hw, EECD, eecd);
+		E1000_WRITE_FLUSH(hw);
+		udelay(eeprom->delay_usec);
+
+		/* Clock low */
+		eecd &= ~E1000_EECD_SK;
+		E1000_WRITE_REG(hw, EECD, eecd);
+		E1000_WRITE_FLUSH(hw);
+		udelay(eeprom->delay_usec);
+	} else if(eeprom->type == e1000_eeprom_spi) {
+		/* Toggle CS to flush commands */
+		eecd |= E1000_EECD_CS;
+		E1000_WRITE_REG(hw, EECD, eecd);
+		E1000_WRITE_FLUSH(hw);
+		udelay(eeprom->delay_usec);
+		eecd &= ~E1000_EECD_CS;
+		E1000_WRITE_REG(hw, EECD, eecd);
+		E1000_WRITE_FLUSH(hw);
+		udelay(eeprom->delay_usec);
+	}
+}
+
+/******************************************************************************
+ * Terminates a command by inverting the EEPROM's chip select pin
+ *
+ * hw - Struct containing variables accessed by shared code
+ *****************************************************************************/
+static void
+e1000_release_eeprom(struct e1000_hw *hw)
+{
+	uint32_t eecd;
+
+	eecd = E1000_READ_REG(hw, EECD);
+
+	if (hw->eeprom.type == e1000_eeprom_spi) {
+		eecd |= E1000_EECD_CS;  /* Pull CS high */
+		eecd &= ~E1000_EECD_SK; /* Lower SCK */
+
+		E1000_WRITE_REG(hw, EECD, eecd);
+
+		udelay(hw->eeprom.delay_usec);
+	} else if(hw->eeprom.type == e1000_eeprom_microwire) {
+		/* cleanup eeprom */
+
+		/* CS on Microwire is active-high */
+		eecd &= ~(E1000_EECD_CS | E1000_EECD_DI);
+
+		E1000_WRITE_REG(hw, EECD, eecd);
+
+		/* Rising edge of clock */
+		eecd |= E1000_EECD_SK;
+		E1000_WRITE_REG(hw, EECD, eecd);
+		E1000_WRITE_FLUSH(hw);
+		udelay(hw->eeprom.delay_usec);
+
+		/* Falling edge of clock */
+		eecd &= ~E1000_EECD_SK;
+		E1000_WRITE_REG(hw, EECD, eecd);
+		E1000_WRITE_FLUSH(hw);
+		udelay(hw->eeprom.delay_usec);
+	}
+
+	/* Stop requesting EEPROM access */
+	if(hw->mac_type > e1000_82544) {
+		eecd &= ~E1000_EECD_REQ;
+		E1000_WRITE_REG(hw, EECD, eecd);
+	}
+}
+
+/******************************************************************************
+ * Reads a 16 bit word from the EEPROM.
+ *
+ * hw - Struct containing variables accessed by shared code
+ *****************************************************************************/
+static int32_t
+e1000_spi_eeprom_ready(struct e1000_hw *hw)
+{
+	uint16_t retry_count = 0;
+	uint8_t spi_stat_reg;
+
+	/* Read "Status Register" repeatedly until the LSB is cleared.  The
+	 * EEPROM will signal that the command has been completed by clearing
+	 * bit 0 of the internal status register.  If it's not cleared within
+	 * 5 milliseconds, then error out.
+	 */
+	retry_count = 0;
+	do {
+		e1000_shift_out_ee_bits(hw, EEPROM_RDSR_OPCODE_SPI,
+		hw->eeprom.opcode_bits);
+		spi_stat_reg = (uint8_t)e1000_shift_in_ee_bits(hw, 8);
+		if (!(spi_stat_reg & EEPROM_STATUS_RDY_SPI))
+			break;
+
+		udelay(5);
+		retry_count += 5;
+
+	} while(retry_count < EEPROM_MAX_RETRY_SPI);
+
+	/* ATMEL SPI write time could vary from 0-20mSec on 3.3V devices (and
+	 * only 0-5mSec on 5V devices)
+	 */
+	if(retry_count >= EEPROM_MAX_RETRY_SPI) {
+		DEBUGOUT("SPI EEPROM Status error\n");
+		return -E1000_ERR_EEPROM;
+	}
+
+	return E1000_SUCCESS;
+}
+
+/******************************************************************************
+ * Reads a 16 bit word from the EEPROM.
+ *
+ * hw - Struct containing variables accessed by shared code
+ * offset - offset of  word in the EEPROM to read
+ * data - word read from the EEPROM
+ * words - number of words to read
+ *****************************************************************************/
+static int
+e1000_read_eeprom(struct e1000_hw *hw,
+                  uint16_t offset,
+		  uint16_t words,
+                  uint16_t *data)
+{
+	struct e1000_eeprom_info *eeprom = &hw->eeprom;
+	uint32_t i = 0;
+	
+	DEBUGFUNC("e1000_read_eeprom");
+
+	/* A check for invalid values:  offset too large, too many words, and not
+	 * enough words.
+	 */
+	if((offset > eeprom->word_size) || (words > eeprom->word_size - offset) ||
+	   (words == 0)) {
+		DEBUGOUT("\"words\" parameter out of bounds\n");
+		return -E1000_ERR_EEPROM;
+	}
+
+	/*  Prepare the EEPROM for reading  */
+	if(e1000_acquire_eeprom(hw) != E1000_SUCCESS)
+		return -E1000_ERR_EEPROM;
+
+	if(eeprom->type == e1000_eeprom_spi) {
+		uint16_t word_in;
+		uint8_t read_opcode = EEPROM_READ_OPCODE_SPI;
+
+		if(e1000_spi_eeprom_ready(hw)) {
+			e1000_release_eeprom(hw);
+			return -E1000_ERR_EEPROM;
+		}
+
+		e1000_standby_eeprom(hw);
+
+		/* Some SPI eeproms use the 8th address bit embedded in the opcode */
+		if((eeprom->address_bits == 8) && (offset >= 128))
+			read_opcode |= EEPROM_A8_OPCODE_SPI;
+
+		/* Send the READ command (opcode + addr)  */
+		e1000_shift_out_ee_bits(hw, read_opcode, eeprom->opcode_bits);
+		e1000_shift_out_ee_bits(hw, (uint16_t)(offset*2), eeprom->address_bits);
+
+		/* Read the data.  The address of the eeprom internally increments with
+		 * each byte (spi) being read, saving on the overhead of eeprom setup
+		 * and tear-down.  The address counter will roll over if reading beyond
+		 * the size of the eeprom, thus allowing the entire memory to be read
+		 * starting from any offset. */
+		for (i = 0; i < words; i++) {
+			word_in = e1000_shift_in_ee_bits(hw, 16);
+			data[i] = (word_in >> 8) | (word_in << 8);
+		}
+	} else if(eeprom->type == e1000_eeprom_microwire) {
+		for (i = 0; i < words; i++) {
+			/*  Send the READ command (opcode + addr)  */
+			e1000_shift_out_ee_bits(hw, EEPROM_READ_OPCODE_MICROWIRE,
+						eeprom->opcode_bits);
+			e1000_shift_out_ee_bits(hw, (uint16_t)(offset + i),
+			                        eeprom->address_bits);
+
+			/* Read the data.  For microwire, each word requires the overhead
+			 * of eeprom setup and tear-down. */
+			data[i] = e1000_shift_in_ee_bits(hw, 16);
+			e1000_standby_eeprom(hw);
+		}
+	}
+
+	/* End this read operation */
+	e1000_release_eeprom(hw);
+
+	return E1000_SUCCESS;
+}
+
+/******************************************************************************
+ * Verifies that the EEPROM has a valid checksum
+ * 
+ * hw - Struct containing variables accessed by shared code
+ *
+ * Reads the first 64 16 bit words of the EEPROM and sums the values read.
+ * If the the sum of the 64 16 bit words is 0xBABA, the EEPROM's checksum is
+ * valid.
+ *****************************************************************************/
+static int
+e1000_validate_eeprom_checksum(struct e1000_hw *hw)
+{
+	uint16_t checksum = 0;
+	uint16_t i, eeprom_data;
+
+	DEBUGFUNC("e1000_validate_eeprom_checksum");
+
+	for(i = 0; i < (EEPROM_CHECKSUM_REG + 1); i++) {
+		if(e1000_read_eeprom(hw, i, 1, &eeprom_data) < 0) {
+			DEBUGOUT("EEPROM Read Error\n");
+			return -E1000_ERR_EEPROM;
+		}
+		checksum += eeprom_data;
+	}
+	
+	if(checksum == (uint16_t) EEPROM_SUM)
+		return E1000_SUCCESS;
+	else {
+		DEBUGOUT("EEPROM Checksum Invalid\n");    
+		return -E1000_ERR_EEPROM;
+	}
+}
+
+/******************************************************************************
+ * Reads the adapter's MAC address from the EEPROM and inverts the LSB for the
+ * second function of dual function devices
+ *
+ * hw - Struct containing variables accessed by shared code
+ *****************************************************************************/
+static int 
+e1000_read_mac_addr(struct e1000_hw *hw)
+{
+	uint16_t offset;
+	uint16_t eeprom_data;
+	int i;
+
+	DEBUGFUNC("e1000_read_mac_addr");
+
+	for(i = 0; i < NODE_ADDRESS_SIZE; i += 2) {
+		offset = i >> 1;
+		if(e1000_read_eeprom(hw, offset, 1, &eeprom_data) < 0) {
+			DEBUGOUT("EEPROM Read Error\n");
+			return -E1000_ERR_EEPROM;
+		}
+		hw->mac_addr[i] = eeprom_data & 0xff;
+		hw->mac_addr[i+1] = (eeprom_data >> 8) & 0xff;
+	}
+	if(((hw->mac_type == e1000_82546) || (hw->mac_type == e1000_82546_rev_3)) &&
+		(E1000_READ_REG(hw, STATUS) & E1000_STATUS_FUNC_1))
+		/* Invert the last bit if this is the second device */
+		hw->mac_addr[5] ^= 1;
+	return E1000_SUCCESS;
+}
+
+/******************************************************************************
+ * Initializes receive address filters.
+ *
+ * hw - Struct containing variables accessed by shared code 
+ *
+ * Places the MAC address in receive address register 0 and clears the rest
+ * of the receive addresss registers. Clears the multicast table. Assumes
+ * the receiver is in reset when the routine is called.
+ *****************************************************************************/
+static void
+e1000_init_rx_addrs(struct e1000_hw *hw)
+{
+	uint32_t i;
+	uint32_t addr_low;
+	uint32_t addr_high;
+	
+	DEBUGFUNC("e1000_init_rx_addrs");
+	
+	/* Setup the receive address. */
+	DEBUGOUT("Programming MAC Address into RAR[0]\n");
+	addr_low = (hw->mac_addr[0] |
+		(hw->mac_addr[1] << 8) |
+		(hw->mac_addr[2] << 16) | (hw->mac_addr[3] << 24));
+	
+	addr_high = (hw->mac_addr[4] |
+		(hw->mac_addr[5] << 8) | E1000_RAH_AV);
+	
+	E1000_WRITE_REG_ARRAY(hw, RA, 0, addr_low);
+	E1000_WRITE_REG_ARRAY(hw, RA, 1, addr_high);
+	
+	/* Zero out the other 15 receive addresses. */
+	DEBUGOUT("Clearing RAR[1-15]\n");
+	for(i = 1; i < E1000_RAR_ENTRIES; i++) {
+		E1000_WRITE_REG_ARRAY(hw, RA, (i << 1), 0);
+		E1000_WRITE_REG_ARRAY(hw, RA, ((i << 1) + 1), 0);
+	}
+}
+
+/******************************************************************************
+ * Clears the VLAN filer table
+ *
+ * hw - Struct containing variables accessed by shared code
+ *****************************************************************************/
+static void
+e1000_clear_vfta(struct e1000_hw *hw)
+{
+	uint32_t offset;
+    
+	for(offset = 0; offset < E1000_VLAN_FILTER_TBL_SIZE; offset++)
+		E1000_WRITE_REG_ARRAY(hw, VFTA, offset, 0);
+}
+
+/******************************************************************************
+* Writes a value to one of the devices registers using port I/O (as opposed to
+* memory mapped I/O). Only 82544 and newer devices support port I/O. *
+* hw - Struct containing variables accessed by shared code
+* offset - offset to write to * value - value to write
+*****************************************************************************/
+void e1000_write_reg_io(struct e1000_hw *hw, uint32_t offset, uint32_t value){
+	uint32_t io_addr = hw->io_base;
+	uint32_t io_data = hw->io_base + 4;
+	e1000_io_write(hw, io_addr, offset);
+	e1000_io_write(hw, io_data, value);
+}
+
+/******************************************************************************
+ * Set the phy type member in the hw struct.
+ *
+ * hw - Struct containing variables accessed by shared code
+ *****************************************************************************/
+static int32_t
+e1000_set_phy_type(struct e1000_hw *hw)
+{
+	DEBUGFUNC("e1000_set_phy_type");
+
+	switch(hw->phy_id) {
+	case M88E1000_E_PHY_ID:
+	case M88E1000_I_PHY_ID:
+	case M88E1011_I_PHY_ID:
+		hw->phy_type = e1000_phy_m88;
+		break;
+	case IGP01E1000_I_PHY_ID:
+		hw->phy_type = e1000_phy_igp;
+		break;
+	default:
+		/* Should never have loaded on this device */
+		hw->phy_type = e1000_phy_undefined;
+		return -E1000_ERR_PHY_TYPE;
+	}
+
+	return E1000_SUCCESS;
+}
+
+/******************************************************************************
+ * IGP phy init script - initializes the GbE PHY
+ *
+ * hw - Struct containing variables accessed by shared code
+ *****************************************************************************/
+static void
+e1000_phy_init_script(struct e1000_hw *hw)
+{
+	DEBUGFUNC("e1000_phy_init_script");
+
+#if 0
+	/* See e1000_sw_init() of the Linux driver */
+	if(hw->phy_init_script) {
+#else
+	if((hw->mac_type == e1000_82541) ||
+	   (hw->mac_type == e1000_82547) ||
+	   (hw->mac_type == e1000_82541_rev_2) ||
+	   (hw->mac_type == e1000_82547_rev_2)) {
+#endif
+		mdelay(20);
+
+		e1000_write_phy_reg(hw,0x0000,0x0140);
+
+		mdelay(5);
+
+		if(hw->mac_type == e1000_82541 || hw->mac_type == e1000_82547) {
+			e1000_write_phy_reg(hw, 0x1F95, 0x0001);
+
+			e1000_write_phy_reg(hw, 0x1F71, 0xBD21);
+
+			e1000_write_phy_reg(hw, 0x1F79, 0x0018);
+
+			e1000_write_phy_reg(hw, 0x1F30, 0x1600);
+
+			e1000_write_phy_reg(hw, 0x1F31, 0x0014);
+
+			e1000_write_phy_reg(hw, 0x1F32, 0x161C);
+
+			e1000_write_phy_reg(hw, 0x1F94, 0x0003);
+
+			e1000_write_phy_reg(hw, 0x1F96, 0x003F);
+
+			e1000_write_phy_reg(hw, 0x2010, 0x0008);
+		} else {
+			e1000_write_phy_reg(hw, 0x1F73, 0x0099);
+		}
+
+		e1000_write_phy_reg(hw, 0x0000, 0x3300);
+
+
+		if(hw->mac_type == e1000_82547) {
+			uint16_t fused, fine, coarse;
+
+			/* Move to analog registers page */
+			e1000_read_phy_reg(hw, IGP01E1000_ANALOG_SPARE_FUSE_STATUS, &fused);
+
+			if(!(fused & IGP01E1000_ANALOG_SPARE_FUSE_ENABLED)) {
+				e1000_read_phy_reg(hw, IGP01E1000_ANALOG_FUSE_STATUS, &fused);
+
+				fine = fused & IGP01E1000_ANALOG_FUSE_FINE_MASK;
+				coarse = fused & IGP01E1000_ANALOG_FUSE_COARSE_MASK;
+
+				if(coarse > IGP01E1000_ANALOG_FUSE_COARSE_THRESH) {
+					coarse -= IGP01E1000_ANALOG_FUSE_COARSE_10;
+					fine -= IGP01E1000_ANALOG_FUSE_FINE_1;
+				} else if(coarse == IGP01E1000_ANALOG_FUSE_COARSE_THRESH)
+					fine -= IGP01E1000_ANALOG_FUSE_FINE_10;
+
+				fused = (fused & IGP01E1000_ANALOG_FUSE_POLY_MASK) |
+					(fine & IGP01E1000_ANALOG_FUSE_FINE_MASK) |
+					(coarse & IGP01E1000_ANALOG_FUSE_COARSE_MASK);
+
+				e1000_write_phy_reg(hw, IGP01E1000_ANALOG_FUSE_CONTROL, fused);
+				e1000_write_phy_reg(hw, IGP01E1000_ANALOG_FUSE_BYPASS,
+						IGP01E1000_ANALOG_FUSE_ENABLE_SW_CONTROL);
+			}
+		}
+	}
+}
+
+/******************************************************************************
+ * Set the mac type member in the hw struct.
+ * 
+ * hw - Struct containing variables accessed by shared code
+ *****************************************************************************/
+static int
+e1000_set_mac_type(struct e1000_hw *hw)
+{
+	DEBUGFUNC("e1000_set_mac_type");
+
+	switch (hw->device_id) {
+	case E1000_DEV_ID_82542:
+		switch (hw->revision_id) {
+		case E1000_82542_2_0_REV_ID:
+			hw->mac_type = e1000_82542_rev2_0;
+			break;
+		case E1000_82542_2_1_REV_ID:
+			hw->mac_type = e1000_82542_rev2_1;
+			break;
+		default:
+			/* Invalid 82542 revision ID */
+			return -E1000_ERR_MAC_TYPE;
+		}
+		break;
+	case E1000_DEV_ID_82543GC_FIBER:
+	case E1000_DEV_ID_82543GC_COPPER:
+		hw->mac_type = e1000_82543;
+		break;
+	case E1000_DEV_ID_82544EI_COPPER:
+	case E1000_DEV_ID_82544EI_FIBER:
+	case E1000_DEV_ID_82544GC_COPPER:
+	case E1000_DEV_ID_82544GC_LOM:
+		hw->mac_type = e1000_82544;
+		break;
+	case E1000_DEV_ID_82540EM:
+	case E1000_DEV_ID_82540EM_LOM:
+	case E1000_DEV_ID_82540EP:
+	case E1000_DEV_ID_82540EP_LOM:
+	case E1000_DEV_ID_82540EP_LP:
+		hw->mac_type = e1000_82540;
+		break;
+	case E1000_DEV_ID_82545EM_COPPER:
+	case E1000_DEV_ID_82545EM_FIBER:
+		hw->mac_type = e1000_82545;
+		break;
+	case E1000_DEV_ID_82545GM_COPPER:
+	case E1000_DEV_ID_82545GM_FIBER:
+	case E1000_DEV_ID_82545GM_SERDES:
+		hw->mac_type = e1000_82545_rev_3;
+		break;
+	case E1000_DEV_ID_82546EB_COPPER:
+	case E1000_DEV_ID_82546EB_FIBER:
+	case E1000_DEV_ID_82546EB_QUAD_COPPER:
+		hw->mac_type = e1000_82546;
+		break;
+	case E1000_DEV_ID_82546GB_COPPER:
+	case E1000_DEV_ID_82546GB_FIBER:
+	case E1000_DEV_ID_82546GB_SERDES:
+		hw->mac_type = e1000_82546_rev_3;
+		break;
+	case E1000_DEV_ID_82541EI:
+	case E1000_DEV_ID_82541EI_MOBILE:
+		hw->mac_type = e1000_82541;
+		break;
+	case E1000_DEV_ID_82541ER:
+	case E1000_DEV_ID_82541GI:
+	case E1000_DEV_ID_82541GI_MOBILE:
+		hw->mac_type = e1000_82541_rev_2;
+		break;
+	case E1000_DEV_ID_82547EI:
+		hw->mac_type = e1000_82547;
+		break;
+	case E1000_DEV_ID_82547GI:
+		hw->mac_type = e1000_82547_rev_2;
+		break;
+	default:
+		/* Should never have loaded on this device */
+		return -E1000_ERR_MAC_TYPE;
+	}
+
+	return E1000_SUCCESS;
+}
+
+/*****************************************************************************
+ * Set media type and TBI compatibility.
+ *
+ * hw - Struct containing variables accessed by shared code
+ * **************************************************************************/
+static void
+e1000_set_media_type(struct e1000_hw *hw)
+{
+	uint32_t status;
+
+	DEBUGFUNC("e1000_set_media_type");
+	
+	if(hw->mac_type != e1000_82543) {
+		/* tbi_compatibility is only valid on 82543 */
+		hw->tbi_compatibility_en = FALSE;
+	}
+
+	switch (hw->device_id) {
+		case E1000_DEV_ID_82545GM_SERDES:
+		case E1000_DEV_ID_82546GB_SERDES:
+			hw->media_type = e1000_media_type_internal_serdes;
+			break;
+		default:
+			if(hw->mac_type >= e1000_82543) {
+				status = E1000_READ_REG(hw, STATUS);
+				if(status & E1000_STATUS_TBIMODE) {
+					hw->media_type = e1000_media_type_fiber;
+					/* tbi_compatibility not valid on fiber */
+					hw->tbi_compatibility_en = FALSE;
+				} else {
+					hw->media_type = e1000_media_type_copper;
+				}
+			} else {
+				/* This is an 82542 (fiber only) */
+				hw->media_type = e1000_media_type_fiber;
+			}
+	}
+}
+
+/******************************************************************************
+ * Reset the transmit and receive units; mask and clear all interrupts.
+ *
+ * hw - Struct containing variables accessed by shared code
+ *****************************************************************************/
+static void
+e1000_reset_hw(struct e1000_hw *hw)
+{
+	uint32_t ctrl;
+	uint32_t ctrl_ext;
+	uint32_t icr;
+	uint32_t manc;
+	
+	DEBUGFUNC("e1000_reset_hw");
+	
+	/* For 82542 (rev 2.0), disable MWI before issuing a device reset */
+	if(hw->mac_type == e1000_82542_rev2_0) {
+		DEBUGOUT("Disabling MWI on 82542 rev 2.0\n");
+		e1000_pci_clear_mwi(hw);
+	}
+
+	/* Clear interrupt mask to stop board from generating interrupts */
+	DEBUGOUT("Masking off all interrupts\n");
+	E1000_WRITE_REG(hw, IMC, 0xffffffff);
+	
+	/* Disable the Transmit and Receive units.  Then delay to allow
+	 * any pending transactions to complete before we hit the MAC with
+	 * the global reset.
+	 */
+	E1000_WRITE_REG(hw, RCTL, 0);
+	E1000_WRITE_REG(hw, TCTL, E1000_TCTL_PSP);
+	E1000_WRITE_FLUSH(hw);
+
+	/* The tbi_compatibility_on Flag must be cleared when Rctl is cleared. */
+	hw->tbi_compatibility_on = FALSE;
+
+	/* Delay to allow any outstanding PCI transactions to complete before
+	 * resetting the device
+	 */ 
+	mdelay(10);
+
+	ctrl = E1000_READ_REG(hw, CTRL);
+
+	/* Must reset the PHY before resetting the MAC */
+	if((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547)) {
+		E1000_WRITE_REG_IO(hw, CTRL, (ctrl | E1000_CTRL_PHY_RST));
+		mdelay(5);
+	}
+
+	/* Issue a global reset to the MAC.  This will reset the chip's
+	 * transmit, receive, DMA, and link units.  It will not effect
+	 * the current PCI configuration.  The global reset bit is self-
+	 * clearing, and should clear within a microsecond.
+	 */
+	DEBUGOUT("Issuing a global reset to MAC\n");
+
+	switch(hw->mac_type) {
+		case e1000_82544:
+		case e1000_82540:
+		case e1000_82545:
+		case e1000_82546:
+		case e1000_82541:
+		case e1000_82541_rev_2:
+			/* These controllers can't ack the 64-bit write when issuing the
+			 * reset, so use IO-mapping as a workaround to issue the reset */
+			E1000_WRITE_REG_IO(hw, CTRL, (ctrl | E1000_CTRL_RST));
+			break;
+		case e1000_82545_rev_3:
+		case e1000_82546_rev_3:
+			/* Reset is performed on a shadow of the control register */
+			E1000_WRITE_REG(hw, CTRL_DUP, (ctrl | E1000_CTRL_RST));
+			break;
+		default:
+			E1000_WRITE_REG(hw, CTRL, (ctrl | E1000_CTRL_RST));
+			break;
+	}
+
+	/* After MAC reset, force reload of EEPROM to restore power-on settings to
+	 * device.  Later controllers reload the EEPROM automatically, so just wait
+	 * for reload to complete.
+	 */
+	switch(hw->mac_type) {
+		case e1000_82542_rev2_0:
+		case e1000_82542_rev2_1:
+		case e1000_82543:
+		case e1000_82544:
+			/* Wait for reset to complete */
+			udelay(10);
+			ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);
+			ctrl_ext |= E1000_CTRL_EXT_EE_RST;
+			E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
+			E1000_WRITE_FLUSH(hw);
+			/* Wait for EEPROM reload */
+			mdelay(2);
+			break;
+		case e1000_82541:
+		case e1000_82541_rev_2:
+		case e1000_82547:
+		case e1000_82547_rev_2:
+			/* Wait for EEPROM reload */
+			mdelay(20);
+			break;
+		default:
+			/* Wait for EEPROM reload (it happens automatically) */
+			mdelay(5);
+			break;
+	}
+
+	/* Disable HW ARPs on ASF enabled adapters */
+	if(hw->mac_type >= e1000_82540) {
+		manc = E1000_READ_REG(hw, MANC);
+		manc &= ~(E1000_MANC_ARP_EN);
+		E1000_WRITE_REG(hw, MANC, manc);
+	}
+
+	if((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547)) {
+		e1000_phy_init_script(hw);
+	}
+
+	/* Clear interrupt mask to stop board from generating interrupts */
+	DEBUGOUT("Masking off all interrupts\n");
+	E1000_WRITE_REG(hw, IMC, 0xffffffff);
+	
+	/* Clear any pending interrupt events. */
+	icr = E1000_READ_REG(hw, ICR);
+
+	/* If MWI was previously enabled, reenable it. */
+	if(hw->mac_type == e1000_82542_rev2_0) {
+#ifdef LINUX_DRIVER
+		if(hw->pci_cmd_word & CMD_MEM_WRT_INVALIDATE)
+#endif
+			e1000_pci_set_mwi(hw);
+	}
+}
+
+/******************************************************************************
+ * Performs basic configuration of the adapter.
+ *
+ * hw - Struct containing variables accessed by shared code
+ * 
+ * Assumes that the controller has previously been reset and is in a 
+ * post-reset uninitialized state. Initializes the receive address registers,
+ * multicast table, and VLAN filter table. Calls routines to setup link
+ * configuration and flow control settings. Clears all on-chip counters. Leaves
+ * the transmit and receive units disabled and uninitialized.
+ *****************************************************************************/
+static int
+e1000_init_hw(struct e1000_hw *hw)
+{
+	uint32_t ctrl, status;
+	uint32_t i;
+	int32_t ret_val;
+	uint16_t pcix_cmd_word;
+	uint16_t pcix_stat_hi_word;
+	uint16_t cmd_mmrbc;
+	uint16_t stat_mmrbc;
+	e1000_bus_type bus_type = e1000_bus_type_unknown;
+
+	DEBUGFUNC("e1000_init_hw");
+
+	/* Set the media type and TBI compatibility */
+	e1000_set_media_type(hw);
+
+	/* Disabling VLAN filtering. */
+	DEBUGOUT("Initializing the IEEE VLAN\n");
+	E1000_WRITE_REG(hw, VET, 0);
+	
+	e1000_clear_vfta(hw);
+	
+	/* For 82542 (rev 2.0), disable MWI and put the receiver into reset */
+	if(hw->mac_type == e1000_82542_rev2_0) {
+		DEBUGOUT("Disabling MWI on 82542 rev 2.0\n");
+		e1000_pci_clear_mwi(hw);
+		E1000_WRITE_REG(hw, RCTL, E1000_RCTL_RST);
+		E1000_WRITE_FLUSH(hw);
+		mdelay(5);
+	}
+	
+	/* Setup the receive address. This involves initializing all of the Receive
+	 * Address Registers (RARs 0 - 15).
+	 */
+	e1000_init_rx_addrs(hw);
+	
+	/* For 82542 (rev 2.0), take the receiver out of reset and enable MWI */
+	if(hw->mac_type == e1000_82542_rev2_0) {
+		E1000_WRITE_REG(hw, RCTL, 0);
+		E1000_WRITE_FLUSH(hw);
+		mdelay(1);
+#ifdef LINUX_DRIVER
+		if(hw->pci_cmd_word & CMD_MEM_WRT_INVALIDATE)
+#endif
+			e1000_pci_set_mwi(hw);
+	}
+	
+	/* Zero out the Multicast HASH table */
+	DEBUGOUT("Zeroing the MTA\n");
+	for(i = 0; i < E1000_MC_TBL_SIZE; i++)
+		E1000_WRITE_REG_ARRAY(hw, MTA, i, 0);
+	
+#if 0
+	/* Set the PCI priority bit correctly in the CTRL register.  This
+	 * determines if the adapter gives priority to receives, or if it
+	 * gives equal priority to transmits and receives.
+	 */
+	if(hw->dma_fairness) {
+		ctrl = E1000_READ_REG(hw, CTRL);
+		E1000_WRITE_REG(hw, CTRL, ctrl | E1000_CTRL_PRIOR);
+	}
+#endif
+
+	switch(hw->mac_type) {
+		case e1000_82545_rev_3:
+		case e1000_82546_rev_3:
+			break;
+		default:
+			if (hw->mac_type >= e1000_82543) {
+				/* See e1000_get_bus_info() of the Linux driver */
+				status = E1000_READ_REG(hw, STATUS);
+				bus_type = (status & E1000_STATUS_PCIX_MODE) ?
+					e1000_bus_type_pcix : e1000_bus_type_pci;
+			}
+
+			/* Workaround for PCI-X problem when BIOS sets MMRBC incorrectly. */
+			if(bus_type == e1000_bus_type_pcix) {
+				pci_read_config_word(hw->pdev, PCIX_COMMAND_REGISTER, &pcix_cmd_word);
+				pci_read_config_word(hw->pdev, PCIX_STATUS_REGISTER_HI, &pcix_stat_hi_word);
+				cmd_mmrbc = (pcix_cmd_word & PCIX_COMMAND_MMRBC_MASK) >>
+					PCIX_COMMAND_MMRBC_SHIFT;
+				stat_mmrbc = (pcix_stat_hi_word & PCIX_STATUS_HI_MMRBC_MASK) >>
+					PCIX_STATUS_HI_MMRBC_SHIFT;
+				if(stat_mmrbc == PCIX_STATUS_HI_MMRBC_4K)
+					stat_mmrbc = PCIX_STATUS_HI_MMRBC_2K;
+				if(cmd_mmrbc > stat_mmrbc) {
+					pcix_cmd_word &= ~PCIX_COMMAND_MMRBC_MASK;
+					pcix_cmd_word |= stat_mmrbc << PCIX_COMMAND_MMRBC_SHIFT;
+					pci_write_config_word(hw->pdev, PCIX_COMMAND_REGISTER, pcix_cmd_word);
+				}
+			}
+			break;
+	}
+
+	/* Call a subroutine to configure the link and setup flow control. */
+	ret_val = e1000_setup_link(hw);
+	
+	/* Set the transmit descriptor write-back policy */
+	if(hw->mac_type > e1000_82544) {
+		ctrl = E1000_READ_REG(hw, TXDCTL);
+		ctrl = (ctrl & ~E1000_TXDCTL_WTHRESH) | E1000_TXDCTL_FULL_TX_DESC_WB;
+		E1000_WRITE_REG(hw, TXDCTL, ctrl);
+	}
+
+#if 0
+	/* Clear all of the statistics registers (clear on read).  It is
+	 * important that we do this after we have tried to establish link
+	 * because the symbol error count will increment wildly if there
+	 * is no link.
+	 */
+	e1000_clear_hw_cntrs(hw);
+#endif
+
+	return ret_val;
+}
+
+/******************************************************************************
+ * Adjust SERDES output amplitude based on EEPROM setting.
+ *
+ * hw - Struct containing variables accessed by shared code.
+ *****************************************************************************/
+static int32_t
+e1000_adjust_serdes_amplitude(struct e1000_hw *hw)
+{
+	uint16_t eeprom_data;
+	int32_t  ret_val;
+
+	DEBUGFUNC("e1000_adjust_serdes_amplitude");
+
+	if(hw->media_type != e1000_media_type_internal_serdes)
+		return E1000_SUCCESS;
+
+	switch(hw->mac_type) {
+		case e1000_82545_rev_3:
+		case e1000_82546_rev_3:
+			break;
+		default:
+			return E1000_SUCCESS;
+	}
+
+	if ((ret_val = e1000_read_eeprom(hw, EEPROM_SERDES_AMPLITUDE, 1,
+					&eeprom_data))) {
+		return ret_val;
+	}
+
+	if(eeprom_data != EEPROM_RESERVED_WORD) {
+		/* Adjust SERDES output amplitude only. */
+		eeprom_data &= EEPROM_SERDES_AMPLITUDE_MASK;
+		if((ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_EXT_CTRL,
+		                                  eeprom_data)))
+			return ret_val;
+	}
+
+	return E1000_SUCCESS;
+}
+								   
+/******************************************************************************
+ * Configures flow control and link settings.
+ * 
+ * hw - Struct containing variables accessed by shared code
+ * 
+ * Determines which flow control settings to use. Calls the apropriate media-
+ * specific link configuration function. Configures the flow control settings.
+ * Assuming the adapter has a valid link partner, a valid link should be
+ * established. Assumes the hardware has previously been reset and the 
+ * transmitter and receiver are not enabled.
+ *****************************************************************************/
+static int
+e1000_setup_link(struct e1000_hw *hw)
+{
+	uint32_t ctrl_ext;
+	int32_t ret_val;
+	uint16_t eeprom_data;
+
+	DEBUGFUNC("e1000_setup_link");
+	
+	/* Read and store word 0x0F of the EEPROM. This word contains bits
+	 * that determine the hardware's default PAUSE (flow control) mode,
+	 * a bit that determines whether the HW defaults to enabling or
+	 * disabling auto-negotiation, and the direction of the
+	 * SW defined pins. If there is no SW over-ride of the flow
+	 * control setting, then the variable hw->fc will
+	 * be initialized based on a value in the EEPROM.
+	 */
+	if(e1000_read_eeprom(hw, EEPROM_INIT_CONTROL2_REG, 1, &eeprom_data) < 0) {
+		DEBUGOUT("EEPROM Read Error\n");
+		return -E1000_ERR_EEPROM;
+	}
+	
+	if(hw->fc == e1000_fc_default) {
+		if((eeprom_data & EEPROM_WORD0F_PAUSE_MASK) == 0)
+			hw->fc = e1000_fc_none;
+		else if((eeprom_data & EEPROM_WORD0F_PAUSE_MASK) == 
+			EEPROM_WORD0F_ASM_DIR)
+			hw->fc = e1000_fc_tx_pause;
+		else
+			hw->fc = e1000_fc_full;
+	}
+	
+	/* We want to save off the original Flow Control configuration just
+	 * in case we get disconnected and then reconnected into a different
+	 * hub or switch with different Flow Control capabilities.
+	 */
+	if(hw->mac_type == e1000_82542_rev2_0)
+		hw->fc &= (~e1000_fc_tx_pause);
+
+#if 0
+	/* See e1000_sw_init() of the Linux driver */
+	if((hw->mac_type < e1000_82543) && (hw->report_tx_early == 1))
+#else
+	if((hw->mac_type < e1000_82543) && (hw->mac_type >= e1000_82543))
+#endif
+		hw->fc &= (~e1000_fc_rx_pause);
+	
+#if 0
+	hw->original_fc = hw->fc;
+#endif
+
+	DEBUGOUT1("After fix-ups FlowControl is now = %x\n", hw->fc);
+	
+	/* Take the 4 bits from EEPROM word 0x0F that determine the initial
+	 * polarity value for the SW controlled pins, and setup the
+	 * Extended Device Control reg with that info.
+	 * This is needed because one of the SW controlled pins is used for
+	 * signal detection.  So this should be done before e1000_setup_pcs_link()
+	 * or e1000_phy_setup() is called.
+	 */
+	if(hw->mac_type == e1000_82543) {
+		ctrl_ext = ((eeprom_data & EEPROM_WORD0F_SWPDIO_EXT) << 
+			SWDPIO__EXT_SHIFT);
+		E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
+	}
+	
+	/* Call the necessary subroutine to configure the link. */
+	ret_val = (hw->media_type == e1000_media_type_copper) ?
+		e1000_setup_copper_link(hw) :
+		e1000_setup_fiber_serdes_link(hw);
+	if (ret_val < 0) {
+		return ret_val;
+	}
+	
+	/* Initialize the flow control address, type, and PAUSE timer
+	 * registers to their default values.  This is done even if flow
+	 * control is disabled, because it does not hurt anything to
+	 * initialize these registers.
+	 */
+	DEBUGOUT("Initializing the Flow Control address, type and timer regs\n");
+	
+	E1000_WRITE_REG(hw, FCAL, FLOW_CONTROL_ADDRESS_LOW);
+	E1000_WRITE_REG(hw, FCAH, FLOW_CONTROL_ADDRESS_HIGH);
+	E1000_WRITE_REG(hw, FCT, FLOW_CONTROL_TYPE);
+#if 0
+	E1000_WRITE_REG(hw, FCTTV, hw->fc_pause_time);
+#else
+	E1000_WRITE_REG(hw, FCTTV, FC_DEFAULT_TX_TIMER);
+#endif
+	
+	/* Set the flow control receive threshold registers.  Normally,
+	 * these registers will be set to a default threshold that may be
+	 * adjusted later by the driver's runtime code.  However, if the
+	 * ability to transmit pause frames in not enabled, then these
+	 * registers will be set to 0. 
+	 */
+	if(!(hw->fc & e1000_fc_tx_pause)) {
+		E1000_WRITE_REG(hw, FCRTL, 0);
+		E1000_WRITE_REG(hw, FCRTH, 0);
+	} else {
+		/* We need to set up the Receive Threshold high and low water marks
+		 * as well as (optionally) enabling the transmission of XON frames.
+		 */
+#if 0
+		if(hw->fc_send_xon) {
+			E1000_WRITE_REG(hw, FCRTL, (hw->fc_low_water | E1000_FCRTL_XONE));
+			E1000_WRITE_REG(hw, FCRTH, hw->fc_high_water);
+		} else {
+			E1000_WRITE_REG(hw, FCRTL, hw->fc_low_water);
+			E1000_WRITE_REG(hw, FCRTH, hw->fc_high_water);
+		}
+#else
+		E1000_WRITE_REG(hw, FCRTL, (FC_DEFAULT_LO_THRESH | E1000_FCRTL_XONE));
+		E1000_WRITE_REG(hw, FCRTH, FC_DEFAULT_HI_THRESH);
+#endif
+	}
+	return ret_val;
+}
+
+/******************************************************************************
+ * Sets up link for a fiber based or serdes based adapter
+ *
+ * hw - Struct containing variables accessed by shared code
+ *
+ * Manipulates Physical Coding Sublayer functions in order to configure
+ * link. Assumes the hardware has been previously reset and the transmitter
+ * and receiver are not enabled.
+ *****************************************************************************/
+static int
+e1000_setup_fiber_serdes_link(struct e1000_hw *hw)
+{
+	uint32_t ctrl;
+	uint32_t status;
+	uint32_t txcw = 0;
+	uint32_t i;
+	uint32_t signal = 0;
+	int32_t ret_val;
+
+	DEBUGFUNC("e1000_setup_fiber_serdes_link");
+
+	/* On adapters with a MAC newer than 82544, SW Defineable pin 1 will be 
+	 * set when the optics detect a signal. On older adapters, it will be 
+	 * cleared when there is a signal.  This applies to fiber media only.
+	 * If we're on serdes media, adjust the output amplitude to value set in
+	 * the EEPROM.
+	 */
+	ctrl = E1000_READ_REG(hw, CTRL);
+	if(hw->media_type == e1000_media_type_fiber)
+		signal = (hw->mac_type > e1000_82544) ? E1000_CTRL_SWDPIN1 : 0;
+
+	if((ret_val = e1000_adjust_serdes_amplitude(hw)))
+		return ret_val;
+
+	/* Take the link out of reset */
+	ctrl &= ~(E1000_CTRL_LRST);
+
+#if 0
+	/* Adjust VCO speed to improve BER performance */
+	if((ret_val = e1000_set_vco_speed(hw)))
+		return ret_val;
+#endif
+
+	e1000_config_collision_dist(hw);
+	
+	/* Check for a software override of the flow control settings, and setup
+	 * the device accordingly.  If auto-negotiation is enabled, then software
+	 * will have to set the "PAUSE" bits to the correct value in the Tranmsit
+	 * Config Word Register (TXCW) and re-start auto-negotiation.  However, if
+	 * auto-negotiation is disabled, then software will have to manually 
+	 * configure the two flow control enable bits in the CTRL register.
+	 *
+	 * The possible values of the "fc" parameter are:
+	 *      0:  Flow control is completely disabled
+	 *      1:  Rx flow control is enabled (we can receive pause frames, but 
+	 *          not send pause frames).
+	 *      2:  Tx flow control is enabled (we can send pause frames but we do
+	 *          not support receiving pause frames).
+	 *      3:  Both Rx and TX flow control (symmetric) are enabled.
+	 */
+	switch (hw->fc) {
+	case e1000_fc_none:
+		/* Flow control is completely disabled by a software over-ride. */
+		txcw = (E1000_TXCW_ANE | E1000_TXCW_FD);
+		break;
+	case e1000_fc_rx_pause:
+		/* RX Flow control is enabled and TX Flow control is disabled by a 
+		 * software over-ride. Since there really isn't a way to advertise 
+		 * that we are capable of RX Pause ONLY, we will advertise that we
+		 * support both symmetric and asymmetric RX PAUSE. Later, we will
+		 *  disable the adapter's ability to send PAUSE frames.
+		 */
+		txcw = (E1000_TXCW_ANE | E1000_TXCW_FD | E1000_TXCW_PAUSE_MASK);
+		break;
+	case e1000_fc_tx_pause:
+		/* TX Flow control is enabled, and RX Flow control is disabled, by a 
+		 * software over-ride.
+		 */
+		txcw = (E1000_TXCW_ANE | E1000_TXCW_FD | E1000_TXCW_ASM_DIR);
+		break;
+	case e1000_fc_full:
+		/* Flow control (both RX and TX) is enabled by a software over-ride. */
+		txcw = (E1000_TXCW_ANE | E1000_TXCW_FD | E1000_TXCW_PAUSE_MASK);
+		break;
+	default:
+		DEBUGOUT("Flow control param set incorrectly\n");
+		return -E1000_ERR_CONFIG;
+		break;
+	}
+	
+	/* Since auto-negotiation is enabled, take the link out of reset (the link
+	 * will be in reset, because we previously reset the chip). This will
+	 * restart auto-negotiation.  If auto-neogtiation is successful then the
+	 * link-up status bit will be set and the flow control enable bits (RFCE
+	 * and TFCE) will be set according to their negotiated value.
+	 */
+	DEBUGOUT("Auto-negotiation enabled\n");
+	
+	E1000_WRITE_REG(hw, TXCW, txcw);
+	E1000_WRITE_REG(hw, CTRL, ctrl);
+	E1000_WRITE_FLUSH(hw);
+	
+	hw->txcw = txcw;
+	mdelay(1);
+	
+	/* If we have a signal (the cable is plugged in) then poll for a "Link-Up"
+	 * indication in the Device Status Register.  Time-out if a link isn't 
+	 * seen in 500 milliseconds seconds (Auto-negotiation should complete in 
+	 * less than 500 milliseconds even if the other end is doing it in SW).
+	 * For internal serdes, we just assume a signal is present, then poll.
+	 */
+	if(hw->media_type == e1000_media_type_internal_serdes ||
+	   (E1000_READ_REG(hw, CTRL) & E1000_CTRL_SWDPIN1) == signal) {
+		DEBUGOUT("Looking for Link\n");
+		for(i = 0; i < (LINK_UP_TIMEOUT / 10); i++) {
+			mdelay(10);
+			status = E1000_READ_REG(hw, STATUS);
+			if(status & E1000_STATUS_LU) break;
+		}
+		if(i == (LINK_UP_TIMEOUT / 10)) {
+			DEBUGOUT("Never got a valid link from auto-neg!!!\n");
+			hw->autoneg_failed = 1;
+			/* AutoNeg failed to achieve a link, so we'll call 
+			 * e1000_check_for_link. This routine will force the link up if
+			 * we detect a signal. This will allow us to communicate with
+			 * non-autonegotiating link partners.
+			 */
+			if((ret_val = e1000_check_for_link(hw))) {
+				DEBUGOUT("Error while checking for link\n");
+				return ret_val;
+			}
+			hw->autoneg_failed = 0;
+		} else {
+			hw->autoneg_failed = 0;
+			DEBUGOUT("Valid Link Found\n");
+		}
+	} else {
+		DEBUGOUT("No Signal Detected\n");
+	}
+	return E1000_SUCCESS;
+}
+
+/******************************************************************************
+* Detects which PHY is present and the speed and duplex
+*
+* hw - Struct containing variables accessed by shared code
+******************************************************************************/
+static int
+e1000_setup_copper_link(struct e1000_hw *hw)
+{
+	uint32_t ctrl;
+	int32_t ret_val;
+	uint16_t i;
+	uint16_t phy_data;
+	
+	DEBUGFUNC("e1000_setup_copper_link");
+	
+	ctrl = E1000_READ_REG(hw, CTRL);
+	/* With 82543, we need to force speed and duplex on the MAC equal to what
+	 * the PHY speed and duplex configuration is. In addition, we need to
+	 * perform a hardware reset on the PHY to take it out of reset.
+	 */
+	if(hw->mac_type > e1000_82543) {
+		ctrl |= E1000_CTRL_SLU;
+		ctrl &= ~(E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);
+		E1000_WRITE_REG(hw, CTRL, ctrl);
+	} else {
+		ctrl |= (E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX | E1000_CTRL_SLU);
+		E1000_WRITE_REG(hw, CTRL, ctrl);
+		e1000_phy_hw_reset(hw);
+	}
+	
+	/* Make sure we have a valid PHY */
+	if((ret_val = e1000_detect_gig_phy(hw))) {
+		DEBUGOUT("Error, did not detect valid phy.\n");
+		return ret_val;
+	}
+	DEBUGOUT1("Phy ID = %x \n", hw->phy_id);
+
+	if(hw->mac_type <= e1000_82543 ||
+	   hw->mac_type == e1000_82541 || hw->mac_type == e1000_82547 ||
+#if 0
+	   hw->mac_type == e1000_82541_rev_2 || hw->mac_type == e1000_82547_rev_2)
+		hw->phy_reset_disable = FALSE;
+
+	if(!hw->phy_reset_disable) {
+#else
+	   hw->mac_type == e1000_82541_rev_2 || hw->mac_type == e1000_82547_rev_2) {
+#endif
+	if (hw->phy_type == e1000_phy_igp) {
+
+		if((ret_val = e1000_phy_reset(hw))) {
+			DEBUGOUT("Error Resetting the PHY\n");
+			return ret_val;
+		}
+
+		/* Wait 10ms for MAC to configure PHY from eeprom settings */
+		mdelay(15);
+
+#if 0
+		/* disable lplu d3 during driver init */
+		if((ret_val = e1000_set_d3_lplu_state(hw, FALSE))) {
+			DEBUGOUT("Error Disabling LPLU D3\n");
+			return ret_val;
+		}
+
+		/* Configure mdi-mdix settings */
+		if((ret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL,
+		                                 &phy_data)))
+			return ret_val;
+
+		if((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547)) {
+			hw->dsp_config_state = e1000_dsp_config_disabled;
+			/* Force MDI for IGP B-0 PHY */
+			phy_data &= ~(IGP01E1000_PSCR_AUTO_MDIX |
+			              IGP01E1000_PSCR_FORCE_MDI_MDIX);
+			hw->mdix = 1;
+
+		} else {
+			hw->dsp_config_state = e1000_dsp_config_enabled;
+			phy_data &= ~IGP01E1000_PSCR_AUTO_MDIX;
+
+			switch (hw->mdix) {
+			case 1:
+				phy_data &= ~IGP01E1000_PSCR_FORCE_MDI_MDIX;
+				break;
+			case 2:
+				phy_data |= IGP01E1000_PSCR_FORCE_MDI_MDIX;
+				break;
+			case 0:
+			default:
+				phy_data |= IGP01E1000_PSCR_AUTO_MDIX;
+				break;
+			}
+		}
+		if((ret_val = e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL,
+		                                  phy_data)))
+			return ret_val;
+
+		/* set auto-master slave resolution settings */
+		e1000_ms_type phy_ms_setting = hw->master_slave;
+
+		if(hw->ffe_config_state == e1000_ffe_config_active)
+			hw->ffe_config_state = e1000_ffe_config_enabled;
+
+		if(hw->dsp_config_state == e1000_dsp_config_activated)
+			hw->dsp_config_state = e1000_dsp_config_enabled;
+#endif
+
+		/* when autonegotiation advertisment is only 1000Mbps then we
+		 * should disable SmartSpeed and enable Auto MasterSlave
+		 * resolution as hardware default. */
+		if(hw->autoneg_advertised == ADVERTISE_1000_FULL) {
+			/* Disable SmartSpeed */
+			if((ret_val = e1000_read_phy_reg(hw,
+			                                 IGP01E1000_PHY_PORT_CONFIG,
+			                                 &phy_data)))
+				return ret_val;
+			phy_data &= ~IGP01E1000_PSCFR_SMART_SPEED;
+			if((ret_val = e1000_write_phy_reg(hw,
+			                                  IGP01E1000_PHY_PORT_CONFIG,
+			                                  phy_data)))
+				return ret_val;
+			/* Set auto Master/Slave resolution process */
+			if((ret_val = e1000_read_phy_reg(hw, PHY_1000T_CTRL,
+			                                 &phy_data)))
+				return ret_val;
+			phy_data &= ~CR_1000T_MS_ENABLE;
+			if((ret_val = e1000_write_phy_reg(hw, PHY_1000T_CTRL,
+			                                  phy_data)))
+				return ret_val;
+		}
+
+		if((ret_val = e1000_read_phy_reg(hw, PHY_1000T_CTRL,
+		                                 &phy_data)))
+			return ret_val;
+
+#if 0
+		/* load defaults for future use */
+		hw->original_master_slave = (phy_data & CR_1000T_MS_ENABLE) ?
+		                            ((phy_data & CR_1000T_MS_VALUE) ?
+		                             e1000_ms_force_master :
+		                             e1000_ms_force_slave) :
+		                             e1000_ms_auto;
+
+		switch (phy_ms_setting) {
+		case e1000_ms_force_master:
+			phy_data |= (CR_1000T_MS_ENABLE | CR_1000T_MS_VALUE);
+			break;
+		case e1000_ms_force_slave:
+			phy_data |= CR_1000T_MS_ENABLE;
+			phy_data &= ~(CR_1000T_MS_VALUE);
+			break;
+		case e1000_ms_auto:
+			phy_data &= ~CR_1000T_MS_ENABLE;
+		default:
+			break;
+		}
+#endif
+
+		if((ret_val = e1000_write_phy_reg(hw, PHY_1000T_CTRL,
+		                                  phy_data)))
+			return ret_val;
+	} else {
+		/* Enable CRS on TX. This must be set for half-duplex operation. */
+		if((ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL,
+		                                 &phy_data)))
+			return ret_val;
+
+		phy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;
+
+		/* Options:
+		 *   MDI/MDI-X = 0 (default)
+		 *   0 - Auto for all speeds
+		 *   1 - MDI mode
+		 *   2 - MDI-X mode
+		 *   3 - Auto for 1000Base-T only (MDI-X for 10/100Base-T modes)
+		 */
+#if 0
+		phy_data &= ~M88E1000_PSCR_AUTO_X_MODE;
+
+		switch (hw->mdix) {
+		case 1:
+			phy_data |= M88E1000_PSCR_MDI_MANUAL_MODE;
+			break;
+		case 2:
+			phy_data |= M88E1000_PSCR_MDIX_MANUAL_MODE;
+			break;
+		case 3:
+			phy_data |= M88E1000_PSCR_AUTO_X_1000T;
+			break;
+		case 0:
+		default:
+#endif
+			phy_data |= M88E1000_PSCR_AUTO_X_MODE;
+#if 0
+			break;
+		}
+#endif
+
+		/* Options:
+		 *   disable_polarity_correction = 0 (default)
+		 *       Automatic Correction for Reversed Cable Polarity
+		 *   0 - Disabled
+		 *   1 - Enabled
+		 */
+		phy_data &= ~M88E1000_PSCR_POLARITY_REVERSAL;
+		if((ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL,
+		                                  phy_data)))
+			return ret_val;
+
+		/* Force TX_CLK in the Extended PHY Specific Control Register
+		 * to 25MHz clock.
+		 */
+		if((ret_val = e1000_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,
+		                                 &phy_data)))
+			return ret_val;
+
+		phy_data |= M88E1000_EPSCR_TX_CLK_25;
+
+#ifdef LINUX_DRIVER
+		if (hw->phy_revision < M88E1011_I_REV_4) {
+#endif
+			/* Configure Master and Slave downshift values */
+			phy_data &= ~(M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK |
+				M88E1000_EPSCR_SLAVE_DOWNSHIFT_MASK);
+			phy_data |= (M88E1000_EPSCR_MASTER_DOWNSHIFT_1X |
+				M88E1000_EPSCR_SLAVE_DOWNSHIFT_1X);
+			if((ret_val = e1000_write_phy_reg(hw,
+			                                  M88E1000_EXT_PHY_SPEC_CTRL,
+			                                  phy_data)))
+				return ret_val;
+		}
+	
+		/* SW Reset the PHY so all changes take effect */
+		if((ret_val = e1000_phy_reset(hw))) {
+			DEBUGOUT("Error Resetting the PHY\n");
+			return ret_val;
+#ifdef LINUX_DRIVER
+		}
+#endif
+	}
+	
+	/* Options:
+	 *   autoneg = 1 (default)
+	 *      PHY will advertise value(s) parsed from
+	 *      autoneg_advertised and fc
+	 *   autoneg = 0
+	 *      PHY will be set to 10H, 10F, 100H, or 100F
+	 *      depending on value parsed from forced_speed_duplex.
+	 */
+	
+	/* Is autoneg enabled?  This is enabled by default or by software
+	 * override.  If so, call e1000_phy_setup_autoneg routine to parse the
+	 * autoneg_advertised and fc options. If autoneg is NOT enabled, then
+	 * the user should have provided a speed/duplex override.  If so, then
+	 * call e1000_phy_force_speed_duplex to parse and set this up.
+	 */
+	/* Perform some bounds checking on the hw->autoneg_advertised
+	 * parameter.  If this variable is zero, then set it to the default.
+	 */
+	hw->autoneg_advertised &= AUTONEG_ADVERTISE_SPEED_DEFAULT;
+	
+	/* If autoneg_advertised is zero, we assume it was not defaulted
+	 * by the calling code so we set to advertise full capability.
+	 */
+	if(hw->autoneg_advertised == 0)
+		hw->autoneg_advertised = AUTONEG_ADVERTISE_SPEED_DEFAULT;
+	
+	DEBUGOUT("Reconfiguring auto-neg advertisement params\n");
+	if((ret_val = e1000_phy_setup_autoneg(hw))) {
+		DEBUGOUT("Error Setting up Auto-Negotiation\n");
+		return ret_val;
+	}
+	DEBUGOUT("Restarting Auto-Neg\n");
+	
+	/* Restart auto-negotiation by setting the Auto Neg Enable bit and
+	 * the Auto Neg Restart bit in the PHY control register.
+	 */
+	if((ret_val = e1000_read_phy_reg(hw, PHY_CTRL, &phy_data)))
+		return ret_val;
+
+	phy_data |= (MII_CR_AUTO_NEG_EN | MII_CR_RESTART_AUTO_NEG);
+	if((ret_val = e1000_write_phy_reg(hw, PHY_CTRL, phy_data)))
+		return ret_val;
+
+#if 0	
+	/* Does the user want to wait for Auto-Neg to complete here, or
+	 * check at a later time (for example, callback routine).
+	 */
+	if(hw->wait_autoneg_complete) {
+		if((ret_val = e1000_wait_autoneg(hw))) {
+			DEBUGOUT("Error while waiting for autoneg to complete\n");
+			return ret_val;
+		}
+	}
+#else
+	/* If we do not wait for autonegotiation to complete I 
+	 * do not see a valid link status.
+	 */
+	if((ret_val = e1000_wait_autoneg(hw))) {
+		DEBUGOUT("Error while waiting for autoneg to complete\n");
+		return ret_val;
+	}
+#endif
+	} /* !hw->phy_reset_disable */
+	
+	/* Check link status. Wait up to 100 microseconds for link to become
+	 * valid.
+	 */
+	for(i = 0; i < 10; i++) {
+		if((ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data)))
+			return ret_val;
+		if((ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data)))
+			return ret_val;
+
+		if(phy_data & MII_SR_LINK_STATUS) {
+			/* We have link, so we need to finish the config process:
+			 *   1) Set up the MAC to the current PHY speed/duplex
+			 *      if we are on 82543.  If we
+			 *      are on newer silicon, we only need to configure
+			 *      collision distance in the Transmit Control Register.
+			 *   2) Set up flow control on the MAC to that established with
+			 *      the link partner.
+			 */
+			if(hw->mac_type >= e1000_82544) {
+				e1000_config_collision_dist(hw);
+			} else {
+				if((ret_val = e1000_config_mac_to_phy(hw))) {
+					DEBUGOUT("Error configuring MAC to PHY settings\n");
+					return ret_val;
+				}
+			}
+			if((ret_val = e1000_config_fc_after_link_up(hw))) {
+				DEBUGOUT("Error Configuring Flow Control\n");
+				return ret_val;
+			}
+#if 0
+			if(hw->phy_type == e1000_phy_igp) {
+				if((ret_val = e1000_config_dsp_after_link_change(hw, TRUE))) {
+					DEBUGOUT("Error Configuring DSP after link up\n");
+					return ret_val;
+				}
+			}
+#endif
+			DEBUGOUT("Valid link established!!!\n");
+			return E1000_SUCCESS;
+		}
+		udelay(10);
+	}
+	
+	DEBUGOUT("Unable to establish link!!!\n");
+	return -E1000_ERR_NOLINK;
+}
+
+/******************************************************************************
+* Configures PHY autoneg and flow control advertisement settings
+*
+* hw - Struct containing variables accessed by shared code
+******************************************************************************/
+static int
+e1000_phy_setup_autoneg(struct e1000_hw *hw)
+{
+	int32_t ret_val;
+	uint16_t mii_autoneg_adv_reg;
+	uint16_t mii_1000t_ctrl_reg;
+
+	DEBUGFUNC("e1000_phy_setup_autoneg");
+	
+	/* Read the MII Auto-Neg Advertisement Register (Address 4). */
+	if((ret_val = e1000_read_phy_reg(hw, PHY_AUTONEG_ADV,
+	                                 &mii_autoneg_adv_reg)))
+		return ret_val;
+
+	/* Read the MII 1000Base-T Control Register (Address 9). */
+	if((ret_val = e1000_read_phy_reg(hw, PHY_1000T_CTRL, &mii_1000t_ctrl_reg)))
+		return ret_val;
+
+	/* Need to parse both autoneg_advertised and fc and set up
+	 * the appropriate PHY registers.  First we will parse for
+	 * autoneg_advertised software override.  Since we can advertise
+	 * a plethora of combinations, we need to check each bit
+	 * individually.
+	 */
+	
+	/* First we clear all the 10/100 mb speed bits in the Auto-Neg
+	 * Advertisement Register (Address 4) and the 1000 mb speed bits in
+	 * the  1000Base-T Control Register (Address 9).
+	 */
+	mii_autoneg_adv_reg &= ~REG4_SPEED_MASK;
+	mii_1000t_ctrl_reg &= ~REG9_SPEED_MASK;
+
+	DEBUGOUT1("autoneg_advertised %x\n", hw->autoneg_advertised);
+
+	/* Do we want to advertise 10 Mb Half Duplex? */
+	if(hw->autoneg_advertised & ADVERTISE_10_HALF) {
+		DEBUGOUT("Advertise 10mb Half duplex\n");
+		mii_autoneg_adv_reg |= NWAY_AR_10T_HD_CAPS;
+	}
+
+	/* Do we want to advertise 10 Mb Full Duplex? */
+	if(hw->autoneg_advertised & ADVERTISE_10_FULL) {
+		DEBUGOUT("Advertise 10mb Full duplex\n");
+		mii_autoneg_adv_reg |= NWAY_AR_10T_FD_CAPS;
+	}
+
+	/* Do we want to advertise 100 Mb Half Duplex? */
+	if(hw->autoneg_advertised & ADVERTISE_100_HALF) {
+		DEBUGOUT("Advertise 100mb Half duplex\n");
+		mii_autoneg_adv_reg |= NWAY_AR_100TX_HD_CAPS;
+	}
+
+	/* Do we want to advertise 100 Mb Full Duplex? */
+	if(hw->autoneg_advertised & ADVERTISE_100_FULL) {
+		DEBUGOUT("Advertise 100mb Full duplex\n");
+		mii_autoneg_adv_reg |= NWAY_AR_100TX_FD_CAPS;
+	}
+
+	/* We do not allow the Phy to advertise 1000 Mb Half Duplex */
+	if(hw->autoneg_advertised & ADVERTISE_1000_HALF) {
+		DEBUGOUT("Advertise 1000mb Half duplex requested, request denied!\n");
+	}
+
+	/* Do we want to advertise 1000 Mb Full Duplex? */
+	if(hw->autoneg_advertised & ADVERTISE_1000_FULL) {
+		DEBUGOUT("Advertise 1000mb Full duplex\n");
+		mii_1000t_ctrl_reg |= CR_1000T_FD_CAPS;
+	}
+
+	/* Check for a software override of the flow control settings, and
+	 * setup the PHY advertisement registers accordingly.  If
+	 * auto-negotiation is enabled, then software will have to set the
+	 * "PAUSE" bits to the correct value in the Auto-Negotiation
+	 * Advertisement Register (PHY_AUTONEG_ADV) and re-start auto-negotiation.
+	 *
+	 * The possible values of the "fc" parameter are:
+	 *      0:  Flow control is completely disabled
+	 *      1:  Rx flow control is enabled (we can receive pause frames
+	 *          but not send pause frames).
+	 *      2:  Tx flow control is enabled (we can send pause frames
+	 *          but we do not support receiving pause frames).
+	 *      3:  Both Rx and TX flow control (symmetric) are enabled.
+	 *  other:  No software override.  The flow control configuration
+	 *          in the EEPROM is used.
+	 */
+	switch (hw->fc) {
+	case e1000_fc_none: /* 0 */
+		/* Flow control (RX & TX) is completely disabled by a
+		 * software over-ride.
+		 */
+		mii_autoneg_adv_reg &= ~(NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);
+		break;
+	case e1000_fc_rx_pause: /* 1 */
+		/* RX Flow control is enabled, and TX Flow control is
+		 * disabled, by a software over-ride.
+		 */
+		/* Since there really isn't a way to advertise that we are
+		 * capable of RX Pause ONLY, we will advertise that we
+		 * support both symmetric and asymmetric RX PAUSE.  Later
+		 * (in e1000_config_fc_after_link_up) we will disable the
+		 *hw's ability to send PAUSE frames.
+		 */
+		mii_autoneg_adv_reg |= (NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);
+		break;
+	case e1000_fc_tx_pause: /* 2 */
+		/* TX Flow control is enabled, and RX Flow control is
+		 * disabled, by a software over-ride.
+		 */
+		mii_autoneg_adv_reg |= NWAY_AR_ASM_DIR;
+		mii_autoneg_adv_reg &= ~NWAY_AR_PAUSE;
+		break;
+	case e1000_fc_full: /* 3 */
+		/* Flow control (both RX and TX) is enabled by a software
+		 * over-ride.
+		 */
+		mii_autoneg_adv_reg |= (NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);
+		break;
+	default:
+		DEBUGOUT("Flow control param set incorrectly\n");
+		return -E1000_ERR_CONFIG;
+	}
+
+	if((ret_val = e1000_write_phy_reg(hw, PHY_AUTONEG_ADV,
+	                       mii_autoneg_adv_reg)))
+		return ret_val;
+
+	DEBUGOUT1("Auto-Neg Advertising %x\n", mii_autoneg_adv_reg);
+
+	if((ret_val = e1000_write_phy_reg(hw, PHY_1000T_CTRL, mii_1000t_ctrl_reg)))
+		return ret_val;
+
+	return E1000_SUCCESS;
+}
+
+/******************************************************************************
+* Sets the collision distance in the Transmit Control register
+*
+* hw - Struct containing variables accessed by shared code
+*
+* Link should have been established previously. Reads the speed and duplex
+* information from the Device Status register.
+******************************************************************************/
+static void
+e1000_config_collision_dist(struct e1000_hw *hw)
+{
+	uint32_t tctl;
+
+	tctl = E1000_READ_REG(hw, TCTL);
+	
+	tctl &= ~E1000_TCTL_COLD;
+	tctl |= E1000_COLLISION_DISTANCE << E1000_COLD_SHIFT;
+	
+	E1000_WRITE_REG(hw, TCTL, tctl);
+	E1000_WRITE_FLUSH(hw);
+}
+
+/******************************************************************************
+* Sets MAC speed and duplex settings to reflect the those in the PHY
+*
+* hw - Struct containing variables accessed by shared code
+* mii_reg - data to write to the MII control register
+*
+* The contents of the PHY register containing the needed information need to
+* be passed in.
+******************************************************************************/
+static int
+e1000_config_mac_to_phy(struct e1000_hw *hw)
+{
+	uint32_t ctrl;
+	int32_t ret_val;
+	uint16_t phy_data;
+
+	DEBUGFUNC("e1000_config_mac_to_phy");
+
+	/* Read the Device Control Register and set the bits to Force Speed
+	 * and Duplex.
+	 */
+	ctrl = E1000_READ_REG(hw, CTRL);
+	ctrl |= (E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);
+	ctrl &= ~(E1000_CTRL_SPD_SEL | E1000_CTRL_ILOS);
+
+	/* Set up duplex in the Device Control and Transmit Control
+	 * registers depending on negotiated values.
+	 */
+	if (hw->phy_type == e1000_phy_igp) {
+		if((ret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS,
+		                                 &phy_data)))
+			return ret_val;
+
+		if(phy_data & IGP01E1000_PSSR_FULL_DUPLEX) ctrl |= E1000_CTRL_FD;
+		else ctrl &= ~E1000_CTRL_FD;
+
+		e1000_config_collision_dist(hw);
+
+		/* Set up speed in the Device Control register depending on
+		 * negotiated values.
+		 */
+		if((phy_data & IGP01E1000_PSSR_SPEED_MASK) ==
+		   IGP01E1000_PSSR_SPEED_1000MBPS)
+			ctrl |= E1000_CTRL_SPD_1000;
+		else if((phy_data & IGP01E1000_PSSR_SPEED_MASK) ==
+			IGP01E1000_PSSR_SPEED_100MBPS)
+			ctrl |= E1000_CTRL_SPD_100;
+	} else {
+		if((ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,
+		                                 &phy_data)))
+			return ret_val;
+		
+		if(phy_data & M88E1000_PSSR_DPLX) ctrl |= E1000_CTRL_FD;
+		else ctrl &= ~E1000_CTRL_FD;
+
+		e1000_config_collision_dist(hw);
+
+		/* Set up speed in the Device Control register depending on
+		 * negotiated values.
+		 */
+		if((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_1000MBS)
+			ctrl |= E1000_CTRL_SPD_1000;
+		else if((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_100MBS)
+			ctrl |= E1000_CTRL_SPD_100;
+	}
+	/* Write the configured values back to the Device Control Reg. */
+	E1000_WRITE_REG(hw, CTRL, ctrl);
+	return E1000_SUCCESS;
+}
+
+/******************************************************************************
+ * Forces the MAC's flow control settings.
+ * 
+ * hw - Struct containing variables accessed by shared code
+ *
+ * Sets the TFCE and RFCE bits in the device control register to reflect
+ * the adapter settings. TFCE and RFCE need to be explicitly set by
+ * software when a Copper PHY is used because autonegotiation is managed
+ * by the PHY rather than the MAC. Software must also configure these
+ * bits when link is forced on a fiber connection.
+ *****************************************************************************/
+static int
+e1000_force_mac_fc(struct e1000_hw *hw)
+{
+	uint32_t ctrl;
+	
+	DEBUGFUNC("e1000_force_mac_fc");
+	
+	/* Get the current configuration of the Device Control Register */
+	ctrl = E1000_READ_REG(hw, CTRL);
+	
+	/* Because we didn't get link via the internal auto-negotiation
+	 * mechanism (we either forced link or we got link via PHY
+	 * auto-neg), we have to manually enable/disable transmit an
+	 * receive flow control.
+	 *
+	 * The "Case" statement below enables/disable flow control
+	 * according to the "hw->fc" parameter.
+	 *
+	 * The possible values of the "fc" parameter are:
+	 *      0:  Flow control is completely disabled
+	 *      1:  Rx flow control is enabled (we can receive pause
+	 *          frames but not send pause frames).
+	 *      2:  Tx flow control is enabled (we can send pause frames
+	 *          frames but we do not receive pause frames).
+	 *      3:  Both Rx and TX flow control (symmetric) is enabled.
+	 *  other:  No other values should be possible at this point.
+	 */
+	
+	switch (hw->fc) {
+	case e1000_fc_none:
+		ctrl &= (~(E1000_CTRL_TFCE | E1000_CTRL_RFCE));
+		break;
+	case e1000_fc_rx_pause:
+		ctrl &= (~E1000_CTRL_TFCE);
+		ctrl |= E1000_CTRL_RFCE;
+		break;
+	case e1000_fc_tx_pause:
+		ctrl &= (~E1000_CTRL_RFCE);
+		ctrl |= E1000_CTRL_TFCE;
+		break;
+	case e1000_fc_full:
+		ctrl |= (E1000_CTRL_TFCE | E1000_CTRL_RFCE);
+		break;
+	default:
+		DEBUGOUT("Flow control param set incorrectly\n");
+		return -E1000_ERR_CONFIG;
+	}
+	
+	/* Disable TX Flow Control for 82542 (rev 2.0) */
+	if(hw->mac_type == e1000_82542_rev2_0)
+		ctrl &= (~E1000_CTRL_TFCE);
+	
+	E1000_WRITE_REG(hw, CTRL, ctrl);
+	return E1000_SUCCESS;
+}
+
+/******************************************************************************
+ * Configures flow control settings after link is established
+ * 
+ * hw - Struct containing variables accessed by shared code
+ *
+ * Should be called immediately after a valid link has been established.
+ * Forces MAC flow control settings if link was forced. When in MII/GMII mode
+ * and autonegotiation is enabled, the MAC flow control settings will be set
+ * based on the flow control negotiated by the PHY. In TBI mode, the TFCE
+ * and RFCE bits will be automaticaly set to the negotiated flow control mode.
+ *****************************************************************************/
+static int
+e1000_config_fc_after_link_up(struct e1000_hw *hw)
+{
+	int32_t ret_val;
+	uint16_t mii_status_reg;
+	uint16_t mii_nway_adv_reg;
+	uint16_t mii_nway_lp_ability_reg;
+	uint16_t speed;
+	uint16_t duplex;
+	
+	DEBUGFUNC("e1000_config_fc_after_link_up");
+	
+	/* Check for the case where we have fiber media and auto-neg failed
+	 * so we had to force link.  In this case, we need to force the
+	 * configuration of the MAC to match the "fc" parameter.
+	 */
+	if(((hw->media_type == e1000_media_type_fiber) && (hw->autoneg_failed)) ||
+	   ((hw->media_type == e1000_media_type_internal_serdes) && (hw->autoneg_failed))) { 
+		if((ret_val = e1000_force_mac_fc(hw))) {
+			DEBUGOUT("Error forcing flow control settings\n");
+			return ret_val;
+		}
+	}
+	
+	/* Check for the case where we have copper media and auto-neg is
+	 * enabled.  In this case, we need to check and see if Auto-Neg
+	 * has completed, and if so, how the PHY and link partner has
+	 * flow control configured.
+	 */
+	if(hw->media_type == e1000_media_type_copper) {
+		/* Read the MII Status Register and check to see if AutoNeg
+		 * has completed.  We read this twice because this reg has
+		 * some "sticky" (latched) bits.
+		 */
+		if((ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg)))
+			return ret_val;
+		if((ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg)))
+			return ret_val;
+		
+		if(mii_status_reg & MII_SR_AUTONEG_COMPLETE) {
+			/* The AutoNeg process has completed, so we now need to
+			 * read both the Auto Negotiation Advertisement Register
+			 * (Address 4) and the Auto_Negotiation Base Page Ability
+			 * Register (Address 5) to determine how flow control was
+			 * negotiated.
+			 */
+			if((ret_val = e1000_read_phy_reg(hw, PHY_AUTONEG_ADV,
+			                                 &mii_nway_adv_reg)))
+				return ret_val;
+			if((ret_val = e1000_read_phy_reg(hw, PHY_LP_ABILITY,
+			                                 &mii_nway_lp_ability_reg)))
+				return ret_val;
+
+			/* Two bits in the Auto Negotiation Advertisement Register
+			 * (Address 4) and two bits in the Auto Negotiation Base
+			 * Page Ability Register (Address 5) determine flow control
+			 * for both the PHY and the link partner.  The following
+			 * table, taken out of the IEEE 802.3ab/D6.0 dated March 25,
+			 * 1999, describes these PAUSE resolution bits and how flow
+			 * control is determined based upon these settings.
+			 * NOTE:  DC = Don't Care
+			 *
+			 *   LOCAL DEVICE  |   LINK PARTNER
+			 * PAUSE | ASM_DIR | PAUSE | ASM_DIR | NIC Resolution
+			 *-------|---------|-------|---------|--------------------
+			 *   0   |    0    |  DC   |   DC    | e1000_fc_none
+			 *   0   |    1    |   0   |   DC    | e1000_fc_none
+			 *   0   |    1    |   1   |    0    | e1000_fc_none
+			 *   0   |    1    |   1   |    1    | e1000_fc_tx_pause
+			 *   1   |    0    |   0   |   DC    | e1000_fc_none
+			 *   1   |   DC    |   1   |   DC    | e1000_fc_full
+			 *   1   |    1    |   0   |    0    | e1000_fc_none
+			 *   1   |    1    |   0   |    1    | e1000_fc_rx_pause
+			 *
+			 */
+			/* Are both PAUSE bits set to 1?  If so, this implies
+			 * Symmetric Flow Control is enabled at both ends.  The
+			 * ASM_DIR bits are irrelevant per the spec.
+			 *
+			 * For Symmetric Flow Control:
+			 *
+			 *   LOCAL DEVICE  |   LINK PARTNER
+			 * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result
+			 *-------|---------|-------|---------|--------------------
+			 *   1   |   DC    |   1   |   DC    | e1000_fc_full
+			 *
+			 */
+			if((mii_nway_adv_reg & NWAY_AR_PAUSE) &&
+				(mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE)) {
+				/* Now we need to check if the user selected RX ONLY
+				 * of pause frames.  In this case, we had to advertise
+				 * FULL flow control because we could not advertise RX
+				 * ONLY. Hence, we must now check to see if we need to
+				 * turn OFF  the TRANSMISSION of PAUSE frames.
+				 */
+#if 0
+				if(hw->original_fc == e1000_fc_full) {
+					hw->fc = e1000_fc_full;
+#else
+				if(hw->fc == e1000_fc_full) {
+#endif
+					DEBUGOUT("Flow Control = FULL.\r\n");
+				} else {
+					hw->fc = e1000_fc_rx_pause;
+					DEBUGOUT("Flow Control = RX PAUSE frames only.\r\n");
+				}
+			}
+			/* For receiving PAUSE frames ONLY.
+			 *
+			 *   LOCAL DEVICE  |   LINK PARTNER
+			 * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result
+			 *-------|---------|-------|---------|--------------------
+			 *   0   |    1    |   1   |    1    | e1000_fc_tx_pause
+			 *
+			 */
+			else if(!(mii_nway_adv_reg & NWAY_AR_PAUSE) &&
+				(mii_nway_adv_reg & NWAY_AR_ASM_DIR) &&
+				(mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE) &&
+				(mii_nway_lp_ability_reg & NWAY_LPAR_ASM_DIR)) {
+				hw->fc = e1000_fc_tx_pause;
+				DEBUGOUT("Flow Control = TX PAUSE frames only.\r\n");
+			}
+			/* For transmitting PAUSE frames ONLY.
+			 *
+			 *   LOCAL DEVICE  |   LINK PARTNER
+			 * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result
+			 *-------|---------|-------|---------|--------------------
+			 *   1   |    1    |   0   |    1    | e1000_fc_rx_pause
+			 *
+			 */
+			else if((mii_nway_adv_reg & NWAY_AR_PAUSE) &&
+				(mii_nway_adv_reg & NWAY_AR_ASM_DIR) &&
+				!(mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE) &&
+				(mii_nway_lp_ability_reg & NWAY_LPAR_ASM_DIR)) {
+				hw->fc = e1000_fc_rx_pause;
+				DEBUGOUT("Flow Control = RX PAUSE frames only.\r\n");
+			}
+			/* Per the IEEE spec, at this point flow control should be
+			 * disabled.  However, we want to consider that we could
+			 * be connected to a legacy switch that doesn't advertise
+			 * desired flow control, but can be forced on the link
+			 * partner.  So if we advertised no flow control, that is
+			 * what we will resolve to.  If we advertised some kind of
+			 * receive capability (Rx Pause Only or Full Flow Control)
+			 * and the link partner advertised none, we will configure
+			 * ourselves to enable Rx Flow Control only.  We can do
+			 * this safely for two reasons:  If the link partner really
+			 * didn't want flow control enabled, and we enable Rx, no
+			 * harm done since we won't be receiving any PAUSE frames
+			 * anyway.  If the intent on the link partner was to have
+			 * flow control enabled, then by us enabling RX only, we
+			 * can at least receive pause frames and process them.
+			 * This is a good idea because in most cases, since we are
+			 * predominantly a server NIC, more times than not we will
+			 * be asked to delay transmission of packets than asking
+			 * our link partner to pause transmission of frames.
+			 */
+#if 0
+			else if(hw->original_fc == e1000_fc_none ||
+				hw->original_fc == e1000_fc_tx_pause) {
+#else
+			else if(hw->fc == e1000_fc_none)
+				DEBUGOUT("Flow Control = NONE.\r\n");
+			else if(hw->fc == e1000_fc_tx_pause) {
+#endif
+				hw->fc = e1000_fc_none;
+				DEBUGOUT("Flow Control = NONE.\r\n");
+			} else {
+				hw->fc = e1000_fc_rx_pause;
+				DEBUGOUT("Flow Control = RX PAUSE frames only.\r\n");
+			}
+			
+			/* Now we need to do one last check...  If we auto-
+			 * negotiated to HALF DUPLEX, flow control should not be
+			 * enabled per IEEE 802.3 spec.
+			 */
+			e1000_get_speed_and_duplex(hw, &speed, &duplex);
+			
+			if(duplex == HALF_DUPLEX)
+				hw->fc = e1000_fc_none;
+			
+			/* Now we call a subroutine to actually force the MAC
+			 * controller to use the correct flow control settings.
+			 */
+			if((ret_val = e1000_force_mac_fc(hw))) {
+				DEBUGOUT("Error forcing flow control settings\n");
+				return ret_val;
+			}
+		} else {
+			DEBUGOUT("Copper PHY and Auto Neg has not completed.\r\n");
+		}
+	}
+	return E1000_SUCCESS;
+}
+
+/******************************************************************************
+ * Checks to see if the link status of the hardware has changed.
+ *
+ * hw - Struct containing variables accessed by shared code
+ *
+ * Called by any function that needs to check the link status of the adapter.
+ *****************************************************************************/
+static int
+e1000_check_for_link(struct e1000_hw *hw)
+{
+	uint32_t rxcw;
+	uint32_t ctrl;
+	uint32_t status;
+	uint32_t rctl;
+	uint32_t signal = 0;
+	int32_t ret_val;
+	uint16_t phy_data;
+	uint16_t lp_capability;
+	
+	DEBUGFUNC("e1000_check_for_link");
+	
+	/* On adapters with a MAC newer than 82544, SW Defineable pin 1 will be 
+	 * set when the optics detect a signal. On older adapters, it will be 
+	 * cleared when there is a signal.  This applies to fiber media only.
+	 */
+	if(hw->media_type == e1000_media_type_fiber)
+		signal = (hw->mac_type > e1000_82544) ? E1000_CTRL_SWDPIN1 : 0;
+
+	ctrl = E1000_READ_REG(hw, CTRL);
+	status = E1000_READ_REG(hw, STATUS);
+	rxcw = E1000_READ_REG(hw, RXCW);
+	
+	/* If we have a copper PHY then we only want to go out to the PHY
+	 * registers to see if Auto-Neg has completed and/or if our link
+	 * status has changed.  The get_link_status flag will be set if we
+	 * receive a Link Status Change interrupt or we have Rx Sequence
+	 * Errors.
+	 */
+#if 0
+	if((hw->media_type == e1000_media_type_copper) && hw->get_link_status) {
+#else
+	if(hw->media_type == e1000_media_type_copper) {
+#endif
+		/* First we want to see if the MII Status Register reports
+		 * link.  If so, then we want to get the current speed/duplex
+		 * of the PHY.
+		 * Read the register twice since the link bit is sticky.
+		 */
+		if((ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data)))
+			return ret_val;
+		if((ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data)))
+			return ret_val;
+		
+		if(phy_data & MII_SR_LINK_STATUS) {
+#if 0
+			hw->get_link_status = FALSE;
+#endif
+		} else {
+			/* No link detected */
+			return -E1000_ERR_NOLINK;
+		}
+
+		/* We have a M88E1000 PHY and Auto-Neg is enabled.  If we
+		 * have Si on board that is 82544 or newer, Auto
+		 * Speed Detection takes care of MAC speed/duplex
+		 * configuration.  So we only need to configure Collision
+		 * Distance in the MAC.  Otherwise, we need to force
+		 * speed/duplex on the MAC to the current PHY speed/duplex
+		 * settings.
+		 */
+		if(hw->mac_type >= e1000_82544)
+			e1000_config_collision_dist(hw);
+		else {
+			if((ret_val = e1000_config_mac_to_phy(hw))) {
+				DEBUGOUT("Error configuring MAC to PHY settings\n");
+				return ret_val;
+			}
+		}
+		
+		/* Configure Flow Control now that Auto-Neg has completed. First, we 
+		 * need to restore the desired flow control settings because we may
+		 * have had to re-autoneg with a different link partner.
+		 */
+		if((ret_val = e1000_config_fc_after_link_up(hw))) {
+			DEBUGOUT("Error configuring flow control\n");
+			return ret_val;
+		}
+		
+		/* At this point we know that we are on copper and we have
+		 * auto-negotiated link.  These are conditions for checking the link
+		 * parter capability register.  We use the link partner capability to
+		 * determine if TBI Compatibility needs to be turned on or off.  If
+		 * the link partner advertises any speed in addition to Gigabit, then
+		 * we assume that they are GMII-based, and TBI compatibility is not
+		 * needed. If no other speeds are advertised, we assume the link
+		 * partner is TBI-based, and we turn on TBI Compatibility.
+		 */
+		if(hw->tbi_compatibility_en) {
+			if((ret_val = e1000_read_phy_reg(hw, PHY_LP_ABILITY,
+			                                 &lp_capability)))
+				return ret_val;
+			if(lp_capability & (NWAY_LPAR_10T_HD_CAPS |
+                                NWAY_LPAR_10T_FD_CAPS |
+                                NWAY_LPAR_100TX_HD_CAPS |
+                                NWAY_LPAR_100TX_FD_CAPS |
+                                NWAY_LPAR_100T4_CAPS)) {
+				/* If our link partner advertises anything in addition to 
+				 * gigabit, we do not need to enable TBI compatibility.
+				 */
+				if(hw->tbi_compatibility_on) {
+					/* If we previously were in the mode, turn it off. */
+					rctl = E1000_READ_REG(hw, RCTL);
+					rctl &= ~E1000_RCTL_SBP;
+					E1000_WRITE_REG(hw, RCTL, rctl);
+					hw->tbi_compatibility_on = FALSE;
+				}
+			} else {
+				/* If TBI compatibility is was previously off, turn it on. For
+				 * compatibility with a TBI link partner, we will store bad
+				 * packets. Some frames have an additional byte on the end and
+				 * will look like CRC errors to to the hardware.
+				 */
+				if(!hw->tbi_compatibility_on) {
+					hw->tbi_compatibility_on = TRUE;
+					rctl = E1000_READ_REG(hw, RCTL);
+					rctl |= E1000_RCTL_SBP;
+					E1000_WRITE_REG(hw, RCTL, rctl);
+				}
+			}
+		}
+	}
+	/* If we don't have link (auto-negotiation failed or link partner cannot
+	 * auto-negotiate), the cable is plugged in (we have signal), and our
+	 * link partner is not trying to auto-negotiate with us (we are receiving
+	 * idles or data), we need to force link up. We also need to give
+	 * auto-negotiation time to complete, in case the cable was just plugged
+	 * in. The autoneg_failed flag does this.
+	 */
+	else if((((hw->media_type == e1000_media_type_fiber) &&
+	        ((ctrl & E1000_CTRL_SWDPIN1) == signal)) ||
+	        (hw->media_type == e1000_media_type_internal_serdes)) &&
+		(!(status & E1000_STATUS_LU)) &&
+		(!(rxcw & E1000_RXCW_C))) {
+		if(hw->autoneg_failed == 0) {
+			hw->autoneg_failed = 1;
+			return 0;
+		}
+		DEBUGOUT("NOT RXing /C/, disable AutoNeg and force link.\r\n");
+		
+		/* Disable auto-negotiation in the TXCW register */
+		E1000_WRITE_REG(hw, TXCW, (hw->txcw & ~E1000_TXCW_ANE));
+		
+		/* Force link-up and also force full-duplex. */
+		ctrl = E1000_READ_REG(hw, CTRL);
+		ctrl |= (E1000_CTRL_SLU | E1000_CTRL_FD);
+		E1000_WRITE_REG(hw, CTRL, ctrl);
+		
+		/* Configure Flow Control after forcing link up. */
+		if((ret_val = e1000_config_fc_after_link_up(hw))) {
+			DEBUGOUT("Error configuring flow control\n");
+			return ret_val;
+		}
+	}
+	/* If we are forcing link and we are receiving /C/ ordered sets, re-enable
+	 * auto-negotiation in the TXCW register and disable forced link in the
+	 * Device Control register in an attempt to auto-negotiate with our link
+	 * partner.
+	 */
+	else if(((hw->media_type == e1000_media_type_fiber)  ||
+	         (hw->media_type == e1000_media_type_internal_serdes)) &&
+		(ctrl & E1000_CTRL_SLU) &&
+		(rxcw & E1000_RXCW_C)) {
+		DEBUGOUT("RXing /C/, enable AutoNeg and stop forcing link.\r\n");
+		E1000_WRITE_REG(hw, TXCW, hw->txcw);
+		E1000_WRITE_REG(hw, CTRL, (ctrl & ~E1000_CTRL_SLU));
+	}
+#if 0
+	/* If we force link for non-auto-negotiation switch, check link status
+	 * based on MAC synchronization for internal serdes media type.
+	 */
+	else if((hw->media_type == e1000_media_type_internal_serdes) &&
+			!(E1000_TXCW_ANE & E1000_READ_REG(hw, TXCW))) {
+		/* SYNCH bit and IV bit are sticky. */
+		udelay(10);
+		if(E1000_RXCW_SYNCH & E1000_READ_REG(hw, RXCW)) {
+			if(!(rxcw & E1000_RXCW_IV)) {
+				hw->serdes_link_down = FALSE;
+				DEBUGOUT("SERDES: Link is up.\n");
+			}
+		} else {
+			hw->serdes_link_down = TRUE;
+			DEBUGOUT("SERDES: Link is down.\n");
+		}
+	}
+#endif
+	return E1000_SUCCESS;
+}
+
+/******************************************************************************
+ * Detects the current speed and duplex settings of the hardware.
+ *
+ * hw - Struct containing variables accessed by shared code
+ * speed - Speed of the connection
+ * duplex - Duplex setting of the connection
+ *****************************************************************************/
+static void 
+e1000_get_speed_and_duplex(struct e1000_hw *hw,
+                           uint16_t *speed,
+                           uint16_t *duplex)
+{
+	uint32_t status;
+	
+	DEBUGFUNC("e1000_get_speed_and_duplex");
+	
+	if(hw->mac_type >= e1000_82543) {
+		status = E1000_READ_REG(hw, STATUS);
+		if(status & E1000_STATUS_SPEED_1000) {
+			*speed = SPEED_1000;
+			DEBUGOUT("1000 Mbs, ");
+		} else if(status & E1000_STATUS_SPEED_100) {
+			*speed = SPEED_100;
+			DEBUGOUT("100 Mbs, ");
+		} else {
+			*speed = SPEED_10;
+			DEBUGOUT("10 Mbs, ");
+		}
+		
+		if(status & E1000_STATUS_FD) {
+			*duplex = FULL_DUPLEX;
+			DEBUGOUT("Full Duplex\r\n");
+		} else {
+			*duplex = HALF_DUPLEX;
+			DEBUGOUT(" Half Duplex\r\n");
+		}
+	} else {
+		DEBUGOUT("1000 Mbs, Full Duplex\r\n");
+		*speed = SPEED_1000;
+		*duplex = FULL_DUPLEX;
+	}
+}
+
+/******************************************************************************
+* Blocks until autoneg completes or times out (~4.5 seconds)
+*
+* hw - Struct containing variables accessed by shared code
+******************************************************************************/
+static int
+e1000_wait_autoneg(struct e1000_hw *hw)
+{
+	int32_t ret_val;
+	uint16_t i;
+	uint16_t phy_data;
+	
+	DEBUGFUNC("e1000_wait_autoneg");
+	DEBUGOUT("Waiting for Auto-Neg to complete.\n");
+	
+	/* We will wait for autoneg to complete or 4.5 seconds to expire. */
+	for(i = PHY_AUTO_NEG_TIME; i > 0; i--) {
+		/* Read the MII Status Register and wait for Auto-Neg
+		 * Complete bit to be set.
+		 */
+		if((ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data)))
+			return ret_val;
+		if((ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data)))
+			return ret_val;
+		if(phy_data & MII_SR_AUTONEG_COMPLETE) {
+			DEBUGOUT("Auto-Neg complete.\n");
+			return E1000_SUCCESS;
+		}
+		mdelay(100);
+	}
+	DEBUGOUT("Auto-Neg timedout.\n");
+	return -E1000_ERR_TIMEOUT;
+}
+
+/******************************************************************************
+* Raises the Management Data Clock
+*
+* hw - Struct containing variables accessed by shared code
+* ctrl - Device control register's current value
+******************************************************************************/
+static void
+e1000_raise_mdi_clk(struct e1000_hw *hw,
+                    uint32_t *ctrl)
+{
+	/* Raise the clock input to the Management Data Clock (by setting the MDC
+	 * bit), and then delay 10 microseconds.
+	 */
+	E1000_WRITE_REG(hw, CTRL, (*ctrl | E1000_CTRL_MDC));
+	E1000_WRITE_FLUSH(hw);
+	udelay(10);
+}
+
+/******************************************************************************
+* Lowers the Management Data Clock
+*
+* hw - Struct containing variables accessed by shared code
+* ctrl - Device control register's current value
+******************************************************************************/
+static void
+e1000_lower_mdi_clk(struct e1000_hw *hw,
+                    uint32_t *ctrl)
+{
+	/* Lower the clock input to the Management Data Clock (by clearing the MDC
+	 * bit), and then delay 10 microseconds.
+	 */
+	E1000_WRITE_REG(hw, CTRL, (*ctrl & ~E1000_CTRL_MDC));
+	E1000_WRITE_FLUSH(hw);
+	udelay(10);
+}
+
+/******************************************************************************
+* Shifts data bits out to the PHY
+*
+* hw - Struct containing variables accessed by shared code
+* data - Data to send out to the PHY
+* count - Number of bits to shift out
+*
+* Bits are shifted out in MSB to LSB order.
+******************************************************************************/
+static void
+e1000_shift_out_mdi_bits(struct e1000_hw *hw,
+                         uint32_t data,
+                         uint16_t count)
+{
+	uint32_t ctrl;
+	uint32_t mask;
+
+	/* We need to shift "count" number of bits out to the PHY. So, the value
+	 * in the "data" parameter will be shifted out to the PHY one bit at a 
+	 * time. In order to do this, "data" must be broken down into bits.
+	 */
+	mask = 0x01;
+	mask <<= (count - 1);
+	
+	ctrl = E1000_READ_REG(hw, CTRL);
+	
+	/* Set MDIO_DIR and MDC_DIR direction bits to be used as output pins. */
+	ctrl |= (E1000_CTRL_MDIO_DIR | E1000_CTRL_MDC_DIR);
+	
+	while(mask) {
+		/* A "1" is shifted out to the PHY by setting the MDIO bit to "1" and
+		 * then raising and lowering the Management Data Clock. A "0" is
+		 * shifted out to the PHY by setting the MDIO bit to "0" and then
+		 * raising and lowering the clock.
+		 */
+		if(data & mask) ctrl |= E1000_CTRL_MDIO;
+		else ctrl &= ~E1000_CTRL_MDIO;
+		
+		E1000_WRITE_REG(hw, CTRL, ctrl);
+		E1000_WRITE_FLUSH(hw);
+		
+		udelay(10);
+
+		e1000_raise_mdi_clk(hw, &ctrl);
+		e1000_lower_mdi_clk(hw, &ctrl);
+
+		mask = mask >> 1;
+	}
+}
+
+/******************************************************************************
+* Shifts data bits in from the PHY
+*
+* hw - Struct containing variables accessed by shared code
+*
+* Bits are shifted in in MSB to LSB order. 
+******************************************************************************/
+static uint16_t
+e1000_shift_in_mdi_bits(struct e1000_hw *hw)
+{
+	uint32_t ctrl;
+	uint16_t data = 0;
+	uint8_t i;
+
+	/* In order to read a register from the PHY, we need to shift in a total
+	 * of 18 bits from the PHY. The first two bit (turnaround) times are used
+	 * to avoid contention on the MDIO pin when a read operation is performed.
+	 * These two bits are ignored by us and thrown away. Bits are "shifted in"
+	 * by raising the input to the Management Data Clock (setting the MDC bit),
+	 * and then reading the value of the MDIO bit.
+	 */ 
+	ctrl = E1000_READ_REG(hw, CTRL);
+	
+	/* Clear MDIO_DIR (SWDPIO1) to indicate this bit is to be used as input. */
+	ctrl &= ~E1000_CTRL_MDIO_DIR;
+	ctrl &= ~E1000_CTRL_MDIO;
+	
+	E1000_WRITE_REG(hw, CTRL, ctrl);
+	E1000_WRITE_FLUSH(hw);
+	
+	/* Raise and Lower the clock before reading in the data. This accounts for
+	 * the turnaround bits. The first clock occurred when we clocked out the
+	 * last bit of the Register Address.
+	 */
+	e1000_raise_mdi_clk(hw, &ctrl);
+	e1000_lower_mdi_clk(hw, &ctrl);
+	
+	for(data = 0, i = 0; i < 16; i++) {
+		data = data << 1;
+		e1000_raise_mdi_clk(hw, &ctrl);
+		ctrl = E1000_READ_REG(hw, CTRL);
+		/* Check to see if we shifted in a "1". */
+		if(ctrl & E1000_CTRL_MDIO) data |= 1;
+		e1000_lower_mdi_clk(hw, &ctrl);
+	}
+	
+	e1000_raise_mdi_clk(hw, &ctrl);
+	e1000_lower_mdi_clk(hw, &ctrl);
+	
+	return data;
+}
+
+/*****************************************************************************
+* Reads the value from a PHY register, if the value is on a specific non zero
+* page, sets the page first.
+*
+* hw - Struct containing variables accessed by shared code
+* reg_addr - address of the PHY register to read
+******************************************************************************/
+static int
+e1000_read_phy_reg(struct e1000_hw *hw,
+                   uint32_t reg_addr,
+                   uint16_t *phy_data)
+{
+	uint32_t ret_val;
+
+	DEBUGFUNC("e1000_read_phy_reg");
+
+	if(hw->phy_type == e1000_phy_igp &&
+	   (reg_addr > MAX_PHY_MULTI_PAGE_REG)) {
+		if((ret_val = e1000_write_phy_reg_ex(hw, IGP01E1000_PHY_PAGE_SELECT,
+		                                     (uint16_t)reg_addr)))
+			return ret_val;
+	}
+
+	ret_val = e1000_read_phy_reg_ex(hw, IGP01E1000_PHY_PAGE_SELECT & reg_addr,
+	                                phy_data);
+
+	return ret_val;
+}
+
+static int
+e1000_read_phy_reg_ex(struct e1000_hw *hw,
+                      uint32_t reg_addr,
+                      uint16_t *phy_data)
+{
+	uint32_t i;
+	uint32_t mdic = 0;
+	const uint32_t phy_addr = 1;
+
+	DEBUGFUNC("e1000_read_phy_reg_ex");
+	
+	if(reg_addr > MAX_PHY_REG_ADDRESS) {
+		DEBUGOUT1("PHY Address %d is out of range\n", reg_addr);
+		return -E1000_ERR_PARAM;
+	}
+	
+	if(hw->mac_type > e1000_82543) {
+		/* Set up Op-code, Phy Address, and register address in the MDI
+		 * Control register.  The MAC will take care of interfacing with the
+		 * PHY to retrieve the desired data.
+		 */
+		mdic = ((reg_addr << E1000_MDIC_REG_SHIFT) |
+			(phy_addr << E1000_MDIC_PHY_SHIFT) | 
+			(E1000_MDIC_OP_READ));
+		
+		E1000_WRITE_REG(hw, MDIC, mdic);
+
+		/* Poll the ready bit to see if the MDI read completed */
+		for(i = 0; i < 64; i++) {
+			udelay(50);
+			mdic = E1000_READ_REG(hw, MDIC);
+			if(mdic & E1000_MDIC_READY) break;
+		}
+		if(!(mdic & E1000_MDIC_READY)) {
+			DEBUGOUT("MDI Read did not complete\n");
+			return -E1000_ERR_PHY;
+		}
+		if(mdic & E1000_MDIC_ERROR) {
+			DEBUGOUT("MDI Error\n");
+			return -E1000_ERR_PHY;
+		}
+		*phy_data = (uint16_t) mdic;
+	} else {
+		/* We must first send a preamble through the MDIO pin to signal the
+		 * beginning of an MII instruction.  This is done by sending 32
+		 * consecutive "1" bits.
+		 */
+		e1000_shift_out_mdi_bits(hw, PHY_PREAMBLE, PHY_PREAMBLE_SIZE);
+		
+		/* Now combine the next few fields that are required for a read
+		 * operation.  We use this method instead of calling the
+		 * e1000_shift_out_mdi_bits routine five different times. The format of
+		 * a MII read instruction consists of a shift out of 14 bits and is
+		 * defined as follows:
+		 *    <Preamble><SOF><Op Code><Phy Addr><Reg Addr>
+		 * followed by a shift in of 18 bits.  This first two bits shifted in
+		 * are TurnAround bits used to avoid contention on the MDIO pin when a
+		 * READ operation is performed.  These two bits are thrown away
+		 * followed by a shift in of 16 bits which contains the desired data.
+		 */
+		mdic = ((reg_addr) | (phy_addr << 5) | 
+			(PHY_OP_READ << 10) | (PHY_SOF << 12));
+		
+		e1000_shift_out_mdi_bits(hw, mdic, 14);
+		
+		/* Now that we've shifted out the read command to the MII, we need to
+		 * "shift in" the 16-bit value (18 total bits) of the requested PHY
+		 * register address.
+		 */
+		*phy_data = e1000_shift_in_mdi_bits(hw);
+	}
+	return E1000_SUCCESS;
+}
+
+/******************************************************************************
+* Writes a value to a PHY register
+*
+* hw - Struct containing variables accessed by shared code
+* reg_addr - address of the PHY register to write
+* data - data to write to the PHY
+******************************************************************************/
+static int 
+e1000_write_phy_reg(struct e1000_hw *hw,
+                    uint32_t reg_addr,
+                    uint16_t phy_data)
+{
+	uint32_t ret_val;
+
+	DEBUGFUNC("e1000_write_phy_reg");
+
+	if(hw->phy_type == e1000_phy_igp &&
+	   (reg_addr > MAX_PHY_MULTI_PAGE_REG)) {
+		if((ret_val = e1000_write_phy_reg_ex(hw, IGP01E1000_PHY_PAGE_SELECT,
+		                                     (uint16_t)reg_addr)))
+			return ret_val;
+	}
+
+	ret_val = e1000_write_phy_reg_ex(hw, IGP01E1000_PHY_PAGE_SELECT & reg_addr,
+	                                 phy_data);
+
+	return ret_val;
+}
+
+static int
+e1000_write_phy_reg_ex(struct e1000_hw *hw,
+                       uint32_t reg_addr,
+                       uint16_t phy_data)
+{
+	uint32_t i;
+	uint32_t mdic = 0;
+	const uint32_t phy_addr = 1;
+	
+	DEBUGFUNC("e1000_write_phy_reg_ex");
+	
+	if(reg_addr > MAX_PHY_REG_ADDRESS) {
+		DEBUGOUT1("PHY Address %d is out of range\n", reg_addr);
+		return -E1000_ERR_PARAM;
+	}
+	
+	if(hw->mac_type > e1000_82543) {
+		/* Set up Op-code, Phy Address, register address, and data intended
+		 * for the PHY register in the MDI Control register.  The MAC will take
+		 * care of interfacing with the PHY to send the desired data.
+		 */
+		mdic = (((uint32_t) phy_data) |
+			(reg_addr << E1000_MDIC_REG_SHIFT) |
+			(phy_addr << E1000_MDIC_PHY_SHIFT) | 
+			(E1000_MDIC_OP_WRITE));
+		
+		E1000_WRITE_REG(hw, MDIC, mdic);
+		
+		/* Poll the ready bit to see if the MDI read completed */
+		for(i = 0; i < 640; i++) {
+			udelay(5);
+			mdic = E1000_READ_REG(hw, MDIC);
+			if(mdic & E1000_MDIC_READY) break;
+		}
+		if(!(mdic & E1000_MDIC_READY)) {
+			DEBUGOUT("MDI Write did not complete\n");
+			return -E1000_ERR_PHY;
+		}
+	} else {
+		/* We'll need to use the SW defined pins to shift the write command
+		 * out to the PHY. We first send a preamble to the PHY to signal the
+		 * beginning of the MII instruction.  This is done by sending 32 
+		 * consecutive "1" bits.
+		 */
+		e1000_shift_out_mdi_bits(hw, PHY_PREAMBLE, PHY_PREAMBLE_SIZE);
+		
+		/* Now combine the remaining required fields that will indicate a 
+		 * write operation. We use this method instead of calling the
+		 * e1000_shift_out_mdi_bits routine for each field in the command. The
+		 * format of a MII write instruction is as follows:
+		 * <Preamble><SOF><Op Code><Phy Addr><Reg Addr><Turnaround><Data>.
+		 */
+		mdic = ((PHY_TURNAROUND) | (reg_addr << 2) | (phy_addr << 7) |
+			(PHY_OP_WRITE << 12) | (PHY_SOF << 14));
+		mdic <<= 16;
+		mdic |= (uint32_t) phy_data;
+		
+		e1000_shift_out_mdi_bits(hw, mdic, 32);
+	}
+
+	return E1000_SUCCESS;
+}
+
+/******************************************************************************
+* Returns the PHY to the power-on reset state
+*
+* hw - Struct containing variables accessed by shared code
+******************************************************************************/
+static void
+e1000_phy_hw_reset(struct e1000_hw *hw)
+{
+	uint32_t ctrl, ctrl_ext;
+
+	DEBUGFUNC("e1000_phy_hw_reset");
+	
+	DEBUGOUT("Resetting Phy...\n");
+	
+	if(hw->mac_type > e1000_82543) {
+		/* Read the device control register and assert the E1000_CTRL_PHY_RST
+		 * bit. Then, take it out of reset.
+		 */
+		ctrl = E1000_READ_REG(hw, CTRL);
+		E1000_WRITE_REG(hw, CTRL, ctrl | E1000_CTRL_PHY_RST);
+		E1000_WRITE_FLUSH(hw);
+		mdelay(10);
+		E1000_WRITE_REG(hw, CTRL, ctrl);
+		E1000_WRITE_FLUSH(hw);
+	} else {
+		/* Read the Extended Device Control Register, assert the PHY_RESET_DIR
+		 * bit to put the PHY into reset. Then, take it out of reset.
+		 */
+		ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);
+		ctrl_ext |= E1000_CTRL_EXT_SDP4_DIR;
+		ctrl_ext &= ~E1000_CTRL_EXT_SDP4_DATA;
+		E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
+		E1000_WRITE_FLUSH(hw);
+		mdelay(10);
+		ctrl_ext |= E1000_CTRL_EXT_SDP4_DATA;
+		E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
+		E1000_WRITE_FLUSH(hw);
+	}
+	udelay(150);
+}
+
+/******************************************************************************
+* Resets the PHY
+*
+* hw - Struct containing variables accessed by shared code
+*
+* Sets bit 15 of the MII Control regiser
+******************************************************************************/
+static int 
+e1000_phy_reset(struct e1000_hw *hw)
+{
+	int32_t ret_val;
+	uint16_t phy_data;
+
+	DEBUGFUNC("e1000_phy_reset");
+
+	if(hw->mac_type != e1000_82541_rev_2) {
+		if((ret_val = e1000_read_phy_reg(hw, PHY_CTRL, &phy_data)))
+			return ret_val;
+		
+		phy_data |= MII_CR_RESET;
+		if((ret_val = e1000_write_phy_reg(hw, PHY_CTRL, phy_data)))
+			return ret_val;
+		
+		udelay(1);
+	} else e1000_phy_hw_reset(hw);
+
+	if(hw->phy_type == e1000_phy_igp)
+		e1000_phy_init_script(hw);
+
+	return E1000_SUCCESS;
+}
+
+/******************************************************************************
+* Probes the expected PHY address for known PHY IDs
+*
+* hw - Struct containing variables accessed by shared code
+******************************************************************************/
+static int
+e1000_detect_gig_phy(struct e1000_hw *hw)
+{
+	int32_t phy_init_status, ret_val;
+	uint16_t phy_id_high, phy_id_low;
+	boolean_t match = FALSE;
+
+	DEBUGFUNC("e1000_detect_gig_phy");
+	
+	/* Read the PHY ID Registers to identify which PHY is onboard. */
+	if((ret_val = e1000_read_phy_reg(hw, PHY_ID1, &phy_id_high)))
+		return ret_val;
+
+	hw->phy_id = (uint32_t) (phy_id_high << 16);
+	udelay(20);
+	if((ret_val = e1000_read_phy_reg(hw, PHY_ID2, &phy_id_low)))
+		return ret_val;
+	
+	hw->phy_id |= (uint32_t) (phy_id_low & PHY_REVISION_MASK);
+#ifdef LINUX_DRIVER
+	hw->phy_revision = (uint32_t) phy_id_low & ~PHY_REVISION_MASK;
+#endif
+	
+	switch(hw->mac_type) {
+	case e1000_82543:
+		if(hw->phy_id == M88E1000_E_PHY_ID) match = TRUE;
+		break;
+	case e1000_82544:
+		if(hw->phy_id == M88E1000_I_PHY_ID) match = TRUE;
+		break;
+	case e1000_82540:
+	case e1000_82545:
+	case e1000_82545_rev_3:
+	case e1000_82546:
+	case e1000_82546_rev_3:
+		if(hw->phy_id == M88E1011_I_PHY_ID) match = TRUE;
+		break;
+	case e1000_82541:
+	case e1000_82541_rev_2:
+	case e1000_82547:
+	case e1000_82547_rev_2:
+		if(hw->phy_id == IGP01E1000_I_PHY_ID) match = TRUE;
+		break;
+	default:
+		DEBUGOUT1("Invalid MAC type %d\n", hw->mac_type);
+		return -E1000_ERR_CONFIG;
+	}
+	phy_init_status = e1000_set_phy_type(hw);
+
+	if ((match) && (phy_init_status == E1000_SUCCESS)) {
+		DEBUGOUT1("PHY ID 0x%X detected\n", hw->phy_id);
+		return E1000_SUCCESS;
+	}
+	DEBUGOUT1("Invalid PHY ID 0x%X\n", hw->phy_id);
+	return -E1000_ERR_PHY;
+}
+
+/******************************************************************************
+ * Sets up eeprom variables in the hw struct.  Must be called after mac_type
+ * is configured.
+ *
+ * hw - Struct containing variables accessed by shared code
+ *****************************************************************************/
+static void
+e1000_init_eeprom_params(struct e1000_hw *hw)
+{
+	struct e1000_eeprom_info *eeprom = &hw->eeprom;
+	uint32_t eecd = E1000_READ_REG(hw, EECD);
+	uint16_t eeprom_size;
+
+	DEBUGFUNC("e1000_init_eeprom_params");
+
+	switch (hw->mac_type) {
+	case e1000_82542_rev2_0:
+	case e1000_82542_rev2_1:
+	case e1000_82543:
+	case e1000_82544:
+		eeprom->type = e1000_eeprom_microwire;
+		eeprom->word_size = 64;
+		eeprom->opcode_bits = 3;
+		eeprom->address_bits = 6;
+		eeprom->delay_usec = 50;
+		break;
+	case e1000_82540:
+	case e1000_82545:
+	case e1000_82545_rev_3:
+	case e1000_82546:
+	case e1000_82546_rev_3:
+		eeprom->type = e1000_eeprom_microwire;
+		eeprom->opcode_bits = 3;
+		eeprom->delay_usec = 50;
+		if(eecd & E1000_EECD_SIZE) {
+			eeprom->word_size = 256;
+			eeprom->address_bits = 8;
+		} else {
+			eeprom->word_size = 64;
+			eeprom->address_bits = 6;
+		}
+		break;
+	case e1000_82541:
+	case e1000_82541_rev_2:
+	case e1000_82547:
+	case e1000_82547_rev_2:
+		if (eecd & E1000_EECD_TYPE) {
+			eeprom->type = e1000_eeprom_spi;
+			if (eecd & E1000_EECD_ADDR_BITS) {
+				eeprom->page_size = 32;
+				eeprom->address_bits = 16;
+			} else {
+				eeprom->page_size = 8;
+				eeprom->address_bits = 8;
+			}
+		} else {
+			eeprom->type = e1000_eeprom_microwire;
+			eeprom->opcode_bits = 3;
+			eeprom->delay_usec = 50;
+			if (eecd & E1000_EECD_ADDR_BITS) {
+				eeprom->word_size = 256;
+				eeprom->address_bits = 8;
+			} else {
+				eeprom->word_size = 64;
+				eeprom->address_bits = 6;
+			}
+		}
+		break;
+	default:
+		eeprom->type = e1000_eeprom_spi;
+		if (eecd & E1000_EECD_ADDR_BITS) {
+			eeprom->page_size = 32;
+			eeprom->address_bits = 16;
+		} else {
+			eeprom->page_size = 8;
+			eeprom->address_bits = 8;
+		}
+		break;
+	}
+
+	if (eeprom->type == e1000_eeprom_spi) {
+		eeprom->opcode_bits = 8;
+		eeprom->delay_usec = 1;
+		eeprom->word_size = 64;
+		if (e1000_read_eeprom(hw, EEPROM_CFG, 1, &eeprom_size) == 0) {
+			eeprom_size &= EEPROM_SIZE_MASK;
+
+			switch (eeprom_size) {
+			case EEPROM_SIZE_16KB:
+				eeprom->word_size = 8192;
+				break;
+			case EEPROM_SIZE_8KB:
+				eeprom->word_size = 4096;
+				break;
+			case EEPROM_SIZE_4KB:
+				eeprom->word_size = 2048;
+				break;
+			case EEPROM_SIZE_2KB:
+				eeprom->word_size = 1024;
+				break;
+			case EEPROM_SIZE_1KB:
+				eeprom->word_size = 512;
+				break;
+			case EEPROM_SIZE_512B:
+				eeprom->word_size = 256;
+				break;
+			case EEPROM_SIZE_128B:
+			default:
+				break;
+			}
+		}
+	}
+}
+
+/**
+ * e1000_reset - Reset the adapter
+ */
+
+static int
+e1000_reset(struct e1000_hw *hw)
+{
+	uint32_t pba;
+	/* Repartition Pba for greater than 9k mtu
+	 * To take effect CTRL.RST is required.
+	 */
+
+	if(hw->mac_type < e1000_82547) {
+		pba = E1000_PBA_48K;
+	} else {
+		pba = E1000_PBA_30K;
+	}
+	E1000_WRITE_REG(hw, PBA, pba);
+
+	/* flow control settings */
+#if 0
+	hw->fc_high_water = FC_DEFAULT_HI_THRESH;
+	hw->fc_low_water = FC_DEFAULT_LO_THRESH;
+	hw->fc_pause_time = FC_DEFAULT_TX_TIMER;
+	hw->fc_send_xon = 1;
+	hw->fc = hw->original_fc;
+#endif
+	
+	e1000_reset_hw(hw);
+	if(hw->mac_type >= e1000_82544)
+		E1000_WRITE_REG(hw, WUC, 0);
+	return e1000_init_hw(hw);
+}
+
+/**
+ * e1000_sw_init - Initialize general software structures (struct e1000_adapter)
+ * @adapter: board private structure to initialize
+ *
+ * e1000_sw_init initializes the Adapter private data structure.
+ * Fields are initialized based on PCI device information and
+ * OS network device settings (MTU size).
+ **/
+
+static int 
+e1000_sw_init(struct pci_device *pdev, struct e1000_hw *hw)
+{
+	int result;
+
+	/* PCI config space info */
+	pci_read_config_word(pdev, PCI_VENDOR_ID, &hw->vendor_id);
+	pci_read_config_word(pdev, PCI_DEVICE_ID, &hw->device_id);
+	pci_read_config_byte(pdev, PCI_REVISION, &hw->revision_id);
+#if 0
+	pci_read_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID,
+                             &hw->subsystem_vendor_id);
+	pci_read_config_word(pdev, PCI_SUBSYSTEM_ID, &hw->subsystem_id);
+#endif
+
+	pci_read_config_word(pdev, PCI_COMMAND, &hw->pci_cmd_word);
+
+	/* identify the MAC */
+
+	result = e1000_set_mac_type(hw);
+	if (result) {
+		E1000_ERR("Unknown MAC Type\n");
+		return result;
+	}
+
+	/* initialize eeprom parameters */
+
+	e1000_init_eeprom_params(hw);
+
+#if 0
+	if((hw->mac_type == e1000_82541) ||
+	   (hw->mac_type == e1000_82547) ||
+	   (hw->mac_type == e1000_82541_rev_2) ||
+	   (hw->mac_type == e1000_82547_rev_2))
+		hw->phy_init_script = 1;
+#endif
+
+	e1000_set_media_type(hw);
+
+#if 0
+	if(hw->mac_type < e1000_82543)
+		hw->report_tx_early = 0;
+	else
+		hw->report_tx_early = 1;
+
+	hw->wait_autoneg_complete = FALSE;
+#endif
+	hw->tbi_compatibility_en = TRUE;
+#if 0
+	hw->adaptive_ifs = TRUE;
+
+	/* Copper options */
+
+	if(hw->media_type == e1000_media_type_copper) {
+		hw->mdix = AUTO_ALL_MODES;
+		hw->disable_polarity_correction = FALSE;
+		hw->master_slave = E1000_MASTER_SLAVE;
+	}
+#endif
+	return E1000_SUCCESS;
+}
+
+static void fill_rx (void)
+{
+	struct e1000_rx_desc *rd;
+	rx_last = rx_tail;
+	rd = rx_base + rx_tail;
+	rx_tail = (rx_tail + 1) % 8;
+	memset (rd, 0, 16);
+	rd->buffer_addr = virt_to_bus(&packet);
+	E1000_WRITE_REG (&hw, RDT, rx_tail);
+}
+
+static void init_descriptor (void)
+{
+	unsigned long ptr;
+	unsigned long tctl;
+
+	ptr = virt_to_phys(tx_pool);
+	if (ptr & 0xf)
+		ptr = (ptr + 0x10) & (~0xf);
+
+	tx_base = phys_to_virt(ptr);
+
+	E1000_WRITE_REG (&hw, TDBAL, virt_to_bus(tx_base));
+	E1000_WRITE_REG (&hw, TDBAH, 0);
+	E1000_WRITE_REG (&hw, TDLEN, 128);
+
+	/* Setup the HW Tx Head and Tail descriptor pointers */
+
+	E1000_WRITE_REG (&hw, TDH, 0);
+	E1000_WRITE_REG (&hw, TDT, 0);
+	tx_tail = 0;
+
+	/* Program the Transmit Control Register */
+
+#ifdef LINUX_DRIVER_TCTL
+	tctl = E1000_READ_REG(&hw, TCTL);
+
+	tctl &= ~E1000_TCTL_CT;
+	tctl |= E1000_TCTL_EN | E1000_TCTL_PSP |
+		(E1000_COLLISION_THRESHOLD << E1000_CT_SHIFT);
+#else
+	tctl = E1000_TCTL_PSP | E1000_TCTL_EN |
+		(E1000_COLLISION_THRESHOLD << E1000_CT_SHIFT) | 
+		(E1000_HDX_COLLISION_DISTANCE << E1000_COLD_SHIFT);
+#endif
+
+	E1000_WRITE_REG (&hw, TCTL, tctl);
+
+	e1000_config_collision_dist(&hw);
+
+
+	rx_tail = 0;
+	/* disable receive */
+	E1000_WRITE_REG (&hw, RCTL, 0);
+	ptr = virt_to_phys(rx_pool);
+	if (ptr & 0xf)
+		ptr = (ptr + 0x10) & (~0xf);
+	rx_base = phys_to_virt(ptr);
+
+	/* Setup the Base and Length of the Rx Descriptor Ring */
+
+	E1000_WRITE_REG (&hw, RDBAL, virt_to_bus(rx_base));
+	E1000_WRITE_REG (&hw, RDBAH, 0);
+
+	E1000_WRITE_REG (&hw, RDLEN, 128);
+
+	/* Setup the HW Rx Head and Tail Descriptor Pointers */
+	E1000_WRITE_REG (&hw, RDH, 0);
+	E1000_WRITE_REG (&hw, RDT, 0);
+
+	E1000_WRITE_REG (&hw, RCTL, 
+		E1000_RCTL_EN | 
+		E1000_RCTL_BAM | 
+		E1000_RCTL_SZ_2048 | 
+		E1000_RCTL_MPE);
+	fill_rx();
+}
+
+
+
+/**************************************************************************
+POLL - Wait for a frame
+***************************************************************************/
+static int
+e1000_poll (struct nic *nic, int retrieve)
+{
+	/* return true if there's an ethernet packet ready to read */
+	/* nic->packet should contain data on return */
+	/* nic->packetlen should contain length of data */
+	struct e1000_rx_desc *rd;
+
+	rd = rx_base + rx_last;
+	if (!rd->status & E1000_RXD_STAT_DD)
+		return 0;
+
+	if ( ! retrieve ) return 1;
+
+	//      printf("recv: packet %! -> %! len=%d \n", packet+6, packet,rd->Length);
+	memcpy (nic->packet, packet, rd->length);
+	nic->packetlen = rd->length;
+	fill_rx ();
+	return 1;
+}
+
+/**************************************************************************
+TRANSMIT - Transmit a frame
+***************************************************************************/
+static void
+e1000_transmit (struct nic *nic, const char *d,	/* Destination */
+		    unsigned int type,	/* Type */
+		    unsigned int size,	/* size */
+		    const char *p)	/* Packet */
+{
+	/* send the packet to destination */
+	struct eth_hdr {
+		unsigned char dst_addr[ETH_ALEN];
+		unsigned char src_addr[ETH_ALEN];
+		unsigned short type;
+	} hdr;
+	struct e1000_tx_desc *txhd;	/* header */
+	struct e1000_tx_desc *txp;	/* payload */
+	DEBUGFUNC("send");
+
+	memcpy (&hdr.dst_addr, d, ETH_ALEN);
+	memcpy (&hdr.src_addr, nic->node_addr, ETH_ALEN);
+
+	hdr.type = htons (type);
+	txhd = tx_base + tx_tail;
+	tx_tail = (tx_tail + 1) % 8;
+	txp = tx_base + tx_tail;
+	tx_tail = (tx_tail + 1) % 8;
+
+	txhd->buffer_addr = virt_to_bus (&hdr);
+	txhd->lower.data = sizeof (hdr);
+	txhd->upper.data = 0;
+
+	txp->buffer_addr = virt_to_bus(p);
+	txp->lower.data = E1000_TXD_CMD_RPS | E1000_TXD_CMD_EOP | E1000_TXD_CMD_IFCS | size;
+	txp->upper.data = 0;
+
+	E1000_WRITE_REG (&hw, TDT, tx_tail);
+	while (!(txp->upper.data & E1000_TXD_STAT_DD)) {
+		udelay(10);	/* give the nic a chance to write to the register */
+		poll_interruptions();
+	}
+	DEBUGFUNC("send end");
+}
+
+
+/**************************************************************************
+DISABLE - Turn off ethernet interface
+***************************************************************************/
+static void e1000_disable (struct dev *dev __unused)
+{
+	/* Clear the transmit ring */
+	E1000_WRITE_REG (&hw, TDH, 0);
+	E1000_WRITE_REG (&hw, TDT, 0);
+
+	/* Clear the receive ring */
+	E1000_WRITE_REG (&hw, RDH, 0);
+	E1000_WRITE_REG (&hw, RDT, 0);
+
+	/* put the card in its initial state */
+	E1000_WRITE_REG (&hw, CTRL, E1000_CTRL_RST);
+
+	/* Turn off the ethernet interface */
+	E1000_WRITE_REG (&hw, RCTL, 0);
+	E1000_WRITE_REG (&hw, TCTL, 0);
+	mdelay (10);
+
+	/* Unmap my window to the device */
+	iounmap(hw.hw_addr);
+}
+
+/**************************************************************************
+IRQ - Enable, Disable, or Force interrupts
+***************************************************************************/
+static void e1000_irq(struct nic *nic __unused, irq_action_t action __unused)
+{
+  switch ( action ) {
+  case DISABLE :
+    break;
+  case ENABLE :
+    break;
+  case FORCE :
+    break;
+  }
+}
+
+#define IORESOURCE_IO	0x00000100     /* Resource type */
+#define BAR_0		0
+#define BAR_1		1
+#define BAR_5		5
+
+/**************************************************************************
+PROBE - Look for an adapter, this routine's visible to the outside
+You should omit the last argument struct pci_device * for a non-PCI NIC
+***************************************************************************/
+static int e1000_probe(struct dev *dev, struct pci_device *p)
+{
+	struct nic *nic = (struct nic *)dev;
+	unsigned long mmio_start, mmio_len;
+	int ret_val, i;
+
+	if (p == 0)
+		return 0;
+	/* Initialize hw with default values */
+	memset(&hw, 0, sizeof(hw));
+	hw.pdev = p;
+
+#if 1
+	/* Are these variables needed? */
+	hw.fc                    = e1000_fc_none;
+#if 0
+	hw.original_fc           = e1000_fc_none;
+#endif
+	hw.autoneg_failed        = 0;
+#if 0
+	hw.get_link_status       = TRUE;
+#endif
+#endif
+
+	mmio_start = pci_bar_start(p, PCI_BASE_ADDRESS_0);
+	mmio_len   = pci_bar_size(p,  PCI_BASE_ADDRESS_0);
+	hw.hw_addr = ioremap(mmio_start, mmio_len);
+
+	for(i = BAR_1; i <= BAR_5; i++) {
+		if(pci_bar_size(p, i) == 0)
+			continue;                
+		if(pci_find_capability(p, i) & IORESOURCE_IO) {
+			hw.io_base = pci_bar_start(p, i);
+			break;
+                }        
+	}
+
+	adjust_pci_device(p);
+
+	nic->ioaddr   = p->ioaddr & ~3;
+	nic->irqno    = 0;
+
+	/* From Matt Hortman <mbhortman@acpthinclient.com> */
+	/* MAC and Phy settings */
+
+	/* setup the private structure */
+	if (e1000_sw_init(p, &hw) < 0) {
+		iounmap(hw.hw_addr);
+		return 0;
+	}
+
+	/* make sure the EEPROM is good */
+
+	if (e1000_validate_eeprom_checksum(&hw) < 0) {
+		printf ("The EEPROM Checksum Is Not Valid\n");
+		iounmap(hw.hw_addr);
+		return 0;
+	}
+
+	/* copy the MAC address out of the EEPROM */
+
+	e1000_read_mac_addr(&hw);
+	memcpy (nic->node_addr, hw.mac_addr, ETH_ALEN);
+	
+	printf("Ethernet addr: %!\n", nic->node_addr);
+
+	/* reset the hardware with the new settings */
+
+	ret_val = e1000_reset(&hw);
+	if (ret_val < 0) {
+		if ((ret_val == -E1000_ERR_NOLINK) ||
+			(ret_val == -E1000_ERR_TIMEOUT)) {
+			E1000_ERR("Valid Link not detected\n");
+		} else {
+			E1000_ERR("Hardware Initialization Failed\n");
+		}
+		iounmap(hw.hw_addr);
+		return 0;
+	}
+	init_descriptor();
+
+	/* point to NIC specific routines */
+	dev->disable  = e1000_disable;
+	nic->poll     = e1000_poll;
+	nic->transmit = e1000_transmit;
+	nic->irq      = e1000_irq;
+
+	return 1;
+}
+
+static struct pci_id e1000_nics[] = {
+PCI_ROM(0x8086, 0x1000, "e1000-82542",               "Intel EtherExpressPro1000"),
+PCI_ROM(0x8086, 0x1001, "e1000-82543gc-fiber",       "Intel EtherExpressPro1000 82543GC Fiber"),
+PCI_ROM(0x8086, 0x1004, "e1000-82543gc-copper",	     "Intel EtherExpressPro1000 82543GC Copper"),
+PCI_ROM(0x8086, 0x1008, "e1000-82544ei-copper",      "Intel EtherExpressPro1000 82544EI Copper"),
+PCI_ROM(0x8086, 0x1009, "e1000-82544ei-fiber",       "Intel EtherExpressPro1000 82544EI Fiber"),
+PCI_ROM(0x8086, 0x100C, "e1000-82544gc-copper",      "Intel EtherExpressPro1000 82544GC Copper"),
+PCI_ROM(0x8086, 0x100D, "e1000-82544gc-lom",         "Intel EtherExpressPro1000 82544GC LOM"),
+PCI_ROM(0x8086, 0x100E, "e1000-82540em",     	     "Intel EtherExpressPro1000 82540EM"),
+PCI_ROM(0x8086, 0x100F, "e1000-82545em-copper",      "Intel EtherExpressPro1000 82545EM Copper"),
+PCI_ROM(0x8086, 0x1010, "e1000-82546eb-copper",      "Intel EtherExpressPro1000 82546EB Copper"),
+PCI_ROM(0x8086, 0x1011, "e1000-82545em-fiber",       "Intel EtherExpressPro1000 82545EM Fiber"),
+PCI_ROM(0x8086, 0x1012, "e1000-82546eb-fiber", 	     "Intel EtherExpressPro1000 82546EB Copper"),
+PCI_ROM(0x8086, 0x1013, "e1000-82541ei",	     "Intel EtherExpressPro1000 82541EI"),
+PCI_ROM(0x8086, 0x1015, "e1000-82540em-lom",  	     "Intel EtherExpressPro1000 82540EM LOM"),
+PCI_ROM(0x8086, 0x1016, "e1000-82540ep-lom",	     "Intel EtherExpressPro1000 82540EP LOM"),
+PCI_ROM(0x8086, 0x1017, "e1000-82540ep",	     "Intel EtherExpressPro1000 82540EP"),
+PCI_ROM(0x8086, 0x1018, "e1000-82541ep",	     "Intel EtherExpressPro1000 82541EP"),
+PCI_ROM(0x8086, 0x1019, "e1000-82547ei",	     "Intel EtherExpressPro1000 82547EI"),
+PCI_ROM(0x8086, 0x101d, "e1000-82546eb-quad-copper", "Intel EtherExpressPro1000 82546EB Quad Copper"),
+PCI_ROM(0x8086, 0x101e, "e1000-82540ep-lp",	     "Intel EtherExpressPro1000 82540EP LP"),
+PCI_ROM(0x8086, 0x1026, "e1000-82545gm-copper",	     "Intel EtherExpressPro1000 82545GM Copper"),
+PCI_ROM(0x8086, 0x1027, "e1000-82545gm-fiber",	     "Intel EtherExpressPro1000 82545GM Fiber"),
+PCI_ROM(0x8086, 0x1028, "e1000-82545gm-serdes",	     "Intel EtherExpressPro1000 82545GM SERDES"),
+PCI_ROM(0x8086, 0x1075, "e1000-82547gi",	     "Intel EtherExpressPro1000 82547GI"),
+PCI_ROM(0x8086, 0x1076, "e1000-82541gi",	     "Intel EtherExpressPro1000 82541GI"),
+PCI_ROM(0x8086, 0x1077, "e1000-82541gi-mobile",	     "Intel EtherExpressPro1000 82541GI Mobile"),
+PCI_ROM(0x8086, 0x1078, "e1000-82541er",	     "Intel EtherExpressPro1000 82541ER"),
+PCI_ROM(0x8086, 0x1079, "e1000-82546gb-copper",	     "Intel EtherExpressPro1000 82546GB Copper"),
+PCI_ROM(0x8086, 0x107a, "e1000-82546gb-fiber",	     "Intel EtherExpressPro1000 82546GB Fiber"),
+PCI_ROM(0x8086, 0x107b, "e1000-82546gb-serdes",	     "Intel EtherExpressPro1000 82546GB SERDES"),
+};
+
+struct pci_driver e1000_driver = {
+	.type     = NIC_DRIVER,
+	.name     = "E1000",
+	.probe    = e1000_probe,
+	.ids      = e1000_nics,
+	.id_count = sizeof(e1000_nics)/sizeof(e1000_nics[0]),
+	.class    = 0,
+};
diff -Naur grub-0.97.orig/netboot/e1000_hw.h grub-0.97/netboot/e1000_hw.h
--- grub-0.97.orig/netboot/e1000_hw.h	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/e1000_hw.h	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,2058 @@
+/*******************************************************************************
+
+  
+  Copyright(c) 1999 - 2003 Intel Corporation. All rights reserved.
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  Linux NICS <linux.nics@intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+
+*******************************************************************************/
+
+/* e1000_hw.h
+ * Structures, enums, and macros for the MAC
+ */
+
+#ifndef _E1000_HW_H_
+#define _E1000_HW_H_
+
+/* Forward declarations of structures used by the shared code */
+struct e1000_hw;
+struct e1000_hw_stats;
+
+/* Enumerated types specific to the e1000 hardware */
+/* Media Access Controlers */
+typedef enum {
+    e1000_undefined = 0,
+    e1000_82542_rev2_0,
+    e1000_82542_rev2_1,
+    e1000_82543,
+    e1000_82544,
+    e1000_82540,
+    e1000_82545,
+    e1000_82545_rev_3,
+    e1000_82546,
+    e1000_82546_rev_3,
+    e1000_82541,
+    e1000_82541_rev_2,
+    e1000_82547,
+    e1000_82547_rev_2,
+    e1000_num_macs
+} e1000_mac_type;
+
+typedef enum {
+    e1000_eeprom_uninitialized = 0,
+    e1000_eeprom_spi,
+    e1000_eeprom_microwire,
+    e1000_num_eeprom_types
+} e1000_eeprom_type;
+
+/* Media Types */
+typedef enum {
+	e1000_media_type_copper = 0,
+	e1000_media_type_fiber = 1,
+	e1000_media_type_internal_serdes = 2,
+	e1000_num_media_types
+} e1000_media_type;
+
+typedef enum {
+    e1000_10_half = 0,
+    e1000_10_full = 1,
+    e1000_100_half = 2,
+    e1000_100_full = 3
+} e1000_speed_duplex_type;
+
+/* Flow Control Settings */
+typedef enum {
+	e1000_fc_none = 0,
+	e1000_fc_rx_pause = 1,
+	e1000_fc_tx_pause = 2,
+	e1000_fc_full = 3,
+	e1000_fc_default = 0xFF
+} e1000_fc_type;
+
+/* PCI bus types */
+typedef enum {
+	e1000_bus_type_unknown = 0,
+	e1000_bus_type_pci,
+	e1000_bus_type_pcix,
+	e1000_bus_type_reserved
+} e1000_bus_type;
+
+/* PCI bus speeds */
+typedef enum {
+	e1000_bus_speed_unknown = 0,
+	e1000_bus_speed_33,
+	e1000_bus_speed_66,
+	e1000_bus_speed_100,
+	e1000_bus_speed_120,
+	e1000_bus_speed_133,
+	e1000_bus_speed_reserved
+} e1000_bus_speed;
+
+/* PCI bus widths */
+typedef enum {
+	e1000_bus_width_unknown = 0,
+	e1000_bus_width_32,
+	e1000_bus_width_64,
+	e1000_bus_width_reserved
+} e1000_bus_width;
+
+/* PHY status info structure and supporting enums */
+typedef enum {
+	e1000_cable_length_50 = 0,
+	e1000_cable_length_50_80,
+	e1000_cable_length_80_110,
+	e1000_cable_length_110_140,
+	e1000_cable_length_140,
+	e1000_cable_length_undefined = 0xFF
+} e1000_cable_length;
+
+typedef enum {
+    e1000_igp_cable_length_10  = 10,
+    e1000_igp_cable_length_20  = 20,
+    e1000_igp_cable_length_30  = 30,
+    e1000_igp_cable_length_40  = 40,
+    e1000_igp_cable_length_50  = 50,
+    e1000_igp_cable_length_60  = 60,
+    e1000_igp_cable_length_70  = 70,
+    e1000_igp_cable_length_80  = 80,
+    e1000_igp_cable_length_90  = 90,
+    e1000_igp_cable_length_100 = 100,
+    e1000_igp_cable_length_110 = 110,
+    e1000_igp_cable_length_120 = 120,
+    e1000_igp_cable_length_130 = 130,
+    e1000_igp_cable_length_140 = 140,
+    e1000_igp_cable_length_150 = 150,
+    e1000_igp_cable_length_160 = 160,
+    e1000_igp_cable_length_170 = 170,
+    e1000_igp_cable_length_180 = 180
+} e1000_igp_cable_length;
+
+typedef enum {
+	e1000_10bt_ext_dist_enable_normal = 0,
+	e1000_10bt_ext_dist_enable_lower,
+	e1000_10bt_ext_dist_enable_undefined = 0xFF
+} e1000_10bt_ext_dist_enable;
+
+typedef enum {
+	e1000_rev_polarity_normal = 0,
+	e1000_rev_polarity_reversed,
+	e1000_rev_polarity_undefined = 0xFF
+} e1000_rev_polarity;
+
+typedef enum {
+    e1000_downshift_normal = 0,
+    e1000_downshift_activated,
+    e1000_downshift_undefined = 0xFF
+} e1000_downshift;
+
+typedef enum {
+	e1000_polarity_reversal_enabled = 0,
+	e1000_polarity_reversal_disabled,
+	e1000_polarity_reversal_undefined = 0xFF
+} e1000_polarity_reversal;
+
+typedef enum {
+	e1000_auto_x_mode_manual_mdi = 0,
+	e1000_auto_x_mode_manual_mdix,
+	e1000_auto_x_mode_auto1,
+	e1000_auto_x_mode_auto2,
+	e1000_auto_x_mode_undefined = 0xFF
+} e1000_auto_x_mode;
+
+typedef enum {
+	e1000_1000t_rx_status_not_ok = 0,
+	e1000_1000t_rx_status_ok,
+	e1000_1000t_rx_status_undefined = 0xFF
+} e1000_1000t_rx_status;
+
+typedef enum {
+    e1000_phy_m88 = 0,
+    e1000_phy_igp,
+    e1000_phy_undefined = 0xFF
+} e1000_phy_type;
+
+typedef enum {
+    e1000_ms_hw_default = 0,
+    e1000_ms_force_master,
+    e1000_ms_force_slave,
+    e1000_ms_auto
+} e1000_ms_type;
+
+typedef enum {
+    e1000_ffe_config_enabled = 0,
+    e1000_ffe_config_active,
+    e1000_ffe_config_blocked
+} e1000_ffe_config;
+
+typedef enum {
+    e1000_dsp_config_disabled = 0,
+    e1000_dsp_config_enabled,
+    e1000_dsp_config_activated,
+    e1000_dsp_config_undefined = 0xFF
+} e1000_dsp_config;
+
+struct e1000_phy_info {
+	e1000_cable_length cable_length;
+	e1000_10bt_ext_dist_enable extended_10bt_distance;
+	e1000_rev_polarity cable_polarity;
+	e1000_downshift downshift;
+	e1000_polarity_reversal polarity_correction;
+	e1000_auto_x_mode mdix_mode;
+	e1000_1000t_rx_status local_rx;
+	e1000_1000t_rx_status remote_rx;
+};
+
+struct e1000_phy_stats {
+	uint32_t idle_errors;
+	uint32_t receive_errors;
+};
+
+struct e1000_eeprom_info {
+    e1000_eeprom_type type;
+    uint16_t word_size;
+    uint16_t opcode_bits;
+    uint16_t address_bits;
+    uint16_t delay_usec;
+    uint16_t page_size;
+};
+
+
+
+/* Error Codes */
+#define E1000_SUCCESS      0
+#define E1000_ERR_EEPROM   1
+#define E1000_ERR_PHY      2
+#define E1000_ERR_CONFIG   3
+#define E1000_ERR_PARAM    4
+#define E1000_ERR_MAC_TYPE 5
+#define E1000_ERR_PHY_TYPE 6
+#define E1000_ERR_NOLINK   7
+#define E1000_ERR_TIMEOUT  8
+
+#define E1000_READ_REG_IO(a, reg) \
+	e1000_read_reg_io((a), E1000_##reg)
+#define E1000_WRITE_REG_IO(a, reg, val) \
+	e1000_write_reg_io((a), E1000_##reg, val)
+
+/* PCI Device IDs */
+#define E1000_DEV_ID_82542               0x1000
+#define E1000_DEV_ID_82543GC_FIBER       0x1001
+#define E1000_DEV_ID_82543GC_COPPER      0x1004
+#define E1000_DEV_ID_82544EI_COPPER      0x1008
+#define E1000_DEV_ID_82544EI_FIBER       0x1009
+#define E1000_DEV_ID_82544GC_COPPER      0x100C
+#define E1000_DEV_ID_82544GC_LOM         0x100D
+#define E1000_DEV_ID_82540EM             0x100E
+#define E1000_DEV_ID_82540EM_LOM         0x1015
+#define E1000_DEV_ID_82540EP_LOM         0x1016
+#define E1000_DEV_ID_82540EP             0x1017
+#define E1000_DEV_ID_82540EP_LP          0x101E
+#define E1000_DEV_ID_82545EM_COPPER      0x100F
+#define E1000_DEV_ID_82545EM_FIBER       0x1011
+#define E1000_DEV_ID_82545GM_COPPER      0x1026
+#define E1000_DEV_ID_82545GM_FIBER       0x1027
+#define E1000_DEV_ID_82545GM_SERDES      0x1028
+#define E1000_DEV_ID_82546EB_COPPER      0x1010
+#define E1000_DEV_ID_82546EB_FIBER       0x1012
+#define E1000_DEV_ID_82546EB_QUAD_COPPER 0x101D
+#define E1000_DEV_ID_82541EI             0x1013
+#define E1000_DEV_ID_82541EI_MOBILE      0x1018
+#define E1000_DEV_ID_82541ER             0x1078
+#define E1000_DEV_ID_82547GI             0x1075
+#define E1000_DEV_ID_82541GI             0x1076
+#define E1000_DEV_ID_82541GI_MOBILE      0x1077
+#define E1000_DEV_ID_82546GB_COPPER      0x1079
+#define E1000_DEV_ID_82546GB_FIBER       0x107A
+#define E1000_DEV_ID_82546GB_SERDES      0x107B
+#define E1000_DEV_ID_82547EI             0x1019
+
+#define NODE_ADDRESS_SIZE 6
+#define ETH_LENGTH_OF_ADDRESS 6
+
+/* MAC decode size is 128K - This is the size of BAR0 */
+#define MAC_DECODE_SIZE (128 * 1024)
+
+#define E1000_82542_2_0_REV_ID 2
+#define E1000_82542_2_1_REV_ID 3
+
+#define SPEED_10    10
+#define SPEED_100   100
+#define SPEED_1000  1000
+#define HALF_DUPLEX 1
+#define FULL_DUPLEX 2
+
+/* The sizes (in bytes) of a ethernet packet */
+#define ENET_HEADER_SIZE             14
+#define MAXIMUM_ETHERNET_FRAME_SIZE  1518 /* With FCS */
+#define MINIMUM_ETHERNET_FRAME_SIZE  64   /* With FCS */
+#define ETHERNET_FCS_SIZE            4
+#define MAXIMUM_ETHERNET_PACKET_SIZE \
+    (MAXIMUM_ETHERNET_FRAME_SIZE - ETHERNET_FCS_SIZE)
+#define MINIMUM_ETHERNET_PACKET_SIZE \
+    (MINIMUM_ETHERNET_FRAME_SIZE - ETHERNET_FCS_SIZE)
+#define CRC_LENGTH                   ETHERNET_FCS_SIZE
+#define MAX_JUMBO_FRAME_SIZE         0x3F00
+
+
+/* 802.1q VLAN Packet Sizes */
+#define VLAN_TAG_SIZE                     4     /* 802.3ac tag (not DMAed) */
+
+/* Ethertype field values */
+#define ETHERNET_IEEE_VLAN_TYPE 0x8100  /* 802.3ac packet */
+#define ETHERNET_IP_TYPE        0x0800  /* IP packets */
+#define ETHERNET_ARP_TYPE       0x0806  /* Address Resolution Protocol (ARP) */
+
+/* Packet Header defines */
+#define IP_PROTOCOL_TCP    6
+#define IP_PROTOCOL_UDP    0x11
+
+/* This defines the bits that are set in the Interrupt Mask
+ * Set/Read Register.  Each bit is documented below:
+ *   o RXDMT0 = Receive Descriptor Minimum Threshold hit (ring 0)
+ *   o RXSEQ  = Receive Sequence Error 
+ */
+#define POLL_IMS_ENABLE_MASK ( \
+    E1000_IMS_RXDMT0 |         \
+    E1000_IMS_RXSEQ)
+
+/* This defines the bits that are set in the Interrupt Mask
+ * Set/Read Register.  Each bit is documented below:
+ *   o RXT0   = Receiver Timer Interrupt (ring 0)
+ *   o TXDW   = Transmit Descriptor Written Back
+ *   o RXDMT0 = Receive Descriptor Minimum Threshold hit (ring 0)
+ *   o RXSEQ  = Receive Sequence Error
+ *   o LSC    = Link Status Change
+ */
+#define IMS_ENABLE_MASK ( \
+    E1000_IMS_RXT0   |    \
+    E1000_IMS_TXDW   |    \
+    E1000_IMS_RXDMT0 |    \
+    E1000_IMS_RXSEQ  |    \
+    E1000_IMS_LSC)
+
+/* Number of high/low register pairs in the RAR. The RAR (Receive Address
+ * Registers) holds the directed and multicast addresses that we monitor. We
+ * reserve one of these spots for our directed address, allowing us room for
+ * E1000_RAR_ENTRIES - 1 multicast addresses. 
+ */
+#define E1000_RAR_ENTRIES 15
+
+#define MIN_NUMBER_OF_DESCRIPTORS 8
+#define MAX_NUMBER_OF_DESCRIPTORS 0xFFF8
+
+/* Receive Descriptor */
+struct e1000_rx_desc {
+    uint64_t buffer_addr; /* Address of the descriptor's data buffer */
+    uint16_t length;     /* Length of data DMAed into data buffer */
+    uint16_t csum;       /* Packet checksum */
+    uint8_t status;      /* Descriptor status */
+    uint8_t errors;      /* Descriptor Errors */
+    uint16_t special;
+};
+
+/* Receive Decriptor bit definitions */
+#define E1000_RXD_STAT_DD       0x01    /* Descriptor Done */
+#define E1000_RXD_STAT_EOP      0x02    /* End of Packet */
+#define E1000_RXD_STAT_IXSM     0x04    /* Ignore checksum */
+#define E1000_RXD_STAT_VP       0x08    /* IEEE VLAN Packet */
+#define E1000_RXD_STAT_TCPCS    0x20    /* TCP xsum calculated */
+#define E1000_RXD_STAT_IPCS     0x40    /* IP xsum calculated */
+#define E1000_RXD_STAT_PIF      0x80    /* passed in-exact filter */
+#define E1000_RXD_ERR_CE        0x01    /* CRC Error */
+#define E1000_RXD_ERR_SE        0x02    /* Symbol Error */
+#define E1000_RXD_ERR_SEQ       0x04    /* Sequence Error */
+#define E1000_RXD_ERR_CXE       0x10    /* Carrier Extension Error */
+#define E1000_RXD_ERR_TCPE      0x20    /* TCP/UDP Checksum Error */
+#define E1000_RXD_ERR_IPE       0x40    /* IP Checksum Error */
+#define E1000_RXD_ERR_RXE       0x80    /* Rx Data Error */
+#define E1000_RXD_SPC_VLAN_MASK 0x0FFF  /* VLAN ID is in lower 12 bits */
+#define E1000_RXD_SPC_PRI_MASK  0xE000  /* Priority is in upper 3 bits */
+#define E1000_RXD_SPC_PRI_SHIFT 0x000D  /* Priority is in upper 3 of 16 */
+#define E1000_RXD_SPC_CFI_MASK  0x1000  /* CFI is bit 12 */
+#define E1000_RXD_SPC_CFI_SHIFT 0x000C  /* CFI is bit 12 */
+
+/* mask to determine if packets should be dropped due to frame errors */
+#define E1000_RXD_ERR_FRAME_ERR_MASK ( \
+    E1000_RXD_ERR_CE  |                \
+    E1000_RXD_ERR_SE  |                \
+    E1000_RXD_ERR_SEQ |                \
+    E1000_RXD_ERR_CXE |                \
+    E1000_RXD_ERR_RXE)
+
+/* Transmit Descriptor */
+struct e1000_tx_desc {
+    uint64_t buffer_addr;       /* Address of the descriptor's data buffer */
+    union {
+        uint32_t data;
+        struct {
+            uint16_t length;    /* Data buffer length */
+            uint8_t cso;        /* Checksum offset */
+            uint8_t cmd;        /* Descriptor control */
+        } flags;
+    } lower;
+    union {
+        uint32_t data;
+        struct {
+            uint8_t status;     /* Descriptor status */
+            uint8_t css;        /* Checksum start */
+            uint16_t special;
+        } fields;
+    } upper;
+};
+
+/* Transmit Descriptor bit definitions */
+#define E1000_TXD_DTYP_D     0x00100000 /* Data Descriptor */
+#define E1000_TXD_DTYP_C     0x00000000 /* Context Descriptor */
+#define E1000_TXD_POPTS_IXSM 0x01       /* Insert IP checksum */
+#define E1000_TXD_POPTS_TXSM 0x02       /* Insert TCP/UDP checksum */
+#define E1000_TXD_CMD_EOP    0x01000000 /* End of Packet */
+#define E1000_TXD_CMD_IFCS   0x02000000 /* Insert FCS (Ethernet CRC) */
+#define E1000_TXD_CMD_IC     0x04000000 /* Insert Checksum */
+#define E1000_TXD_CMD_RS     0x08000000 /* Report Status */
+#define E1000_TXD_CMD_RPS    0x10000000 /* Report Packet Sent */
+#define E1000_TXD_CMD_DEXT   0x20000000 /* Descriptor extension (0 = legacy) */
+#define E1000_TXD_CMD_VLE    0x40000000 /* Add VLAN tag */
+#define E1000_TXD_CMD_IDE    0x80000000 /* Enable Tidv register */
+#define E1000_TXD_STAT_DD    0x00000001 /* Descriptor Done */
+#define E1000_TXD_STAT_EC    0x00000002 /* Excess Collisions */
+#define E1000_TXD_STAT_LC    0x00000004 /* Late Collisions */
+#define E1000_TXD_STAT_TU    0x00000008 /* Transmit underrun */
+#define E1000_TXD_CMD_TCP    0x01000000 /* TCP packet */
+#define E1000_TXD_CMD_IP     0x02000000 /* IP packet */
+#define E1000_TXD_CMD_TSE    0x04000000 /* TCP Seg enable */
+#define E1000_TXD_STAT_TC    0x00000004 /* Tx Underrun */
+
+/* Offload Context Descriptor */
+struct e1000_context_desc {
+    union {
+        uint32_t ip_config;
+        struct {
+            uint8_t ipcss;      /* IP checksum start */
+            uint8_t ipcso;      /* IP checksum offset */
+            uint16_t ipcse;     /* IP checksum end */
+        } ip_fields;
+    } lower_setup;
+    union {
+        uint32_t tcp_config;
+        struct {
+            uint8_t tucss;      /* TCP checksum start */
+            uint8_t tucso;      /* TCP checksum offset */
+            uint16_t tucse;     /* TCP checksum end */
+        } tcp_fields;
+    } upper_setup;
+    uint32_t cmd_and_length;    /* */
+    union {
+        uint32_t data;
+        struct {
+            uint8_t status;     /* Descriptor status */
+            uint8_t hdr_len;    /* Header length */
+            uint16_t mss;       /* Maximum segment size */
+        } fields;
+    } tcp_seg_setup;
+};
+
+/* Offload data descriptor */
+struct e1000_data_desc {
+    uint64_t buffer_addr;       /* Address of the descriptor's buffer address */
+    union {
+        uint32_t data;
+        struct {
+            uint16_t length;    /* Data buffer length */
+            uint8_t typ_len_ext;        /* */
+            uint8_t cmd;        /* */
+        } flags;
+    } lower;
+    union {
+        uint32_t data;
+        struct {
+            uint8_t status;     /* Descriptor status */
+            uint8_t popts;      /* Packet Options */
+            uint16_t special;   /* */
+        } fields;
+    } upper;
+};
+
+/* Filters */
+#define E1000_NUM_UNICAST          16   /* Unicast filter entries */
+#define E1000_MC_TBL_SIZE          128  /* Multicast Filter Table (4096 bits) */
+#define E1000_VLAN_FILTER_TBL_SIZE 128  /* VLAN Filter Table (4096 bits) */
+
+
+/* Receive Address Register */
+struct e1000_rar {
+    volatile uint32_t low;      /* receive address low */
+    volatile uint32_t high;     /* receive address high */
+};
+
+/* Number of entries in the Multicast Table Array (MTA). */
+#define E1000_NUM_MTA_REGISTERS 128
+
+/* IPv4 Address Table Entry */
+struct e1000_ipv4_at_entry {
+    volatile uint32_t ipv4_addr;        /* IP Address (RW) */
+    volatile uint32_t reserved;
+};
+
+/* Four wakeup IP addresses are supported */
+#define E1000_WAKEUP_IP_ADDRESS_COUNT_MAX 4
+#define E1000_IP4AT_SIZE                  E1000_WAKEUP_IP_ADDRESS_COUNT_MAX
+#define E1000_IP6AT_SIZE                  1
+
+/* IPv6 Address Table Entry */
+struct e1000_ipv6_at_entry {
+    volatile uint8_t ipv6_addr[16];
+};
+
+/* Flexible Filter Length Table Entry */
+struct e1000_fflt_entry {
+    volatile uint32_t length;   /* Flexible Filter Length (RW) */
+    volatile uint32_t reserved;
+};
+
+/* Flexible Filter Mask Table Entry */
+struct e1000_ffmt_entry {
+    volatile uint32_t mask;     /* Flexible Filter Mask (RW) */
+    volatile uint32_t reserved;
+};
+
+/* Flexible Filter Value Table Entry */
+struct e1000_ffvt_entry {
+    volatile uint32_t value;    /* Flexible Filter Value (RW) */
+    volatile uint32_t reserved;
+};
+
+/* Four Flexible Filters are supported */
+#define E1000_FLEXIBLE_FILTER_COUNT_MAX 4
+
+/* Each Flexible Filter is at most 128 (0x80) bytes in length */
+#define E1000_FLEXIBLE_FILTER_SIZE_MAX  128
+
+#define E1000_FFLT_SIZE E1000_FLEXIBLE_FILTER_COUNT_MAX
+#define E1000_FFMT_SIZE E1000_FLEXIBLE_FILTER_SIZE_MAX
+#define E1000_FFVT_SIZE E1000_FLEXIBLE_FILTER_SIZE_MAX
+
+/* Register Set. (82543, 82544)
+ *
+ * Registers are defined to be 32 bits and  should be accessed as 32 bit values.
+ * These registers are physically located on the NIC, but are mapped into the 
+ * host memory address space.
+ *
+ * RW - register is both readable and writable
+ * RO - register is read only
+ * WO - register is write only
+ * R/clr - register is read only and is cleared when read
+ * A - register array
+ */
+#define E1000_CTRL     0x00000  /* Device Control - RW */
+#define E1000_CTRL_DUP 0x00004  /* Device Control Duplicate (Shadow) - RW */
+#define E1000_STATUS   0x00008  /* Device Status - RO */
+#define E1000_EECD     0x00010  /* EEPROM/Flash Control - RW */
+#define E1000_EERD     0x00014  /* EEPROM Read - RW */
+#define E1000_CTRL_EXT 0x00018  /* Extended Device Control - RW */
+#define E1000_FLA      0x0001C  /* Flash Access - RW */
+#define E1000_MDIC     0x00020  /* MDI Control - RW */
+#define E1000_FCAL     0x00028  /* Flow Control Address Low - RW */
+#define E1000_FCAH     0x0002C  /* Flow Control Address High -RW */
+#define E1000_FCT      0x00030  /* Flow Control Type - RW */
+#define E1000_VET      0x00038  /* VLAN Ether Type - RW */
+#define E1000_ICR      0x000C0  /* Interrupt Cause Read - R/clr */
+#define E1000_ITR      0x000C4  /* Interrupt Throttling Rate - RW */
+#define E1000_ICS      0x000C8  /* Interrupt Cause Set - WO */
+#define E1000_IMS      0x000D0  /* Interrupt Mask Set - RW */
+#define E1000_IMC      0x000D8  /* Interrupt Mask Clear - WO */
+#define E1000_RCTL     0x00100  /* RX Control - RW */
+#define E1000_FCTTV    0x00170  /* Flow Control Transmit Timer Value - RW */
+#define E1000_TXCW     0x00178  /* TX Configuration Word - RW */
+#define E1000_RXCW     0x00180  /* RX Configuration Word - RO */
+#define E1000_TCTL     0x00400  /* TX Control - RW */
+#define E1000_TIPG     0x00410  /* TX Inter-packet gap -RW */
+#define E1000_TBT      0x00448  /* TX Burst Timer - RW */
+#define E1000_AIT      0x00458  /* Adaptive Interframe Spacing Throttle - RW */
+#define E1000_LEDCTL   0x00E00  /* LED Control - RW */
+#define E1000_PBA      0x01000  /* Packet Buffer Allocation - RW */
+#define E1000_FCRTL    0x02160  /* Flow Control Receive Threshold Low - RW */
+#define E1000_FCRTH    0x02168  /* Flow Control Receive Threshold High - RW */
+#define E1000_RDBAL    0x02800  /* RX Descriptor Base Address Low - RW */
+#define E1000_RDBAH    0x02804  /* RX Descriptor Base Address High - RW */
+#define E1000_RDLEN    0x02808  /* RX Descriptor Length - RW */
+#define E1000_RDH      0x02810  /* RX Descriptor Head - RW */
+#define E1000_RDT      0x02818  /* RX Descriptor Tail - RW */
+#define E1000_RDTR     0x02820  /* RX Delay Timer - RW */
+#define E1000_RXDCTL   0x02828  /* RX Descriptor Control - RW */
+#define E1000_RADV     0x0282C  /* RX Interrupt Absolute Delay Timer - RW */
+#define E1000_RSRPD    0x02C00  /* RX Small Packet Detect - RW */
+#define E1000_TXDMAC   0x03000  /* TX DMA Control - RW */
+#define E1000_TDFH     0x03410  /* TX Data FIFO Head - RW */
+#define E1000_TDFT     0x03418  /* TX Data FIFO Tail - RW */
+#define E1000_TDFHS    0x03420  /* TX Data FIFO Head Saved - RW */
+#define E1000_TDFTS    0x03428  /* TX Data FIFO Tail Saved - RW */
+#define E1000_TDFPC    0x03430  /* TX Data FIFO Packet Count - RW */
+#define E1000_TDBAL    0x03800  /* TX Descriptor Base Address Low - RW */
+#define E1000_TDBAH    0x03804  /* TX Descriptor Base Address High - RW */
+#define E1000_TDLEN    0x03808  /* TX Descriptor Length - RW */
+#define E1000_TDH      0x03810  /* TX Descriptor Head - RW */
+#define E1000_TDT      0x03818  /* TX Descripotr Tail - RW */
+#define E1000_TIDV     0x03820  /* TX Interrupt Delay Value - RW */
+#define E1000_TXDCTL   0x03828  /* TX Descriptor Control - RW */
+#define E1000_TADV     0x0382C  /* TX Interrupt Absolute Delay Val - RW */
+#define E1000_TSPMT    0x03830  /* TCP Segmentation PAD & Min Threshold - RW */
+#define E1000_CRCERRS  0x04000  /* CRC Error Count - R/clr */
+#define E1000_ALGNERRC 0x04004  /* Alignment Error Count - R/clr */
+#define E1000_SYMERRS  0x04008  /* Symbol Error Count - R/clr */
+#define E1000_RXERRC   0x0400C  /* Receive Error Count - R/clr */
+#define E1000_MPC      0x04010  /* Missed Packet Count - R/clr */
+#define E1000_SCC      0x04014  /* Single Collision Count - R/clr */
+#define E1000_ECOL     0x04018  /* Excessive Collision Count - R/clr */
+#define E1000_MCC      0x0401C  /* Multiple Collision Count - R/clr */
+#define E1000_LATECOL  0x04020  /* Late Collision Count - R/clr */
+#define E1000_COLC     0x04028  /* Collision Count - R/clr */
+#define E1000_DC       0x04030  /* Defer Count - R/clr */
+#define E1000_TNCRS    0x04034  /* TX-No CRS - R/clr */
+#define E1000_SEC      0x04038  /* Sequence Error Count - R/clr */
+#define E1000_CEXTERR  0x0403C  /* Carrier Extension Error Count - R/clr */
+#define E1000_RLEC     0x04040  /* Receive Length Error Count - R/clr */
+#define E1000_XONRXC   0x04048  /* XON RX Count - R/clr */
+#define E1000_XONTXC   0x0404C  /* XON TX Count - R/clr */
+#define E1000_XOFFRXC  0x04050  /* XOFF RX Count - R/clr */
+#define E1000_XOFFTXC  0x04054  /* XOFF TX Count - R/clr */
+#define E1000_FCRUC    0x04058  /* Flow Control RX Unsupported Count- R/clr */
+#define E1000_PRC64    0x0405C  /* Packets RX (64 bytes) - R/clr */
+#define E1000_PRC127   0x04060  /* Packets RX (65-127 bytes) - R/clr */
+#define E1000_PRC255   0x04064  /* Packets RX (128-255 bytes) - R/clr */
+#define E1000_PRC511   0x04068  /* Packets RX (255-511 bytes) - R/clr */
+#define E1000_PRC1023  0x0406C  /* Packets RX (512-1023 bytes) - R/clr */
+#define E1000_PRC1522  0x04070  /* Packets RX (1024-1522 bytes) - R/clr */
+#define E1000_GPRC     0x04074  /* Good Packets RX Count - R/clr */
+#define E1000_BPRC     0x04078  /* Broadcast Packets RX Count - R/clr */
+#define E1000_MPRC     0x0407C  /* Multicast Packets RX Count - R/clr */
+#define E1000_GPTC     0x04080  /* Good Packets TX Count - R/clr */
+#define E1000_GORCL    0x04088  /* Good Octets RX Count Low - R/clr */
+#define E1000_GORCH    0x0408C  /* Good Octets RX Count High - R/clr */
+#define E1000_GOTCL    0x04090  /* Good Octets TX Count Low - R/clr */
+#define E1000_GOTCH    0x04094  /* Good Octets TX Count High - R/clr */
+#define E1000_RNBC     0x040A0  /* RX No Buffers Count - R/clr */
+#define E1000_RUC      0x040A4  /* RX Undersize Count - R/clr */
+#define E1000_RFC      0x040A8  /* RX Fragment Count - R/clr */
+#define E1000_ROC      0x040AC  /* RX Oversize Count - R/clr */
+#define E1000_RJC      0x040B0  /* RX Jabber Count - R/clr */
+#define E1000_MGTPRC   0x040B4  /* Management Packets RX Count - R/clr */
+#define E1000_MGTPDC   0x040B8  /* Management Packets Dropped Count - R/clr */
+#define E1000_MGTPTC   0x040BC  /* Management Packets TX Count - R/clr */
+#define E1000_TORL     0x040C0  /* Total Octets RX Low - R/clr */
+#define E1000_TORH     0x040C4  /* Total Octets RX High - R/clr */
+#define E1000_TOTL     0x040C8  /* Total Octets TX Low - R/clr */
+#define E1000_TOTH     0x040CC  /* Total Octets TX High - R/clr */
+#define E1000_TPR      0x040D0  /* Total Packets RX - R/clr */
+#define E1000_TPT      0x040D4  /* Total Packets TX - R/clr */
+#define E1000_PTC64    0x040D8  /* Packets TX (64 bytes) - R/clr */
+#define E1000_PTC127   0x040DC  /* Packets TX (65-127 bytes) - R/clr */
+#define E1000_PTC255   0x040E0  /* Packets TX (128-255 bytes) - R/clr */
+#define E1000_PTC511   0x040E4  /* Packets TX (256-511 bytes) - R/clr */
+#define E1000_PTC1023  0x040E8  /* Packets TX (512-1023 bytes) - R/clr */
+#define E1000_PTC1522  0x040EC  /* Packets TX (1024-1522 Bytes) - R/clr */
+#define E1000_MPTC     0x040F0  /* Multicast Packets TX Count - R/clr */
+#define E1000_BPTC     0x040F4  /* Broadcast Packets TX Count - R/clr */
+#define E1000_TSCTC    0x040F8  /* TCP Segmentation Context TX - R/clr */
+#define E1000_TSCTFC   0x040FC  /* TCP Segmentation Context TX Fail - R/clr */
+#define E1000_RXCSUM   0x05000  /* RX Checksum Control - RW */
+#define E1000_MTA      0x05200  /* Multicast Table Array - RW Array */
+#define E1000_RA       0x05400  /* Receive Address - RW Array */
+#define E1000_VFTA     0x05600  /* VLAN Filter Table Array - RW Array */
+#define E1000_WUC      0x05800  /* Wakeup Control - RW */
+#define E1000_WUFC     0x05808  /* Wakeup Filter Control - RW */
+#define E1000_WUS      0x05810  /* Wakeup Status - RO */
+#define E1000_MANC     0x05820  /* Management Control - RW */
+#define E1000_IPAV     0x05838  /* IP Address Valid - RW */
+#define E1000_IP4AT    0x05840  /* IPv4 Address Table - RW Array */
+#define E1000_IP6AT    0x05880  /* IPv6 Address Table - RW Array */
+#define E1000_WUPL     0x05900  /* Wakeup Packet Length - RW */
+#define E1000_WUPM     0x05A00  /* Wakeup Packet Memory - RO A */
+#define E1000_FFLT     0x05F00  /* Flexible Filter Length Table - RW Array */
+#define E1000_FFMT     0x09000  /* Flexible Filter Mask Table - RW Array */
+#define E1000_FFVT     0x09800  /* Flexible Filter Value Table - RW Array */
+
+/* Register Set (82542)
+ *
+ * Some of the 82542 registers are located at different offsets than they are
+ * in more current versions of the 8254x. Despite the difference in location,
+ * the registers function in the same manner.
+ */
+#define E1000_82542_CTRL     E1000_CTRL
+#define E1000_82542_CTRL_DUP E1000_CTRL_DUP
+#define E1000_82542_STATUS   E1000_STATUS
+#define E1000_82542_EECD     E1000_EECD
+#define E1000_82542_EERD     E1000_EERD
+#define E1000_82542_CTRL_EXT E1000_CTRL_EXT
+#define E1000_82542_FLA      E1000_FLA
+#define E1000_82542_MDIC     E1000_MDIC
+#define E1000_82542_FCAL     E1000_FCAL
+#define E1000_82542_FCAH     E1000_FCAH
+#define E1000_82542_FCT      E1000_FCT
+#define E1000_82542_VET      E1000_VET
+#define E1000_82542_RA       0x00040
+#define E1000_82542_ICR      E1000_ICR
+#define E1000_82542_ITR      E1000_ITR
+#define E1000_82542_ICS      E1000_ICS
+#define E1000_82542_IMS      E1000_IMS
+#define E1000_82542_IMC      E1000_IMC
+#define E1000_82542_RCTL     E1000_RCTL
+#define E1000_82542_RDTR     0x00108
+#define E1000_82542_RDBAL    0x00110
+#define E1000_82542_RDBAH    0x00114
+#define E1000_82542_RDLEN    0x00118
+#define E1000_82542_RDH      0x00120
+#define E1000_82542_RDT      0x00128
+#define E1000_82542_FCRTH    0x00160
+#define E1000_82542_FCRTL    0x00168
+#define E1000_82542_FCTTV    E1000_FCTTV
+#define E1000_82542_TXCW     E1000_TXCW
+#define E1000_82542_RXCW     E1000_RXCW
+#define E1000_82542_MTA      0x00200
+#define E1000_82542_TCTL     E1000_TCTL
+#define E1000_82542_TIPG     E1000_TIPG
+#define E1000_82542_TDBAL    0x00420
+#define E1000_82542_TDBAH    0x00424
+#define E1000_82542_TDLEN    0x00428
+#define E1000_82542_TDH      0x00430
+#define E1000_82542_TDT      0x00438
+#define E1000_82542_TIDV     0x00440
+#define E1000_82542_TBT      E1000_TBT
+#define E1000_82542_AIT      E1000_AIT
+#define E1000_82542_VFTA     0x00600
+#define E1000_82542_LEDCTL   E1000_LEDCTL
+#define E1000_82542_PBA      E1000_PBA
+#define E1000_82542_RXDCTL   E1000_RXDCTL
+#define E1000_82542_RADV     E1000_RADV
+#define E1000_82542_RSRPD    E1000_RSRPD
+#define E1000_82542_TXDMAC   E1000_TXDMAC
+#define E1000_82542_TDFHS    E1000_TDFHS
+#define E1000_82542_TDFTS    E1000_TDFTS
+#define E1000_82542_TDFPC    E1000_TDFPC
+#define E1000_82542_TXDCTL   E1000_TXDCTL
+#define E1000_82542_TADV     E1000_TADV
+#define E1000_82542_TSPMT    E1000_TSPMT
+#define E1000_82542_CRCERRS  E1000_CRCERRS
+#define E1000_82542_ALGNERRC E1000_ALGNERRC
+#define E1000_82542_SYMERRS  E1000_SYMERRS
+#define E1000_82542_RXERRC   E1000_RXERRC
+#define E1000_82542_MPC      E1000_MPC
+#define E1000_82542_SCC      E1000_SCC
+#define E1000_82542_ECOL     E1000_ECOL
+#define E1000_82542_MCC      E1000_MCC
+#define E1000_82542_LATECOL  E1000_LATECOL
+#define E1000_82542_COLC     E1000_COLC
+#define E1000_82542_DC       E1000_DC
+#define E1000_82542_TNCRS    E1000_TNCRS
+#define E1000_82542_SEC      E1000_SEC
+#define E1000_82542_CEXTERR  E1000_CEXTERR
+#define E1000_82542_RLEC     E1000_RLEC
+#define E1000_82542_XONRXC   E1000_XONRXC
+#define E1000_82542_XONTXC   E1000_XONTXC
+#define E1000_82542_XOFFRXC  E1000_XOFFRXC
+#define E1000_82542_XOFFTXC  E1000_XOFFTXC
+#define E1000_82542_FCRUC    E1000_FCRUC
+#define E1000_82542_PRC64    E1000_PRC64
+#define E1000_82542_PRC127   E1000_PRC127
+#define E1000_82542_PRC255   E1000_PRC255
+#define E1000_82542_PRC511   E1000_PRC511
+#define E1000_82542_PRC1023  E1000_PRC1023
+#define E1000_82542_PRC1522  E1000_PRC1522
+#define E1000_82542_GPRC     E1000_GPRC
+#define E1000_82542_BPRC     E1000_BPRC
+#define E1000_82542_MPRC     E1000_MPRC
+#define E1000_82542_GPTC     E1000_GPTC
+#define E1000_82542_GORCL    E1000_GORCL
+#define E1000_82542_GORCH    E1000_GORCH
+#define E1000_82542_GOTCL    E1000_GOTCL
+#define E1000_82542_GOTCH    E1000_GOTCH
+#define E1000_82542_RNBC     E1000_RNBC
+#define E1000_82542_RUC      E1000_RUC
+#define E1000_82542_RFC      E1000_RFC
+#define E1000_82542_ROC      E1000_ROC
+#define E1000_82542_RJC      E1000_RJC
+#define E1000_82542_MGTPRC   E1000_MGTPRC
+#define E1000_82542_MGTPDC   E1000_MGTPDC
+#define E1000_82542_MGTPTC   E1000_MGTPTC
+#define E1000_82542_TORL     E1000_TORL
+#define E1000_82542_TORH     E1000_TORH
+#define E1000_82542_TOTL     E1000_TOTL
+#define E1000_82542_TOTH     E1000_TOTH
+#define E1000_82542_TPR      E1000_TPR
+#define E1000_82542_TPT      E1000_TPT
+#define E1000_82542_PTC64    E1000_PTC64
+#define E1000_82542_PTC127   E1000_PTC127
+#define E1000_82542_PTC255   E1000_PTC255
+#define E1000_82542_PTC511   E1000_PTC511
+#define E1000_82542_PTC1023  E1000_PTC1023
+#define E1000_82542_PTC1522  E1000_PTC1522
+#define E1000_82542_MPTC     E1000_MPTC
+#define E1000_82542_BPTC     E1000_BPTC
+#define E1000_82542_TSCTC    E1000_TSCTC
+#define E1000_82542_TSCTFC   E1000_TSCTFC
+#define E1000_82542_RXCSUM   E1000_RXCSUM
+#define E1000_82542_WUC      E1000_WUC
+#define E1000_82542_WUFC     E1000_WUFC
+#define E1000_82542_WUS      E1000_WUS
+#define E1000_82542_MANC     E1000_MANC
+#define E1000_82542_IPAV     E1000_IPAV
+#define E1000_82542_IP4AT    E1000_IP4AT
+#define E1000_82542_IP6AT    E1000_IP6AT
+#define E1000_82542_WUPL     E1000_WUPL
+#define E1000_82542_WUPM     E1000_WUPM
+#define E1000_82542_FFLT     E1000_FFLT
+#define E1000_82542_TDFH     0x08010
+#define E1000_82542_TDFT     0x08018
+#define E1000_82542_FFMT     E1000_FFMT
+#define E1000_82542_FFVT     E1000_FFVT
+
+/* Statistics counters collected by the MAC */
+struct e1000_hw_stats {
+    uint64_t crcerrs;
+    uint64_t algnerrc;
+    uint64_t symerrs;
+    uint64_t rxerrc;
+    uint64_t mpc;
+    uint64_t scc;
+    uint64_t ecol;
+    uint64_t mcc;
+    uint64_t latecol;
+    uint64_t colc;
+    uint64_t dc;
+    uint64_t tncrs;
+    uint64_t sec;
+    uint64_t cexterr;
+    uint64_t rlec;
+    uint64_t xonrxc;
+    uint64_t xontxc;
+    uint64_t xoffrxc;
+    uint64_t xofftxc;
+    uint64_t fcruc;
+    uint64_t prc64;
+    uint64_t prc127;
+    uint64_t prc255;
+    uint64_t prc511;
+    uint64_t prc1023;
+    uint64_t prc1522;
+    uint64_t gprc;
+    uint64_t bprc;
+    uint64_t mprc;
+    uint64_t gptc;
+    uint64_t gorcl;
+    uint64_t gorch;
+    uint64_t gotcl;
+    uint64_t gotch;
+    uint64_t rnbc;
+    uint64_t ruc;
+    uint64_t rfc;
+    uint64_t roc;
+    uint64_t rjc;
+    uint64_t mgprc;
+    uint64_t mgpdc;
+    uint64_t mgptc;
+    uint64_t torl;
+    uint64_t torh;
+    uint64_t totl;
+    uint64_t toth;
+    uint64_t tpr;
+    uint64_t tpt;
+    uint64_t ptc64;
+    uint64_t ptc127;
+    uint64_t ptc255;
+    uint64_t ptc511;
+    uint64_t ptc1023;
+    uint64_t ptc1522;
+    uint64_t mptc;
+    uint64_t bptc;
+    uint64_t tsctc;
+    uint64_t tsctfc;
+};
+
+/* Structure containing variables used by the shared code (e1000_hw.c) */
+struct e1000_hw {
+	struct pci_device *pdev;
+	uint8_t *hw_addr;
+	e1000_mac_type   mac_type;
+	e1000_phy_type phy_type;
+#if 0
+	uint32_t phy_init_script;
+#endif
+	e1000_media_type media_type;
+	e1000_fc_type    fc;
+#if 0
+	e1000_bus_speed bus_speed;
+	e1000_bus_width bus_width;
+	e1000_bus_type  bus_type;
+#endif
+	struct e1000_eeprom_info eeprom;
+#if 0
+	e1000_ms_type master_slave;
+	e1000_ms_type original_master_slave;
+	e1000_ffe_config ffe_config_state;
+#endif
+	uint32_t io_base;
+	uint32_t phy_id;
+#ifdef LINUX_DRIVER
+	uint32_t phy_revision;
+#endif
+	uint32_t phy_addr;
+#if 0
+	uint32_t original_fc;
+#endif
+	uint32_t txcw;
+	uint32_t autoneg_failed;
+#if 0
+	uint32_t max_frame_size;
+	uint32_t min_frame_size;
+	uint32_t mc_filter_type;
+	uint32_t num_mc_addrs;
+	uint32_t collision_delta;
+	uint32_t tx_packet_delta;
+	uint32_t ledctl_default;
+	uint32_t ledctl_mode1;
+	uint32_t ledctl_mode2;
+	uint16_t phy_spd_default;
+#endif
+	uint16_t autoneg_advertised;
+	uint16_t pci_cmd_word;
+#if 0
+	uint16_t fc_high_water;
+	uint16_t fc_low_water;
+	uint16_t fc_pause_time;
+	uint16_t current_ifs_val;
+	uint16_t ifs_min_val;
+	uint16_t ifs_max_val;
+	uint16_t ifs_step_size;
+	uint16_t ifs_ratio;
+#endif
+	uint16_t device_id;
+	uint16_t vendor_id;
+#if 0
+	uint16_t subsystem_id;
+	uint16_t subsystem_vendor_id;
+#endif
+	uint8_t revision_id;
+#if 0
+	uint8_t autoneg;
+	uint8_t mdix;
+	uint8_t forced_speed_duplex;
+	uint8_t wait_autoneg_complete;
+	uint8_t dma_fairness;
+#endif
+	uint8_t mac_addr[NODE_ADDRESS_SIZE];
+#if 0
+	uint8_t perm_mac_addr[NODE_ADDRESS_SIZE];
+	boolean_t disable_polarity_correction;
+	boolean_t speed_downgraded;
+	e1000_dsp_config dsp_config_state;
+	boolean_t get_link_status;
+	boolean_t serdes_link_down;
+#endif
+	boolean_t tbi_compatibility_en;
+	boolean_t tbi_compatibility_on;
+#if 0
+	boolean_t phy_reset_disable;
+	boolean_t fc_send_xon;
+	boolean_t fc_strict_ieee;
+	boolean_t report_tx_early;
+	boolean_t adaptive_ifs;
+	boolean_t ifs_params_forced;
+	boolean_t in_ifs_mode;
+#endif
+};
+
+
+#define E1000_EEPROM_SWDPIN0   0x0001   /* SWDPIN 0 EEPROM Value */
+#define E1000_EEPROM_LED_LOGIC 0x0020   /* Led Logic Word */
+
+/* Register Bit Masks */
+/* Device Control */
+#define E1000_CTRL_FD       0x00000001  /* Full duplex.0=half; 1=full */
+#define E1000_CTRL_BEM      0x00000002  /* Endian Mode.0=little,1=big */
+#define E1000_CTRL_PRIOR    0x00000004  /* Priority on PCI. 0=rx,1=fair */
+#define E1000_CTRL_LRST     0x00000008  /* Link reset. 0=normal,1=reset */
+#define E1000_CTRL_TME      0x00000010  /* Test mode. 0=normal,1=test */
+#define E1000_CTRL_SLE      0x00000020  /* Serial Link on 0=dis,1=en */
+#define E1000_CTRL_ASDE     0x00000020  /* Auto-speed detect enable */
+#define E1000_CTRL_SLU      0x00000040  /* Set link up (Force Link) */
+#define E1000_CTRL_ILOS     0x00000080  /* Invert Loss-Of Signal */
+#define E1000_CTRL_SPD_SEL  0x00000300  /* Speed Select Mask */
+#define E1000_CTRL_SPD_10   0x00000000  /* Force 10Mb */
+#define E1000_CTRL_SPD_100  0x00000100  /* Force 100Mb */
+#define E1000_CTRL_SPD_1000 0x00000200  /* Force 1Gb */
+#define E1000_CTRL_BEM32    0x00000400  /* Big Endian 32 mode */
+#define E1000_CTRL_FRCSPD   0x00000800  /* Force Speed */
+#define E1000_CTRL_FRCDPX   0x00001000  /* Force Duplex */
+#define E1000_CTRL_SWDPIN0  0x00040000  /* SWDPIN 0 value */
+#define E1000_CTRL_SWDPIN1  0x00080000  /* SWDPIN 1 value */
+#define E1000_CTRL_SWDPIN2  0x00100000  /* SWDPIN 2 value */
+#define E1000_CTRL_SWDPIN3  0x00200000  /* SWDPIN 3 value */
+#define E1000_CTRL_SWDPIO0  0x00400000  /* SWDPIN 0 Input or output */
+#define E1000_CTRL_SWDPIO1  0x00800000  /* SWDPIN 1 input or output */
+#define E1000_CTRL_SWDPIO2  0x01000000  /* SWDPIN 2 input or output */
+#define E1000_CTRL_SWDPIO3  0x02000000  /* SWDPIN 3 input or output */
+#define E1000_CTRL_RST      0x04000000  /* Global reset */
+#define E1000_CTRL_RFCE     0x08000000  /* Receive Flow Control enable */
+#define E1000_CTRL_TFCE     0x10000000  /* Transmit flow control enable */
+#define E1000_CTRL_RTE      0x20000000  /* Routing tag enable */
+#define E1000_CTRL_VME      0x40000000  /* IEEE VLAN mode enable */
+#define E1000_CTRL_PHY_RST  0x80000000  /* PHY Reset */
+
+/* Device Status */
+#define E1000_STATUS_FD         0x00000001      /* Full duplex.0=half,1=full */
+#define E1000_STATUS_LU         0x00000002      /* Link up.0=no,1=link */
+#define E1000_STATUS_FUNC_MASK  0x0000000C      /* PCI Function Mask */
+#define E1000_STATUS_FUNC_0     0x00000000      /* Function 0 */
+#define E1000_STATUS_FUNC_1     0x00000004      /* Function 1 */
+#define E1000_STATUS_TXOFF      0x00000010      /* transmission paused */
+#define E1000_STATUS_TBIMODE    0x00000020      /* TBI mode */
+#define E1000_STATUS_SPEED_MASK 0x000000C0
+#define E1000_STATUS_SPEED_10   0x00000000      /* Speed 10Mb/s */
+#define E1000_STATUS_SPEED_100  0x00000040      /* Speed 100Mb/s */
+#define E1000_STATUS_SPEED_1000 0x00000080      /* Speed 1000Mb/s */
+#define E1000_STATUS_ASDV       0x00000300      /* Auto speed detect value */
+#define E1000_STATUS_MTXCKOK    0x00000400      /* MTX clock running OK */
+#define E1000_STATUS_PCI66      0x00000800      /* In 66Mhz slot */
+#define E1000_STATUS_BUS64      0x00001000      /* In 64 bit slot */
+#define E1000_STATUS_PCIX_MODE  0x00002000      /* PCI-X mode */
+#define E1000_STATUS_PCIX_SPEED 0x0000C000      /* PCI-X bus speed */
+
+/* Constants used to intrepret the masked PCI-X bus speed. */
+#define E1000_STATUS_PCIX_SPEED_66  0x00000000 /* PCI-X bus speed  50-66 MHz */
+#define E1000_STATUS_PCIX_SPEED_100 0x00004000 /* PCI-X bus speed  66-100 MHz */
+#define E1000_STATUS_PCIX_SPEED_133 0x00008000 /* PCI-X bus speed 100-133 MHz */
+
+/* EEPROM/Flash Control */
+#define E1000_EECD_SK        0x00000001 /* EEPROM Clock */
+#define E1000_EECD_CS        0x00000002 /* EEPROM Chip Select */
+#define E1000_EECD_DI        0x00000004 /* EEPROM Data In */
+#define E1000_EECD_DO        0x00000008 /* EEPROM Data Out */
+#define E1000_EECD_FWE_MASK  0x00000030 
+#define E1000_EECD_FWE_DIS   0x00000010 /* Disable FLASH writes */
+#define E1000_EECD_FWE_EN    0x00000020 /* Enable FLASH writes */
+#define E1000_EECD_FWE_SHIFT 4
+#define E1000_EECD_REQ       0x00000040 /* EEPROM Access Request */
+#define E1000_EECD_GNT       0x00000080 /* EEPROM Access Grant */
+#define E1000_EECD_PRES      0x00000100 /* EEPROM Present */
+#define E1000_EECD_SIZE      0x00000200 /* EEPROM Size (0=64 word 1=256 word) */
+#define E1000_EECD_ADDR_BITS 0x00000400 /* EEPROM Addressing bits based on type
+                                         * (0-small, 1-large) */
+#define E1000_EECD_TYPE      0x00002000 /* EEPROM Type (1-SPI, 0-Microwire) */
+#ifndef E1000_EEPROM_GRANT_ATTEMPTS
+#define E1000_EEPROM_GRANT_ATTEMPTS 1000 /* EEPROM # attempts to gain grant */
+#endif
+
+/* EEPROM Read */
+#define E1000_EERD_START      0x00000001 /* Start Read */
+#define E1000_EERD_DONE       0x00000010 /* Read Done */
+#define E1000_EERD_ADDR_SHIFT 8
+#define E1000_EERD_ADDR_MASK  0x0000FF00 /* Read Address */
+#define E1000_EERD_DATA_SHIFT 16
+#define E1000_EERD_DATA_MASK  0xFFFF0000 /* Read Data */
+
+/* SPI EEPROM Status Register */
+#define EEPROM_STATUS_RDY_SPI  0x01
+#define EEPROM_STATUS_WEN_SPI  0x02
+#define EEPROM_STATUS_BP0_SPI  0x04
+#define EEPROM_STATUS_BP1_SPI  0x08
+#define EEPROM_STATUS_WPEN_SPI 0x80
+
+/* Extended Device Control */
+#define E1000_CTRL_EXT_GPI0_EN   0x00000001 /* Maps SDP4 to GPI0 */ 
+#define E1000_CTRL_EXT_GPI1_EN   0x00000002 /* Maps SDP5 to GPI1 */
+#define E1000_CTRL_EXT_PHYINT_EN E1000_CTRL_EXT_GPI1_EN
+#define E1000_CTRL_EXT_GPI2_EN   0x00000004 /* Maps SDP6 to GPI2 */
+#define E1000_CTRL_EXT_GPI3_EN   0x00000008 /* Maps SDP7 to GPI3 */
+#define E1000_CTRL_EXT_SDP4_DATA 0x00000010 /* Value of SW Defineable Pin 4 */
+#define E1000_CTRL_EXT_SDP5_DATA 0x00000020 /* Value of SW Defineable Pin 5 */
+#define E1000_CTRL_EXT_PHY_INT   E1000_CTRL_EXT_SDP5_DATA
+#define E1000_CTRL_EXT_SDP6_DATA 0x00000040 /* Value of SW Defineable Pin 6 */
+#define E1000_CTRL_EXT_SDP7_DATA 0x00000080 /* Value of SW Defineable Pin 7 */
+#define E1000_CTRL_EXT_SDP4_DIR  0x00000100 /* Direction of SDP4 0=in 1=out */
+#define E1000_CTRL_EXT_SDP5_DIR  0x00000200 /* Direction of SDP5 0=in 1=out */
+#define E1000_CTRL_EXT_SDP6_DIR  0x00000400 /* Direction of SDP6 0=in 1=out */
+#define E1000_CTRL_EXT_SDP7_DIR  0x00000800 /* Direction of SDP7 0=in 1=out */
+#define E1000_CTRL_EXT_ASDCHK    0x00001000 /* Initiate an ASD sequence */
+#define E1000_CTRL_EXT_EE_RST    0x00002000 /* Reinitialize from EEPROM */
+#define E1000_CTRL_EXT_IPS       0x00004000 /* Invert Power State */
+#define E1000_CTRL_EXT_SPD_BYPS  0x00008000 /* Speed Select Bypass */
+#define E1000_CTRL_EXT_LINK_MODE_MASK 0x00C00000
+#define E1000_CTRL_EXT_LINK_MODE_GMII 0x00000000
+#define E1000_CTRL_EXT_LINK_MODE_TBI  0x00C00000
+#define E1000_CTRL_EXT_WR_WMARK_MASK  0x03000000
+#define E1000_CTRL_EXT_WR_WMARK_256   0x00000000
+#define E1000_CTRL_EXT_WR_WMARK_320   0x01000000
+#define E1000_CTRL_EXT_WR_WMARK_384   0x02000000
+#define E1000_CTRL_EXT_WR_WMARK_448   0x03000000
+
+/* MDI Control */
+#define E1000_MDIC_DATA_MASK 0x0000FFFF
+#define E1000_MDIC_REG_MASK  0x001F0000
+#define E1000_MDIC_REG_SHIFT 16
+#define E1000_MDIC_PHY_MASK  0x03E00000
+#define E1000_MDIC_PHY_SHIFT 21
+#define E1000_MDIC_OP_WRITE  0x04000000
+#define E1000_MDIC_OP_READ   0x08000000
+#define E1000_MDIC_READY     0x10000000
+#define E1000_MDIC_INT_EN    0x20000000
+#define E1000_MDIC_ERROR     0x40000000
+
+/* LED Control */
+#define E1000_LEDCTL_LED0_MODE_MASK  0x0000000F
+#define E1000_LEDCTL_LED0_MODE_SHIFT 0
+#define E1000_LEDCTL_LED0_IVRT       0x00000040
+#define E1000_LEDCTL_LED0_BLINK      0x00000080
+#define E1000_LEDCTL_LED1_MODE_MASK  0x00000F00
+#define E1000_LEDCTL_LED1_MODE_SHIFT 8
+#define E1000_LEDCTL_LED1_IVRT       0x00004000
+#define E1000_LEDCTL_LED1_BLINK      0x00008000
+#define E1000_LEDCTL_LED2_MODE_MASK  0x000F0000
+#define E1000_LEDCTL_LED2_MODE_SHIFT 16
+#define E1000_LEDCTL_LED2_IVRT       0x00400000
+#define E1000_LEDCTL_LED2_BLINK      0x00800000
+#define E1000_LEDCTL_LED3_MODE_MASK  0x0F000000
+#define E1000_LEDCTL_LED3_MODE_SHIFT 24
+#define E1000_LEDCTL_LED3_IVRT       0x40000000
+#define E1000_LEDCTL_LED3_BLINK      0x80000000
+
+#define E1000_LEDCTL_MODE_LINK_10_1000  0x0
+#define E1000_LEDCTL_MODE_LINK_100_1000 0x1
+#define E1000_LEDCTL_MODE_LINK_UP       0x2
+#define E1000_LEDCTL_MODE_ACTIVITY      0x3
+#define E1000_LEDCTL_MODE_LINK_ACTIVITY 0x4
+#define E1000_LEDCTL_MODE_LINK_10       0x5
+#define E1000_LEDCTL_MODE_LINK_100      0x6
+#define E1000_LEDCTL_MODE_LINK_1000     0x7
+#define E1000_LEDCTL_MODE_PCIX_MODE     0x8
+#define E1000_LEDCTL_MODE_FULL_DUPLEX   0x9
+#define E1000_LEDCTL_MODE_COLLISION     0xA
+#define E1000_LEDCTL_MODE_BUS_SPEED     0xB
+#define E1000_LEDCTL_MODE_BUS_SIZE      0xC
+#define E1000_LEDCTL_MODE_PAUSED        0xD
+#define E1000_LEDCTL_MODE_LED_ON        0xE
+#define E1000_LEDCTL_MODE_LED_OFF       0xF
+
+/* Receive Address */
+#define E1000_RAH_AV  0x80000000        /* Receive descriptor valid */
+
+/* Interrupt Cause Read */
+#define E1000_ICR_TXDW    0x00000001    /* Transmit desc written back */
+#define E1000_ICR_TXQE    0x00000002    /* Transmit Queue empty */
+#define E1000_ICR_LSC     0x00000004    /* Link Status Change */
+#define E1000_ICR_RXSEQ   0x00000008    /* rx sequence error */
+#define E1000_ICR_RXDMT0  0x00000010    /* rx desc min. threshold (0) */
+#define E1000_ICR_RXO     0x00000040    /* rx overrun */
+#define E1000_ICR_RXT0    0x00000080    /* rx timer intr (ring 0) */
+#define E1000_ICR_MDAC    0x00000200    /* MDIO access complete */
+#define E1000_ICR_RXCFG   0x00000400    /* RX /c/ ordered set */
+#define E1000_ICR_GPI_EN0 0x00000800    /* GP Int 0 */
+#define E1000_ICR_GPI_EN1 0x00001000    /* GP Int 1 */
+#define E1000_ICR_GPI_EN2 0x00002000    /* GP Int 2 */
+#define E1000_ICR_GPI_EN3 0x00004000    /* GP Int 3 */
+#define E1000_ICR_TXD_LOW 0x00008000
+#define E1000_ICR_SRPD    0x00010000
+
+/* Interrupt Cause Set */
+#define E1000_ICS_TXDW    E1000_ICR_TXDW        /* Transmit desc written back */
+#define E1000_ICS_TXQE    E1000_ICR_TXQE        /* Transmit Queue empty */
+#define E1000_ICS_LSC     E1000_ICR_LSC         /* Link Status Change */
+#define E1000_ICS_RXSEQ   E1000_ICR_RXSEQ       /* rx sequence error */
+#define E1000_ICS_RXDMT0  E1000_ICR_RXDMT0      /* rx desc min. threshold */
+#define E1000_ICS_RXO     E1000_ICR_RXO         /* rx overrun */
+#define E1000_ICS_RXT0    E1000_ICR_RXT0        /* rx timer intr */
+#define E1000_ICS_MDAC    E1000_ICR_MDAC        /* MDIO access complete */
+#define E1000_ICS_RXCFG   E1000_ICR_RXCFG       /* RX /c/ ordered set */
+#define E1000_ICS_GPI_EN0 E1000_ICR_GPI_EN0     /* GP Int 0 */
+#define E1000_ICS_GPI_EN1 E1000_ICR_GPI_EN1     /* GP Int 1 */
+#define E1000_ICS_GPI_EN2 E1000_ICR_GPI_EN2     /* GP Int 2 */
+#define E1000_ICS_GPI_EN3 E1000_ICR_GPI_EN3     /* GP Int 3 */
+#define E1000_ICS_TXD_LOW E1000_ICR_TXD_LOW
+#define E1000_ICS_SRPD    E1000_ICR_SRPD
+
+/* Interrupt Mask Set */
+#define E1000_IMS_TXDW    E1000_ICR_TXDW        /* Transmit desc written back */
+#define E1000_IMS_TXQE    E1000_ICR_TXQE        /* Transmit Queue empty */
+#define E1000_IMS_LSC     E1000_ICR_LSC         /* Link Status Change */
+#define E1000_IMS_RXSEQ   E1000_ICR_RXSEQ       /* rx sequence error */
+#define E1000_IMS_RXDMT0  E1000_ICR_RXDMT0      /* rx desc min. threshold */
+#define E1000_IMS_RXO     E1000_ICR_RXO         /* rx overrun */
+#define E1000_IMS_RXT0    E1000_ICR_RXT0        /* rx timer intr */
+#define E1000_IMS_MDAC    E1000_ICR_MDAC        /* MDIO access complete */
+#define E1000_IMS_RXCFG   E1000_ICR_RXCFG       /* RX /c/ ordered set */
+#define E1000_IMS_GPI_EN0 E1000_ICR_GPI_EN0     /* GP Int 0 */
+#define E1000_IMS_GPI_EN1 E1000_ICR_GPI_EN1     /* GP Int 1 */
+#define E1000_IMS_GPI_EN2 E1000_ICR_GPI_EN2     /* GP Int 2 */
+#define E1000_IMS_GPI_EN3 E1000_ICR_GPI_EN3     /* GP Int 3 */
+#define E1000_IMS_TXD_LOW E1000_ICR_TXD_LOW
+#define E1000_IMS_SRPD    E1000_ICR_SRPD
+
+/* Interrupt Mask Clear */
+#define E1000_IMC_TXDW    E1000_ICR_TXDW        /* Transmit desc written back */
+#define E1000_IMC_TXQE    E1000_ICR_TXQE        /* Transmit Queue empty */
+#define E1000_IMC_LSC     E1000_ICR_LSC         /* Link Status Change */
+#define E1000_IMC_RXSEQ   E1000_ICR_RXSEQ       /* rx sequence error */
+#define E1000_IMC_RXDMT0  E1000_ICR_RXDMT0      /* rx desc min. threshold */
+#define E1000_IMC_RXO     E1000_ICR_RXO         /* rx overrun */
+#define E1000_IMC_RXT0    E1000_ICR_RXT0        /* rx timer intr */
+#define E1000_IMC_MDAC    E1000_ICR_MDAC        /* MDIO access complete */
+#define E1000_IMC_RXCFG   E1000_ICR_RXCFG       /* RX /c/ ordered set */
+#define E1000_IMC_GPI_EN0 E1000_ICR_GPI_EN0     /* GP Int 0 */
+#define E1000_IMC_GPI_EN1 E1000_ICR_GPI_EN1     /* GP Int 1 */
+#define E1000_IMC_GPI_EN2 E1000_ICR_GPI_EN2     /* GP Int 2 */
+#define E1000_IMC_GPI_EN3 E1000_ICR_GPI_EN3     /* GP Int 3 */
+#define E1000_IMC_TXD_LOW E1000_ICR_TXD_LOW
+#define E1000_IMC_SRPD    E1000_ICR_SRPD
+
+/* Receive Control */
+#define E1000_RCTL_RST          0x00000001      /* Software reset */
+#define E1000_RCTL_EN           0x00000002      /* enable */
+#define E1000_RCTL_SBP          0x00000004      /* store bad packet */
+#define E1000_RCTL_UPE          0x00000008      /* unicast promiscuous enable */
+#define E1000_RCTL_MPE          0x00000010      /* multicast promiscuous enab */
+#define E1000_RCTL_LPE          0x00000020      /* long packet enable */
+#define E1000_RCTL_LBM_NO       0x00000000      /* no loopback mode */
+#define E1000_RCTL_LBM_MAC      0x00000040      /* MAC loopback mode */
+#define E1000_RCTL_LBM_SLP      0x00000080      /* serial link loopback mode */
+#define E1000_RCTL_LBM_TCVR     0x000000C0      /* tcvr loopback mode */
+#define E1000_RCTL_RDMTS_HALF   0x00000000      /* rx desc min threshold size */
+#define E1000_RCTL_RDMTS_QUAT   0x00000100      /* rx desc min threshold size */
+#define E1000_RCTL_RDMTS_EIGTH  0x00000200      /* rx desc min threshold size */
+#define E1000_RCTL_MO_SHIFT     12              /* multicast offset shift */
+#define E1000_RCTL_MO_0         0x00000000      /* multicast offset 11:0 */
+#define E1000_RCTL_MO_1         0x00001000      /* multicast offset 12:1 */
+#define E1000_RCTL_MO_2         0x00002000      /* multicast offset 13:2 */
+#define E1000_RCTL_MO_3         0x00003000      /* multicast offset 15:4 */
+#define E1000_RCTL_MDR          0x00004000      /* multicast desc ring 0 */
+#define E1000_RCTL_BAM          0x00008000      /* broadcast enable */
+/* these buffer sizes are valid if E1000_RCTL_BSEX is 0 */
+#define E1000_RCTL_SZ_2048      0x00000000      /* rx buffer size 2048 */
+#define E1000_RCTL_SZ_1024      0x00010000      /* rx buffer size 1024 */
+#define E1000_RCTL_SZ_512       0x00020000      /* rx buffer size 512 */
+#define E1000_RCTL_SZ_256       0x00030000      /* rx buffer size 256 */
+/* these buffer sizes are valid if E1000_RCTL_BSEX is 1 */
+#define E1000_RCTL_SZ_16384     0x00010000      /* rx buffer size 16384 */
+#define E1000_RCTL_SZ_8192      0x00020000      /* rx buffer size 8192 */
+#define E1000_RCTL_SZ_4096      0x00030000      /* rx buffer size 4096 */
+#define E1000_RCTL_VFE          0x00040000      /* vlan filter enable */
+#define E1000_RCTL_CFIEN        0x00080000      /* canonical form enable */
+#define E1000_RCTL_CFI          0x00100000      /* canonical form indicator */
+#define E1000_RCTL_DPF          0x00400000      /* discard pause frames */
+#define E1000_RCTL_PMCF         0x00800000      /* pass MAC control frames */
+#define E1000_RCTL_BSEX         0x02000000      /* Buffer size extension */
+
+/* Receive Descriptor */
+#define E1000_RDT_DELAY 0x0000ffff      /* Delay timer (1=1024us) */
+#define E1000_RDT_FPDB  0x80000000      /* Flush descriptor block */
+#define E1000_RDLEN_LEN 0x0007ff80      /* descriptor length */
+#define E1000_RDH_RDH   0x0000ffff      /* receive descriptor head */
+#define E1000_RDT_RDT   0x0000ffff      /* receive descriptor tail */
+
+/* Flow Control */
+#define E1000_FCRTH_RTH  0x0000FFF8     /* Mask Bits[15:3] for RTH */
+#define E1000_FCRTH_XFCE 0x80000000     /* External Flow Control Enable */
+#define E1000_FCRTL_RTL  0x0000FFF8     /* Mask Bits[15:3] for RTL */
+#define E1000_FCRTL_XONE 0x80000000     /* Enable XON frame transmission */
+
+/* Receive Descriptor Control */
+#define E1000_RXDCTL_PTHRESH 0x0000003F /* RXDCTL Prefetch Threshold */
+#define E1000_RXDCTL_HTHRESH 0x00003F00 /* RXDCTL Host Threshold */
+#define E1000_RXDCTL_WTHRESH 0x003F0000 /* RXDCTL Writeback Threshold */
+#define E1000_RXDCTL_GRAN    0x01000000 /* RXDCTL Granularity */
+
+/* Transmit Descriptor Control */
+#define E1000_TXDCTL_PTHRESH 0x000000FF /* TXDCTL Prefetch Threshold */
+#define E1000_TXDCTL_HTHRESH 0x0000FF00 /* TXDCTL Host Threshold */
+#define E1000_TXDCTL_WTHRESH 0x00FF0000 /* TXDCTL Writeback Threshold */
+#define E1000_TXDCTL_GRAN    0x01000000 /* TXDCTL Granularity */
+#define E1000_TXDCTL_LWTHRESH 0xFE000000 /* TXDCTL Low Threshold */
+#define E1000_TXDCTL_FULL_TX_DESC_WB 0x01010000 /* GRAN=1, WTHRESH=1 */
+
+/* Transmit Configuration Word */
+#define E1000_TXCW_FD         0x00000020        /* TXCW full duplex */
+#define E1000_TXCW_HD         0x00000040        /* TXCW half duplex */
+#define E1000_TXCW_PAUSE      0x00000080        /* TXCW sym pause request */
+#define E1000_TXCW_ASM_DIR    0x00000100        /* TXCW astm pause direction */
+#define E1000_TXCW_PAUSE_MASK 0x00000180        /* TXCW pause request mask */
+#define E1000_TXCW_RF         0x00003000        /* TXCW remote fault */
+#define E1000_TXCW_NP         0x00008000        /* TXCW next page */
+#define E1000_TXCW_CW         0x0000ffff        /* TxConfigWord mask */
+#define E1000_TXCW_TXC        0x40000000        /* Transmit Config control */
+#define E1000_TXCW_ANE        0x80000000        /* Auto-neg enable */
+
+/* Receive Configuration Word */
+#define E1000_RXCW_CW    0x0000ffff     /* RxConfigWord mask */
+#define E1000_RXCW_NC    0x04000000     /* Receive config no carrier */
+#define E1000_RXCW_IV    0x08000000     /* Receive config invalid */
+#define E1000_RXCW_CC    0x10000000     /* Receive config change */
+#define E1000_RXCW_C     0x20000000     /* Receive config */
+#define E1000_RXCW_SYNCH 0x40000000     /* Receive config synch */
+#define E1000_RXCW_ANC   0x80000000     /* Auto-neg complete */
+
+/* Transmit Control */
+#define E1000_TCTL_RST    0x00000001    /* software reset */
+#define E1000_TCTL_EN     0x00000002    /* enable tx */
+#define E1000_TCTL_BCE    0x00000004    /* busy check enable */
+#define E1000_TCTL_PSP    0x00000008    /* pad short packets */
+#define E1000_TCTL_CT     0x00000ff0    /* collision threshold */
+#define E1000_TCTL_COLD   0x003ff000    /* collision distance */
+#define E1000_TCTL_SWXOFF 0x00400000    /* SW Xoff transmission */
+#define E1000_TCTL_PBE    0x00800000    /* Packet Burst Enable */
+#define E1000_TCTL_RTLC   0x01000000    /* Re-transmit on late collision */
+#define E1000_TCTL_NRTU   0x02000000    /* No Re-transmit on underrun */
+
+/* Receive Checksum Control */
+#define E1000_RXCSUM_PCSS_MASK 0x000000FF   /* Packet Checksum Start */
+#define E1000_RXCSUM_IPOFL     0x00000100   /* IPv4 checksum offload */
+#define E1000_RXCSUM_TUOFL     0x00000200   /* TCP / UDP checksum offload */
+#define E1000_RXCSUM_IPV6OFL   0x00000400   /* IPv6 checksum offload */
+
+/* Definitions for power management and wakeup registers */
+/* Wake Up Control */
+#define E1000_WUC_APME       0x00000001 /* APM Enable */
+#define E1000_WUC_PME_EN     0x00000002 /* PME Enable */
+#define E1000_WUC_PME_STATUS 0x00000004 /* PME Status */
+#define E1000_WUC_APMPME     0x00000008 /* Assert PME on APM Wakeup */
+#define E1000_WUC_SPM        0x80000000 /* Enable SPM */
+
+/* Wake Up Filter Control */
+#define E1000_WUFC_LNKC 0x00000001 /* Link Status Change Wakeup Enable */
+#define E1000_WUFC_MAG  0x00000002 /* Magic Packet Wakeup Enable */
+#define E1000_WUFC_EX   0x00000004 /* Directed Exact Wakeup Enable */
+#define E1000_WUFC_MC   0x00000008 /* Directed Multicast Wakeup Enable */
+#define E1000_WUFC_BC   0x00000010 /* Broadcast Wakeup Enable */
+#define E1000_WUFC_ARP  0x00000020 /* ARP Request Packet Wakeup Enable */
+#define E1000_WUFC_IPV4 0x00000040 /* Directed IPv4 Packet Wakeup Enable */
+#define E1000_WUFC_IPV6 0x00000080 /* Directed IPv6 Packet Wakeup Enable */
+#define E1000_WUFC_FLX0 0x00010000 /* Flexible Filter 0 Enable */
+#define E1000_WUFC_FLX1 0x00020000 /* Flexible Filter 1 Enable */
+#define E1000_WUFC_FLX2 0x00040000 /* Flexible Filter 2 Enable */
+#define E1000_WUFC_FLX3 0x00080000 /* Flexible Filter 3 Enable */
+#define E1000_WUFC_ALL_FILTERS 0x000F00FF /* Mask for all wakeup filters */
+#define E1000_WUFC_FLX_OFFSET 16       /* Offset to the Flexible Filters bits */
+#define E1000_WUFC_FLX_FILTERS 0x000F0000 /* Mask for the 4 flexible filters */
+
+/* Wake Up Status */
+#define E1000_WUS_LNKC 0x00000001 /* Link Status Changed */
+#define E1000_WUS_MAG  0x00000002 /* Magic Packet Received */
+#define E1000_WUS_EX   0x00000004 /* Directed Exact Received */
+#define E1000_WUS_MC   0x00000008 /* Directed Multicast Received */
+#define E1000_WUS_BC   0x00000010 /* Broadcast Received */
+#define E1000_WUS_ARP  0x00000020 /* ARP Request Packet Received */
+#define E1000_WUS_IPV4 0x00000040 /* Directed IPv4 Packet Wakeup Received */
+#define E1000_WUS_IPV6 0x00000080 /* Directed IPv6 Packet Wakeup Received */
+#define E1000_WUS_FLX0 0x00010000 /* Flexible Filter 0 Match */
+#define E1000_WUS_FLX1 0x00020000 /* Flexible Filter 1 Match */
+#define E1000_WUS_FLX2 0x00040000 /* Flexible Filter 2 Match */
+#define E1000_WUS_FLX3 0x00080000 /* Flexible Filter 3 Match */
+#define E1000_WUS_FLX_FILTERS 0x000F0000 /* Mask for the 4 flexible filters */
+
+/* Management Control */
+#define E1000_MANC_SMBUS_EN      0x00000001 /* SMBus Enabled - RO */
+#define E1000_MANC_ASF_EN        0x00000002 /* ASF Enabled - RO */
+#define E1000_MANC_R_ON_FORCE    0x00000004 /* Reset on Force TCO - RO */
+#define E1000_MANC_RMCP_EN       0x00000100 /* Enable RCMP 026Fh Filtering */
+#define E1000_MANC_0298_EN       0x00000200 /* Enable RCMP 0298h Filtering */
+#define E1000_MANC_IPV4_EN       0x00000400 /* Enable IPv4 */
+#define E1000_MANC_IPV6_EN       0x00000800 /* Enable IPv6 */
+#define E1000_MANC_SNAP_EN       0x00001000 /* Accept LLC/SNAP */
+#define E1000_MANC_ARP_EN        0x00002000 /* Enable ARP Request Filtering */
+#define E1000_MANC_NEIGHBOR_EN   0x00004000 /* Enable Neighbor Discovery 
+                                             * Filtering */
+#define E1000_MANC_TCO_RESET     0x00010000 /* TCO Reset Occurred */
+#define E1000_MANC_RCV_TCO_EN    0x00020000 /* Receive TCO Packets Enabled */
+#define E1000_MANC_REPORT_STATUS 0x00040000 /* Status Reporting Enabled */
+#define E1000_MANC_SMB_REQ       0x01000000 /* SMBus Request */
+#define E1000_MANC_SMB_GNT       0x02000000 /* SMBus Grant */
+#define E1000_MANC_SMB_CLK_IN    0x04000000 /* SMBus Clock In */
+#define E1000_MANC_SMB_DATA_IN   0x08000000 /* SMBus Data In */
+#define E1000_MANC_SMB_DATA_OUT  0x10000000 /* SMBus Data Out */
+#define E1000_MANC_SMB_CLK_OUT   0x20000000 /* SMBus Clock Out */
+
+#define E1000_MANC_SMB_DATA_OUT_SHIFT  28 /* SMBus Data Out Shift */
+#define E1000_MANC_SMB_CLK_OUT_SHIFT   29 /* SMBus Clock Out Shift */
+
+/* Wake Up Packet Length */
+#define E1000_WUPL_LENGTH_MASK 0x0FFF   /* Only the lower 12 bits are valid */
+
+#define E1000_MDALIGN          4096
+
+/* EEPROM Commands - Microwire */
+#define EEPROM_READ_OPCODE_MICROWIRE  0x6  /* EEPROM read opcode */
+#define EEPROM_WRITE_OPCODE_MICROWIRE 0x5  /* EEPROM write opcode */
+#define EEPROM_ERASE_OPCODE_MICROWIRE 0x7  /* EEPROM erase opcode */
+#define EEPROM_EWEN_OPCODE_MICROWIRE  0x13 /* EEPROM erase/write enable */
+#define EEPROM_EWDS_OPCODE_MICROWIRE  0x10 /* EEPROM erast/write disable */
+
+/* EEPROM Commands - SPI */
+#define EEPROM_MAX_RETRY_SPI    5000 /* Max wait of 5ms, for RDY signal */
+#define EEPROM_READ_OPCODE_SPI  0x3  /* EEPROM read opcode */
+#define EEPROM_WRITE_OPCODE_SPI 0x2  /* EEPROM write opcode */
+#define EEPROM_A8_OPCODE_SPI    0x8  /* opcode bit-3 = address bit-8 */
+#define EEPROM_WREN_OPCODE_SPI  0x6  /* EEPROM set Write Enable latch */
+#define EEPROM_WRDI_OPCODE_SPI  0x4  /* EEPROM reset Write Enable latch */
+#define EEPROM_RDSR_OPCODE_SPI  0x5  /* EEPROM read Status register */
+#define EEPROM_WRSR_OPCODE_SPI  0x1  /* EEPROM write Status register */
+
+/* EEPROM Size definitions */
+#define EEPROM_SIZE_16KB        0x1800
+#define EEPROM_SIZE_8KB         0x1400
+#define EEPROM_SIZE_4KB         0x1000
+#define EEPROM_SIZE_2KB         0x0C00
+#define EEPROM_SIZE_1KB         0x0800
+#define EEPROM_SIZE_512B        0x0400
+#define EEPROM_SIZE_128B        0x0000
+#define EEPROM_SIZE_MASK        0x1C00
+
+/* EEPROM Word Offsets */
+#define EEPROM_COMPAT              0x0003
+#define EEPROM_ID_LED_SETTINGS     0x0004
+#define EEPROM_SERDES_AMPLITUDE       0x0006 /* For SERDES output amplitude adjustment. */
+#define EEPROM_INIT_CONTROL1_REG   0x000A
+#define EEPROM_INIT_CONTROL2_REG   0x000F
+#define EEPROM_INIT_CONTROL3_PORT_B   0x0014
+#define EEPROM_INIT_CONTROL3_PORT_A   0x0024
+#define EEPROM_CFG                 0x0012
+#define EEPROM_FLASH_VERSION       0x0032
+#define EEPROM_CHECKSUM_REG        0x003F
+
+/* Word definitions for ID LED Settings */
+#define ID_LED_RESERVED_0000 0x0000
+#define ID_LED_RESERVED_FFFF 0xFFFF
+#define ID_LED_DEFAULT       ((ID_LED_OFF1_ON2 << 12) | \
+                              (ID_LED_OFF1_OFF2 << 8) | \
+                              (ID_LED_DEF1_DEF2 << 4) | \
+                              (ID_LED_DEF1_DEF2))
+#define ID_LED_DEF1_DEF2     0x1
+#define ID_LED_DEF1_ON2      0x2
+#define ID_LED_DEF1_OFF2     0x3
+#define ID_LED_ON1_DEF2      0x4
+#define ID_LED_ON1_ON2       0x5
+#define ID_LED_ON1_OFF2      0x6
+#define ID_LED_OFF1_DEF2     0x7
+#define ID_LED_OFF1_ON2      0x8
+#define ID_LED_OFF1_OFF2     0x9
+
+#define IGP_ACTIVITY_LED_MASK   0xFFFFF0FF
+#define IGP_ACTIVITY_LED_ENABLE 0x0300
+#define IGP_LED3_MODE           0x07000000
+
+
+/* Mask bits for SERDES amplitude adjustment in Word 6 of the EEPROM */
+#define EEPROM_SERDES_AMPLITUDE_MASK  0x000F
+
+/* Mask bits for fields in Word 0x0a of the EEPROM */
+#define EEPROM_WORD0A_ILOS   0x0010
+#define EEPROM_WORD0A_SWDPIO 0x01E0
+#define EEPROM_WORD0A_LRST   0x0200
+#define EEPROM_WORD0A_FD     0x0400
+#define EEPROM_WORD0A_66MHZ  0x0800
+
+/* Mask bits for fields in Word 0x0f of the EEPROM */
+#define EEPROM_WORD0F_PAUSE_MASK 0x3000
+#define EEPROM_WORD0F_PAUSE      0x1000
+#define EEPROM_WORD0F_ASM_DIR    0x2000
+#define EEPROM_WORD0F_ANE        0x0800
+#define EEPROM_WORD0F_SWPDIO_EXT 0x00F0
+
+/* For checksumming, the sum of all words in the EEPROM should equal 0xBABA. */
+#define EEPROM_SUM 0xBABA
+
+/* EEPROM Map defines (WORD OFFSETS)*/
+#define EEPROM_NODE_ADDRESS_BYTE_0 0
+#define EEPROM_PBA_BYTE_1          8
+
+#define EEPROM_RESERVED_WORD          0xFFFF
+
+/* EEPROM Map Sizes (Byte Counts) */
+#define PBA_SIZE 4
+
+/* Collision related configuration parameters */
+#define E1000_COLLISION_THRESHOLD       16
+#define E1000_CT_SHIFT                  4
+#define E1000_COLLISION_DISTANCE        64
+#define E1000_FDX_COLLISION_DISTANCE    E1000_COLLISION_DISTANCE
+#define E1000_HDX_COLLISION_DISTANCE    E1000_COLLISION_DISTANCE
+#define E1000_COLD_SHIFT                12
+
+/* Number of Transmit and Receive Descriptors must be a multiple of 8 */
+#define REQ_TX_DESCRIPTOR_MULTIPLE  8
+#define REQ_RX_DESCRIPTOR_MULTIPLE  8
+
+/* Default values for the transmit IPG register */
+#define DEFAULT_82542_TIPG_IPGT        10
+#define DEFAULT_82543_TIPG_IPGT_FIBER  9
+#define DEFAULT_82543_TIPG_IPGT_COPPER 8
+
+#define E1000_TIPG_IPGT_MASK  0x000003FF
+#define E1000_TIPG_IPGR1_MASK 0x000FFC00
+#define E1000_TIPG_IPGR2_MASK 0x3FF00000
+
+#define DEFAULT_82542_TIPG_IPGR1 2
+#define DEFAULT_82543_TIPG_IPGR1 8
+#define E1000_TIPG_IPGR1_SHIFT  10
+
+#define DEFAULT_82542_TIPG_IPGR2 10
+#define DEFAULT_82543_TIPG_IPGR2 6
+#define E1000_TIPG_IPGR2_SHIFT  20
+
+#define E1000_TXDMAC_DPP 0x00000001
+
+/* Adaptive IFS defines */
+#define TX_THRESHOLD_START     8
+#define TX_THRESHOLD_INCREMENT 10
+#define TX_THRESHOLD_DECREMENT 1
+#define TX_THRESHOLD_STOP      190
+#define TX_THRESHOLD_DISABLE   0
+#define TX_THRESHOLD_TIMER_MS  10000
+#define MIN_NUM_XMITS          1000
+#define IFS_MAX                80
+#define IFS_STEP               10
+#define IFS_MIN                40
+#define IFS_RATIO              4
+
+/* PBA constants */
+#define E1000_PBA_16K 0x0010    /* 16KB, default TX allocation */
+#define E1000_PBA_22K 0x0016
+#define E1000_PBA_24K 0x0018
+#define E1000_PBA_30K 0x001E
+#define E1000_PBA_40K 0x0028
+#define E1000_PBA_48K 0x0030    /* 48KB, default RX allocation */
+
+/* Flow Control Constants */
+#define FLOW_CONTROL_ADDRESS_LOW  0x00C28001
+#define FLOW_CONTROL_ADDRESS_HIGH 0x00000100
+#define FLOW_CONTROL_TYPE         0x8808
+
+/* The historical defaults for the flow control values are given below. */
+#define FC_DEFAULT_HI_THRESH        (0x8000)    /* 32KB */
+#define FC_DEFAULT_LO_THRESH        (0x4000)    /* 16KB */
+#define FC_DEFAULT_TX_TIMER         (0x100)     /* ~130 us */
+
+/* PCIX Config space */
+#define PCIX_COMMAND_REGISTER    0xE6
+#define PCIX_STATUS_REGISTER_LO  0xE8
+#define PCIX_STATUS_REGISTER_HI  0xEA
+
+#define PCIX_COMMAND_MMRBC_MASK      0x000C
+#define PCIX_COMMAND_MMRBC_SHIFT     0x2
+#define PCIX_STATUS_HI_MMRBC_MASK    0x0060
+#define PCIX_STATUS_HI_MMRBC_SHIFT   0x5
+#define PCIX_STATUS_HI_MMRBC_4K      0x3
+#define PCIX_STATUS_HI_MMRBC_2K      0x2
+
+
+/* Number of bits required to shift right the "pause" bits from the
+ * EEPROM (bits 13:12) to the "pause" (bits 8:7) field in the TXCW register.
+ */
+#define PAUSE_SHIFT 5
+
+/* Number of bits required to shift left the "SWDPIO" bits from the
+ * EEPROM (bits 8:5) to the "SWDPIO" (bits 25:22) field in the CTRL register.
+ */
+#define SWDPIO_SHIFT 17
+
+/* Number of bits required to shift left the "SWDPIO_EXT" bits from the
+ * EEPROM word F (bits 7:4) to the bits 11:8 of The Extended CTRL register.
+ */
+#define SWDPIO__EXT_SHIFT 4
+
+/* Number of bits required to shift left the "ILOS" bit from the EEPROM
+ * (bit 4) to the "ILOS" (bit 7) field in the CTRL register.
+ */
+#define ILOS_SHIFT  3
+
+
+#define RECEIVE_BUFFER_ALIGN_SIZE  (256)
+
+/* Number of milliseconds we wait for auto-negotiation to complete */
+#define LINK_UP_TIMEOUT             500
+
+#define E1000_TX_BUFFER_SIZE ((uint32_t)1514)
+
+/* The carrier extension symbol, as received by the NIC. */
+#define CARRIER_EXTENSION   0x0F
+
+/* TBI_ACCEPT macro definition:
+ *
+ * This macro requires:
+ *      adapter = a pointer to struct e1000_hw 
+ *      status = the 8 bit status field of the RX descriptor with EOP set
+ *      error = the 8 bit error field of the RX descriptor with EOP set
+ *      length = the sum of all the length fields of the RX descriptors that
+ *               make up the current frame
+ *      last_byte = the last byte of the frame DMAed by the hardware
+ *      max_frame_length = the maximum frame length we want to accept.
+ *      min_frame_length = the minimum frame length we want to accept.
+ *
+ * This macro is a conditional that should be used in the interrupt 
+ * handler's Rx processing routine when RxErrors have been detected.
+ *
+ * Typical use:
+ *  ...
+ *  if (TBI_ACCEPT) {
+ *      accept_frame = TRUE;
+ *      e1000_tbi_adjust_stats(adapter, MacAddress);
+ *      frame_length--;
+ *  } else {
+ *      accept_frame = FALSE;
+ *  }
+ *  ...
+ */
+
+#define TBI_ACCEPT(adapter, status, errors, length, last_byte) \
+    ((adapter)->tbi_compatibility_on && \
+     (((errors) & E1000_RXD_ERR_FRAME_ERR_MASK) == E1000_RXD_ERR_CE) && \
+     ((last_byte) == CARRIER_EXTENSION) && \
+     (((status) & E1000_RXD_STAT_VP) ? \
+          (((length) > ((adapter)->min_frame_size - VLAN_TAG_SIZE)) && \
+           ((length) <= ((adapter)->max_frame_size + 1))) : \
+          (((length) > (adapter)->min_frame_size) && \
+           ((length) <= ((adapter)->max_frame_size + VLAN_TAG_SIZE + 1)))))
+
+
+/* Structures, enums, and macros for the PHY */
+
+/* Bit definitions for the Management Data IO (MDIO) and Management Data
+ * Clock (MDC) pins in the Device Control Register.
+ */
+#define E1000_CTRL_PHY_RESET_DIR  E1000_CTRL_SWDPIO0
+#define E1000_CTRL_PHY_RESET      E1000_CTRL_SWDPIN0
+#define E1000_CTRL_MDIO_DIR       E1000_CTRL_SWDPIO2
+#define E1000_CTRL_MDIO           E1000_CTRL_SWDPIN2
+#define E1000_CTRL_MDC_DIR        E1000_CTRL_SWDPIO3
+#define E1000_CTRL_MDC            E1000_CTRL_SWDPIN3
+#define E1000_CTRL_PHY_RESET_DIR4 E1000_CTRL_EXT_SDP4_DIR
+#define E1000_CTRL_PHY_RESET4     E1000_CTRL_EXT_SDP4_DATA
+
+/* PHY 1000 MII Register/Bit Definitions */
+/* PHY Registers defined by IEEE */
+#define PHY_CTRL         0x00 /* Control Register */
+#define PHY_STATUS       0x01 /* Status Regiser */
+#define PHY_ID1          0x02 /* Phy Id Reg (word 1) */
+#define PHY_ID2          0x03 /* Phy Id Reg (word 2) */
+#define PHY_AUTONEG_ADV  0x04 /* Autoneg Advertisement */
+#define PHY_LP_ABILITY   0x05 /* Link Partner Ability (Base Page) */
+#define PHY_AUTONEG_EXP  0x06 /* Autoneg Expansion Reg */
+#define PHY_NEXT_PAGE_TX 0x07 /* Next Page TX */
+#define PHY_LP_NEXT_PAGE 0x08 /* Link Partner Next Page */
+#define PHY_1000T_CTRL   0x09 /* 1000Base-T Control Reg */
+#define PHY_1000T_STATUS 0x0A /* 1000Base-T Status Reg */
+#define PHY_EXT_STATUS   0x0F /* Extended Status Reg */
+
+/* M88E1000 Specific Registers */
+#define M88E1000_PHY_SPEC_CTRL     0x10  /* PHY Specific Control Register */
+#define M88E1000_PHY_SPEC_STATUS   0x11  /* PHY Specific Status Register */
+#define M88E1000_INT_ENABLE        0x12  /* Interrupt Enable Register */
+#define M88E1000_INT_STATUS        0x13  /* Interrupt Status Register */
+#define M88E1000_EXT_PHY_SPEC_CTRL 0x14  /* Extended PHY Specific Control */
+#define M88E1000_RX_ERR_CNTR       0x15  /* Receive Error Counter */
+
+#define M88E1000_PHY_EXT_CTRL      0x1A  /* PHY extend control register */
+#define M88E1000_PHY_PAGE_SELECT   0x1D  /* Reg 29 for page number setting */
+#define M88E1000_PHY_GEN_CONTROL   0x1E  /* Its meaning depends on reg 29 */
+#define M88E1000_PHY_VCO_REG_BIT8  0x100 /* Bits 8 & 11 are adjusted for */
+#define M88E1000_PHY_VCO_REG_BIT11 0x800    /* improved BER performance */
+
+#define IGP01E1000_IEEE_REGS_PAGE  0x0000
+#define IGP01E1000_IEEE_RESTART_AUTONEG 0x3300
+#define IGP01E1000_IEEE_FORCE_GIGA      0x0140
+
+/* IGP01E1000 Specific Registers */
+#define IGP01E1000_PHY_PORT_CONFIG 0x10 /* PHY Specific Port Config Register */
+#define IGP01E1000_PHY_PORT_STATUS 0x11 /* PHY Specific Status Register */
+#define IGP01E1000_PHY_PORT_CTRL   0x12 /* PHY Specific Control Register */
+#define IGP01E1000_PHY_LINK_HEALTH 0x13 /* PHY Link Health Register */
+#define IGP01E1000_GMII_FIFO       0x14 /* GMII FIFO Register */
+#define IGP01E1000_PHY_CHANNEL_QUALITY 0x15 /* PHY Channel Quality Register */
+#define IGP01E1000_PHY_PAGE_SELECT     0x1F /* PHY Page Select Core Register */
+
+/* IGP01E1000 AGC Registers - stores the cable length values*/
+#define IGP01E1000_PHY_AGC_A        0x1172
+#define IGP01E1000_PHY_AGC_B        0x1272
+#define IGP01E1000_PHY_AGC_C        0x1472
+#define IGP01E1000_PHY_AGC_D        0x1872
+
+/* IGP01E1000 DSP Reset Register */
+#define IGP01E1000_PHY_DSP_RESET   0x1F33
+#define IGP01E1000_PHY_DSP_SET     0x1F71
+#define IGP01E1000_PHY_DSP_FFE     0x1F35
+
+#define IGP01E1000_PHY_CHANNEL_NUM    4
+#define IGP01E1000_PHY_AGC_PARAM_A    0x1171
+#define IGP01E1000_PHY_AGC_PARAM_B    0x1271
+#define IGP01E1000_PHY_AGC_PARAM_C    0x1471
+#define IGP01E1000_PHY_AGC_PARAM_D    0x1871
+
+#define IGP01E1000_PHY_EDAC_MU_INDEX        0xC000
+#define IGP01E1000_PHY_EDAC_SIGN_EXT_9_BITS 0x8000
+
+#define IGP01E1000_PHY_ANALOG_TX_STATE      0x2890
+#define IGP01E1000_PHY_ANALOG_CLASS_A       0x2000
+#define IGP01E1000_PHY_FORCE_ANALOG_ENABLE  0x0004
+#define IGP01E1000_PHY_DSP_FFE_CM_CP        0x0069
+
+#define IGP01E1000_PHY_DSP_FFE_DEFAULT      0x002A
+/* IGP01E1000 PCS Initialization register - stores the polarity status when
+ * speed = 1000 Mbps. */
+#define IGP01E1000_PHY_PCS_INIT_REG  0x00B4
+#define IGP01E1000_PHY_PCS_CTRL_REG  0x00B5
+
+#define IGP01E1000_ANALOG_REGS_PAGE  0x20C0
+  
+#define MAX_PHY_REG_ADDRESS 0x1F        /* 5 bit address bus (0-0x1F) */
+#define MAX_PHY_MULTI_PAGE_REG  0xF     /*Registers that are equal on all pages*/
+/* PHY Control Register */
+#define MII_CR_SPEED_SELECT_MSB 0x0040  /* bits 6,13: 10=1000, 01=100, 00=10 */
+#define MII_CR_COLL_TEST_ENABLE 0x0080  /* Collision test enable */
+#define MII_CR_FULL_DUPLEX      0x0100  /* FDX =1, half duplex =0 */
+#define MII_CR_RESTART_AUTO_NEG 0x0200  /* Restart auto negotiation */
+#define MII_CR_ISOLATE          0x0400  /* Isolate PHY from MII */
+#define MII_CR_POWER_DOWN       0x0800  /* Power down */
+#define MII_CR_AUTO_NEG_EN      0x1000  /* Auto Neg Enable */
+#define MII_CR_SPEED_SELECT_LSB 0x2000  /* bits 6,13: 10=1000, 01=100, 00=10 */
+#define MII_CR_LOOPBACK         0x4000  /* 0 = normal, 1 = loopback */
+#define MII_CR_RESET            0x8000  /* 0 = normal, 1 = PHY reset */
+
+/* PHY Status Register */
+#define MII_SR_EXTENDED_CAPS     0x0001 /* Extended register capabilities */
+#define MII_SR_JABBER_DETECT     0x0002 /* Jabber Detected */
+#define MII_SR_LINK_STATUS       0x0004 /* Link Status 1 = link */
+#define MII_SR_AUTONEG_CAPS      0x0008 /* Auto Neg Capable */
+#define MII_SR_REMOTE_FAULT      0x0010 /* Remote Fault Detect */
+#define MII_SR_AUTONEG_COMPLETE  0x0020 /* Auto Neg Complete */
+#define MII_SR_PREAMBLE_SUPPRESS 0x0040 /* Preamble may be suppressed */
+#define MII_SR_EXTENDED_STATUS   0x0100 /* Ext. status info in Reg 0x0F */
+#define MII_SR_100T2_HD_CAPS     0x0200 /* 100T2 Half Duplex Capable */
+#define MII_SR_100T2_FD_CAPS     0x0400 /* 100T2 Full Duplex Capable */
+#define MII_SR_10T_HD_CAPS       0x0800 /* 10T   Half Duplex Capable */
+#define MII_SR_10T_FD_CAPS       0x1000 /* 10T   Full Duplex Capable */
+#define MII_SR_100X_HD_CAPS      0x2000 /* 100X  Half Duplex Capable */
+#define MII_SR_100X_FD_CAPS      0x4000 /* 100X  Full Duplex Capable */
+#define MII_SR_100T4_CAPS        0x8000 /* 100T4 Capable */
+
+/* Autoneg Advertisement Register */
+#define NWAY_AR_SELECTOR_FIELD 0x0001   /* indicates IEEE 802.3 CSMA/CD */
+#define NWAY_AR_10T_HD_CAPS    0x0020   /* 10T   Half Duplex Capable */
+#define NWAY_AR_10T_FD_CAPS    0x0040   /* 10T   Full Duplex Capable */
+#define NWAY_AR_100TX_HD_CAPS  0x0080   /* 100TX Half Duplex Capable */
+#define NWAY_AR_100TX_FD_CAPS  0x0100   /* 100TX Full Duplex Capable */
+#define NWAY_AR_100T4_CAPS     0x0200   /* 100T4 Capable */
+#define NWAY_AR_PAUSE          0x0400   /* Pause operation desired */
+#define NWAY_AR_ASM_DIR        0x0800   /* Asymmetric Pause Direction bit */
+#define NWAY_AR_REMOTE_FAULT   0x2000   /* Remote Fault detected */
+#define NWAY_AR_NEXT_PAGE      0x8000   /* Next Page ability supported */
+
+/* Link Partner Ability Register (Base Page) */
+#define NWAY_LPAR_SELECTOR_FIELD 0x0000 /* LP protocol selector field */
+#define NWAY_LPAR_10T_HD_CAPS    0x0020 /* LP is 10T   Half Duplex Capable */
+#define NWAY_LPAR_10T_FD_CAPS    0x0040 /* LP is 10T   Full Duplex Capable */
+#define NWAY_LPAR_100TX_HD_CAPS  0x0080 /* LP is 100TX Half Duplex Capable */
+#define NWAY_LPAR_100TX_FD_CAPS  0x0100 /* LP is 100TX Full Duplex Capable */
+#define NWAY_LPAR_100T4_CAPS     0x0200 /* LP is 100T4 Capable */
+#define NWAY_LPAR_PAUSE          0x0400 /* LP Pause operation desired */
+#define NWAY_LPAR_ASM_DIR        0x0800 /* LP Asymmetric Pause Direction bit */
+#define NWAY_LPAR_REMOTE_FAULT   0x2000 /* LP has detected Remote Fault */
+#define NWAY_LPAR_ACKNOWLEDGE    0x4000 /* LP has rx'd link code word */
+#define NWAY_LPAR_NEXT_PAGE      0x8000 /* Next Page ability supported */
+
+/* Autoneg Expansion Register */
+#define NWAY_ER_LP_NWAY_CAPS      0x0001 /* LP has Auto Neg Capability */
+#define NWAY_ER_PAGE_RXD          0x0002 /* LP is 10T   Half Duplex Capable */
+#define NWAY_ER_NEXT_PAGE_CAPS    0x0004 /* LP is 10T   Full Duplex Capable */
+#define NWAY_ER_LP_NEXT_PAGE_CAPS 0x0008 /* LP is 100TX Half Duplex Capable */
+#define NWAY_ER_PAR_DETECT_FAULT  0x0010 /* LP is 100TX Full Duplex Capable */
+
+/* Next Page TX Register */
+#define NPTX_MSG_CODE_FIELD 0x0001 /* NP msg code or unformatted data */
+#define NPTX_TOGGLE         0x0800 /* Toggles between exchanges
+                                    * of different NP
+                                    */
+#define NPTX_ACKNOWLDGE2    0x1000 /* 1 = will comply with msg
+                                    * 0 = cannot comply with msg
+                                    */
+#define NPTX_MSG_PAGE       0x2000 /* formatted(1)/unformatted(0) pg */
+#define NPTX_NEXT_PAGE      0x8000 /* 1 = addition NP will follow 
+                                    * 0 = sending last NP
+                                    */
+
+/* Link Partner Next Page Register */
+#define LP_RNPR_MSG_CODE_FIELD 0x0001 /* NP msg code or unformatted data */
+#define LP_RNPR_TOGGLE         0x0800 /* Toggles between exchanges
+                                       * of different NP
+                                       */
+#define LP_RNPR_ACKNOWLDGE2    0x1000 /* 1 = will comply with msg 
+                                       * 0 = cannot comply with msg
+                                       */
+#define LP_RNPR_MSG_PAGE       0x2000  /* formatted(1)/unformatted(0) pg */
+#define LP_RNPR_ACKNOWLDGE     0x4000  /* 1 = ACK / 0 = NO ACK */
+#define LP_RNPR_NEXT_PAGE      0x8000  /* 1 = addition NP will follow
+                                        * 0 = sending last NP 
+                                        */
+
+/* 1000BASE-T Control Register */
+#define CR_1000T_ASYM_PAUSE      0x0080 /* Advertise asymmetric pause bit */
+#define CR_1000T_HD_CAPS         0x0100 /* Advertise 1000T HD capability */
+#define CR_1000T_FD_CAPS         0x0200 /* Advertise 1000T FD capability  */
+#define CR_1000T_REPEATER_DTE    0x0400 /* 1=Repeater/switch device port */
+                                        /* 0=DTE device */
+#define CR_1000T_MS_VALUE        0x0800 /* 1=Configure PHY as Master */
+                                        /* 0=Configure PHY as Slave */
+#define CR_1000T_MS_ENABLE       0x1000 /* 1=Master/Slave manual config value */
+                                        /* 0=Automatic Master/Slave config */
+#define CR_1000T_TEST_MODE_NORMAL 0x0000 /* Normal Operation */
+#define CR_1000T_TEST_MODE_1     0x2000 /* Transmit Waveform test */
+#define CR_1000T_TEST_MODE_2     0x4000 /* Master Transmit Jitter test */
+#define CR_1000T_TEST_MODE_3     0x6000 /* Slave Transmit Jitter test */
+#define CR_1000T_TEST_MODE_4     0x8000 /* Transmitter Distortion test */
+
+/* 1000BASE-T Status Register */
+#define SR_1000T_IDLE_ERROR_CNT   0x00FF /* Num idle errors since last read */
+#define SR_1000T_ASYM_PAUSE_DIR   0x0100 /* LP asymmetric pause direction bit */
+#define SR_1000T_LP_HD_CAPS       0x0400 /* LP is 1000T HD capable */
+#define SR_1000T_LP_FD_CAPS       0x0800 /* LP is 1000T FD capable */
+#define SR_1000T_REMOTE_RX_STATUS 0x1000 /* Remote receiver OK */
+#define SR_1000T_LOCAL_RX_STATUS  0x2000 /* Local receiver OK */
+#define SR_1000T_MS_CONFIG_RES    0x4000 /* 1=Local TX is Master, 0=Slave */
+#define SR_1000T_MS_CONFIG_FAULT  0x8000 /* Master/Slave config fault */
+#define SR_1000T_REMOTE_RX_STATUS_SHIFT 12
+#define SR_1000T_LOCAL_RX_STATUS_SHIFT  13
+#define SR_1000T_PHY_EXCESSIVE_IDLE_ERR_COUNT    5
+#define FFE_IDLE_ERR_COUNT_TIMEOUT_20            20
+#define FFE_IDLE_ERR_COUNT_TIMEOUT_100           100
+
+/* Extended Status Register */
+#define IEEE_ESR_1000T_HD_CAPS 0x1000 /* 1000T HD capable */
+#define IEEE_ESR_1000T_FD_CAPS 0x2000 /* 1000T FD capable */
+#define IEEE_ESR_1000X_HD_CAPS 0x4000 /* 1000X HD capable */
+#define IEEE_ESR_1000X_FD_CAPS 0x8000 /* 1000X FD capable */
+
+#define PHY_TX_POLARITY_MASK   0x0100 /* register 10h bit 8 (polarity bit) */
+#define PHY_TX_NORMAL_POLARITY 0      /* register 10h bit 8 (normal polarity) */
+
+#define AUTO_POLARITY_DISABLE  0x0010 /* register 11h bit 4 */
+                                      /* (0=enable, 1=disable) */
+
+/* M88E1000 PHY Specific Control Register */
+#define M88E1000_PSCR_JABBER_DISABLE    0x0001 /* 1=Jabber Function disabled */
+#define M88E1000_PSCR_POLARITY_REVERSAL 0x0002 /* 1=Polarity Reversal enabled */
+#define M88E1000_PSCR_SQE_TEST          0x0004 /* 1=SQE Test enabled */
+#define M88E1000_PSCR_CLK125_DISABLE    0x0010 /* 1=CLK125 low, 
+                                                * 0=CLK125 toggling
+                                                */
+#define M88E1000_PSCR_MDI_MANUAL_MODE  0x0000  /* MDI Crossover Mode bits 6:5 */
+                                               /* Manual MDI configuration */
+#define M88E1000_PSCR_MDIX_MANUAL_MODE 0x0020  /* Manual MDIX configuration */
+#define M88E1000_PSCR_AUTO_X_1000T     0x0040  /* 1000BASE-T: Auto crossover,
+                                                *  100BASE-TX/10BASE-T: 
+                                                *  MDI Mode
+                                                */
+#define M88E1000_PSCR_AUTO_X_MODE      0x0060  /* Auto crossover enabled 
+                                                * all speeds. 
+                                                */
+#define M88E1000_PSCR_10BT_EXT_DIST_ENABLE 0x0080 
+                                        /* 1=Enable Extended 10BASE-T distance
+                                         * (Lower 10BASE-T RX Threshold)
+                                         * 0=Normal 10BASE-T RX Threshold */
+#define M88E1000_PSCR_MII_5BIT_ENABLE      0x0100
+                                        /* 1=5-Bit interface in 100BASE-TX
+                                         * 0=MII interface in 100BASE-TX */
+#define M88E1000_PSCR_SCRAMBLER_DISABLE    0x0200 /* 1=Scrambler disable */
+#define M88E1000_PSCR_FORCE_LINK_GOOD      0x0400 /* 1=Force link good */
+#define M88E1000_PSCR_ASSERT_CRS_ON_TX     0x0800 /* 1=Assert CRS on Transmit */
+
+#define M88E1000_PSCR_POLARITY_REVERSAL_SHIFT    1
+#define M88E1000_PSCR_AUTO_X_MODE_SHIFT          5
+#define M88E1000_PSCR_10BT_EXT_DIST_ENABLE_SHIFT 7
+
+/* M88E1000 PHY Specific Status Register */
+#define M88E1000_PSSR_JABBER             0x0001 /* 1=Jabber */
+#define M88E1000_PSSR_REV_POLARITY       0x0002 /* 1=Polarity reversed */
+#define M88E1000_PSSR_DOWNSHIFT          0x0020 /* 1=Downshifted */
+#define M88E1000_PSSR_MDIX               0x0040 /* 1=MDIX; 0=MDI */
+#define M88E1000_PSSR_CABLE_LENGTH       0x0380 /* 0=<50M;1=50-80M;2=80-110M;
+                                            * 3=110-140M;4=>140M */
+#define M88E1000_PSSR_LINK               0x0400 /* 1=Link up, 0=Link down */
+#define M88E1000_PSSR_SPD_DPLX_RESOLVED  0x0800 /* 1=Speed & Duplex resolved */
+#define M88E1000_PSSR_PAGE_RCVD          0x1000 /* 1=Page received */
+#define M88E1000_PSSR_DPLX               0x2000 /* 1=Duplex 0=Half Duplex */
+#define M88E1000_PSSR_SPEED              0xC000 /* Speed, bits 14:15 */
+#define M88E1000_PSSR_10MBS              0x0000 /* 00=10Mbs */
+#define M88E1000_PSSR_100MBS             0x4000 /* 01=100Mbs */
+#define M88E1000_PSSR_1000MBS            0x8000 /* 10=1000Mbs */
+
+#define M88E1000_PSSR_REV_POLARITY_SHIFT 1
+#define M88E1000_PSSR_DOWNSHIFT_SHIFT    5
+#define M88E1000_PSSR_MDIX_SHIFT         6
+#define M88E1000_PSSR_CABLE_LENGTH_SHIFT 7
+
+/* M88E1000 Extended PHY Specific Control Register */
+#define M88E1000_EPSCR_FIBER_LOOPBACK 0x4000 /* 1=Fiber loopback */
+#define M88E1000_EPSCR_DOWN_NO_IDLE   0x8000 /* 1=Lost lock detect enabled.
+                                              * Will assert lost lock and bring
+                                              * link down if idle not seen
+                                              * within 1ms in 1000BASE-T 
+                                              */
+/* Number of times we will attempt to autonegotiate before downshifting if we
+ * are the master */
+#define M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK 0x0C00
+#define M88E1000_EPSCR_MASTER_DOWNSHIFT_1X   0x0000    
+#define M88E1000_EPSCR_MASTER_DOWNSHIFT_2X   0x0400
+#define M88E1000_EPSCR_MASTER_DOWNSHIFT_3X   0x0800
+#define M88E1000_EPSCR_MASTER_DOWNSHIFT_4X   0x0C00
+/* Number of times we will attempt to autonegotiate before downshifting if we
+ * are the slave */
+#define M88E1000_EPSCR_SLAVE_DOWNSHIFT_MASK  0x0300
+#define M88E1000_EPSCR_SLAVE_DOWNSHIFT_DIS   0x0000
+#define M88E1000_EPSCR_SLAVE_DOWNSHIFT_1X    0x0100
+#define M88E1000_EPSCR_SLAVE_DOWNSHIFT_2X    0x0200
+#define M88E1000_EPSCR_SLAVE_DOWNSHIFT_3X    0x0300
+#define M88E1000_EPSCR_TX_CLK_2_5     0x0060 /* 2.5 MHz TX_CLK */
+#define M88E1000_EPSCR_TX_CLK_25      0x0070 /* 25  MHz TX_CLK */
+#define M88E1000_EPSCR_TX_CLK_0       0x0000 /* NO  TX_CLK */
+
+/* IGP01E1000 Specific Port Config Register - R/W */
+#define IGP01E1000_PSCFR_AUTO_MDIX_PAR_DETECT  0x0010
+#define IGP01E1000_PSCFR_PRE_EN                0x0020
+#define IGP01E1000_PSCFR_SMART_SPEED           0x0080
+#define IGP01E1000_PSCFR_DISABLE_TPLOOPBACK    0x0100
+#define IGP01E1000_PSCFR_DISABLE_JABBER        0x0400
+#define IGP01E1000_PSCFR_DISABLE_TRANSMIT      0x2000
+
+/* IGP01E1000 Specific Port Status Register - R/O */
+#define IGP01E1000_PSSR_AUTONEG_FAILED         0x0001 /* RO LH SC */
+#define IGP01E1000_PSSR_POLARITY_REVERSED      0x0002
+#define IGP01E1000_PSSR_CABLE_LENGTH           0x007C
+#define IGP01E1000_PSSR_FULL_DUPLEX            0x0200
+#define IGP01E1000_PSSR_LINK_UP                0x0400
+#define IGP01E1000_PSSR_MDIX                   0x0800
+#define IGP01E1000_PSSR_SPEED_MASK             0xC000 /* speed bits mask */
+#define IGP01E1000_PSSR_SPEED_10MBPS           0x4000
+#define IGP01E1000_PSSR_SPEED_100MBPS          0x8000
+#define IGP01E1000_PSSR_SPEED_1000MBPS         0xC000
+#define IGP01E1000_PSSR_CABLE_LENGTH_SHIFT     0x0002 /* shift right 2 */
+#define IGP01E1000_PSSR_MDIX_SHIFT             0x000B /* shift right 11 */
+
+/* IGP01E1000 Specific Port Control Register - R/W */
+#define IGP01E1000_PSCR_TP_LOOPBACK            0x0001
+#define IGP01E1000_PSCR_CORRECT_NC_SCMBLR      0x0200
+#define IGP01E1000_PSCR_TEN_CRS_SELECT         0x0400
+#define IGP01E1000_PSCR_FLIP_CHIP              0x0800
+#define IGP01E1000_PSCR_AUTO_MDIX              0x1000
+#define IGP01E1000_PSCR_FORCE_MDI_MDIX         0x2000 /* 0-MDI, 1-MDIX */
+
+/* IGP01E1000 Specific Port Link Health Register */
+#define IGP01E1000_PLHR_SS_DOWNGRADE           0x8000
+#define IGP01E1000_PLHR_GIG_SCRAMBLER_ERROR    0x4000
+#define IGP01E1000_PLHR_GIG_REM_RCVR_NOK       0x0800 /* LH */
+#define IGP01E1000_PLHR_IDLE_ERROR_CNT_OFLOW   0x0400 /* LH */
+#define IGP01E1000_PLHR_DATA_ERR_1             0x0200 /* LH */
+#define IGP01E1000_PLHR_DATA_ERR_0             0x0100
+#define IGP01E1000_PLHR_AUTONEG_FAULT          0x0010
+#define IGP01E1000_PLHR_AUTONEG_ACTIVE         0x0008
+#define IGP01E1000_PLHR_VALID_CHANNEL_D        0x0004
+#define IGP01E1000_PLHR_VALID_CHANNEL_C        0x0002
+#define IGP01E1000_PLHR_VALID_CHANNEL_B        0x0001
+#define IGP01E1000_PLHR_VALID_CHANNEL_A        0x0000
+
+/* IGP01E1000 Channel Quality Register */
+#define IGP01E1000_MSE_CHANNEL_D        0x000F
+#define IGP01E1000_MSE_CHANNEL_C        0x00F0
+#define IGP01E1000_MSE_CHANNEL_B        0x0F00
+#define IGP01E1000_MSE_CHANNEL_A        0xF000
+
+/* IGP01E1000 DSP reset macros */
+#define DSP_RESET_ENABLE     0x0
+#define DSP_RESET_DISABLE    0x2
+#define E1000_MAX_DSP_RESETS 10
+
+/* IGP01E1000 AGC Registers */
+
+#define IGP01E1000_AGC_LENGTH_SHIFT 7         /* Coarse - 13:11, Fine - 10:7 */
+
+/* 7 bits (3 Coarse + 4 Fine) --> 128 optional values */
+#define IGP01E1000_AGC_LENGTH_TABLE_SIZE 128
+
+/* The precision of the length is +/- 10 meters */
+#define IGP01E1000_AGC_RANGE    10
+
+/* IGP01E1000 PCS Initialization register */
+/* bits 3:6 in the PCS registers stores the channels polarity */
+#define IGP01E1000_PHY_POLARITY_MASK    0x0078
+
+/* IGP01E1000 GMII FIFO Register */
+#define IGP01E1000_GMII_FLEX_SPD               0x10 /* Enable flexible speed
+                                                     * on Link-Up */
+#define IGP01E1000_GMII_SPD                    0x20 /* Enable SPD */
+
+/* IGP01E1000 Analog Register */
+#define IGP01E1000_ANALOG_SPARE_FUSE_STATUS         0x20D1
+#define IGP01E1000_ANALOG_FUSE_STATUS               0x20D0
+#define IGP01E1000_ANALOG_FUSE_CONTROL              0x20DC
+#define IGP01E1000_ANALOG_FUSE_BYPASS               0x20DE
+
+#define IGP01E1000_ANALOG_FUSE_POLY_MASK            0xF000
+#define IGP01E1000_ANALOG_FUSE_FINE_MASK            0x0F80
+#define IGP01E1000_ANALOG_FUSE_COARSE_MASK          0x0070
+#define IGP01E1000_ANALOG_SPARE_FUSE_ENABLED        0x0100
+#define IGP01E1000_ANALOG_FUSE_ENABLE_SW_CONTROL    0x0002
+
+#define IGP01E1000_ANALOG_FUSE_COARSE_THRESH        0x0040
+#define IGP01E1000_ANALOG_FUSE_COARSE_10            0x0010
+#define IGP01E1000_ANALOG_FUSE_FINE_1               0x0080
+#define IGP01E1000_ANALOG_FUSE_FINE_10              0x0500
+
+/* Bit definitions for valid PHY IDs. */
+#define M88E1000_E_PHY_ID  0x01410C50
+#define M88E1000_I_PHY_ID  0x01410C30
+#define M88E1011_I_PHY_ID  0x01410C20
+#define IGP01E1000_I_PHY_ID  0x02A80380
+#define M88E1000_12_PHY_ID M88E1000_E_PHY_ID
+#define M88E1000_14_PHY_ID M88E1000_E_PHY_ID
+#define M88E1011_I_REV_4   0x04
+
+/* Miscellaneous PHY bit definitions. */
+#define PHY_PREAMBLE        0xFFFFFFFF
+#define PHY_SOF             0x01
+#define PHY_OP_READ         0x02
+#define PHY_OP_WRITE        0x01
+#define PHY_TURNAROUND      0x02
+#define PHY_PREAMBLE_SIZE   32
+#define MII_CR_SPEED_1000   0x0040
+#define MII_CR_SPEED_100    0x2000
+#define MII_CR_SPEED_10     0x0000
+#define E1000_PHY_ADDRESS   0x01
+#define PHY_AUTO_NEG_TIME   45  /* 4.5 Seconds */
+#define PHY_FORCE_TIME      20  /* 2.0 Seconds */
+#define PHY_REVISION_MASK   0xFFFFFFF0
+#define DEVICE_SPEED_MASK   0x00000300  /* Device Ctrl Reg Speed Mask */
+#define REG4_SPEED_MASK     0x01E0
+#define REG9_SPEED_MASK     0x0300
+#define ADVERTISE_10_HALF   0x0001
+#define ADVERTISE_10_FULL   0x0002
+#define ADVERTISE_100_HALF  0x0004
+#define ADVERTISE_100_FULL  0x0008
+#define ADVERTISE_1000_HALF 0x0010
+#define ADVERTISE_1000_FULL 0x0020
+#define AUTONEG_ADVERTISE_SPEED_DEFAULT 0x002F  /* Everything but 1000-Half */
+#define AUTONEG_ADVERTISE_10_100_ALL    0x000F	/* All 10/100 speeds*/
+#define AUTONEG_ADVERTISE_10_ALL        0x0003	/* 10Mbps Full & Half speeds*/
+
+#endif /* _E1000_HW_H_ */
diff -Naur grub-0.97.orig/netboot/eepro.c grub-0.97/netboot/eepro.c
--- grub-0.97.orig/netboot/eepro.c	2003-07-09 11:45:37.000000000 +0000
+++ grub-0.97/netboot/eepro.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,586 +0,0 @@
-/**************************************************************************
-Etherboot -  BOOTP/TFTP Bootstrap Program
-Intel EEPRO/10 NIC driver for Etherboot
-Adapted from Linux eepro.c from kernel 2.2.17
-
-This board accepts a 32 pin EEPROM (29C256), however a test with a
-27C010 shows that this EPROM also works in the socket, but it's not clear
-how repeatably. The two top address pins appear to be held low, thus
-the bottom 32kB of the 27C010 is visible in the CPU's address space.
-To be sure you could put 4 copies of the code in the 27C010, then
-it doesn't matter whether the extra lines are held low or high, just
-hopefully not floating as CMOS chips don't like floating inputs.
-
-Be careful with seating the EPROM as the socket on my board actually
-has 34 pins, the top row of 2 are not used.
-***************************************************************************/
-
-/*
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2, or (at
- * your option) any later version.
- */
-
-/* to get some global routines like printf */
-#include "etherboot.h"
-/* to get the interface to the body of the program */
-#include "nic.h"
-/* to get our own prototype */
-#include "cards.h"
-/* we use timer2 for microsecond waits */
-#include "timer.h"
-
-#undef	DEBUG		/* only after include files */
-
-/* Different 82595 chips */
-#define LAN595		0
-#define LAN595TX	1
-#define LAN595FX	2
-#define LAN595FX_10ISA	3
-
-#define	SLOW_DOWN	inb(0x80);
-
-/* The station (ethernet) address prefix, used for IDing the board. */
-#define SA_ADDR0 0x00	/* Etherexpress Pro/10 */
-#define SA_ADDR1 0xaa
-#define SA_ADDR2 0x00
-
-#define GetBit(x,y) ((x & (1<<y))>>y)
-
-/* EEPROM Word 0: */
-#define ee_PnP       0  /* Plug 'n Play enable bit */
-#define ee_Word1     1  /* Word 1? */
-#define ee_BusWidth  2  /* 8/16 bit */
-#define ee_FlashAddr 3  /* Flash Address */
-#define ee_FlashMask 0x7   /* Mask */
-#define ee_AutoIO    6  /* */
-#define ee_reserved0 7  /* =0! */
-#define ee_Flash     8  /* Flash there? */
-#define ee_AutoNeg   9  /* Auto Negotiation enabled? */
-#define ee_IO0       10 /* IO Address LSB */
-#define ee_IO0Mask   0x /*...*/
-#define ee_IO1       15 /* IO MSB */
-
-/* EEPROM Word 1: */
-#define ee_IntSel    0   /* Interrupt */
-#define ee_IntMask   0x7
-#define ee_LI        3   /* Link Integrity 0= enabled */
-#define ee_PC        4   /* Polarity Correction 0= enabled */
-#define ee_TPE_AUI   5   /* PortSelection 1=TPE */
-#define ee_Jabber    6   /* Jabber prevention 0= enabled */
-#define ee_AutoPort  7   /* Auto Port Selection 1= Disabled */
-#define ee_SMOUT     8   /* SMout Pin Control 0= Input */
-#define ee_PROM      9   /* Flash EPROM / PROM 0=Flash */
-#define ee_reserved1 10  /* .. 12 =0! */
-#define ee_AltReady  13  /* Alternate Ready, 0=normal */
-#define ee_reserved2 14  /* =0! */
-#define ee_Duplex    15
-
-/* Word2,3,4: */
-#define ee_IA5       0 /*bit start for individual Addr Byte 5 */
-#define ee_IA4       8 /*bit start for individual Addr Byte 5 */
-#define ee_IA3       0 /*bit start for individual Addr Byte 5 */
-#define ee_IA2       8 /*bit start for individual Addr Byte 5 */
-#define ee_IA1       0 /*bit start for individual Addr Byte 5 */
-#define ee_IA0       8 /*bit start for individual Addr Byte 5 */
-
-/* Word 5: */
-#define ee_BNC_TPE   0 /* 0=TPE */
-#define ee_BootType  1 /* 00=None, 01=IPX, 10=ODI, 11=NDIS */
-#define ee_BootTypeMask 0x3 
-#define ee_NumConn   3  /* Number of Connections 0= One or Two */
-#define ee_FlashSock 4  /* Presence of Flash Socket 0= Present */
-#define ee_PortTPE   5
-#define ee_PortBNC   6
-#define ee_PortAUI   7
-#define ee_PowerMgt  10 /* 0= disabled */
-#define ee_CP        13 /* Concurrent Processing */
-#define ee_CPMask    0x7
-
-/* Word 6: */
-#define ee_Stepping  0 /* Stepping info */
-#define ee_StepMask  0x0F
-#define ee_BoardID   4 /* Manucaturer Board ID, reserved */
-#define ee_BoardMask 0x0FFF
-
-/* Word 7: */
-#define ee_INT_TO_IRQ 0 /* int to IRQ Mapping  = 0x1EB8 for Pro/10+ */
-#define ee_FX_INT2IRQ 0x1EB8 /* the _only_ mapping allowed for FX chips */
-
-/*..*/
-#define ee_SIZE 0x40 /* total EEprom Size */
-#define ee_Checksum 0xBABA /* initial and final value for adding checksum */
-
-
-/* Card identification via EEprom:   */
-#define ee_addr_vendor 0x10  /* Word offset for EISA Vendor ID */
-#define ee_addr_id 0x11      /* Word offset for Card ID */
-#define ee_addr_SN 0x12      /* Serial Number */
-#define ee_addr_CRC_8 0x14   /* CRC over last thee Bytes */
-
-
-#define ee_vendor_intel0 0x25  /* Vendor ID Intel */
-#define ee_vendor_intel1 0xD4
-#define ee_id_eepro10p0 0x10   /* ID for eepro/10+ */
-#define ee_id_eepro10p1 0x31
-
-/* now this section could be used by both boards: the oldies and the ee10:
- * ee10 uses tx buffer before of rx buffer and the oldies the inverse.
- * (aris)
- */
-#define	RAM_SIZE	0x8000
-
-#define	RCV_HEADER	8
-#define RCV_DEFAULT_RAM	0x6000
-#define RCV_RAM 	rcv_ram
-
-static unsigned rcv_ram = RCV_DEFAULT_RAM;
-
-#define XMT_HEADER	8
-#define XMT_RAM		(RAM_SIZE - RCV_RAM)
-
-#define XMT_START	((rcv_start + RCV_RAM) % RAM_SIZE)
-
-#define RCV_LOWER_LIMIT	(rcv_start >> 8)
-#define RCV_UPPER_LIMIT	(((rcv_start + RCV_RAM) - 2) >> 8)
-#define XMT_LOWER_LIMIT	(XMT_START >> 8)
-#define XMT_UPPER_LIMIT	(((XMT_START + XMT_RAM) - 2) >> 8)
-
-#define RCV_START_PRO	0x00
-#define RCV_START_10	XMT_RAM
-					/* by default the old driver */
-static unsigned rcv_start = RCV_START_PRO;
-
-#define	RCV_DONE	0x0008
-#define	RX_OK		0x2000
-#define	RX_ERROR	0x0d81
-
-#define	TX_DONE_BIT	0x0080
-#define	CHAIN_BIT	0x8000
-#define	XMT_STATUS	0x02
-#define	XMT_CHAIN	0x04
-#define	XMT_COUNT	0x06
-
-#define	BANK0_SELECT	0x00		
-#define	BANK1_SELECT	0x40		
-#define	BANK2_SELECT	0x80		
-
-/* Bank 0 registers */
-#define	COMMAND_REG	0x00	/* Register 0 */
-#define	MC_SETUP	0x03
-#define	XMT_CMD		0x04
-#define	DIAGNOSE_CMD	0x07
-#define	RCV_ENABLE_CMD	0x08
-#define	RCV_DISABLE_CMD	0x0a
-#define	STOP_RCV_CMD	0x0b
-#define	RESET_CMD	0x0e
-#define	POWER_DOWN_CMD	0x18
-#define	RESUME_XMT_CMD	0x1c
-#define	SEL_RESET_CMD	0x1e
-#define	STATUS_REG	0x01	/* Register 1 */
-#define	RX_INT		0x02
-#define	TX_INT		0x04
-#define	EXEC_STATUS	0x30
-#define	ID_REG		0x02	/* Register 2	*/
-#define	R_ROBIN_BITS	0xc0	/* round robin counter */
-#define	ID_REG_MASK	0x2c
-#define	ID_REG_SIG	0x24
-#define	AUTO_ENABLE	0x10
-#define	INT_MASK_REG	0x03	/* Register 3	*/
-#define	RX_STOP_MASK	0x01
-#define	RX_MASK		0x02
-#define	TX_MASK		0x04
-#define	EXEC_MASK	0x08
-#define	ALL_MASK	0x0f
-#define	IO_32_BIT	0x10
-#define	RCV_BAR		0x04	/* The following are word (16-bit) registers */
-#define	RCV_STOP	0x06
-
-#define	XMT_BAR_PRO	0x0a
-#define	XMT_BAR_10	0x0b
-static unsigned xmt_bar = XMT_BAR_PRO;
-
-#define	HOST_ADDRESS_REG	0x0c
-#define	IO_PORT		0x0e
-#define	IO_PORT_32_BIT	0x0c
-
-/* Bank 1 registers */
-#define	REG1	0x01
-#define	WORD_WIDTH	0x02
-#define	INT_ENABLE	0x80
-#define INT_NO_REG	0x02
-#define	RCV_LOWER_LIMIT_REG	0x08
-#define	RCV_UPPER_LIMIT_REG	0x09
-
-#define	XMT_LOWER_LIMIT_REG_PRO	0x0a
-#define	XMT_UPPER_LIMIT_REG_PRO	0x0b
-#define	XMT_LOWER_LIMIT_REG_10	0x0b
-#define	XMT_UPPER_LIMIT_REG_10	0x0a
-static unsigned xmt_lower_limit_reg = XMT_LOWER_LIMIT_REG_PRO;
-static unsigned xmt_upper_limit_reg = XMT_UPPER_LIMIT_REG_PRO;
-
-/* Bank 2 registers */
-#define	XMT_Chain_Int	0x20	/* Interrupt at the end of the transmit chain */
-#define	XMT_Chain_ErrStop	0x40 /* Interrupt at the end of the chain even if there are errors */
-#define	RCV_Discard_BadFrame	0x80 /* Throw bad frames away, and continue to receive others */
-#define	REG2		0x02
-#define	PRMSC_Mode	0x01
-#define	Multi_IA	0x20
-#define	REG3		0x03
-#define	TPE_BIT		0x04
-#define	BNC_BIT		0x20
-#define	REG13		0x0d
-#define	FDX		0x00
-#define	A_N_ENABLE	0x02
-	
-#define	I_ADD_REG0	0x04
-#define	I_ADD_REG1	0x05
-#define	I_ADD_REG2	0x06
-#define	I_ADD_REG3	0x07
-#define	I_ADD_REG4	0x08
-#define	I_ADD_REG5	0x09
-
-#define EEPROM_REG_PRO	0x0a
-#define EEPROM_REG_10	0x0b
-static unsigned eeprom_reg = EEPROM_REG_PRO;
-
-#define EESK 0x01
-#define EECS 0x02
-#define EEDI 0x04
-#define EEDO 0x08
-
-/* The horrible routine to read a word from the serial EEPROM. */
-/* IMPORTANT - the 82595 will be set to Bank 0 after the eeprom is read */
-
-/* The delay between EEPROM clock transitions. */
-#define eeprom_delay() { udelay(40); }
-#define EE_READ_CMD (6 << 6)
-
-/* do a full reset */
-#define eepro_full_reset(ioaddr)	outb(RESET_CMD, ioaddr); udelay(40);
-
-/* do a nice reset */
-#define eepro_sel_reset(ioaddr) 	{ \
-					outb(SEL_RESET_CMD, ioaddr); \
-					SLOW_DOWN; \
-					SLOW_DOWN; \
-					}
-
-/* clear all interrupts */
-#define	eepro_clear_int(ioaddr)	outb(ALL_MASK, ioaddr + STATUS_REG)
-
-/* enable rx */
-#define	eepro_en_rx(ioaddr)	outb(RCV_ENABLE_CMD, ioaddr)
-
-/* disable rx */
-#define	eepro_dis_rx(ioaddr)	outb(RCV_DISABLE_CMD, ioaddr)
-
-/* switch bank */
-#define eepro_sw2bank0(ioaddr) outb(BANK0_SELECT, ioaddr)
-#define eepro_sw2bank1(ioaddr) outb(BANK1_SELECT, ioaddr)
-#define eepro_sw2bank2(ioaddr) outb(BANK2_SELECT, ioaddr)
-
-static unsigned int	rx_start, tx_start;
-static int		tx_last;
-static unsigned		tx_end;
-static int		eepro = 0;
-static unsigned short	ioaddr = 0;
-static unsigned int	mem_start, mem_end = RCV_DEFAULT_RAM / 1024;
-
-#define	udelay(n)	waiton_timer2(((n)*TICKS_PER_MS)/1000)
-
-/**************************************************************************
-RESET - Reset adapter
-***************************************************************************/
-static void eepro_reset(struct nic *nic)
-{
-	int		temp_reg, i;
-
-	/* put the card in its initial state */
-	eepro_sw2bank2(ioaddr);	/* be careful, bank2 now */
-	temp_reg = inb(ioaddr + eeprom_reg);
-#ifdef	DEBUG
-	printf("Stepping %d\n", temp_reg >> 5);
-#endif
-	if (temp_reg & 0x10)	/* check the TurnOff Enable bit */
-		outb(temp_reg & 0xEF, ioaddr + eeprom_reg);
-	for (i = 0; i < ETH_ALEN; i++)	/* fill the MAC address */
-		outb(nic->node_addr[i], ioaddr + I_ADD_REG0 + i);
-	temp_reg = inb(ioaddr + REG1);
-	/* setup Transmit Chaining and discard bad RCV frames */
-	outb(temp_reg | XMT_Chain_Int | XMT_Chain_ErrStop
-		| RCV_Discard_BadFrame, ioaddr + REG1);
-	temp_reg = inb(ioaddr + REG2);		/* match broadcast */
-	outb(temp_reg | 0x14, ioaddr + REG2);
-	temp_reg = inb(ioaddr + REG3);
-	outb(temp_reg & 0x3F, ioaddr + REG3);	/* clear test mode */
-	/* set the receiving mode */
-	eepro_sw2bank1(ioaddr);	/* be careful, bank1 now */
-	/* initialise the RCV and XMT upper and lower limits */
-	outb(RCV_LOWER_LIMIT, ioaddr + RCV_LOWER_LIMIT_REG);
-	outb(RCV_UPPER_LIMIT, ioaddr + RCV_UPPER_LIMIT_REG);
-	outb(XMT_LOWER_LIMIT, ioaddr + xmt_lower_limit_reg);
-	outb(XMT_UPPER_LIMIT, ioaddr + xmt_upper_limit_reg);
-	eepro_sw2bank0(ioaddr);	/* Switch back to bank 0 */
-	eepro_clear_int(ioaddr);
-	/* Initialise RCV */
-	outw(rx_start = (RCV_LOWER_LIMIT << 8), ioaddr + RCV_BAR);
-	outw(((RCV_UPPER_LIMIT << 8) | 0xFE), ioaddr + RCV_STOP);
-	/* Intialise XMT */
-	outw((XMT_LOWER_LIMIT << 8), ioaddr + xmt_bar);
-	eepro_sel_reset(ioaddr);
-	tx_start = tx_end = (XMT_LOWER_LIMIT << 8);
-	tx_last = 0;
-	eepro_en_rx(ioaddr);
-}
-
-/**************************************************************************
-POLL - Wait for a frame
-***************************************************************************/
-static int eepro_poll(struct nic *nic)
-{
-	int		i;
-	unsigned int	rcv_car = rx_start;
-	unsigned int	rcv_event, rcv_status, rcv_next_frame, rcv_size;
-
-	/* return true if there's an ethernet packet ready to read */
-	/* nic->packet should contain data on return */
-	/* nic->packetlen should contain length of data */
-#if	0
-	if ((inb(ioaddr + STATUS_REG) & 0x40) == 0)
-		return (0);
-	outb(0x40, ioaddr + STATUS_REG);
-#endif
-	outw(rcv_car, ioaddr + HOST_ADDRESS_REG);
-	rcv_event = inw(ioaddr + IO_PORT);
-	if (rcv_event != RCV_DONE)
-		return (0);
-	rcv_status = inw(ioaddr + IO_PORT);
-	rcv_next_frame = inw(ioaddr + IO_PORT);
-	rcv_size = inw(ioaddr + IO_PORT);
-#if	0
-	printf("%hX %hX %d %hhX\n", rcv_status, rcv_next_frame, rcv_size,
-		inb(ioaddr + STATUS_REG));
-#endif
-	if ((rcv_status & (RX_OK|RX_ERROR)) != RX_OK) {
-		printf("Receive error %hX\n", rcv_status);
-		return (0);
-	}
-	rcv_size &= 0x3FFF;
-	insw(ioaddr + IO_PORT, nic->packet, ((rcv_size + 3) >> 1));
-#if	0
-	for (i = 0; i < 48; i++) {
-		printf("%hhX", nic->packet[i]);
-		putchar(i % 16 == 15 ? '\n' : ' ');
-	}
-#endif
-	nic->packetlen = rcv_size;
-	rcv_car = rx_start + RCV_HEADER + rcv_size;
-	rx_start = rcv_next_frame;
-	if (rcv_car == 0)
-		rcv_car = ((RCV_UPPER_LIMIT << 8) | 0xff);
-	outw(rcv_car - 1, ioaddr + RCV_STOP);
-	return (1);
-}
-
-/**************************************************************************
-TRANSMIT - Transmit a frame
-***************************************************************************/
-static void eepro_transmit(
-	struct nic *nic,
-	const char *d,			/* Destination */
-	unsigned int t,			/* Type */
-	unsigned int s,			/* size */
-	const char *p)			/* Packet */
-{
-	unsigned int	status, tx_available, last, end, length;
-	unsigned short	type;
-	int		boguscount = 20;
-
-	length = s + ETH_HLEN;
-	if (tx_end > tx_start)
-		tx_available = XMT_RAM - (tx_end - tx_start);
-	else if (tx_end < tx_start)
-		tx_available = tx_start - tx_end;
-	else
-		tx_available = XMT_RAM;
-	last = tx_end;
-	end = last + (((length + 3) >> 1) << 1) + XMT_HEADER;
-	if (end >= (XMT_UPPER_LIMIT << 8)) {
-		last = (XMT_LOWER_LIMIT << 8);
-		end = last + (((length + 3) >> 1) << 1) + XMT_HEADER;
-	}
-	outw(last, ioaddr + HOST_ADDRESS_REG);
-	outw(XMT_CMD, ioaddr + IO_PORT);
-	outw(0, ioaddr + IO_PORT);
-	outw(end, ioaddr + IO_PORT);
-	outw(length, ioaddr + IO_PORT);
-	outsw(ioaddr + IO_PORT, d, ETH_ALEN / 2);
-	outsw(ioaddr + IO_PORT, nic->node_addr, ETH_ALEN / 2);
-	type = htons(t);
-	outsw(ioaddr + IO_PORT, &type, sizeof(type) / 2);
-	outsw(ioaddr + IO_PORT, p, (s + 3) >> 1);
-	/* A dummy read to flush the DRAM write pipeline */
-	status = inw(ioaddr + IO_PORT);
-	outw(last, ioaddr + xmt_bar);
-	outb(XMT_CMD, ioaddr);
-	tx_start = last;
-	tx_last = last;
-	tx_end = end;
-#if	0
-	printf("%d %d\n", tx_start, tx_end);
-#endif
-	while (boguscount > 0) {
-		if (((status = inw(ioaddr + IO_PORT)) & TX_DONE_BIT) == 0) {
-			udelay(40);
-			boguscount--;
-			continue;
-		}
-#if	DEBUG
-		if ((status & 0x2000) == 0)
-			printf("Transmit status %hX\n", status);
-#endif
-	}
-}
-
-/**************************************************************************
-DISABLE - Turn off ethernet interface
-***************************************************************************/
-static void eepro_disable(struct nic *nic)
-{
-	eepro_sw2bank0(ioaddr);	/* Switch to bank 0 */
-	/* Flush the Tx and disable Rx */
-	outb(STOP_RCV_CMD, ioaddr);
-	tx_start = tx_end = (XMT_LOWER_LIMIT << 8);
-	tx_last = 0;
-	/* Reset the 82595 */
-	eepro_full_reset(ioaddr);
-}
-
-static int read_eeprom(int location)
-{
-	int		i;
-	unsigned short	retval = 0;
-	int		ee_addr = ioaddr + eeprom_reg;
-	int		read_cmd = location | EE_READ_CMD;
-	int		ctrl_val = EECS;
-
-	if (eepro == LAN595FX_10ISA) {
-		eepro_sw2bank1(ioaddr);
-		outb(0x00, ioaddr + STATUS_REG);
-	}
-	eepro_sw2bank2(ioaddr);
-	outb(ctrl_val, ee_addr);
-	/* shift the read command bits out */
-	for (i = 8; i >= 0; i--) {
-		short outval = (read_cmd & (1 << i)) ? ctrl_val | EEDI : ctrl_val;
-		outb(outval, ee_addr);
-		outb(outval | EESK, ee_addr);	/* EEPROM clock tick */
-		eeprom_delay();
-		outb(outval, ee_addr);		/* finish EEPROM clock tick */
-		eeprom_delay();
-	}
-	outb(ctrl_val, ee_addr);
-	for (i = 16; i > 0; i--) {
-		outb(ctrl_val | EESK, ee_addr);
-		eeprom_delay();
-		retval = (retval << 1) | ((inb(ee_addr) & EEDO) ? 1 : 0);
-		outb(ctrl_val, ee_addr);
-		eeprom_delay();
-	}
-	/* terminate the EEPROM access */
-	ctrl_val &= ~EECS;
-	outb(ctrl_val | EESK, ee_addr);
-	eeprom_delay();
-	outb(ctrl_val, ee_addr);
-	eeprom_delay();
-	eepro_sw2bank0(ioaddr);
-	return (retval);
-}
-
-static int eepro_probe1(struct nic *nic)
-{
-	int		i, id, counter, l_eepro = 0;
-	union {
-		unsigned char	caddr[ETH_ALEN];
-		unsigned short	saddr[ETH_ALEN/2];
-	} station_addr;
-	char		*name;
-
-	id = inb(ioaddr + ID_REG);
-	if ((id & ID_REG_MASK) != ID_REG_SIG)
-		return (0);
-	counter = id & R_ROBIN_BITS;
-	if (((id = inb(ioaddr + ID_REG)) & R_ROBIN_BITS) != (counter + 0x40))
-		return (0);
-	/* yes the 82595 has been found */
-	station_addr.saddr[2] = read_eeprom(2);
-	if (station_addr.saddr[2] == 0x0000 || station_addr.saddr[2] == 0xFFFF) {
-		l_eepro = 3;
-		eepro = LAN595FX_10ISA;
-		eeprom_reg= EEPROM_REG_10;
-		rcv_start = RCV_START_10;
-		xmt_lower_limit_reg = XMT_LOWER_LIMIT_REG_10;
-		xmt_upper_limit_reg = XMT_UPPER_LIMIT_REG_10;
-		station_addr.saddr[2] = read_eeprom(2);
-	}
-	station_addr.saddr[1] = read_eeprom(3);
-	station_addr.saddr[0] = read_eeprom(4);
-	if (l_eepro)
-		name = "Intel EtherExpress 10 ISA";
-	else if (read_eeprom(7) == ee_FX_INT2IRQ) {
-		name = "Intel EtherExpress Pro/10+ ISA";
-		l_eepro = 2;
-	} else if (station_addr.saddr[0] == SA_ADDR1) {
-		name = "Intel EtherExpress Pro/10 ISA";
-		l_eepro = 1;
-	} else {
-		l_eepro = 0;
-		name = "Intel 82595-based LAN card";
-	}
-	station_addr.saddr[0] = swap16(station_addr.saddr[0]);
-	station_addr.saddr[1] = swap16(station_addr.saddr[1]);
-	station_addr.saddr[2] = swap16(station_addr.saddr[2]);
-	for (i = 0; i < ETH_ALEN; i++) {
-		nic->node_addr[i] = station_addr.caddr[i];
-	}
-	printf("\n%s ioaddr %#hX, addr %!", name, ioaddr, nic->node_addr);
-	mem_start = RCV_LOWER_LIMIT << 8;
-	if ((mem_end & 0x3F) < 3 || (mem_end & 0x3F) > 29)
-		mem_end = RCV_UPPER_LIMIT << 8;
-	else {
-		mem_end = mem_end * 1024 + (RCV_LOWER_LIMIT << 8);
-		rcv_ram = mem_end - (RCV_LOWER_LIMIT << 8);
-	}
-	printf(", Rx mem %dK, if %s\n", (mem_end - mem_start) >> 10,
-		GetBit(read_eeprom(5), ee_BNC_TPE) ? "BNC" : "TP");
-	return (1);
-}
-
-/**************************************************************************
-PROBE - Look for an adapter, this routine's visible to the outside
-***************************************************************************/
-struct nic *eepro_probe(struct nic *nic, unsigned short *probe_addrs)
-{
-	unsigned short		*p;
-	/* same probe list as the Linux driver */
-	static unsigned short	ioaddrs[] = {
-		0x300, 0x210, 0x240, 0x280, 0x2C0, 0x200, 0x320, 0x340, 0x360, 0};
-
-	if (probe_addrs == 0 || probe_addrs[0] == 0)
-		probe_addrs = ioaddrs;
-	for (p = probe_addrs; (ioaddr = *p) != 0; p++) {
-		if (eepro_probe1(nic))
-			break;
-	}
-	if (*p == 0)
-		return (0);
-	eepro_reset(nic);
-	/* point to NIC specific routines */
-	nic->reset = eepro_reset;
-	nic->poll = eepro_poll;
-	nic->transmit = eepro_transmit;
-	nic->disable = eepro_disable;
-	return (nic);
-}
diff -Naur grub-0.97.orig/netboot/eepro100.c grub-0.97/netboot/eepro100.c
--- grub-0.97.orig/netboot/eepro100.c	2003-07-09 11:45:37.000000000 +0000
+++ grub-0.97/netboot/eepro100.c	2005-08-31 19:03:35.000000000 +0000
@@ -80,8 +80,8 @@
  *
  * Caveats:
  *
- * The etherboot framework moves the code to the 32k segment from
- * 0x98000 to 0xa0000. There is just a little room between the end of
+ * The Etherboot framework moves the code to the 48k segment from
+ * 0x94000 to 0xa0000. There is just a little room between the end of
  * this driver and the 0xa0000 address. If you compile in too many
  * features, this will overflow.
  * The number under "hex" in the output of size that scrolls by while
@@ -92,17 +92,13 @@
 /* The etherboot authors seem to dislike the argument ordering in
  * outb macros that Linux uses. I disklike the confusion that this
  * has caused even more.... This file uses the Linux argument ordering.  */
-/* Sorry not us. It's inherted code from FreeBSD. [The authors] */
+/* Sorry not us. It's inherited code from FreeBSD. [The authors] */
 
 #include "etherboot.h"
 #include "nic.h"
 #include "pci.h"
-#include "cards.h"
 #include "timer.h"
 
-#undef	virt_to_bus
-#define	virt_to_bus(x)	((unsigned long)x)
-
 static int ioaddr;
 
 typedef unsigned char  u8;
@@ -121,6 +117,18 @@
   SCBEarlyRx = 20,                /* Early receive byte count. */
 };
 
+enum SCBCmdBits {
+	SCBMaskCmdDone=0x8000, SCBMaskRxDone=0x4000, SCBMaskCmdIdle=0x2000,
+	SCBMaskRxSuspend=0x1000, SCBMaskEarlyRx=0x0800, SCBMaskFlowCtl=0x0400,
+	SCBTriggerIntr=0x0200, SCBMaskAll=0x0100,
+	/* The rest are Rx and Tx commands. */
+	CUStart=0x0010, CUResume=0x0020, CUStatsAddr=0x0040, CUShowStats=0x0050,
+	CUCmdBase=0x0060,	/* CU Base address (set to zero) . */
+	CUDumpStats=0x0070, /* Dump then reset stats counters. */
+	RxStart=0x0001, RxResume=0x0002, RxAbort=0x0004, RxAddrLoad=0x0006,
+	RxResumeNoResources=0x0007,
+};
+
 static int do_eeprom_cmd(int cmd, int cmd_len);
 void hd(void *where, int n);
 
@@ -139,8 +147,6 @@
 #define EE_WRITE_1      0x4806
 #define EE_ENB          (0x4800 | EE_CS)
 
-#define udelay(n)       waiton_timer2(((n)*TICKS_PER_MS)/1000)
-
 /* The EEPROM commands include the alway-set leading bit. */
 #define EE_READ_CMD     6
 
@@ -184,9 +190,18 @@
    Typically this takes 0 ticks. */
 static inline void wait_for_cmd_done(int cmd_ioaddr)
 {
-  short wait = 100;
-  do   ;
-  while(inb(cmd_ioaddr) && --wait >= 0);
+  int wait = 0;
+  int delayed_cmd;
+
+  do
+    if (inb(cmd_ioaddr) == 0) return;
+  while(++wait <= 100);
+  delayed_cmd = inb(cmd_ioaddr);
+  do
+    if (inb(cmd_ioaddr) == 0) break;
+  while(++wait <= 10000);
+  printf("Command %2.2x was not immediately accepted, %d ticks!\n",
+      delayed_cmd, wait);
 }
 
 /* Elements of the dump_statistics block. This block must be lword aligned. */
@@ -212,35 +227,30 @@
 
 /* A speedo3 TX buffer descriptor with two buffers... */
 static struct TxFD {
-  volatile s16 status;
-  s16 command;
-  u32 link;          /* void * */
-  u32 tx_desc_addr;  /* (almost) Always points to the tx_buf_addr element. */
-  s32 count;         /* # of TBD (=2), Tx start thresh., etc. */
-                     /* This constitutes two "TBD" entries: hdr and data */
-  u32 tx_buf_addr0;  /* void *, header of frame to be transmitted.  */
-  s32 tx_buf_size0;  /* Length of Tx hdr. */
-  u32 tx_buf_addr1;  /* void *, data to be transmitted.  */
-  s32 tx_buf_size1;  /* Length of Tx data. */
+	volatile s16 status;
+	s16 command;
+	u32 link;          /* void * */
+	u32 tx_desc_addr;  /* (almost) Always points to the tx_buf_addr element. */
+	s32 count;         /* # of TBD (=2), Tx start thresh., etc. */
+	/* This constitutes two "TBD" entries: hdr and data */
+	u32 tx_buf_addr0;  /* void *, header of frame to be transmitted.  */
+	s32 tx_buf_size0;  /* Length of Tx hdr. */
+	u32 tx_buf_addr1;  /* void *, data to be transmitted.  */
+	s32 tx_buf_size1;  /* Length of Tx data. */
 } txfd;
 
 struct RxFD {               /* Receive frame descriptor. */
-  volatile s16 status;
-  s16 command;
-  u32 link;                 /* struct RxFD * */
-  u32 rx_buf_addr;          /* void * */
-  u16 count;
-  u16 size;
-  char packet[1518];
+	volatile s16 status;
+	s16 command;
+	u32 link;                 /* struct RxFD * */
+	u32 rx_buf_addr;          /* void * */
+	u16 count;
+	u16 size;
+	char packet[1518];
 };
 
-#ifdef	USE_LOWMEM_BUFFER
-#define rxfd ((struct RxFD *)(0x10000 - sizeof(struct RxFD)))
-#define ACCESS(x) x->
-#else
 static struct RxFD rxfd;
 #define ACCESS(x) x.
-#endif
 
 static int congenb = 0;         /* Enable congestion control in the DP83840. */
 static int txfifo = 8;          /* Tx FIFO threshold in 4 byte units, 0-15 */
@@ -256,8 +266,7 @@
   u32 link;
   unsigned char data[22];
 } confcmd = {
-  0, CmdConfigure,
-  (u32) & txfd,
+  0, 0, 0, /* filled in later */
   {22, 0x08, 0, 0,  0, 0x80, 0x32, 0x03,  1, /* 1=Use MII  0=Use AUI */
    0, 0x2E, 0,  0x60, 0,
    0xf2, 0x48,   0, 0x40, 0xf2, 0x80,        /* 0x40=Force full-duplex */
@@ -276,19 +285,20 @@
 
 static int mdio_write(int phy_id, int location, int value)
 {
-  int val, boguscnt = 64*4;         /* <64 usec. to complete, typ 27 ticks */
+	int val, boguscnt = 64*4;         /* <64 usec. to complete, typ 27 ticks */
 
-  outl(0x04000000 | (location<<16) | (phy_id<<21) | value,
-       ioaddr + SCBCtrlMDI);
-  do {
-    udelay(16);
-
-    val = inl(ioaddr + SCBCtrlMDI);
-    if (--boguscnt < 0) {
-      printf(" mdio_write() timed out with val = %X.\n", val);
-    }
-  } while (! (val & 0x10000000));
-  return val & 0xffff;
+	outl(0x04000000 | (location<<16) | (phy_id<<21) | value,
+	     ioaddr + SCBCtrlMDI);
+	do {
+		udelay(16);
+		
+		val = inl(ioaddr + SCBCtrlMDI);
+		if (--boguscnt < 0) {
+			printf(" mdio_write() timed out with val = %X.\n", val);
+			break;
+		}
+	} while (! (val & 0x10000000));
+	return val & 0xffff;
 }
 
 /* Support function: mdio_read
@@ -298,17 +308,19 @@
  */
 static int mdio_read(int phy_id, int location)
 {
-  int val, boguscnt = 64*4;               /* <64 usec. to complete, typ 27 ticks */
-  outl(0x08000000 | (location<<16) | (phy_id<<21), ioaddr + SCBCtrlMDI);
-  do {
-    udelay(16);
-
-    val = inl(ioaddr + SCBCtrlMDI);
-    if (--boguscnt < 0) {
-      printf( " mdio_read() timed out with val = %X.\n", val);
-    }
-  } while (! (val & 0x10000000));
-  return val & 0xffff;
+	int val, boguscnt = 64*4;               /* <64 usec. to complete, typ 27 ticks */
+	outl(0x08000000 | (location<<16) | (phy_id<<21), ioaddr + SCBCtrlMDI);
+	do {
+		udelay(16);
+		
+		val = inl(ioaddr + SCBCtrlMDI);
+
+		if (--boguscnt < 0) {
+			printf( " mdio_read() timed out with val = %X.\n", val);
+			break;
+		}
+	} while (! (val & 0x10000000));
+	return val & 0xffff;
 }
 
 /* The fixes for the code were kindly provided by Dragan Stancevic
@@ -340,25 +352,26 @@
 	return retval;
 }
 
+#if 0
 static inline void whereami (const char *str)
 {
-#if	0
   printf ("%s\n", str);
   sleep (2);
-#endif
 }
+#else
+#define whereami(s)
+#endif
 
-/* function: eepro100_reset
- * resets the card. This is used to allow Etherboot to probe the card again
- * from a "virginal" state....
- * Arguments: none
- *
- * returns:   void.
- */
-
-static void eepro100_reset(struct nic *nic)
+static void eepro100_irq(struct nic *nic __unused, irq_action_t action __unused)
 {
-  outl(0, ioaddr + SCBPort);
+  switch ( action ) {
+  case DISABLE :
+    break;
+  case ENABLE :
+    break;
+  case FORCE :
+    break;
+  }
 }
 
 /* function: eepro100_transmit
@@ -373,61 +386,87 @@
 
 static void eepro100_transmit(struct nic *nic, const char *d, unsigned int t, unsigned int s, const char *p)
 {
-  struct eth_hdr {
-    unsigned char dst_addr[ETH_ALEN];
-    unsigned char src_addr[ETH_ALEN];
-    unsigned short type;
-  } hdr;
-  unsigned short status;
-  int to;
-  int s1, s2;
-
-  status = inw(ioaddr + SCBStatus);
-  /* Acknowledge all of the current interrupt sources ASAP. */
-  outw(status & 0xfc00, ioaddr + SCBStatus);
+	struct eth_hdr {
+		unsigned char dst_addr[ETH_ALEN];
+		unsigned char src_addr[ETH_ALEN];
+		unsigned short type;
+	} hdr;
+	unsigned short status;
+	int s1, s2;
+
+	status = inw(ioaddr + SCBStatus);
+	/* Acknowledge all of the current interrupt sources ASAP. */
+	outw(status & 0xfc00, ioaddr + SCBStatus);
 
 #ifdef	DEBUG
-  printf ("transmitting type %hX packet (%d bytes). status = %hX, cmd=%hX\n",
-	  t, s, status, inw (ioaddr + SCBCmd));
+	printf ("transmitting type %hX packet (%d bytes). status = %hX, cmd=%hX\n",
+		t, s, status, inw (ioaddr + SCBCmd));
 #endif
 
-  memcpy (&hdr.dst_addr, d, ETH_ALEN);
-  memcpy (&hdr.src_addr, nic->node_addr, ETH_ALEN);
+	memcpy (&hdr.dst_addr, d, ETH_ALEN);
+	memcpy (&hdr.src_addr, nic->node_addr, ETH_ALEN);
 
-  hdr.type = htons (t);
+	hdr.type = htons (t);
 
-  txfd.status = 0;
-  txfd.command = CmdSuspend | CmdTx | CmdTxFlex;
-  txfd.link   = virt_to_bus (&txfd);
-  txfd.count   = 0x02208000;
-  txfd.tx_desc_addr = (u32)&txfd.tx_buf_addr0;
+	txfd.status = 0;
+	txfd.command = CmdSuspend | CmdTx | CmdTxFlex;
+	txfd.link   = virt_to_bus (&txfd);
+	txfd.count   = 0x02208000;
+	txfd.tx_desc_addr = virt_to_bus(&txfd.tx_buf_addr0);
 
-  txfd.tx_buf_addr0 = virt_to_bus (&hdr);
-  txfd.tx_buf_size0 = sizeof (hdr);
+	txfd.tx_buf_addr0 = virt_to_bus (&hdr);
+	txfd.tx_buf_size0 = sizeof (hdr);
 
-  txfd.tx_buf_addr1 = virt_to_bus (p);
-  txfd.tx_buf_size1 = s;
+	txfd.tx_buf_addr1 = virt_to_bus (p);
+	txfd.tx_buf_size1 = s;
 
 #ifdef	DEBUG
-  printf ("txfd: \n");
-  hd (&txfd, sizeof (txfd));
+	printf ("txfd: \n");
+	hd (&txfd, sizeof (txfd));
 #endif
 
-  outl(virt_to_bus(&txfd), ioaddr + SCBPointer);
-  outw(INT_MASK | CU_START, ioaddr + SCBCmd);
-  wait_for_cmd_done(ioaddr + SCBCmd);
-
-  s1 = inw (ioaddr + SCBStatus);
-  load_timer2(10*TICKS_PER_MS);		/* timeout 10 ms for transmit */
-  while (!txfd.status && timer2_running())
-    /* Wait */;
-  s2 = inw (ioaddr + SCBStatus);
+	outl(virt_to_bus(&txfd), ioaddr + SCBPointer);
+	outw(INT_MASK | CU_START, ioaddr + SCBCmd);
+	wait_for_cmd_done(ioaddr + SCBCmd);
+
+	s1 = inw (ioaddr + SCBStatus);
+	load_timer2(10*TICKS_PER_MS);		/* timeout 10 ms for transmit */
+	while (!txfd.status && timer2_running())
+		/* Wait */;
+	s2 = inw (ioaddr + SCBStatus);
 
 #ifdef	DEBUG
-  printf ("s1 = %hX, s2 = %hX.\n", s1, s2);
+	printf ("s1 = %hX, s2 = %hX.\n", s1, s2);
 #endif
 }
 
+/*
+ * Sometimes the receiver stops making progress.  This routine knows how to
+ * get it going again, without losing packets or being otherwise nasty like
+ * a chip reset would be.  Previously the driver had a whole sequence
+ * of if RxSuspended, if it's no buffers do one thing, if it's no resources,
+ * do another, etc.  But those things don't really matter.  Separate logic
+ * in the ISR provides for allocating buffers--the other half of operation
+ * is just making sure the receiver is active.  speedo_rx_soft_reset does that.
+ * This problem with the old, more involved algorithm is shown up under
+ * ping floods on the order of 60K packets/second on a 100Mbps fdx network.
+ */
+static void
+speedo_rx_soft_reset(void)
+{
+  wait_for_cmd_done(ioaddr + SCBCmd);
+	/*
+	* Put the hardware into a known state.
+	*/
+	outb(RX_ABORT, ioaddr + SCBCmd);
+
+	ACCESS(rxfd)rx_buf_addr = 0xffffffff;
+
+  wait_for_cmd_done(ioaddr + SCBCmd);
+
+	outb(RX_START, ioaddr + SCBCmd);
+}
+
 /* function: eepro100_poll / eth_poll
  * This recieves a packet from the network.
  *
@@ -440,34 +479,87 @@
  *            returns the length of the packet in nic->packetlen.
  */
 
-static int eepro100_poll(struct nic *nic)
+static int eepro100_poll(struct nic *nic, int retrieve)
 {
-  if (!ACCESS(rxfd)status)
-    return 0;
+  unsigned int status;
+  status = inw(ioaddr + SCBStatus);
 
-  /* Ok. We got a packet. Now restart the reciever.... */
-  ACCESS(rxfd)status = 0;
-  ACCESS(rxfd)command = 0xc000;
-  outl(virt_to_bus(&(ACCESS(rxfd)status)), ioaddr + SCBPointer);
-  outw(INT_MASK | RX_START, ioaddr + SCBCmd);
-  wait_for_cmd_done(ioaddr + SCBCmd);
+	if (!ACCESS(rxfd)status)
+		return 0;
+
+	/* There is a packet ready */
+	if ( ! retrieve ) return 1;
+
+  /*
+   * The chip may have suspended reception for various reasons.
+   * Check for that, and re-prime it should this be the case.
+   */
+  switch ((status >> 2) & 0xf) {
+  case 0: /* Idle */
+    break;
+  case 1:	/* Suspended */
+  case 2:	/* No resources (RxFDs) */
+  case 9:	/* Suspended with no more RBDs */
+  case 10: /* No resources due to no RBDs */
+  case 12: /* Ready with no RBDs */
+    speedo_rx_soft_reset();
+    break;
+  case 3:  case 5:  case 6:  case 7:  case 8:
+  case 11:  case 13:  case 14:  case 15:
+    /* these are all reserved values */
+    break;
+  }
+
+	/* Ok. We got a packet. Now restart the reciever.... */
+	ACCESS(rxfd)status = 0;
+	ACCESS(rxfd)command = 0xc000;
+	outl(virt_to_bus(&(ACCESS(rxfd)status)), ioaddr + SCBPointer);
+	outw(INT_MASK | RX_START, ioaddr + SCBCmd);
+	wait_for_cmd_done(ioaddr + SCBCmd);
 
 #ifdef	DEBUG
-  printf ("Got a packet: Len = %d.\n", ACCESS(rxfd)count & 0x3fff);
+	printf ("Got a packet: Len = %d.\n", ACCESS(rxfd)count & 0x3fff);
 #endif
-  nic->packetlen =  ACCESS(rxfd)count & 0x3fff;
-  memcpy (nic->packet, ACCESS(rxfd)packet, nic->packetlen);
+	nic->packetlen =  ACCESS(rxfd)count & 0x3fff;
+	memcpy (nic->packet, ACCESS(rxfd)packet, nic->packetlen);
 #ifdef	DEBUG
-  hd (nic->packet, 0x30);
+	hd (nic->packet, 0x30);
 #endif
-  return 1;
+	return 1;
 }
 
-static void eepro100_disable(struct nic *nic)
+/* function: eepro100_disable
+ * resets the card. This is used to allow Etherboot or Linux
+ * to probe the card again from a "virginal" state....
+ * Arguments: none
+ *
+ * returns:   void.
+ */
+static void eepro100_disable(struct dev *dev __unused)
 {
-    /* See if this PartialReset solves the problem with interfering with
-       kernel operation after Etherboot hands over. - Ken 20001102 */
-    outl(2, ioaddr + SCBPort);
+/* from eepro100_reset */
+	outl(0, ioaddr + SCBPort);
+/* from eepro100_disable */
+	/* See if this PartialReset solves the problem with interfering with
+	   kernel operation after Etherboot hands over. - Ken 20001102 */
+	outl(2, ioaddr + SCBPort);
+
+	/* The following is from the Intel e100 driver.
+	 * This hopefully solves the problem with hanging hard DOS images. */
+
+	/* wait for the reset to take effect */
+	udelay(20);
+
+	/* Mask off our interrupt line -- it is unmasked after reset */
+	{
+		u16 intr_status;
+		/* Disable interrupts on our PCI board by setting the mask bit */
+		outw(INT_MASK, ioaddr + SCBCmd);
+		intr_status = inw(ioaddr + SCBStatus);
+		/* ack and clear intrs */
+		outw(intr_status, ioaddr + SCBStatus);
+		inw(ioaddr + SCBStatus);
+	}
 }
 
 /* exported function: eepro100_probe / eth_probe
@@ -478,25 +570,30 @@
  *            leaves the 82557 initialized, and ready to recieve packets.
  */
 
-struct nic *eepro100_probe(struct nic *nic, unsigned short *probeaddrs, struct pci_device *p)
+static int eepro100_probe(struct dev *dev, struct pci_device *p)
 {
+	struct nic *nic = (struct nic *)dev;
 	unsigned short sum = 0;
 	int i;
 	int read_cmd, ee_size;
-	unsigned short value;
 	int options;
-	int promisc;
+	int rx_mode;
 
 	/* we cache only the first few words of the EEPROM data
 	   be careful not to access beyond this array */
 	unsigned short eeprom[16];
 
-	if (probeaddrs == 0 || probeaddrs[0] == 0)
+	if (p->ioaddr == 0)
 		return 0;
-	ioaddr = probeaddrs[0] & ~3; /* Mask the bit that says "this is an io addr" */
+	ioaddr = p->ioaddr & ~3; /* Mask the bit that says "this is an io addr" */
+	nic->ioaddr = ioaddr;
 
 	adjust_pci_device(p);
 
+	/* Copy IRQ from PCI information */
+	/* nic->irqno = pci->irq; */
+	nic->irqno = 0;
+
 	if ((do_eeprom_cmd(EE_READ_CMD << 24, 27) & 0xffe0000)
 		== 0xffe0000) {
 		ee_size = 0x100;
@@ -513,123 +610,138 @@
 		sum += value;
 	}
 
-  for (i=0;i<ETH_ALEN;i++) {
-	nic->node_addr[i] =  (eeprom[i/2] >> (8*(i&1))) & 0xff;
-  }
-  printf ("Ethernet addr: %!\n", nic->node_addr);
-
-  if (sum != 0xBABA)
-	printf("eepro100: Invalid EEPROM checksum %#hX, "
-	       "check settings before activating this device!\n", sum);
-  outl(0, ioaddr + SCBPort);
-  udelay (10000);
-
-  whereami ("Got eeprom.");
-
-  outl(virt_to_bus(&lstats), ioaddr + SCBPointer);
-  outw(INT_MASK | CU_STATSADDR, ioaddr + SCBCmd);
-  wait_for_cmd_done(ioaddr + SCBCmd);
-
-  whereami ("set stats addr.");
-  /* INIT RX stuff. */
-
-  /* Base = 0 */
-  outl(0, ioaddr + SCBPointer);
-  outw(INT_MASK | RX_ADDR_LOAD, ioaddr + SCBCmd);
-  wait_for_cmd_done(ioaddr + SCBCmd);
-
-  whereami ("set rx base addr.");
-
-  ACCESS(rxfd)status  = 0x0001;
-  ACCESS(rxfd)command = 0x0000;
-  ACCESS(rxfd)link    = virt_to_bus(&(ACCESS(rxfd)status));
-  ACCESS(rxfd)rx_buf_addr = (int) &nic->packet;
-  ACCESS(rxfd)count   = 0;
-  ACCESS(rxfd)size    = 1528;
-
-  outl(virt_to_bus(&(ACCESS(rxfd)status)), ioaddr + SCBPointer);
-  outw(INT_MASK | RX_START, ioaddr + SCBCmd);
-  wait_for_cmd_done(ioaddr + SCBCmd);
-
-  whereami ("started RX process.");
-
-  /* Start the reciever.... */
-  ACCESS(rxfd)status = 0;
-  ACCESS(rxfd)command = 0xc000;
-  outl(virt_to_bus(&(ACCESS(rxfd)status)), ioaddr + SCBPointer);
-  outw(INT_MASK | RX_START, ioaddr + SCBCmd);
-
-  /* INIT TX stuff. */
-
-  /* Base = 0 */
-  outl(0, ioaddr + SCBPointer);
-  outw(INT_MASK | CU_CMD_BASE, ioaddr + SCBCmd);
-  wait_for_cmd_done(ioaddr + SCBCmd);
-
-  whereami ("set TX base addr.");
-
-  txfd.command      = (CmdIASetup);
-  txfd.status       = 0x0000;
-  txfd.link         = virt_to_bus (&confcmd);
-
-  {
-	char *t = (char *)&txfd.tx_desc_addr;
+	for (i=0;i<ETH_ALEN;i++) {
+		nic->node_addr[i] =  (eeprom[i/2] >> (8*(i&1))) & 0xff;
+	}
+	printf ("Ethernet addr: %!\n", nic->node_addr);
 
-	for (i=0;i<ETH_ALEN;i++)
-		t[i] = nic->node_addr[i];
-  }
+	if (sum != 0xBABA)
+		printf("eepro100: Invalid EEPROM checksum %#hX, "
+		       "check settings before activating this device!\n", sum);
+	outl(0, ioaddr + SCBPort);
+	udelay (10000);
+	whereami ("Got eeprom.");
+
+	/* Base = 0 */
+	outl(0, ioaddr + SCBPointer);
+	outw(INT_MASK | RX_ADDR_LOAD, ioaddr + SCBCmd);
+	wait_for_cmd_done(ioaddr + SCBCmd);
+	whereami ("set rx base addr.");
+
+	outl(virt_to_bus(&lstats), ioaddr + SCBPointer);
+	outw(INT_MASK | CU_STATSADDR, ioaddr + SCBCmd);
+	wait_for_cmd_done(ioaddr + SCBCmd);
+	whereami ("set stats addr.");
+
+	/* INIT RX stuff. */
+	ACCESS(rxfd)status  = 0x0001;
+	ACCESS(rxfd)command = 0x0000;
+	ACCESS(rxfd)link    = virt_to_bus(&(ACCESS(rxfd)status));
+	ACCESS(rxfd)rx_buf_addr = virt_to_bus(&nic->packet);
+	ACCESS(rxfd)count   = 0;
+	ACCESS(rxfd)size    = 1528;
+
+	outl(virt_to_bus(&(ACCESS(rxfd)status)), ioaddr + SCBPointer);
+	outw(INT_MASK | RX_START, ioaddr + SCBCmd);
+	wait_for_cmd_done(ioaddr + SCBCmd);
+
+	whereami ("started RX process.");
+
+	/* Start the reciever.... */
+	ACCESS(rxfd)status = 0;
+	ACCESS(rxfd)command = 0xc000;
+	outl(virt_to_bus(&(ACCESS(rxfd)status)), ioaddr + SCBPointer);
+	outw(INT_MASK | RX_START, ioaddr + SCBCmd);
+
+	/* INIT TX stuff. */
+
+	/* Base = 0 */
+	outl(0, ioaddr + SCBPointer);
+	outw(INT_MASK | CU_CMD_BASE, ioaddr + SCBCmd);
+	wait_for_cmd_done(ioaddr + SCBCmd);
+
+	whereami ("set TX base addr.");
+
+	txfd.command      = (CmdIASetup);
+	txfd.status       = 0x0000;
+	txfd.link         = virt_to_bus (&confcmd);
+
+	{
+		char *t = (char *)&txfd.tx_desc_addr;
+		
+		for (i=0;i<ETH_ALEN;i++)
+			t[i] = nic->node_addr[i];
+	}
 
 #ifdef	DEBUG
-  printf ("Setup_eaddr:\n");
-  hd (&txfd, 0x20);
+	printf ("Setup_eaddr:\n");
+	hd (&txfd, 0x20);
 #endif
-  /*      options = 0x40; */ /* 10mbps half duplex... */
-  options = 0x00;            /* Autosense */
-
-  promisc = 0;
-
-  if (   ((eeprom[6]>>8) & 0x3f) == DP83840
-	  || ((eeprom[6]>>8) & 0x3f) == DP83840A) {
-	int mdi_reg23 = mdio_read(eeprom[6] & 0x1f, 23) | 0x0422;
-	if (congenb)
-	  mdi_reg23 |= 0x0100;
-	printf("  DP83840 specific setup, setting register 23 to %hX.\n",
-	       mdi_reg23);
-	mdio_write(eeprom[6] & 0x1f, 23, mdi_reg23);
-  }
-  whereami ("Done DP8340 special setup.");
-  if (options != 0) {
-	mdio_write(eeprom[6] & 0x1f, 0,
-		   ((options & 0x20) ? 0x2000 : 0) |    /* 100mbps? */
-		   ((options & 0x10) ? 0x0100 : 0)); /* Full duplex? */
-	whereami ("set mdio_register.");
-  }
+	/*      options = 0x40; */ /* 10mbps half duplex... */
+	options = 0x00;            /* Autosense */
 
-  confcmd.command  = CmdSuspend | CmdConfigure;
-  confcmd.status   = 0x0000;
-  confcmd.link     = virt_to_bus (&txfd);
-  confcmd.data[1]  = (txfifo << 4) | rxfifo;
-  confcmd.data[4]  = rxdmacount;
-  confcmd.data[5]  = txdmacount + 0x80;
-  confcmd.data[15] = promisc ? 0x49: 0x48;
-  confcmd.data[19] = (options & 0x10) ? 0xC0 : 0x80;
-  confcmd.data[21] = promisc ? 0x0D: 0x05;
+#ifdef PROMISC
+	rx_mode = 3;
+#elif ALLMULTI
+	rx_mode = 1;
+#else
+	rx_mode = 0;
+#endif
 
-  outl(virt_to_bus(&txfd), ioaddr + SCBPointer);
-  outw(INT_MASK | CU_START, ioaddr + SCBCmd);
-  wait_for_cmd_done(ioaddr + SCBCmd);
+	if (   ((eeprom[6]>>8) & 0x3f) == DP83840
+	       || ((eeprom[6]>>8) & 0x3f) == DP83840A) {
+		int mdi_reg23 = mdio_read(eeprom[6] & 0x1f, 23) | 0x0422;
+		if (congenb)
+			mdi_reg23 |= 0x0100;
+		printf("  DP83840 specific setup, setting register 23 to %hX.\n",
+		       mdi_reg23);
+		mdio_write(eeprom[6] & 0x1f, 23, mdi_reg23);
+	}
+	whereami ("Done DP8340 special setup.");
+	if (options != 0) {
+		mdio_write(eeprom[6] & 0x1f, 0,
+			   ((options & 0x20) ? 0x2000 : 0) |    /* 100mbps? */
+			   ((options & 0x10) ? 0x0100 : 0)); /* Full duplex? */
+		whereami ("set mdio_register.");
+	}
 
-  whereami ("started TX thingy (config, iasetup).");
+	confcmd.command  = CmdSuspend | CmdConfigure;
+	confcmd.status   = 0x0000;
+	confcmd.link     = virt_to_bus (&txfd);
+	confcmd.data[1]  = (txfifo << 4) | rxfifo;
+	confcmd.data[4]  = rxdmacount;
+	confcmd.data[5]  = txdmacount + 0x80;
+	confcmd.data[15] = (rx_mode & 2) ? 0x49: 0x48;
+	confcmd.data[19] = (options & 0x10) ? 0xC0 : 0x80;
+	confcmd.data[21] = (rx_mode & 1) ? 0x0D: 0x05;
+
+	outl(virt_to_bus(&txfd), ioaddr + SCBPointer);
+	outw(INT_MASK | CU_START, ioaddr + SCBCmd);
+	wait_for_cmd_done(ioaddr + SCBCmd);
+
+	whereami ("started TX thingy (config, iasetup).");
+
+	load_timer2(10*TICKS_PER_MS);
+	while (!txfd.status && timer2_running())
+		/* Wait */;
+
+	/* Read the status register once to disgard stale data */
+	mdio_read(eeprom[6] & 0x1f, 1);
+	/* Check to see if the network cable is plugged in.
+	 * This allows for faster failure if there is nothing
+	 * we can do.
+	 */
+	if (!(mdio_read(eeprom[6] & 0x1f, 1) & (1 << 2))) {
+		printf("Valid link not established\n");
+		eepro100_disable(dev);
+		return 0;
+	}
 
-  load_timer2(10*TICKS_PER_MS);
-  while (!txfd.status && timer2_running())
-	/* Wait */;
-
-  nic->reset = eepro100_reset;
-  nic->poll = eepro100_poll;
-  nic->transmit = eepro100_transmit;
-  nic->disable = eepro100_disable;
-  return nic;
+	dev->disable  = eepro100_disable;
+	nic->poll     = eepro100_poll;
+	nic->transmit = eepro100_transmit;
+	nic->irq      = eepro100_irq;
+	return 1;
 }
 
 /*********************************************************************/
@@ -639,16 +751,59 @@
 /* Hexdump a number of bytes from memory... */
 void hd (void *where, int n)
 {
-  int i;
+	int i;
 
-  while (n > 0) {
-    printf ("%X ", where);
-    for (i=0;i < ( (n>16)?16:n);i++)
-      printf (" %hhX", ((char *)where)[i]);
-    printf ("\n");
-    n -= 16;
-    where += 16;
-  }
+	while (n > 0) {
+		printf ("%X ", where);
+		for (i=0;i < ( (n>16)?16:n);i++)
+			printf (" %hhX", ((char *)where)[i]);
+		printf ("\n");
+		n -= 16;
+		where += 16;
+	}
 }
 #endif
 
+static struct pci_id eepro100_nics[] = {
+PCI_ROM(0x8086, 0x1029, "id1029",        "Intel EtherExpressPro100 ID1029"),
+PCI_ROM(0x8086, 0x1030, "id1030",        "Intel EtherExpressPro100 ID1030"),
+PCI_ROM(0x8086, 0x1031, "82801cam",      "Intel 82801CAM (ICH3) Chipset Ethernet Controller"),
+PCI_ROM(0x8086, 0x1032, "eepro100-1032", "Intel PRO/100 VE Network Connection"),
+PCI_ROM(0x8086, 0x1033, "eepro100-1033", "Intel PRO/100 VM Network Connection"),
+PCI_ROM(0x8086, 0x1034, "eepro100-1034", "Intel PRO/100 VM Network Connection"),
+PCI_ROM(0x8086, 0x1035, "eepro100-1035", "Intel 82801CAM (ICH3) Chipset Ethernet Controller"),
+PCI_ROM(0x8086, 0x1036, "eepro100-1036", "Intel 82801CAM (ICH3) Chipset Ethernet Controller"),
+PCI_ROM(0x8086, 0x1037, "eepro100-1037", "Intel 82801CAM (ICH3) Chipset Ethernet Controller"),
+PCI_ROM(0x8086, 0x1038, "id1038",        "Intel PRO/100 VM Network Connection"),
+PCI_ROM(0x8086, 0x1039, "82562et",       "Intel PRO100 VE 82562ET"),
+PCI_ROM(0x8086, 0x103a, "id103a",        "Intel Corporation 82559 InBusiness 10/100"),
+PCI_ROM(0x8086, 0x103b, "82562etb",      "Intel PRO100 VE 82562ETB"),
+PCI_ROM(0x8086, 0x103c, "eepro100-103c", "Intel PRO/100 VM Network Connection"),
+PCI_ROM(0x8086, 0x103d, "eepro100-103d", "Intel PRO/100 VE Network Connection"),
+PCI_ROM(0x8086, 0x103e, "eepro100-103e", "Intel PRO/100 VM Network Connection"),
+PCI_ROM(0x8086, 0x1059, "82551qm",       "Intel PRO/100 M Mobile Connection"),
+PCI_ROM(0x8086, 0x1209, "82559er",       "Intel EtherExpressPro100 82559ER"),
+PCI_ROM(0x8086, 0x1227, "82865",         "Intel 82865 EtherExpress PRO/100A"),
+PCI_ROM(0x8086, 0x1228, "82556",         "Intel 82556 EtherExpress PRO/100 Smart"),
+PCI_ROM(0x8086, 0x1229, "eepro100",      "Intel EtherExpressPro100"),
+PCI_ROM(0x8086, 0x2449, "82562em",       "Intel EtherExpressPro100 82562EM"),
+PCI_ROM(0x8086, 0x2459, "82562-1",       "Intel 82562 based Fast Ethernet Connection"),
+PCI_ROM(0x8086, 0x245d, "82562-2",       "Intel 82562 based Fast Ethernet Connection"),
+PCI_ROM(0x8086, 0x1050, "82562ez",       "Intel 82562EZ Network Connection"),
+PCI_ROM(0x8086, 0x5200, "eepro100-5200", "Intel EtherExpress PRO/100 Intelligent Server"),
+PCI_ROM(0x8086, 0x5201, "eepro100-5201", "Intel EtherExpress PRO/100 Intelligent Server"),
+};
+
+/* Cards with device ids 0x1030 to 0x103F, 0x2449, 0x2459 or 0x245D might need
+ * a workaround for hardware bug on 10 mbit half duplex (see linux driver eepro100.c)
+ * 2003/03/17 gbaum */
+
+
+struct pci_driver eepro100_driver = {
+	.type      = NIC_DRIVER,
+	.name      = "EEPRO100",
+	.probe     = eepro100_probe,
+	.ids       = eepro100_nics,
+	.id_count  = sizeof(eepro100_nics)/sizeof(eepro100_nics[0]),
+	.class     = 0
+};
diff -Naur grub-0.97.orig/netboot/elf.h grub-0.97/netboot/elf.h
--- grub-0.97.orig/netboot/elf.h	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/elf.h	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,234 @@
+#ifndef ELF_H
+#define ELF_H
+
+#define EI_NIDENT	16	/* Size of e_ident array. */
+
+/* Values for e_type. */
+#define ET_NONE		0	/* No file type */
+#define ET_REL		1	/* Relocatable file */
+#define ET_EXEC		2	/* Executable file */
+#define ET_DYN		3	/* Shared object file */
+#define ET_CORE		4	/* Core file */
+
+/* Values for e_machine (architecute). */
+#define EM_NONE		 0		/* No machine */
+#define EM_M32		 1		/* AT&T WE 32100 */
+#define EM_SPARC	 2		/* SUN SPARC */
+#define EM_386		 3		/* Intel 80386+ */
+#define EM_68K		 4		/* Motorola m68k family */
+#define EM_88K		 5		/* Motorola m88k family */
+#define EM_486		 6		/* Perhaps disused */
+#define EM_860		 7		/* Intel 80860 */
+#define EM_MIPS		 8		/* MIPS R3000 big-endian */
+#define EM_S370		 9		/* IBM System/370 */
+#define EM_MIPS_RS3_LE	10		/* MIPS R3000 little-endian */
+
+#define EM_PARISC	15		/* HPPA */
+#define EM_VPP500	17		/* Fujitsu VPP500 */
+#define EM_SPARC32PLUS	18		/* Sun's "v8plus" */
+#define EM_960		19		/* Intel 80960 */
+#define EM_PPC		20		/* PowerPC */
+#define EM_PPC64	21		/* PowerPC 64-bit */
+#define EM_S390		22		/* IBM S390 */
+
+#define EM_V800		36		/* NEC V800 series */
+#define EM_FR20		37		/* Fujitsu FR20 */
+#define EM_RH32		38		/* TRW RH-32 */
+#define EM_RCE		39		/* Motorola RCE */
+#define EM_ARM		40		/* ARM */
+#define EM_FAKE_ALPHA	41		/* Digital Alpha */
+#define EM_SH		42		/* Hitachi SH */
+#define EM_SPARCV9	43		/* SPARC v9 64-bit */
+#define EM_TRICORE	44		/* Siemens Tricore */
+#define EM_ARC		45		/* Argonaut RISC Core */
+#define EM_H8_300	46		/* Hitachi H8/300 */
+#define EM_H8_300H	47		/* Hitachi H8/300H */
+#define EM_H8S		48		/* Hitachi H8S */
+#define EM_H8_500	49		/* Hitachi H8/500 */
+#define EM_IA_64	50		/* Intel Merced */
+#define EM_MIPS_X	51		/* Stanford MIPS-X */
+#define EM_COLDFIRE	52		/* Motorola Coldfire */
+#define EM_68HC12	53		/* Motorola M68HC12 */
+#define EM_MMA		54		/* Fujitsu MMA Multimedia Accelerator*/
+#define EM_PCP		55		/* Siemens PCP */
+#define EM_NCPU		56		/* Sony nCPU embeeded RISC */
+#define EM_NDR1		57		/* Denso NDR1 microprocessor */
+#define EM_STARCORE	58		/* Motorola Start*Core processor */
+#define EM_ME16		59		/* Toyota ME16 processor */
+#define EM_ST100	60		/* STMicroelectronic ST100 processor */
+#define EM_TINYJ	61		/* Advanced Logic Corp. Tinyj emb.fam*/
+#define EM_X86_64	62		/* AMD x86-64 architecture */
+#define EM_PDSP		63		/* Sony DSP Processor */
+
+#define EM_FX66		66		/* Siemens FX66 microcontroller */
+#define EM_ST9PLUS	67		/* STMicroelectronics ST9+ 8/16 mc */
+#define EM_ST7		68		/* STmicroelectronics ST7 8 bit mc */
+#define EM_68HC16	69		/* Motorola MC68HC16 microcontroller */
+#define EM_68HC11	70		/* Motorola MC68HC11 microcontroller */
+#define EM_68HC08	71		/* Motorola MC68HC08 microcontroller */
+#define EM_68HC05	72		/* Motorola MC68HC05 microcontroller */
+#define EM_SVX		73		/* Silicon Graphics SVx */
+#define EM_AT19		74		/* STMicroelectronics ST19 8 bit mc */
+#define EM_VAX		75		/* Digital VAX */
+#define EM_CRIS		76		/* Axis Communications 32-bit embedded processor */
+#define EM_JAVELIN	77		/* Infineon Technologies 32-bit embedded processor */
+#define EM_FIREPATH	78		/* Element 14 64-bit DSP Processor */
+#define EM_ZSP		79		/* LSI Logic 16-bit DSP Processor */
+#define EM_MMIX		80		/* Donald Knuth's educational 64-bit processor */
+#define EM_HUANY	81		/* Harvard University machine-independent object files */
+#define EM_PRISM	82		/* SiTera Prism */
+#define EM_AVR		83		/* Atmel AVR 8-bit microcontroller */
+#define EM_FR30		84		/* Fujitsu FR30 */
+#define EM_D10V		85		/* Mitsubishi D10V */
+#define EM_D30V		86		/* Mitsubishi D30V */
+#define EM_V850		87		/* NEC v850 */
+#define EM_M32R		88		/* Mitsubishi M32R */
+#define EM_MN10300	89		/* Matsushita MN10300 */
+#define EM_MN10200	90		/* Matsushita MN10200 */
+#define EM_PJ		91		/* picoJava */
+#define EM_OPENRISC	92		/* OpenRISC 32-bit embedded processor */
+#define EM_ARC_A5	93		/* ARC Cores Tangent-A5 */
+#define EM_XTENSA	94		/* Tensilica Xtensa Architecture */
+#define EM_NUM		95
+
+/* Values for p_type. */
+#define PT_NULL		0	/* Unused entry. */
+#define PT_LOAD		1	/* Loadable segment. */
+#define PT_DYNAMIC	2	/* Dynamic linking information segment. */
+#define PT_INTERP	3	/* Pathname of interpreter. */
+#define PT_NOTE		4	/* Auxiliary information. */
+#define PT_SHLIB	5	/* Reserved (not used). */
+#define PT_PHDR		6	/* Location of program header itself. */
+
+/* Values for p_flags. */
+#define PF_X		0x1	/* Executable. */
+#define PF_W		0x2	/* Writable. */
+#define PF_R		0x4	/* Readable. */
+
+
+#define	ELF_PROGRAM_RETURNS_BIT	0x8000000	/* e_flags bit 31 */
+
+#define EI_MAG0		0
+#define ELFMAG0		0x7f
+
+#define EI_MAG1		1
+#define ELFMAG1		'E'
+
+#define EI_MAG2		2
+#define ELFMAG2		'L'
+
+#define EI_MAG3		3
+#define ELFMAG3		'F'
+
+#define ELFMAG		"\177ELF"
+
+#define EI_CLASS	4	/* File class byte index */
+#define ELFCLASSNONE	0	/* Invalid class */
+#define ELFCLASS32	1	/* 32-bit objects */
+#define ELFCLASS64	2	/* 64-bit objects */
+
+#define EI_DATA		5	/* Data encodeing byte index */
+#define ELFDATANONE	0	/* Invalid data encoding */
+#define ELFDATA2LSB	1	/* 2's complement little endian */
+#define ELFDATA2MSB	2	/* 2's complement big endian */
+
+#define EI_VERSION	6	/* File version byte index */
+				/* Value must be EV_CURRENT */
+
+#define EV_NONE		0	/* Invalid ELF Version */
+#define EV_CURRENT	1	/* Current version */
+
+#define ELF32_PHDR_SIZE (8*4)	/* Size of an elf program header */
+
+#ifndef ASSEMBLY
+/*
+ * ELF definitions common to all 32-bit architectures.
+ */
+
+typedef uint32_t	Elf32_Addr;
+typedef uint16_t	Elf32_Half;
+typedef uint32_t	Elf32_Off;
+typedef int32_t		Elf32_Sword;
+typedef uint32_t	Elf32_Word;
+typedef uint32_t	Elf32_Size;
+
+typedef uint64_t	Elf64_Addr;
+typedef uint16_t	Elf64_Half;
+typedef uint64_t	Elf64_Off;
+typedef int32_t		Elf64_Sword;
+typedef uint32_t	Elf64_Word;
+typedef uint64_t	Elf64_Size;
+
+/*
+ * ELF header.
+ */
+typedef struct {
+	unsigned char	e_ident[EI_NIDENT];	/* File identification. */
+	Elf32_Half	e_type;		/* File type. */
+	Elf32_Half	e_machine;	/* Machine architecture. */
+	Elf32_Word	e_version;	/* ELF format version. */
+	Elf32_Addr	e_entry;	/* Entry point. */
+	Elf32_Off	e_phoff;	/* Program header file offset. */
+	Elf32_Off	e_shoff;	/* Section header file offset. */
+	Elf32_Word	e_flags;	/* Architecture-specific flags. */
+	Elf32_Half	e_ehsize;	/* Size of ELF header in bytes. */
+	Elf32_Half	e_phentsize;	/* Size of program header entry. */
+	Elf32_Half	e_phnum;	/* Number of program header entries. */
+	Elf32_Half	e_shentsize;	/* Size of section header entry. */
+	Elf32_Half	e_shnum;	/* Number of section header entries. */
+	Elf32_Half	e_shstrndx;	/* Section name strings section. */
+} Elf32_Ehdr;
+
+typedef struct {
+	unsigned char	e_ident[EI_NIDENT];	/* File identification. */
+	Elf64_Half	e_type;		/* File type. */
+	Elf64_Half	e_machine;	/* Machine architecture. */
+	Elf64_Word	e_version;	/* ELF format version. */
+	Elf64_Addr	e_entry;	/* Entry point. */
+	Elf64_Off	e_phoff;	/* Program header file offset. */
+	Elf64_Off	e_shoff;	/* Section header file offset. */
+	Elf64_Word	e_flags;	/* Architecture-specific flags. */
+	Elf64_Half	e_ehsize;	/* Size of ELF header in bytes. */
+	Elf64_Half	e_phentsize;	/* Size of program header entry. */
+	Elf64_Half	e_phnum;	/* Number of program header entries. */
+	Elf64_Half	e_shentsize;	/* Size of section header entry. */
+	Elf64_Half	e_shnum;	/* Number of section header entries. */
+	Elf64_Half	e_shstrndx;	/* Section name strings section. */
+} Elf64_Ehdr;
+
+/*
+ * Program header.
+ */
+typedef struct {
+	Elf32_Word	p_type;		/* Entry type. */
+	Elf32_Off	p_offset;	/* File offset of contents. */
+	Elf32_Addr	p_vaddr;	/* Virtual address (not used). */
+	Elf32_Addr	p_paddr;	/* Physical address. */
+	Elf32_Size	p_filesz;	/* Size of contents in file. */
+	Elf32_Size	p_memsz;	/* Size of contents in memory. */
+	Elf32_Word	p_flags;	/* Access permission flags. */
+	Elf32_Size	p_align;	/* Alignment in memory and file. */
+} Elf32_Phdr;
+
+typedef struct {
+	Elf64_Word	p_type;		/* Entry type. */
+	Elf64_Word	p_flags;	/* Access permission flags. */
+	Elf64_Off	p_offset;	/* File offset of contents. */
+	Elf64_Addr	p_vaddr;	/* Virtual address (not used). */
+	Elf64_Addr	p_paddr;	/* Physical address. */
+	Elf64_Size	p_filesz;	/* Size of contents in file. */
+	Elf64_Size	p_memsz;	/* Size of contents in memory. */
+	Elf64_Size	p_align;	/* Alignment in memory and file. */
+} Elf64_Phdr;
+
+/* Standardized Elf image notes for booting... The name for all of these is ELFBoot */
+
+
+/* ELF Defines for the current architecture */
+#include "i386_elf.h"
+
+#endif /* ASSEMBLY */
+
+//#include "elf_boot.h"
+
+#endif /* ELF_H */
diff -Naur grub-0.97.orig/netboot/endian.h grub-0.97/netboot/endian.h
--- grub-0.97.orig/netboot/endian.h	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/endian.h	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,19 @@
+#ifndef ETHERBOOT_ENDIAN_H
+#define ETHERBOOT_ENDIAN_H
+
+/* Definitions for byte order, according to significance of bytes,
+   from low addresses to high addresses.  The value is what you get by
+   putting '4' in the most significant byte, '3' in the second most
+   significant byte, '2' in the second least significant byte, and '1'
+   in the least significant byte, and then writing down one digit for
+   each byte, starting with the byte at the lowest address at the left,
+   and proceeding to the byte with the highest address at the right.  */
+
+#define __LITTLE_ENDIAN 1234
+#define __BIG_ENDIAN    4321
+#define __PDP_ENDIAN    3412
+
+#include "i386_endian.h"
+
+
+#endif /* ETHERBOOT_ENDIAN_H */
diff -Naur grub-0.97.orig/netboot/epic100.c grub-0.97/netboot/epic100.c
--- grub-0.97.orig/netboot/epic100.c	2003-07-09 11:45:37.000000000 +0000
+++ grub-0.97/netboot/epic100.c	2005-08-31 19:03:35.000000000 +0000
@@ -1,15 +1,18 @@
+
 /* epic100.c: A SMC 83c170 EPIC/100 fast ethernet driver for Etherboot */
 
+/* 05/06/2003	timlegge	Fixed relocation and implemented Multicast */
 #define LINUX_OUT_MACROS
 
 #include "etherboot.h"
+#include "pci.h"
 #include "nic.h"
-#include "cards.h"
 #include "timer.h"
 #include "epic100.h"
 
-#undef	virt_to_bus
-#define	virt_to_bus(x)	((unsigned long)x)
+/* Condensed operations for readability */
+#define virt_to_le32desc(addr)	cpu_to_le32(virt_to_bus(addr))
+#define le32desc_to_virt(addr)	bus_to_virt(le32_to_cpu(addr))
 
 #define TX_RING_SIZE	2	/* use at least 2 buffers for TX */
 #define RX_RING_SIZE	2
@@ -26,23 +29,18 @@
 
 /* The EPIC100 Rx and Tx buffer descriptors. */
 struct epic_rx_desc {
-    unsigned short status;
-    unsigned short rxlength;
-    unsigned long  bufaddr;
-    unsigned short buflength;
-    unsigned short control;
-    unsigned long  next;
+    unsigned long status;
+    unsigned long bufaddr;
+    unsigned long buflength;
+    unsigned long next;
 };
-
 /* description of the tx descriptors control bits commonly used */
 #define TD_STDFLAGS	TD_LASTDESC
 
 struct epic_tx_desc {
-    unsigned short status;
-    unsigned short txlength;
-    unsigned long  bufaddr;
-    unsigned short buflength;
-    unsigned short control;
+    unsigned long status;
+    unsigned long bufaddr;
+    unsigned long buflength;
     unsigned long  next;
 };
 
@@ -51,12 +49,15 @@
 
 static void	epic100_open(void);
 static void	epic100_init_ring(void);
-static void	epic100_disable(struct nic *nic);
-static int	epic100_poll(struct nic *nic);
+static void	epic100_disable(struct dev *dev);
+static int	epic100_poll(struct nic *nic, int retrieve);
 static void	epic100_transmit(struct nic *nic, const char *destaddr,
 				 unsigned int type, unsigned int len, const char *data);
+#ifdef	DEBUG_EEPROM
 static int	read_eeprom(int location);
+#endif
 static int	mii_read(int phy_id, int location);
+static void     epic100_irq(struct nic *nic, irq_action_t action);
 
 static int	ioaddr;
 
@@ -69,6 +70,7 @@
 static int	mmctl  ;
 static int	mmdata ;
 static int	lan0   ;
+static int	mc0    ;
 static int	rxcon  ;
 static int	txcon  ;
 static int	prcdar ;
@@ -80,37 +82,27 @@
 static unsigned short	eeprom[64];
 #endif
 static signed char	phys[4];		/* MII device addresses. */
-static struct epic_rx_desc	rx_ring[RX_RING_SIZE];
-static struct epic_tx_desc	tx_ring[TX_RING_SIZE];
-#ifdef	USE_LOWMEM_BUFFER
-#define rx_packet ((char *)0x10000 - PKT_BUF_SZ * RX_RING_SIZE)
-#define tx_packet ((char *)0x10000 - PKT_BUF_SZ * RX_RING_SIZE - PKT_BUF_SZ * TX_RING_SIZE)
-#else
-static char		rx_packet[PKT_BUF_SZ * RX_RING_SIZE];
-static char		tx_packet[PKT_BUF_SZ * TX_RING_SIZE];
-#endif
+static struct epic_rx_desc	rx_ring[RX_RING_SIZE]
+	__attribute__ ((aligned(4)));
+static struct epic_tx_desc	tx_ring[TX_RING_SIZE]
+	__attribute__ ((aligned(4)));
+static unsigned char	 	rx_packet[PKT_BUF_SZ * RX_RING_SIZE];
+static unsigned char		tx_packet[PKT_BUF_SZ * TX_RING_SIZE];
 
 /***********************************************************************/
 /*                    Externally visible functions                     */
 /***********************************************************************/
 
-    static void
-epic100_reset(struct nic *nic)
-{
-    /* Soft reset the chip. */
-    outl(GC_SOFT_RESET, genctl);
-}
 
-    struct nic*
-epic100_probe(struct nic *nic, unsigned short *probeaddrs)
+    static int
+epic100_probe(struct dev *dev, struct pci_device *pci)
 {
-    unsigned short sum = 0;
-    unsigned short value;
+    struct nic *nic = (struct nic *)dev;
     int i;
     unsigned short* ap;
     unsigned int phy, phy_idx;
 
-    if (probeaddrs == 0 || probeaddrs[0] == 0)
+    if (pci->ioaddr == 0)
 	return 0;
 
     /* Ideally we would detect all network cards in slot order.  That would
@@ -118,7 +110,9 @@
        well with the current structure.  So instead we detect just the
        Epic cards in slot order. */
 
-    ioaddr = probeaddrs[0] & ~3; /* Mask the bit that says "this is an io addr" */
+    ioaddr = pci->ioaddr;
+    nic->irqno  = 0;
+    nic->ioaddr = pci->ioaddr & ~3;
 
     /* compute all used static epic100 registers address */
     command = ioaddr + COMMAND;		/* Control Register */
@@ -130,6 +124,7 @@
     mmctl   = ioaddr + MMCTL;		/* MII Management Interface Control */
     mmdata  = ioaddr + MMDATA;		/* MII Management Interface Data */
     lan0    = ioaddr + LAN0;		/* MAC address. (0x40-0x48) */
+    mc0     = ioaddr + MC0; 		/* Multicast Control */
     rxcon   = ioaddr + RXCON;		/* Receive Control */
     txcon   = ioaddr + TXCON;		/* Transmit Control */
     prcdar  = ioaddr + PRCDAR;		/* PCI Receive Current Descr Address */
@@ -160,11 +155,15 @@
     }
 
 #ifdef	DEBUG_EEPROM
+{
+    unsigned short sum = 0;
+    unsigned short value;
     for (i = 0; i < 64; i++) {
 	value = read_eeprom(i);
 	eeprom[i] = value;
 	sum += value;
     }
+}
 
 #if	(EPIC_DEBUG > 1)
     printf("EEPROM contents\n");
@@ -202,15 +201,26 @@
 
     epic100_open();
 
-    nic->reset    = epic100_reset;
+    dev->disable  = epic100_disable;
     nic->poll     = epic100_poll;
     nic->transmit = epic100_transmit;
-    nic->disable  = epic100_disable;
+    nic->irq      = epic100_irq;
 
-    return nic;
+    return 1;
 }
 
-    static void
+static void set_rx_mode(void)
+{
+	unsigned char mc_filter[8];
+	int i;
+	memset(mc_filter, 0xff, sizeof(mc_filter));
+	outl(0x0C, rxcon);
+	for(i = 0; i < 4; i++)
+		outw(((unsigned short *)mc_filter)[i], mc0 + i*4);
+	return;
+}
+	
+   static void
 epic100_open(void)
 {
     int mii_reg5;
@@ -237,11 +247,11 @@
     outl(tmp, txcon);
 
     /* Give adress of RX and TX ring to the chip */
-    outl(virt_to_bus(&rx_ring), prcdar);
-    outl(virt_to_bus(&tx_ring), ptcdar);
+    outl(virt_to_le32desc(&rx_ring), prcdar);
+    outl(virt_to_le32desc(&tx_ring), ptcdar);
 
     /* Start the chip's Rx process: receive unicast and broadcast */
-    outl(0x04, rxcon);
+    set_rx_mode();
     outl(CR_START_RX | CR_QUEUE_RX, command);
 
     putchar('\n');
@@ -252,34 +262,30 @@
 epic100_init_ring(void)
 {
     int i;
-    char* p;
 
     cur_rx = cur_tx = 0;
 
-    p = &rx_packet[0];
     for (i = 0; i < RX_RING_SIZE; i++) {
-	rx_ring[i].status    = RRING_OWN;	/* Owned by Epic chip */
-	rx_ring[i].buflength = PKT_BUF_SZ;
-	rx_ring[i].bufaddr   = virt_to_bus(p + (PKT_BUF_SZ * i));
-	rx_ring[i].control   = 0;
-	rx_ring[i].next      = virt_to_bus(&(rx_ring[i + 1]) );
+	rx_ring[i].status    = cpu_to_le32(RRING_OWN);	/* Owned by Epic chip */
+	rx_ring[i].buflength = cpu_to_le32(PKT_BUF_SZ);
+	rx_ring[i].bufaddr   = virt_to_bus(&rx_packet[i * PKT_BUF_SZ]);
+	rx_ring[i].next      = virt_to_le32desc(&rx_ring[i + 1]) ;
     }
     /* Mark the last entry as wrapping the ring. */
-    rx_ring[i-1].next = virt_to_bus(&rx_ring[0]);
+    rx_ring[i-1].next = virt_to_le32desc(&rx_ring[0]);
 
     /*
      *The Tx buffer descriptor is filled in as needed,
      * but we do need to clear the ownership bit.
      */
-    p = &tx_packet[0];
 
     for (i = 0; i < TX_RING_SIZE; i++) {
-	tx_ring[i].status  = 0;			/* Owned by CPU */
-	tx_ring[i].bufaddr = virt_to_bus(p + (PKT_BUF_SZ * i));
-	tx_ring[i].control = TD_STDFLAGS;
-	tx_ring[i].next    = virt_to_bus(&(tx_ring[i + 1]) );
+	tx_ring[i].status  = 0x0000;			/* Owned by CPU */
+    	tx_ring[i].buflength = 0x0000 | cpu_to_le32(TD_STDFLAGS << 16);
+	tx_ring[i].bufaddr = virt_to_bus(&tx_packet[i * PKT_BUF_SZ]);
+	tx_ring[i].next    = virt_to_le32desc(&tx_ring[i + 1]);
     }
-    tx_ring[i-1].next = virt_to_bus(&tx_ring[0]);
+	tx_ring[i-1].next    = virt_to_le32desc(&tx_ring[0]);
 }
 
 /* function: epic100_transmit
@@ -296,7 +302,7 @@
 		 unsigned int len, const char *data)
 {
     unsigned short nstype;
-    char* txp;
+    unsigned char *txp;
     int entry;
 
     /* Calculate the next Tx descriptor entry. */
@@ -310,7 +316,7 @@
 	return;
     }
 
-    txp = (char*)tx_ring[entry].bufaddr;
+    txp = tx_packet + (entry * PKT_BUF_SZ);
 
     memcpy(txp, destaddr, ETH_ALEN);
     memcpy(txp + ETH_ALEN, nic->node_addr, ETH_ALEN);
@@ -319,26 +325,29 @@
     memcpy(txp + ETH_HLEN, data, len);
 
     len += ETH_HLEN;
-
+	len &= 0x0FFF;
+	while(len < ETH_ZLEN)
+		txp[len++] = '\0';
     /*
      * Caution: the write order is important here,
      * set the base address with the "ownership"
      * bits last.
      */
-    tx_ring[entry].txlength  = (len >= 60 ? len : 60);
-    tx_ring[entry].buflength = len;
-    tx_ring[entry].status    = TRING_OWN;	/* Pass ownership to the chip. */
+    
+    tx_ring[entry].buflength |= cpu_to_le32(len);
+    tx_ring[entry].status = cpu_to_le32(len << 16) | 
+	    cpu_to_le32(TRING_OWN);	/* Pass ownership to the chip. */
 
     cur_tx++;
 
     /* Trigger an immediate transmit demand. */
-    outl(CR_QUEUE_TX, command);
-
+    outl(CR_QUEUE_TX, command); 
+    
     load_timer2(10*TICKS_PER_MS);         /* timeout 10 ms for transmit */
-    while ((tx_ring[entry].status & TRING_OWN) && timer2_running())
+    while ((le32_to_cpu(tx_ring[entry].status) & (TRING_OWN)) && timer2_running())
 	/* Wait */;
 
-    if ((tx_ring[entry].status & TRING_OWN) != 0)
+    if ((le32_to_cpu(tx_ring[entry].status) & TRING_OWN) != 0)
 	printf("Oops, transmitter timeout, status=%hX\n",
 	    tx_ring[entry].status);
 }
@@ -356,17 +365,19 @@
  */
 
     static int
-epic100_poll(struct nic *nic)
+epic100_poll(struct nic *nic, int retrieve)
 {
     int entry;
-    int status;
     int retcode;
-
+    int status;
     entry = cur_rx % RX_RING_SIZE;
 
-    if ((status = rx_ring[entry].status & RRING_OWN) == RRING_OWN)
+    if ((rx_ring[entry].status & cpu_to_le32(RRING_OWN)) == RRING_OWN)
 	return (0);
 
+    if ( ! retrieve ) return 1;
+
+    status = le32_to_cpu(rx_ring[entry].status);
     /* We own the next entry, it's a new packet. Send it up. */
 
 #if	(EPIC_DEBUG > 4)
@@ -383,8 +394,8 @@
 	retcode = 0;
     } else {
 	/* Omit the four octet CRC from the length. */
-	nic->packetlen = rx_ring[entry].rxlength - 4;
-	memcpy(nic->packet, (char*)rx_ring[entry].bufaddr, nic->packetlen);
+	nic->packetlen = le32_to_cpu((rx_ring[entry].buflength))- 4;
+	memcpy(nic->packet, &rx_packet[entry * PKT_BUF_SZ], nic->packetlen);
 	retcode = 1;
     }
 
@@ -395,17 +406,30 @@
     rx_ring[entry].status = RRING_OWN;
 
     /* Restart Receiver */
-    outl(CR_START_RX | CR_QUEUE_RX, command);
+    outl(CR_START_RX | CR_QUEUE_RX, command); 
 
     return retcode;
 }
 
 
     static void
-epic100_disable(struct nic *nic)
+epic100_disable(struct dev *dev __unused)
 {
+	/* Soft reset the chip. */
+	outl(GC_SOFT_RESET, genctl);
 }
 
+static void epic100_irq(struct nic *nic __unused, irq_action_t action __unused)
+{
+  switch ( action ) {
+  case DISABLE :
+    break;
+  case ENABLE :
+    break;
+  case FORCE :
+    break;
+  }
+}
 
 #ifdef	DEBUG_EEPROM
 /* Serial EEPROM section. */
@@ -479,3 +503,18 @@
 	    break;
     return inw(mmdata);
 }
+
+
+static struct pci_id epic100_nics[] = {
+PCI_ROM(0x10b8, 0x0005, "epic100",    "SMC EtherPowerII"),		/* SMC 83c170 EPIC/100 */
+PCI_ROM(0x10b8, 0x0006, "smc-83c175", "SMC EPIC/C 83c175"),
+};
+
+struct pci_driver epic100_driver = {
+	.type     = NIC_DRIVER,
+	.name     = "EPIC100",
+	.probe    = epic100_probe,
+	.ids      = epic100_nics,
+	.id_count = sizeof(epic100_nics)/sizeof(epic100_nics[0]),
+	.class    = 0,
+};
diff -Naur grub-0.97.orig/netboot/etherboot.h grub-0.97/netboot/etherboot.h
--- grub-0.97.orig/netboot/etherboot.h	2003-07-09 11:45:37.000000000 +0000
+++ grub-0.97/netboot/etherboot.h	2005-08-31 19:03:35.000000000 +0000
@@ -1,6 +1,6 @@
 /*
  *  GRUB  --  GRand Unified Bootloader
- *  Copyright (C) 2000,2001,2002  Free Software Foundation, Inc.
+ *  Copyright (C) 1999,2000,2001,2002,2003,2004  Free Software Foundation, Inc.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -17,531 +17,45 @@
  *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-/* RULE: You must define the macro ``GRUB'' when including this header
-   file in GRUB code.  */
-
-/* Based on "src/etherboot.h" in etherboot-5.0.5.  */
-
-/**************************************************************************
-ETHERBOOT -  BOOTP/TFTP Bootstrap Program
-
-Author: Martin Renters
-  Date: Dec/93
-
-**************************************************************************/
-
-/* Include GRUB-specific macros and prototypes here.  */
-#include <shared.h>
-
-/* FIXME: For now, enable the DHCP support. Perhaps I should segregate
-   the DHCP support from the BOOTP support, and permit both to
-   co-exist.  */
-#undef NO_DHCP_SUPPORT
-
-/* In GRUB, the relocated address in Etherboot doesn't have any sense.
-   Just define it as a bogus value.  */
-#define RELOC	0
-
-/* FIXME: Should be an option.  */
-#define BACKOFF_LIMIT	7
-
-#include <osdep.h>
-
-#define CTRL_C		3
-
-#ifndef	MAX_TFTP_RETRIES
-# define MAX_TFTP_RETRIES	20
-#endif
-
-#ifndef	MAX_BOOTP_RETRIES
-# define MAX_BOOTP_RETRIES	20
-#endif
-
-#define MAX_BOOTP_EXTLEN	(ETH_FRAME_LEN - ETH_HLEN - \
-				 sizeof (struct bootp_t))
+/* 
+ * Transport layer to use Etherboot NIC drivers in GRUB.
+ */
 
-#ifndef	MAX_ARP_RETRIES
-# define MAX_ARP_RETRIES	20
-#endif
+#ifndef ETHERBOOT_H
+#define ETHERBOOT_H
 
-#ifndef	MAX_RPC_RETRIES
-# define MAX_RPC_RETRIES	20
+#include "shared.h"
+#include "osdep.h"
+#include "if_ether.h"
+#include "in.h"
+
+/* Link configuration time in tenths of a second */
+#ifndef VALID_LINK_TIMEOUT
+#define VALID_LINK_TIMEOUT	100 /* 10.0 seconds */
 #endif
 
-#define	TICKS_PER_SEC		18
-
-/* Inter-packet retry in ticks */
-#define TIMEOUT			(10 * TICKS_PER_SEC)
-
-/* These settings have sense only if compiled with -DCONGESTED */
-/* total retransmission timeout in ticks */
-#define TFTP_TIMEOUT		(30 * TICKS_PER_SEC)
-/* packet retransmission timeout in ticks */
-#define TFTP_REXMT		(3 * TICKS_PER_SEC)
-
 #ifndef	NULL
-# define NULL			((void *) 0)
+#define NULL	((void *)0)
 #endif
 
-/*
-   I'm moving towards the defined names in linux/if_ether.h for clarity.
-   The confusion between 60/64 and 1514/1518 arose because the NS8390
-   counts the 4 byte frame checksum in the incoming packet, but not
-   in the outgoing packet. 60/1514 are the correct numbers for most
-   if not all of the other NIC controllers. I will be retiring the
-   64/1518 defines in the lead-up to 5.0.
-*/
-
-#define ETH_ALEN		6	/* Size of Ethernet address */
-#define ETH_HLEN		14	/* Size of ethernet header */
-#define	ETH_ZLEN		60	/* Minimum packet */
-/*#define ETH_MIN_PACKET		64*/
-#define	ETH_FRAME_LEN		1514	/* Maximum packet */
-/*#define ETH_MAX_PACKET		1518*/
-/* Because some DHCP/BOOTP servers don't treat the maximum length the same
-   as Etherboot, subtract the size of an IP header and that of an UDP
-   header.  */
-#define	ETH_MAX_MTU		(ETH_FRAME_LEN - ETH_HLEN \
-				- sizeof (struct iphdr) \
-				- sizeof (struct udphdr))
-
-#define ARP_CLIENT	0
-#define ARP_SERVER	1
-#define ARP_GATEWAY	2
-#define ARP_ROOTSERVER	3
-#define ARP_SWAPSERVER	4
-#define MAX_ARP		ARP_SWAPSERVER+1
-
-#define	RARP_REQUEST	3
-#define	RARP_REPLY	4
-
-#define IP		0x0800
-#define ARP		0x0806
-#define	RARP		0x8035
-
-#define BOOTP_SERVER	67
-#define BOOTP_CLIENT	68
-#define TFTP_PORT	69
-#define SUNRPC_PORT	111
-
-#define IP_UDP		17
-/* Same after going through htonl */
-#define IP_BROADCAST	0xFFFFFFFF
-
-#define ARP_REQUEST	1
-#define ARP_REPLY	2
-
-#define BOOTP_REQUEST	1
-#define BOOTP_REPLY	2
-
-#define TAG_LEN(p)		(*((p) + 1))
-#define RFC1533_COOKIE		99, 130, 83, 99
-#define RFC1533_PAD		0
-#define RFC1533_NETMASK		1
-#define RFC1533_TIMEOFFSET	2
-#define RFC1533_GATEWAY		3
-#define RFC1533_TIMESERVER	4
-#define RFC1533_IEN116NS	5
-#define RFC1533_DNS		6
-#define RFC1533_LOGSERVER	7
-#define RFC1533_COOKIESERVER	8
-#define RFC1533_LPRSERVER	9
-#define RFC1533_IMPRESSSERVER	10
-#define RFC1533_RESOURCESERVER	11
-#define RFC1533_HOSTNAME	12
-#define RFC1533_BOOTFILESIZE	13
-#define RFC1533_MERITDUMPFILE	14
-#define RFC1533_DOMAINNAME	15
-#define RFC1533_SWAPSERVER	16
-#define RFC1533_ROOTPATH	17
-#define RFC1533_EXTENSIONPATH	18
-#define RFC1533_IPFORWARDING	19
-#define RFC1533_IPSOURCEROUTING	20
-#define RFC1533_IPPOLICYFILTER	21
-#define RFC1533_IPMAXREASSEMBLY	22
-#define RFC1533_IPTTL		23
-#define RFC1533_IPMTU		24
-#define RFC1533_IPMTUPLATEAU	25
-#define RFC1533_INTMTU		26
-#define RFC1533_INTLOCALSUBNETS	27
-#define RFC1533_INTBROADCAST	28
-#define RFC1533_INTICMPDISCOVER	29
-#define RFC1533_INTICMPRESPOND	30
-#define RFC1533_INTROUTEDISCOVER 31
-#define RFC1533_INTROUTESOLICIT	32
-#define RFC1533_INTSTATICROUTES	33
-#define RFC1533_LLTRAILERENCAP	34
-#define RFC1533_LLARPCACHETMO	35
-#define RFC1533_LLETHERNETENCAP	36
-#define RFC1533_TCPTTL		37
-#define RFC1533_TCPKEEPALIVETMO	38
-#define RFC1533_TCPKEEPALIVEGB	39
-#define RFC1533_NISDOMAIN	40
-#define RFC1533_NISSERVER	41
-#define RFC1533_NTPSERVER	42
-#define RFC1533_VENDOR		43
-#define RFC1533_NBNS		44
-#define RFC1533_NBDD		45
-#define RFC1533_NBNT		46
-#define RFC1533_NBSCOPE		47
-#define RFC1533_XFS		48
-#define RFC1533_XDM		49
-#ifndef	NO_DHCP_SUPPORT
-#define RFC2132_REQ_ADDR	50
-#define RFC2132_MSG_TYPE	53
-#define RFC2132_SRV_ID		54
-#define RFC2132_PARAM_LIST	55
-#define RFC2132_MAX_SIZE	57
-#define RFC2132_VENDOR_CLASS_ID	60
-
-#define DHCPDISCOVER		1
-#define DHCPOFFER		2
-#define DHCPREQUEST		3
-#define DHCPACK			5
-#endif	/* NO_DHCP_SUPPORT */
-
-#define RFC1533_VENDOR_MAJOR	0
-#define RFC1533_VENDOR_MINOR	0
-
-#define RFC1533_VENDOR_MAGIC	128
-#define RFC1533_VENDOR_ADDPARM	129
-#define RFC1533_VENDOR_MNUOPTS	160
-#define RFC1533_VENDOR_SELECTION 176
-#define RFC1533_VENDOR_MOTD	184
-#define RFC1533_VENDOR_NUMOFMOTD 8
-#define RFC1533_VENDOR_IMG	192
-#define RFC1533_VENDOR_NUMOFIMG	16
-
-#define RFC1533_VENDOR_CONFIGFILE	150
-
-#define RFC1533_END		255
-
-#define BOOTP_VENDOR_LEN	64
-#ifndef	NO_DHCP_SUPPORT
-#define DHCP_OPT_LEN		312
-#endif	/* NO_DHCP_SUPPORT */
-
-#define	TFTP_DEFAULTSIZE_PACKET	512
-#define	TFTP_MAX_PACKET		1432 /* 512 */
-
-#define TFTP_RRQ	1
-#define TFTP_WRQ	2
-#define TFTP_DATA	3
-#define TFTP_ACK	4
-#define TFTP_ERROR	5
-#define TFTP_OACK	6
-
-#define TFTP_CODE_EOF	1
-#define TFTP_CODE_MORE	2
-#define TFTP_CODE_ERROR	3
-#define TFTP_CODE_BOOT	4
-#define TFTP_CODE_CFG	5
-
-#define AWAIT_ARP	0
-#define AWAIT_BOOTP	1
-#define AWAIT_TFTP	2
-#define AWAIT_RARP	3
-#define AWAIT_RPC	4
-#define AWAIT_QDRAIN	5	/* drain queue, process ARP requests */
-
-typedef struct
-{
-  unsigned long	s_addr;
-}
-in_addr;
-
-struct arptable_t
-{
-  in_addr ipaddr;
-  unsigned char node[6];
-};
-
-/*
- * A pity sipaddr and tipaddr are not longword aligned or we could use
- * in_addr. No, I don't want to use #pragma packed.
- */
-struct arprequest
-{
-  unsigned short hwtype;
-  unsigned short protocol;
-  char hwlen;
-  char protolen;
-  unsigned short opcode;
-  char shwaddr[6];
-  char sipaddr[4];
-  char thwaddr[6];
-  char tipaddr[4];
-};
-
-struct iphdr
-{
-  char verhdrlen;
-  char service;
-  unsigned short len;
-  unsigned short ident;
-  unsigned short frags;
-  char ttl;
-  char protocol;
-  unsigned short chksum;
-  in_addr src;
-  in_addr dest;
-};
-
-struct udphdr
-{
-  unsigned short src;
-  unsigned short dest;
-  unsigned short len;
-  unsigned short chksum;
-};
-
-/* Format of a bootp packet.  */
-struct bootp_t
-{
-  char bp_op;
-  char bp_htype;
-  char bp_hlen;
-  char bp_hops;
-  unsigned long bp_xid;
-  unsigned short bp_secs;
-  unsigned short unused;
-  in_addr bp_ciaddr;
-  in_addr bp_yiaddr;
-  in_addr bp_siaddr;
-  in_addr bp_giaddr;
-  char bp_hwaddr[16];
-  char bp_sname[64];
-  char bp_file[128];
-#ifdef	NO_DHCP_SUPPORT
-  char bp_vend[BOOTP_VENDOR_LEN];
-#else
-  char bp_vend[DHCP_OPT_LEN];
-#endif	/* NO_DHCP_SUPPORT */
-};
-
-/* Format of a bootp IP packet.  */
-struct bootpip_t
-{
-  struct iphdr ip;
-  struct udphdr udp;
-  struct bootp_t bp;
-};
-
-/* Format of bootp packet with extensions.  */
-struct bootpd_t
-{
-  struct bootp_t bootp_reply;
-  unsigned char  bootp_extension[MAX_BOOTP_EXTLEN];
-};
-
-struct tftp_t
-{
-  struct iphdr ip;
-  struct udphdr udp;
-  unsigned short opcode;
-  union
-  {
-    char rrq[TFTP_DEFAULTSIZE_PACKET];
-    
-    struct
-    {
-      unsigned short block;
-      char download[TFTP_MAX_PACKET];
-    }
-    data;
-    
-    struct
-    {
-      unsigned short block;
-    }
-    ack;
-    
-    struct
-    {
-      unsigned short errcode;
-      char errmsg[TFTP_DEFAULTSIZE_PACKET];
-    }
-    err;
-    
-    struct
-    {
-      char data[TFTP_DEFAULTSIZE_PACKET+2];
-    }
-    oack;
-  }
-  u;
-};
-
-/* Define a smaller tftp packet solely for making requests to conserve stack
-   512 bytes should be enough.  */
-struct tftpreq_t
-{
-  struct iphdr ip;
-  struct udphdr udp;
-  unsigned short opcode;
-  union
-  {
-    char rrq[512];
-    
-    struct
-    {
-      unsigned short block;
-    }
-    ack;
-    
-    struct
-    {
-      unsigned short errcode;
-      char errmsg[512-2];
-    }
-    err;
-  }
-  u;
-};
-
-#define TFTP_MIN_PACKET	(sizeof(struct iphdr) + sizeof(struct udphdr) + 4)
-
-struct rpc_t
-{
-  struct iphdr ip;
-  struct udphdr udp;
-  union
-  {
-    char data[300];		/* longest RPC call must fit!!!! */
-    
-    struct
-    {
-      long id;
-      long type;
-      long rpcvers;
-      long prog;
-      long vers;
-      long proc;
-      long data[1];
-    }
-    call;
-    
-    struct
-    {
-      long id;
-      long type;
-      long rstatus;
-      long verifier;
-      long v2;
-      long astatus;
-      long data[1];
-    }
-    reply;
-  }
-  u;
-};
-
-#define PROG_PORTMAP	100000
-#define PROG_NFS	100003
-#define PROG_MOUNT	100005
-
-#define MSG_CALL	0
-#define MSG_REPLY	1
-
-#define PORTMAP_GETPORT	3
-
-#define MOUNT_ADDENTRY	1
-#define MOUNT_UMOUNTALL	4
-
-#define NFS_LOOKUP	4
-#define NFS_READ	6
-
-#define NFS_FHSIZE	32
-
-#define NFSERR_PERM	1
-#define NFSERR_NOENT	2
-#define NFSERR_ACCES	13
-
-/* Block size used for NFS read accesses.  A RPC reply packet (including  all
- * headers) must fit within a single Ethernet frame to avoid fragmentation.
- * Chosen to be a power of two, as most NFS servers are optimized for this.  */
-#define NFS_READ_SIZE	1024
-
-#define	FLOPPY_BOOT_LOCATION	0x7c00
-/* Must match offsets in loader.S */
-#define ROM_SEGMENT		0x1fa
-#define ROM_LENGTH		0x1fc
-
-#define	ROM_INFO_LOCATION	(FLOPPY_BOOT_LOCATION + ROM_SEGMENT)
-/* at end of floppy boot block */
-
-struct rom_info
-{
-  unsigned short	rom_segment;
-  unsigned short	rom_length;
-};
-
-static inline int
-rom_address_ok (struct rom_info *rom, int assigned_rom_segment)
-{
-  return (assigned_rom_segment < 0xC000
-	  || assigned_rom_segment == rom->rom_segment);
-}
-
-/* Define a type for passing info to a loaded program.  */
-struct ebinfo
-{
-  unsigned char	major, minor;	/* Version */
-  unsigned short	flags;		/* Bit flags */
-};
-
-/***************************************************************************
-External prototypes
-***************************************************************************/
-/* main.c */
-extern void print_network_configuration (void);
-extern int ifconfig (char *ip, char *sm, char *gw, char *svr);
-extern int udp_transmit (unsigned long destip, unsigned int srcsock,
-			 unsigned int destsock, int len, const void *buf);
-extern int await_reply (int type, int ival, void *ptr, int timeout);
-extern int decode_rfc1533 (unsigned char *, int, int, int);
-extern long rfc2131_sleep_interval (int base, int exp);
-extern void cleanup (void);
-extern int rarp (void);
-extern int bootp (void);
-extern void cleanup_net (void);
-
-/* config.c */
-extern void print_config (void);
-extern void eth_reset (void);
-extern int eth_probe (void);
-extern int eth_poll (void);
-extern void eth_transmit (const char *d, unsigned int t,
-			  unsigned int s, const void *p);
-extern void eth_disable (void);
-
-/* misc.c */
-extern void twiddle (void);
-extern void sleep (int secs);
-extern int getdec (char **s);
-extern void etherboot_printf (const char *, ...);
-extern int etherboot_sprintf (char *, const char *, ...);
-extern int inet_aton (char *p, in_addr *i);
-
-/***************************************************************************
-External variables
-***************************************************************************/
-/* main.c */
-extern int ip_abort;
-extern int network_ready;
-extern struct rom_info rom;
-extern struct arptable_t arptable[MAX_ARP];
-extern struct bootpd_t bootp_data;
-#define	BOOTP_DATA_ADDR	(&bootp_data)
-extern unsigned char *end_of_rfc1533;
 
-/* config.c */
-extern struct nic nic;
+#define gateA20_set() gateA20(1)
+#define gateA20_unset() gateA20(0)
+#define EBDEBUG 0
+/* The 'rom_info' maybe arch depended. It must be moved to some other
+ * place */
+struct rom_info {
+	unsigned short	rom_segment;
+	unsigned short	rom_length;
+};
+
+extern void poll_interruptions P((void));
+
+/* For UNDI drivers */
+extern void fake_irq ( uint8_t irq );
+extern void _trivial_irq_handler_start;
+extern uint32_t get_free_base_memory ( void );
+extern void forget_base_memory ( void*, size_t );
+extern void free_unused_base_memory ( void );
 
-/* Local hack - define some macros to use etherboot source files "as is".  */
-#ifndef GRUB
-# undef printf
-# define printf	etherboot_printf
-# undef sprintf
-# define sprintf etherboot_sprintf
-#endif /* GRUB */
+#endif /* ETHERBOOT_H */
diff -Naur grub-0.97.orig/netboot/fa311.c grub-0.97/netboot/fa311.c
--- grub-0.97.orig/netboot/fa311.c	2003-07-09 11:45:37.000000000 +0000
+++ grub-0.97/netboot/fa311.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,421 +0,0 @@
-/*
-        Driver for the National Semiconductor DP83810 Ethernet controller.
-        
-        Portions Copyright (C) 2001 Inprimis Technologies, Inc.
-        http://www.inprimis.com/
-        
-        This driver is based (heavily) on the Linux driver for this chip 
-        which is copyright 1999-2001 by Donald Becker.
-
-        This software has no warranties expressed or implied for any
-        purpose.
-
-        This software may be used and distributed according to the terms of
-        the GNU General Public License (GPL), incorporated herein by reference.
-        Drivers based on or derived from this code fall under the GPL and must
-        retain the authorship, copyright and license notice.  This file is not
-        a complete program and may only be used when the entire operating
-        system is licensed under the GPL.  License for under other terms may be
-        available.  Contact the original author for details.
-
-        The original author may be reached as becker@scyld.com, or at
-        Scyld Computing Corporation
-        410 Severn Ave., Suite 210
-        Annapolis MD 21403
-*/
-
-
-typedef unsigned char  u8;
-typedef   signed char  s8;
-typedef unsigned short u16;
-typedef   signed short s16;
-typedef unsigned int   u32;
-typedef   signed int   s32;
-
-#include "etherboot.h"
-#include "nic.h"
-#include "pci.h"
-
-#undef	virt_to_bus
-#define	virt_to_bus(x)          ((unsigned long)x)
-#define cpu_to_le32(val)        (val)
-#define le32_to_cpu(val)        (val)
-#define virt_to_le32desc(addr)  cpu_to_le32(virt_to_bus(addr))
-#define le32desc_to_virt(addr)  bus_to_virt(le32_to_cpu(addr))
-
-#define TX_RING_SIZE 1
-#define RX_RING_SIZE 4
-#define TIME_OUT     1000000
-#define PKT_BUF_SZ   1536
-
-/* Offsets to the device registers. */
-enum register_offsets {
-    ChipCmd=0x00, ChipConfig=0x04, EECtrl=0x08, PCIBusCfg=0x0C,
-    IntrStatus=0x10, IntrMask=0x14, IntrEnable=0x18,
-    TxRingPtr=0x20, TxConfig=0x24,
-    RxRingPtr=0x30, RxConfig=0x34,
-    WOLCmd=0x40, PauseCmd=0x44, RxFilterAddr=0x48, RxFilterData=0x4C,
-    BootRomAddr=0x50, BootRomData=0x54, StatsCtrl=0x5C, StatsData=0x60,
-    RxPktErrs=0x60, RxMissed=0x68, RxCRCErrs=0x64,
-};
-
-/* Bit in ChipCmd. */
-enum ChipCmdBits {
-    ChipReset=0x100, RxReset=0x20, TxReset=0x10, RxOff=0x08, RxOn=0x04,
-    TxOff=0x02, TxOn=0x01,
-};
-
-/* Bits in the interrupt status/mask registers. */
-enum intr_status_bits {
-    IntrRxDone=0x0001, IntrRxIntr=0x0002, IntrRxErr=0x0004, IntrRxEarly=0x0008,
-    IntrRxIdle=0x0010, IntrRxOverrun=0x0020,
-    IntrTxDone=0x0040, IntrTxIntr=0x0080, IntrTxErr=0x0100,
-    IntrTxIdle=0x0200, IntrTxUnderrun=0x0400,
-    StatsMax=0x0800, LinkChange=0x4000,	WOLPkt=0x2000,
-    RxResetDone=0x1000000, TxResetDone=0x2000000,
-    IntrPCIErr=0x00f00000, IntrNormalSummary=0x0251, IntrAbnormalSummary=0xED20,
-};
-
-/* Bits in the RxMode register. */
-enum rx_mode_bits {
-    AcceptErr=0x20, AcceptRunt=0x10, AcceptBroadcast=0xC0000000,
-    AcceptMulticast=0x00200000, AcceptAllMulticast=0x20000000,
-    AcceptAllPhys=0x10000000, AcceptMyPhys=0x08000000,
-};
-
-/* Bits in network_desc.status */
-enum desc_status_bits {
-    DescOwn=0x80000000, DescMore=0x40000000, DescIntr=0x20000000,
-    DescNoCRC=0x10000000,
-    DescPktOK=0x08000000, RxTooLong=0x00400000,
-};
-
-/* The Rx and Tx buffer descriptors. */
-struct netdev_desc {
-    u32 next_desc;
-    s32 cmd_status;
-    u32 addr;
-};
-
-static struct FA311_DEV {
-    unsigned int    ioaddr;
-    unsigned short  vendor;
-    unsigned short  device;
-    unsigned int    cur_rx;
-    unsigned int    cur_tx;
-    unsigned int    rx_buf_sz;
-    volatile struct netdev_desc *rx_head_desc;
-    volatile struct netdev_desc rx_ring[RX_RING_SIZE] __attribute__ ((aligned (4)));
-    volatile struct netdev_desc tx_ring[TX_RING_SIZE] __attribute__ ((aligned (4)));
-} fa311_dev;
-
-static int  eeprom_read(long ioaddr, int location);
-static void init_ring(struct FA311_DEV *dev);
-static void fa311_reset(struct nic *nic);
-static int  fa311_poll(struct nic *nic);
-static void fa311_transmit(struct nic *nic, const char *d, unsigned int t, unsigned int s, const char *p);
-static void fa311_disable(struct nic *nic);
-
-static char rx_packet[PKT_BUF_SZ * RX_RING_SIZE] __attribute__ ((aligned (4)));
-static char tx_packet[PKT_BUF_SZ * TX_RING_SIZE] __attribute__ ((aligned (4)));
-
-struct nic * fa311_probe(struct nic *nic, unsigned short *io_addrs, struct pci_device *pci)
-{
-int            prev_eedata;
-int            i;
-int            duplex;
-int            tx_config;
-int            rx_config;
-unsigned char  macaddr[6];
-unsigned char  mactest;
-unsigned char  pci_bus = 0;
-struct FA311_DEV* dev = &fa311_dev;
-	
-    if (io_addrs == 0 || *io_addrs == 0)
-        return (0);
-    memset(dev, 0, sizeof(*dev));
-    dev->vendor = pci->vendor;
-    dev->device = pci->dev_id;
-    dev->ioaddr = pci->membase;
-
-    /* Work around the dropped serial bit. */
-    prev_eedata = eeprom_read(dev->ioaddr, 6);
-    for (i = 0; i < 3; i++) {
-        int eedata = eeprom_read(dev->ioaddr, i + 7);
-        macaddr[i*2] = (eedata << 1) + (prev_eedata >> 15);
-        macaddr[i*2+1] = eedata >> 7;
-        prev_eedata = eedata;
-    }
-    mactest = 0;
-    for (i = 0; i < 6; i++)
-        mactest |= macaddr[i];
-    if (mactest == 0)
-        return (0);
-    for (i = 0; i < 6; i++)
-        nic->node_addr[i] = macaddr[i];
-    printf("%! ", nic->node_addr);
-
-    adjust_pci_device(pci);
-
-    fa311_reset(nic);
-
-    nic->reset = fa311_reset;
-    nic->disable = fa311_disable;
-    nic->poll = fa311_poll;
-    nic->transmit = fa311_transmit;
-
-    init_ring(dev);
-
-    writel(virt_to_bus(dev->rx_ring), dev->ioaddr + RxRingPtr);
-    writel(virt_to_bus(dev->tx_ring), dev->ioaddr + TxRingPtr);
-
-    for (i = 0; i < 6; i += 2)
-    {
-        writel(i, dev->ioaddr + RxFilterAddr);
-        writew(macaddr[i] + (macaddr[i+1] << 8),
-               dev->ioaddr + RxFilterData);
-    }
-
-    /* Initialize other registers. */
-    /* Configure for standard, in-spec Ethernet. */
-    if (readl(dev->ioaddr + ChipConfig) & 0x20000000)
-    {    /* Full duplex */
-        tx_config = 0xD0801002;
-        rx_config = 0x10000020;
-    }
-    else
-    {
-        tx_config = 0x10801002;
-        rx_config = 0x0020;
-    }
-    writel(tx_config, dev->ioaddr + TxConfig);
-    writel(rx_config, dev->ioaddr + RxConfig);
-
-    duplex = readl(dev->ioaddr + ChipConfig) & 0x20000000 ? 1 : 0;
-    if (duplex) {
-        rx_config |= 0x10000000;
-        tx_config |= 0xC0000000;
-    } else {
-        rx_config &= ~0x10000000;
-        tx_config &= ~0xC0000000;
-    }
-    writew(tx_config, dev->ioaddr + TxConfig);
-    writew(rx_config, dev->ioaddr + RxConfig);
-
-    writel(AcceptBroadcast | AcceptAllMulticast | AcceptMyPhys, 
-           dev->ioaddr + RxFilterAddr);
-
-    writel(RxOn | TxOn, dev->ioaddr + ChipCmd);
-    writel(4, dev->ioaddr + StatsCtrl);              /* Clear Stats */
-    return nic;	
-
-}
-
-static void fa311_reset(struct nic *nic)
-{
-u32 chip_config;
-struct FA311_DEV* dev = &fa311_dev;
-
-    /* Reset the chip to erase previous misconfiguration. */
-    outl(ChipReset, dev->ioaddr + ChipCmd);
-
-    if ((readl(dev->ioaddr + ChipConfig) & 0xe000) != 0xe000)
-    {
-        chip_config = readl(dev->ioaddr + ChipConfig);
-    }
-}
-
-static int fa311_poll(struct nic *nic)
-{
-s32 desc_status;
-int to;
-int entry;
-int retcode;
-struct FA311_DEV* dev = &fa311_dev;
-
-    retcode = 0;
-    entry = dev->cur_rx;
-    to = TIME_OUT;
-    while (to != 0)
-    {
-        desc_status = dev->rx_ring[entry].cmd_status;
-        if ((desc_status & DescOwn) != 0)
-            break;
-        else
-            --to;
-    }
-    if (to != 0)
-    {
-        readl(dev->ioaddr + IntrStatus);         /* clear interrrupt bits */
-        /* driver owns the next entry it's a new packet. Send it up. */
-        if ((desc_status & (DescMore|DescPktOK|RxTooLong)) == DescPktOK)
-        {
-            nic->packetlen = (desc_status & 0x0fff) - 4;    /* Omit CRC size. */
-            memcpy(nic->packet, (char*)(dev->rx_ring[entry].addr), nic->packetlen);
-            retcode = 1;
-        }
-        /* Give the descriptor back to the chip */
-        dev->rx_ring[entry].cmd_status = cpu_to_le32(dev->rx_buf_sz);
-        dev->cur_rx++;
-        if (dev->cur_rx >= RX_RING_SIZE)
-            dev->cur_rx = 0;
-        dev->rx_head_desc = &dev->rx_ring[dev->cur_rx];
-    }
-    /* Restart Rx engine if stopped. */
-    writel(RxOn, dev->ioaddr + ChipCmd);
-    return retcode;
-}
-
-static void fa311_transmit(struct nic *nic, const char *destaddr, unsigned int type, unsigned int len, const char *data)
-{
-unsigned short nstype;
-s32            desc_status;
-int            to;
-int            entry;
-char*          txp;
-unsigned char* s;
-struct FA311_DEV* dev = &fa311_dev;
-
-    /* Calculate the next Tx descriptor entry. */
-    entry = dev->cur_tx;
-    txp = (char*)(dev->tx_ring[entry].addr);
-
-    memcpy(txp, destaddr, ETH_ALEN);
-    memcpy(txp + ETH_ALEN, nic->node_addr, ETH_ALEN);
-    nstype = htons(type);
-    memcpy(txp + 12, (char*)&nstype, 2);
-    memcpy(txp + ETH_HLEN, data, len);
-    len += ETH_HLEN;
-    /* pad frame */
-    if (len <  ETH_ZLEN)
-    {
-        s = (unsigned char*)(txp+len);
-        while (s < (unsigned char*)(txp+ETH_ZLEN))
-            *s++ = 0;
-        len = ETH_ZLEN;
-    }
-    dev->tx_ring[entry].cmd_status = cpu_to_le32(DescOwn | len);
-    dev->cur_tx++;
-    if (dev->cur_tx >= TX_RING_SIZE)
-        dev->cur_tx = 0;
-
-    /* Wake the potentially-idle transmit channel. */
-    writel(TxOn, dev->ioaddr + ChipCmd);
-
-    /* wait for tranmission to complete */
-    to = TIME_OUT;
-    while (to != 0)
-    {
-        desc_status = dev->tx_ring[entry].cmd_status;
-        if ((desc_status & DescOwn) == 0)
-            break;
-        else
-            --to;
-    }
-
-    readl(dev->ioaddr + IntrStatus);         /* clear interrrupt bits */
-    return;
-}
-
-static void fa311_disable(struct nic *nic)
-{
-struct FA311_DEV* dev = &fa311_dev;
-
-    /* Stop the chip's Tx and Rx processes. */
-    writel(RxOff | TxOff, dev->ioaddr + ChipCmd);
-}
-
-
-/* Read the EEPROM and MII Management Data I/O (MDIO) interfaces.
-   The EEPROM code is for the common 93c06/46 EEPROMs with 6 bit addresses. */
-
-/* Delay between EEPROM clock transitions.
-   No extra delay is needed with 33Mhz PCI, but future 66Mhz access may need
-   a delay.  Note that pre-2.0.34 kernels had a cache-alignment bug that
-   made udelay() unreliable.
-   The old method of using an ISA access as a delay, __SLOW_DOWN_IO__, is
-   depricated.
-*/
-#define eeprom_delay(ee_addr)	inl(ee_addr)
-
-enum EEPROM_Ctrl_Bits {
-	EE_ShiftClk=0x04, EE_DataIn=0x01, EE_ChipSelect=0x08, EE_DataOut=0x02,
-};
-#define EE_Write0 (EE_ChipSelect)
-#define EE_Write1 (EE_ChipSelect | EE_DataIn)
-
-/* The EEPROM commands include the alway-set leading bit. */
-enum EEPROM_Cmds {
-	EE_WriteCmd=(5 << 6), EE_ReadCmd=(6 << 6), EE_EraseCmd=(7 << 6),
-};
-
-
-static int eeprom_read(long addr, int location)
-{
-	int i;
-	int retval = 0;
-	int ee_addr = addr + EECtrl;
-	int read_cmd = location | EE_ReadCmd;
-	writel(EE_Write0, ee_addr);
-
-	/* Shift the read command bits out. */
-	for (i = 10; i >= 0; i--) {
-		short dataval = (read_cmd & (1 << i)) ? EE_Write1 : EE_Write0;
-		writel(dataval, ee_addr);
-		eeprom_delay(ee_addr);
-		writel(dataval | EE_ShiftClk, ee_addr);
-		eeprom_delay(ee_addr);
-	}
-	writel(EE_ChipSelect, ee_addr);
-	eeprom_delay(ee_addr);
-
-	for (i = 0; i < 16; i++) {
-		writel(EE_ChipSelect | EE_ShiftClk, ee_addr);
-		eeprom_delay(ee_addr);
-		retval |= (readl(ee_addr) & EE_DataOut) ? 1 << i : 0;
-		writel(EE_ChipSelect, ee_addr);
-		eeprom_delay(ee_addr);
-	}
-
-	/* Terminate the EEPROM access. */
-	writel(EE_Write0, ee_addr);
-	writel(0, ee_addr);
-	return retval;
-}
-
-/* Initialize the Rx and Tx rings, along with various 'dev' bits. */
-static void init_ring(struct FA311_DEV *dev)
-{
-	int i;
-
-	dev->cur_rx = 0;
-    dev->cur_tx = 0;
-
-	dev->rx_buf_sz = PKT_BUF_SZ;
-	dev->rx_head_desc = &dev->rx_ring[0];
-
-	/* Initialize all Rx descriptors. */
-	for (i = 0; i < RX_RING_SIZE; i++) {
-		dev->rx_ring[i].next_desc = virt_to_le32desc(&dev->rx_ring[i+1]);
-		dev->rx_ring[i].cmd_status = DescOwn;
-	}
-	/* Mark the last entry as wrapping the ring. */
-	dev->rx_ring[i-1].next_desc = virt_to_le32desc(&dev->rx_ring[0]);
-
-	/* Fill in the Rx buffers.  Handle allocation failure gracefully. */
-	for (i = 0; i < RX_RING_SIZE; i++) {
-		dev->rx_ring[i].addr = (u32)(&rx_packet[PKT_BUF_SZ * i]);
-	    dev->rx_ring[i].cmd_status = cpu_to_le32(dev->rx_buf_sz);
-	}
-
-	for (i = 0; i < TX_RING_SIZE; i++) {
-		dev->tx_ring[i].next_desc = virt_to_le32desc(&dev->tx_ring[i+1]);
-		dev->tx_ring[i].cmd_status = 0;
-	}
-	dev->tx_ring[i-1].next_desc = virt_to_le32desc(&dev->tx_ring[0]);
-
-	for (i = 0; i < TX_RING_SIZE; i++)
-		dev->tx_ring[i].addr = (u32)(&tx_packet[PKT_BUF_SZ * i]);
-	return;
-}
-
diff -Naur grub-0.97.orig/netboot/forcedeth.c grub-0.97/netboot/forcedeth.c
--- grub-0.97.orig/netboot/forcedeth.c	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/forcedeth.c	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,1039 @@
+/**************************************************************************
+*    forcedeth.c -- Etherboot device driver for the NVIDIA nForce 
+*			media access controllers.
+*
+* Note: This driver is based on the Linux driver that was based on
+*      a cleanroom reimplementation which was based on reverse
+*      engineered documentation written by Carl-Daniel Hailfinger
+*      and Andrew de Quincey. It's neither supported nor endorsed
+*      by NVIDIA Corp. Use at your own risk.
+*
+*    Written 2004 by Timothy Legge <tlegge@rogers.com>
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the License, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not, write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*    Portions of this code based on:
+*		forcedeth: Ethernet driver for NVIDIA nForce media access controllers:
+*
+*	(C) 2003 Manfred Spraul
+*		See Linux Driver for full information
+*	
+*	Linux Driver Version 0.22, 19 Jan 2004
+* 
+* 
+*    REVISION HISTORY:
+*    ================
+*    v1.0	01-31-2004	timlegge	Initial port of Linux driver
+*    v1.1	02-03-2004	timlegge	Large Clean up, first release 
+*    
+*    Indent Options: indent -kr -i8
+***************************************************************************/
+
+/* to get some global routines like printf */
+#include "etherboot.h"
+/* to get the interface to the body of the program */
+#include "nic.h"
+/* to get the PCI support functions, if this is a PCI NIC */
+#include "pci.h"
+/* Include timer support functions */
+#include "timer.h"
+
+#define drv_version "v1.1"
+#define drv_date "02-03-2004"
+
+//#define TFTM_DEBUG
+#ifdef TFTM_DEBUG
+#define dprintf(x) printf x
+#else
+#define dprintf(x)
+#endif
+
+typedef unsigned char u8;
+typedef signed char s8;
+typedef unsigned short u16;
+typedef signed short s16;
+typedef unsigned int u32;
+typedef signed int s32;
+
+/* Condensed operations for readability. */
+#define virt_to_le32desc(addr)  cpu_to_le32(virt_to_bus(addr))
+#define le32desc_to_virt(addr)  bus_to_virt(le32_to_cpu(addr))
+
+unsigned long BASE;
+/* NIC specific static variables go here */
+
+
+/*
+ * Hardware access:
+ */
+
+#define DEV_NEED_LASTPACKET1	0x0001
+#define DEV_IRQMASK_1		0x0002
+#define DEV_IRQMASK_2		0x0004
+#define DEV_NEED_TIMERIRQ	0x0008
+
+enum {
+	NvRegIrqStatus = 0x000,
+#define NVREG_IRQSTAT_MIIEVENT	0040
+#define NVREG_IRQSTAT_MASK		0x1ff
+	NvRegIrqMask = 0x004,
+#define NVREG_IRQ_RX			0x0002
+#define NVREG_IRQ_RX_NOBUF		0x0004
+#define NVREG_IRQ_TX_ERR		0x0008
+#define NVREG_IRQ_TX2			0x0010
+#define NVREG_IRQ_TIMER			0x0020
+#define NVREG_IRQ_LINK			0x0040
+#define NVREG_IRQ_TX1			0x0100
+#define NVREG_IRQMASK_WANTED_1		0x005f
+#define NVREG_IRQMASK_WANTED_2		0x0147
+#define NVREG_IRQ_UNKNOWN		(~(NVREG_IRQ_RX|NVREG_IRQ_RX_NOBUF|NVREG_IRQ_TX_ERR|NVREG_IRQ_TX2|NVREG_IRQ_TIMER|NVREG_IRQ_LINK|NVREG_IRQ_TX1))
+
+	NvRegUnknownSetupReg6 = 0x008,
+#define NVREG_UNKSETUP6_VAL		3
+
+/*
+ * NVREG_POLL_DEFAULT is the interval length of the timer source on the nic
+ * NVREG_POLL_DEFAULT=97 would result in an interval length of 1 ms
+ */
+	NvRegPollingInterval = 0x00c,
+#define NVREG_POLL_DEFAULT	970
+	NvRegMisc1 = 0x080,
+#define NVREG_MISC1_HD		0x02
+#define NVREG_MISC1_FORCE	0x3b0f3c
+
+	NvRegTransmitterControl = 0x084,
+#define NVREG_XMITCTL_START	0x01
+	NvRegTransmitterStatus = 0x088,
+#define NVREG_XMITSTAT_BUSY	0x01
+
+	NvRegPacketFilterFlags = 0x8c,
+#define NVREG_PFF_ALWAYS	0x7F0008
+#define NVREG_PFF_PROMISC	0x80
+#define NVREG_PFF_MYADDR	0x20
+
+	NvRegOffloadConfig = 0x90,
+#define NVREG_OFFLOAD_HOMEPHY	0x601
+#define NVREG_OFFLOAD_NORMAL	0x5ee
+	NvRegReceiverControl = 0x094,
+#define NVREG_RCVCTL_START	0x01
+	NvRegReceiverStatus = 0x98,
+#define NVREG_RCVSTAT_BUSY	0x01
+
+	NvRegRandomSeed = 0x9c,
+#define NVREG_RNDSEED_MASK	0x00ff
+#define NVREG_RNDSEED_FORCE	0x7f00
+
+	NvRegUnknownSetupReg1 = 0xA0,
+#define NVREG_UNKSETUP1_VAL	0x16070f
+	NvRegUnknownSetupReg2 = 0xA4,
+#define NVREG_UNKSETUP2_VAL	0x16
+	NvRegMacAddrA = 0xA8,
+	NvRegMacAddrB = 0xAC,
+	NvRegMulticastAddrA = 0xB0,
+#define NVREG_MCASTADDRA_FORCE	0x01
+	NvRegMulticastAddrB = 0xB4,
+	NvRegMulticastMaskA = 0xB8,
+	NvRegMulticastMaskB = 0xBC,
+
+	NvRegTxRingPhysAddr = 0x100,
+	NvRegRxRingPhysAddr = 0x104,
+	NvRegRingSizes = 0x108,
+#define NVREG_RINGSZ_TXSHIFT 0
+#define NVREG_RINGSZ_RXSHIFT 16
+	NvRegUnknownTransmitterReg = 0x10c,
+	NvRegLinkSpeed = 0x110,
+#define NVREG_LINKSPEED_FORCE 0x10000
+#define NVREG_LINKSPEED_10	10
+#define NVREG_LINKSPEED_100	100
+#define NVREG_LINKSPEED_1000	1000
+	NvRegUnknownSetupReg5 = 0x130,
+#define NVREG_UNKSETUP5_BIT31	(1<<31)
+	NvRegUnknownSetupReg3 = 0x134,
+#define NVREG_UNKSETUP3_VAL1	0x200010
+	NvRegTxRxControl = 0x144,
+#define NVREG_TXRXCTL_KICK	0x0001
+#define NVREG_TXRXCTL_BIT1	0x0002
+#define NVREG_TXRXCTL_BIT2	0x0004
+#define NVREG_TXRXCTL_IDLE	0x0008
+#define NVREG_TXRXCTL_RESET	0x0010
+	NvRegMIIStatus = 0x180,
+#define NVREG_MIISTAT_ERROR		0x0001
+#define NVREG_MIISTAT_LINKCHANGE	0x0008
+#define NVREG_MIISTAT_MASK		0x000f
+#define NVREG_MIISTAT_MASK2		0x000f
+	NvRegUnknownSetupReg4 = 0x184,
+#define NVREG_UNKSETUP4_VAL	8
+
+	NvRegAdapterControl = 0x188,
+#define NVREG_ADAPTCTL_START	0x02
+#define NVREG_ADAPTCTL_LINKUP	0x04
+#define NVREG_ADAPTCTL_PHYVALID	0x4000
+#define NVREG_ADAPTCTL_RUNNING	0x100000
+#define NVREG_ADAPTCTL_PHYSHIFT	24
+	NvRegMIISpeed = 0x18c,
+#define NVREG_MIISPEED_BIT8	(1<<8)
+#define NVREG_MIIDELAY	5
+	NvRegMIIControl = 0x190,
+#define NVREG_MIICTL_INUSE	0x10000
+#define NVREG_MIICTL_WRITE	0x08000
+#define NVREG_MIICTL_ADDRSHIFT	5
+	NvRegMIIData = 0x194,
+	NvRegWakeUpFlags = 0x200,
+#define NVREG_WAKEUPFLAGS_VAL		0x7770
+#define NVREG_WAKEUPFLAGS_BUSYSHIFT	24
+#define NVREG_WAKEUPFLAGS_ENABLESHIFT	16
+#define NVREG_WAKEUPFLAGS_D3SHIFT	12
+#define NVREG_WAKEUPFLAGS_D2SHIFT	8
+#define NVREG_WAKEUPFLAGS_D1SHIFT	4
+#define NVREG_WAKEUPFLAGS_D0SHIFT	0
+#define NVREG_WAKEUPFLAGS_ACCEPT_MAGPAT		0x01
+#define NVREG_WAKEUPFLAGS_ACCEPT_WAKEUPPAT	0x02
+#define NVREG_WAKEUPFLAGS_ACCEPT_LINKCHANGE	0x04
+
+	NvRegPatternCRC = 0x204,
+	NvRegPatternMask = 0x208,
+	NvRegPowerCap = 0x268,
+#define NVREG_POWERCAP_D3SUPP	(1<<30)
+#define NVREG_POWERCAP_D2SUPP	(1<<26)
+#define NVREG_POWERCAP_D1SUPP	(1<<25)
+	NvRegPowerState = 0x26c,
+#define NVREG_POWERSTATE_POWEREDUP	0x8000
+#define NVREG_POWERSTATE_VALID		0x0100
+#define NVREG_POWERSTATE_MASK		0x0003
+#define NVREG_POWERSTATE_D0		0x0000
+#define NVREG_POWERSTATE_D1		0x0001
+#define NVREG_POWERSTATE_D2		0x0002
+#define NVREG_POWERSTATE_D3		0x0003
+};
+
+
+
+#define NV_TX_LASTPACKET	(1<<0)
+#define NV_TX_RETRYERROR	(1<<3)
+#define NV_TX_LASTPACKET1	(1<<8)
+#define NV_TX_DEFERRED		(1<<10)
+#define NV_TX_CARRIERLOST	(1<<11)
+#define NV_TX_LATECOLLISION	(1<<12)
+#define NV_TX_UNDERFLOW		(1<<13)
+#define NV_TX_ERROR		(1<<14)
+#define NV_TX_VALID		(1<<15)
+
+#define NV_RX_DESCRIPTORVALID	(1<<0)
+#define NV_RX_MISSEDFRAME	(1<<1)
+#define NV_RX_SUBSTRACT1	(1<<3)
+#define NV_RX_ERROR1		(1<<7)
+#define NV_RX_ERROR2		(1<<8)
+#define NV_RX_ERROR3		(1<<9)
+#define NV_RX_ERROR4		(1<<10)
+#define NV_RX_CRCERR		(1<<11)
+#define NV_RX_OVERFLOW		(1<<12)
+#define NV_RX_FRAMINGERR	(1<<13)
+#define NV_RX_ERROR		(1<<14)
+#define NV_RX_AVAIL		(1<<15)
+
+/* Miscelaneous hardware related defines: */
+#define NV_PCI_REGSZ		0x270
+
+/* various timeout delays: all in usec */
+#define NV_TXRX_RESET_DELAY	4
+#define NV_TXSTOP_DELAY1	10
+#define NV_TXSTOP_DELAY1MAX	500000
+#define NV_TXSTOP_DELAY2	100
+#define NV_RXSTOP_DELAY1	10
+#define NV_RXSTOP_DELAY1MAX	500000
+#define NV_RXSTOP_DELAY2	100
+#define NV_SETUP5_DELAY		5
+#define NV_SETUP5_DELAYMAX	50000
+#define NV_POWERUP_DELAY	5
+#define NV_POWERUP_DELAYMAX	5000
+#define NV_MIIBUSY_DELAY	50
+#define NV_MIIPHY_DELAY	10
+#define NV_MIIPHY_DELAYMAX	10000
+
+#define NV_WAKEUPPATTERNS	5
+#define NV_WAKEUPMASKENTRIES	4
+
+/* General driver defaults */
+#define NV_WATCHDOG_TIMEO	(2*HZ)
+#define DEFAULT_MTU		1500	/* also maximum supported, at least for now */
+
+#define RX_RING		4
+#define TX_RING		2
+/* limited to 1 packet until we understand NV_TX_LASTPACKET */
+#define TX_LIMIT_STOP	10
+#define TX_LIMIT_START	5
+
+/* rx/tx mac addr + type + vlan + align + slack*/
+#define RX_NIC_BUFSIZE		(DEFAULT_MTU + 64)
+/* even more slack */
+#define RX_ALLOC_BUFSIZE	(DEFAULT_MTU + 128)
+
+#define OOM_REFILL	(1+HZ/20)
+#define POLL_WAIT	(1+HZ/100)
+
+struct ring_desc {
+	u32 PacketBuffer;
+	u16 Length;
+	u16 Flags;
+};
+
+
+/* Define the TX Descriptor */
+static struct ring_desc tx_ring[TX_RING];
+
+/* Create a static buffer of size RX_BUF_SZ for each
+TX Descriptor.  All descriptors point to a
+part of this buffer */
+static unsigned char txb[TX_RING * RX_NIC_BUFSIZE];
+
+/* Define the TX Descriptor */
+static struct ring_desc rx_ring[RX_RING];
+
+/* Create a static buffer of size RX_BUF_SZ for each
+RX Descriptor   All descriptors point to a
+part of this buffer */
+static unsigned char rxb[RX_RING * RX_NIC_BUFSIZE];
+
+/* Private Storage for the NIC */
+struct forcedeth_private {
+	/* General data:
+	 * Locking: spin_lock(&np->lock); */
+	int in_shutdown;
+	u32 linkspeed;
+	int duplex;
+	int phyaddr;
+
+	/* General data: RO fields */
+	u8 *ring_addr;
+	u32 orig_mac[2];
+	u32 irqmask;
+	/* rx specific fields.
+	 * Locking: Within irq hander or disable_irq+spin_lock(&np->lock);
+	 */
+	struct ring_desc *rx_ring;
+	unsigned int cur_rx, refill_rx;
+	struct sk_buff *rx_skbuff[RX_RING];
+	u32 rx_dma[RX_RING];
+	unsigned int rx_buf_sz;
+
+	/*
+	 * tx specific fields.
+	 */
+	struct ring_desc *tx_ring;
+	unsigned int next_tx, nic_tx;
+	struct sk_buff *tx_skbuff[TX_RING];
+	u32 tx_dma[TX_RING];
+	u16 tx_flags;
+} npx;
+
+static struct forcedeth_private *np;
+
+static inline void pci_push(u8 * base)
+{
+	/* force out pending posted writes */
+	readl(base);
+}
+static int reg_delay(int offset, u32 mask,
+		     u32 target, int delay, int delaymax, const char *msg)
+{
+	u8 *base = (u8 *) BASE;
+
+	pci_push(base);
+	do {
+		udelay(delay);
+		delaymax -= delay;
+		if (delaymax < 0) {
+			if (msg)
+				printf(msg);
+			return 1;
+		}
+	} while ((readl(base + offset) & mask) != target);
+	return 0;
+}
+
+#define MII_READ	(-1)
+#define MII_PHYSID1         0x02	/* PHYS ID 1                   */
+#define MII_PHYSID2         0x03	/* PHYS ID 2                   */
+#define MII_BMCR            0x00	/* Basic mode control register */
+#define MII_BMSR            0x01	/* Basic mode status register  */
+#define MII_ADVERTISE       0x04	/* Advertisement control reg   */
+#define MII_LPA             0x05	/* Link partner ability reg    */
+
+#define BMSR_ANEGCOMPLETE       0x0020	/* Auto-negotiation complete   */
+
+/* Link partner ability register. */
+#define LPA_SLCT                0x001f	/* Same as advertise selector  */
+#define LPA_10HALF              0x0020	/* Can do 10mbps half-duplex   */
+#define LPA_10FULL              0x0040	/* Can do 10mbps full-duplex   */
+#define LPA_100HALF             0x0080	/* Can do 100mbps half-duplex  */
+#define LPA_100FULL             0x0100	/* Can do 100mbps full-duplex  */
+#define LPA_100BASE4            0x0200	/* Can do 100mbps 4k packets   */
+#define LPA_RESV                0x1c00	/* Unused...                   */
+#define LPA_RFAULT              0x2000	/* Link partner faulted        */
+#define LPA_LPACK               0x4000	/* Link partner acked us       */
+#define LPA_NPAGE               0x8000	/* Next page bit               */
+
+/* mii_rw: read/write a register on the PHY.
+ *
+ * Caller must guarantee serialization
+ */
+static int mii_rw(struct nic *nic __unused, int addr, int miireg,
+		  int value)
+{
+	u8 *base = (u8 *) BASE;
+	int was_running;
+	u32 reg;
+	int retval;
+
+	writel(NVREG_MIISTAT_MASK, base + NvRegMIIStatus);
+	was_running = 0;
+	reg = readl(base + NvRegAdapterControl);
+	if (reg & NVREG_ADAPTCTL_RUNNING) {
+		was_running = 1;
+		writel(reg & ~NVREG_ADAPTCTL_RUNNING,
+		       base + NvRegAdapterControl);
+	}
+	reg = readl(base + NvRegMIIControl);
+	if (reg & NVREG_MIICTL_INUSE) {
+		writel(NVREG_MIICTL_INUSE, base + NvRegMIIControl);
+		udelay(NV_MIIBUSY_DELAY);
+	}
+
+	reg =
+	    NVREG_MIICTL_INUSE | (addr << NVREG_MIICTL_ADDRSHIFT) | miireg;
+	if (value != MII_READ) {
+		writel(value, base + NvRegMIIData);
+		reg |= NVREG_MIICTL_WRITE;
+	}
+	writel(reg, base + NvRegMIIControl);
+
+	if (reg_delay(NvRegMIIControl, NVREG_MIICTL_INUSE, 0,
+		      NV_MIIPHY_DELAY, NV_MIIPHY_DELAYMAX, NULL)) {
+		dprintf(("mii_rw of reg %d at PHY %d timed out.\n",
+			 miireg, addr));
+		retval = -1;
+	} else if (value != MII_READ) {
+		/* it was a write operation - fewer failures are detectable */
+		dprintf(("mii_rw wrote 0x%x to reg %d at PHY %d\n",
+			 value, miireg, addr));
+		retval = 0;
+	} else if (readl(base + NvRegMIIStatus) & NVREG_MIISTAT_ERROR) {
+		dprintf(("mii_rw of reg %d at PHY %d failed.\n",
+			 miireg, addr));
+		retval = -1;
+	} else {
+		/* FIXME: why is that required? */
+		udelay(50);
+		retval = readl(base + NvRegMIIData);
+		dprintf(("mii_rw read from reg %d at PHY %d: 0x%x.\n",
+			 miireg, addr, retval));
+	}
+	if (was_running) {
+		reg = readl(base + NvRegAdapterControl);
+		writel(reg | NVREG_ADAPTCTL_RUNNING,
+		       base + NvRegAdapterControl);
+	}
+	return retval;
+}
+
+static void start_rx(struct nic *nic __unused)
+{
+	u8 *base = (u8 *) BASE;
+
+	dprintf(("start_rx\n"));
+	/* Already running? Stop it. */
+	if (readl(base + NvRegReceiverControl) & NVREG_RCVCTL_START) {
+		writel(0, base + NvRegReceiverControl);
+		pci_push(base);
+	}
+	writel(np->linkspeed, base + NvRegLinkSpeed);
+	pci_push(base);
+	writel(NVREG_RCVCTL_START, base + NvRegReceiverControl);
+	pci_push(base);
+}
+
+static void stop_rx(void)
+{
+	u8 *base = (u8 *) BASE;
+
+	dprintf(("stop_rx\n"));
+	writel(0, base + NvRegReceiverControl);
+	reg_delay(NvRegReceiverStatus, NVREG_RCVSTAT_BUSY, 0,
+		  NV_RXSTOP_DELAY1, NV_RXSTOP_DELAY1MAX,
+		  "stop_rx: ReceiverStatus remained busy");
+
+	udelay(NV_RXSTOP_DELAY2);
+	writel(0, base + NvRegLinkSpeed);
+}
+
+static void start_tx(struct nic *nic __unused)
+{
+	u8 *base = (u8 *) BASE;
+
+	dprintf(("start_tx\n"));
+	writel(NVREG_XMITCTL_START, base + NvRegTransmitterControl);
+	pci_push(base);
+}
+
+static void stop_tx(void)
+{
+	u8 *base = (u8 *) BASE;
+
+	dprintf(("stop_tx\n"));
+	writel(0, base + NvRegTransmitterControl);
+	reg_delay(NvRegTransmitterStatus, NVREG_XMITSTAT_BUSY, 0,
+		  NV_TXSTOP_DELAY1, NV_TXSTOP_DELAY1MAX,
+		  "stop_tx: TransmitterStatus remained busy");
+
+	udelay(NV_TXSTOP_DELAY2);
+	writel(0, base + NvRegUnknownTransmitterReg);
+}
+
+
+static void txrx_reset(struct nic *nic __unused)
+{
+	u8 *base = (u8 *) BASE;
+
+	dprintf(("txrx_reset\n"));
+	writel(NVREG_TXRXCTL_BIT2 | NVREG_TXRXCTL_RESET,
+	       base + NvRegTxRxControl);
+	pci_push(base);
+	udelay(NV_TXRX_RESET_DELAY);
+	writel(NVREG_TXRXCTL_BIT2, base + NvRegTxRxControl);
+	pci_push(base);
+}
+
+/*
+ * alloc_rx: fill rx ring entries.
+ * Return 1 if the allocations for the skbs failed and the
+ * rx engine is without Available descriptors
+ */
+static int alloc_rx(struct nic *nic __unused)
+{
+	unsigned int refill_rx = np->refill_rx;
+	int i;
+	//while (np->cur_rx != refill_rx) {
+	for (i = 0; i < RX_RING; i++) {
+		//int nr = refill_rx % RX_RING;
+		rx_ring[i].PacketBuffer =
+		    virt_to_le32desc(&rxb[i * RX_NIC_BUFSIZE]);
+		rx_ring[i].Length = cpu_to_le16(RX_NIC_BUFSIZE);
+		wmb();
+		rx_ring[i].Flags = cpu_to_le16(NV_RX_AVAIL);
+		/*      printf("alloc_rx: Packet  %d marked as Available\n",
+		   refill_rx); */
+		refill_rx++;
+	}
+	np->refill_rx = refill_rx;
+	if (np->cur_rx - refill_rx == RX_RING)
+		return 1;
+	return 0;
+}
+
+static int update_linkspeed(struct nic *nic)
+{
+	int adv, lpa, newdup;
+	u32 newls;
+	adv = mii_rw(nic, np->phyaddr, MII_ADVERTISE, MII_READ);
+	lpa = mii_rw(nic, np->phyaddr, MII_LPA, MII_READ);
+	dprintf(("update_linkspeed: PHY advertises 0x%hX, lpa 0x%hX.\n",
+		 adv, lpa));
+
+	/* FIXME: handle parallel detection properly, handle gigabit ethernet */
+	lpa = lpa & adv;
+	if (lpa & LPA_100FULL) {
+		newls = NVREG_LINKSPEED_FORCE | NVREG_LINKSPEED_100;
+		newdup = 1;
+	} else if (lpa & LPA_100HALF) {
+		newls = NVREG_LINKSPEED_FORCE | NVREG_LINKSPEED_100;
+		newdup = 0;
+	} else if (lpa & LPA_10FULL) {
+		newls = NVREG_LINKSPEED_FORCE | NVREG_LINKSPEED_10;
+		newdup = 1;
+	} else if (lpa & LPA_10HALF) {
+		newls = NVREG_LINKSPEED_FORCE | NVREG_LINKSPEED_10;
+		newdup = 0;
+	} else {
+		printf("bad ability %hX - falling back to 10HD.\n", lpa);
+		newls = NVREG_LINKSPEED_FORCE | NVREG_LINKSPEED_10;
+		newdup = 0;
+	}
+	if (np->duplex != newdup || np->linkspeed != newls) {
+		np->duplex = newdup;
+		np->linkspeed = newls;
+		return 1;
+	}
+	return 0;
+}
+
+
+
+static int init_ring(struct nic *nic)
+{
+	int i;
+
+	np->next_tx = np->nic_tx = 0;
+	for (i = 0; i < TX_RING; i++) {
+		tx_ring[i].Flags = 0;
+	}
+
+	np->cur_rx = 0;
+	np->refill_rx = 0;
+	for (i = 0; i < RX_RING; i++) {
+		rx_ring[i].Flags = 0;
+	}
+	return alloc_rx(nic);
+}
+
+static void set_multicast(struct nic *nic)
+{
+
+	u8 *base = (u8 *) BASE;
+	u32 addr[2];
+	u32 mask[2];
+	u32 pff;
+	u32 alwaysOff[2];
+	u32 alwaysOn[2];
+
+	memset(addr, 0, sizeof(addr));
+	memset(mask, 0, sizeof(mask));
+
+	pff = NVREG_PFF_MYADDR;
+
+	alwaysOn[0] = alwaysOn[1] = alwaysOff[0] = alwaysOff[1] = 0;
+
+	addr[0] = alwaysOn[0];
+	addr[1] = alwaysOn[1];
+	mask[0] = alwaysOn[0] | alwaysOff[0];
+	mask[1] = alwaysOn[1] | alwaysOff[1];
+
+	addr[0] |= NVREG_MCASTADDRA_FORCE;
+	pff |= NVREG_PFF_ALWAYS;
+	stop_rx();
+	writel(addr[0], base + NvRegMulticastAddrA);
+	writel(addr[1], base + NvRegMulticastAddrB);
+	writel(mask[0], base + NvRegMulticastMaskA);
+	writel(mask[1], base + NvRegMulticastMaskB);
+	writel(pff, base + NvRegPacketFilterFlags);
+	start_rx(nic);
+}
+
+/**************************************************************************
+RESET - Reset the NIC to prepare for use
+***************************************************************************/
+static int forcedeth_reset(struct nic *nic)
+{
+	u8 *base = (u8 *) BASE;
+	int ret, oom, i;
+	ret = 0;
+	dprintf(("forcedeth: open\n"));
+
+	/* 1) erase previous misconfiguration */
+	/* 4.1-1: stop adapter: ignored, 4.3 seems to be overkill */
+	writel(NVREG_MCASTADDRA_FORCE, base + NvRegMulticastAddrA);
+	writel(0, base + NvRegMulticastAddrB);
+	writel(0, base + NvRegMulticastMaskA);
+	writel(0, base + NvRegMulticastMaskB);
+	writel(0, base + NvRegPacketFilterFlags);
+	writel(0, base + NvRegAdapterControl);
+	writel(0, base + NvRegLinkSpeed);
+	writel(0, base + NvRegUnknownTransmitterReg);
+	txrx_reset(nic);
+	writel(0, base + NvRegUnknownSetupReg6);
+
+	/* 2) initialize descriptor rings */
+	np->in_shutdown = 0;
+	oom = init_ring(nic);
+
+	/* 3) set mac address */
+	{
+		u32 mac[2];
+
+		mac[0] =
+		    (nic->node_addr[0] << 0) + (nic->node_addr[1] << 8) +
+		    (nic->node_addr[2] << 16) + (nic->node_addr[3] << 24);
+		mac[1] =
+		    (nic->node_addr[4] << 0) + (nic->node_addr[5] << 8);
+
+		writel(mac[0], base + NvRegMacAddrA);
+		writel(mac[1], base + NvRegMacAddrB);
+	}
+
+	/* 4) continue setup */
+	np->linkspeed = NVREG_LINKSPEED_FORCE | NVREG_LINKSPEED_10;
+	np->duplex = 0;
+	writel(NVREG_UNKSETUP3_VAL1, base + NvRegUnknownSetupReg3);
+	writel(0, base + NvRegTxRxControl);
+	pci_push(base);
+	writel(NVREG_TXRXCTL_BIT1, base + NvRegTxRxControl);
+
+	reg_delay(NvRegUnknownSetupReg5, NVREG_UNKSETUP5_BIT31,
+		  NVREG_UNKSETUP5_BIT31, NV_SETUP5_DELAY,
+		  NV_SETUP5_DELAYMAX,
+		  "open: SetupReg5, Bit 31 remained off\n");
+	writel(0, base + NvRegUnknownSetupReg4);
+
+	/* 5) Find a suitable PHY */
+	writel(NVREG_MIISPEED_BIT8 | NVREG_MIIDELAY, base + NvRegMIISpeed);
+	for (i = 1; i < 32; i++) {
+		int id1, id2;
+
+		id1 = mii_rw(nic, i, MII_PHYSID1, MII_READ);
+		if (id1 < 0)
+			continue;
+		id2 = mii_rw(nic, i, MII_PHYSID2, MII_READ);
+		if (id2 < 0)
+			continue;
+		dprintf(("open: Found PHY %04x:%04x at address %d.\n",
+			 id1, id2, i));
+		np->phyaddr = i;
+
+		update_linkspeed(nic);
+
+		break;
+	}
+	if (i == 32) {
+		printf("open: failing due to lack of suitable PHY.\n");
+		ret = -1;
+		goto out_drain;
+	}
+
+	printf("%d-Mbs Link, %s-Duplex\n",
+	       np->linkspeed & NVREG_LINKSPEED_10 ? 10 : 100,
+	       np->duplex ? "Full" : "Half");
+	/* 6) continue setup */
+	writel(NVREG_MISC1_FORCE | (np->duplex ? 0 : NVREG_MISC1_HD),
+	       base + NvRegMisc1);
+	writel(readl(base + NvRegTransmitterStatus),
+	       base + NvRegTransmitterStatus);
+	writel(NVREG_PFF_ALWAYS, base + NvRegPacketFilterFlags);
+	writel(NVREG_OFFLOAD_NORMAL, base + NvRegOffloadConfig);
+
+	writel(readl(base + NvRegReceiverStatus),
+	       base + NvRegReceiverStatus);
+
+	/* FIXME: I cheated and used the calculator to get a random number */
+	i = 75963081;
+	writel(NVREG_RNDSEED_FORCE | (i & NVREG_RNDSEED_MASK),
+	       base + NvRegRandomSeed);
+	writel(NVREG_UNKSETUP1_VAL, base + NvRegUnknownSetupReg1);
+	writel(NVREG_UNKSETUP2_VAL, base + NvRegUnknownSetupReg2);
+	writel(NVREG_POLL_DEFAULT, base + NvRegPollingInterval);
+	writel(NVREG_UNKSETUP6_VAL, base + NvRegUnknownSetupReg6);
+	writel((np->
+		phyaddr << NVREG_ADAPTCTL_PHYSHIFT) |
+	       NVREG_ADAPTCTL_PHYVALID, base + NvRegAdapterControl);
+	writel(NVREG_UNKSETUP4_VAL, base + NvRegUnknownSetupReg4);
+	writel(NVREG_WAKEUPFLAGS_VAL, base + NvRegWakeUpFlags);
+
+	/* 7) start packet processing */
+	writel((u32) virt_to_le32desc(&rx_ring[0]),
+	       base + NvRegRxRingPhysAddr);
+	writel((u32) virt_to_le32desc(&tx_ring[0]),
+	       base + NvRegTxRingPhysAddr);
+
+
+	writel(((RX_RING - 1) << NVREG_RINGSZ_RXSHIFT) +
+	       ((TX_RING - 1) << NVREG_RINGSZ_TXSHIFT),
+	       base + NvRegRingSizes);
+
+	i = readl(base + NvRegPowerState);
+	if ((i & NVREG_POWERSTATE_POWEREDUP) == 0) {
+		writel(NVREG_POWERSTATE_POWEREDUP | i,
+		       base + NvRegPowerState);
+	}
+	pci_push(base);
+	udelay(10);
+	writel(readl(base + NvRegPowerState) | NVREG_POWERSTATE_VALID,
+	       base + NvRegPowerState);
+	writel(NVREG_ADAPTCTL_RUNNING, base + NvRegAdapterControl);
+
+	writel(0, base + NvRegIrqMask);
+	pci_push(base);
+	writel(NVREG_IRQSTAT_MASK, base + NvRegIrqStatus);
+	pci_push(base);
+	writel(NVREG_MIISTAT_MASK2, base + NvRegMIIStatus);
+	writel(NVREG_IRQSTAT_MASK, base + NvRegIrqStatus);
+	pci_push(base);
+/*
+	writel(np->irqmask, base + NvRegIrqMask);
+*/
+	writel(NVREG_MCASTADDRA_FORCE, base + NvRegMulticastAddrA);
+	writel(0, base + NvRegMulticastAddrB);
+	writel(0, base + NvRegMulticastMaskA);
+	writel(0, base + NvRegMulticastMaskB);
+	writel(NVREG_PFF_ALWAYS | NVREG_PFF_MYADDR,
+	       base + NvRegPacketFilterFlags);
+
+	set_multicast(nic);
+	//start_rx(nic);
+	start_tx(nic);
+
+	if (!
+	    (mii_rw(nic, np->phyaddr, MII_BMSR, MII_READ) &
+	     BMSR_ANEGCOMPLETE)) {
+		printf("no link during initialization.\n");
+	}
+
+	udelay(10000);
+      out_drain:
+	return ret;
+}
+
+//extern void hex_dump(const char *data, const unsigned int len);
+
+/**************************************************************************
+POLL - Wait for a frame
+***************************************************************************/
+static int forcedeth_poll(struct nic *nic, int retrieve)
+{
+	/* return true if there's an ethernet packet ready to read */
+	/* nic->packet should contain data on return */
+	/* nic->packetlen should contain length of data */
+
+	struct ring_desc *prd;
+	int len;
+	int i;
+
+	i = np->cur_rx % RX_RING;
+	prd = &rx_ring[i];
+
+	if ( ! (prd->Flags & cpu_to_le16(NV_RX_DESCRIPTORVALID)) ) {
+	  return 0;
+	}
+
+	if ( ! retrieve ) return 1;
+
+	/* got a valid packet - forward it to the network core */
+	len = cpu_to_le16(prd->Length);
+	nic->packetlen = len;
+	//hex_dump(rxb + (i * RX_NIC_BUFSIZE), len);
+	memcpy(nic->packet, rxb +
+	       (i * RX_NIC_BUFSIZE), nic->packetlen);
+
+	wmb();
+	np->cur_rx++;
+	alloc_rx(nic);
+	return 1;
+}
+
+
+/**************************************************************************
+TRANSMIT - Transmit a frame
+***************************************************************************/
+static void forcedeth_transmit(struct nic *nic, const char *d,	/* Destination */
+			       unsigned int t,	/* Type */
+			       unsigned int s,	/* size */
+			       const char *p)
+{				/* Packet */
+	/* send the packet to destination */
+	u8 *ptxb;
+	u16 nstype;
+	//u16 status;
+	u8 *base = (u8 *) BASE;
+	int nr = np->next_tx % TX_RING;
+
+	/* point to the current txb incase multiple tx_rings are used */
+	ptxb = txb + (nr * RX_NIC_BUFSIZE);
+	//np->tx_skbuff[nr] = ptxb;
+
+	/* copy the packet to ring buffer */
+	memcpy(ptxb, d, ETH_ALEN);	/* dst */
+	memcpy(ptxb + ETH_ALEN, nic->node_addr, ETH_ALEN);	/* src */
+	nstype = htons((u16) t);	/* type */
+	memcpy(ptxb + 2 * ETH_ALEN, (u8 *) & nstype, 2);	/* type */
+	memcpy(ptxb + ETH_HLEN, p, s);
+
+	s += ETH_HLEN;
+	while (s < ETH_ZLEN)	/* pad to min length */
+		ptxb[s++] = '\0';
+
+	tx_ring[nr].PacketBuffer = (u32) virt_to_le32desc(ptxb);
+	tx_ring[nr].Length = cpu_to_le16(s - 1);
+
+	wmb();
+	tx_ring[nr].Flags = np->tx_flags;
+
+	writel(NVREG_TXRXCTL_KICK, base + NvRegTxRxControl);
+	pci_push(base);
+	tx_ring[nr].Flags = np->tx_flags;
+	np->next_tx++;
+}
+
+/**************************************************************************
+DISABLE - Turn off ethernet interface
+***************************************************************************/
+static void forcedeth_disable(struct dev *dev __unused)
+{
+	/* put the card in its initial state */
+	/* This function serves 3 purposes.
+	 * This disables DMA and interrupts so we don't receive
+	 *  unexpected packets or interrupts from the card after
+	 *  etherboot has finished. 
+	 * This frees resources so etherboot may use
+	 *  this driver on another interface
+	 * This allows etherboot to reinitialize the interface
+	 *  if something is something goes wrong.
+	 */
+	u8 *base = (u8 *) BASE;
+	np->in_shutdown = 1;
+	stop_tx();
+	stop_rx();
+
+	/* disable interrupts on the nic or we will lock up */
+	writel(0, base + NvRegIrqMask);
+	pci_push(base);
+	dprintf(("Irqmask is zero again\n"));
+
+	/* specia op:o write back the misordered MAC address - otherwise
+	 * the next probe_nic would see a wrong address.
+	 */
+	writel(np->orig_mac[0], base + NvRegMacAddrA);
+	writel(np->orig_mac[1], base + NvRegMacAddrB);
+}
+
+/**************************************************************************
+IRQ - Enable, Disable, or Force interrupts
+***************************************************************************/
+static void forcedeth_irq(struct nic *nic __unused, irq_action_t action __unused)
+{
+  switch ( action ) {
+  case DISABLE :
+    break;
+  case ENABLE :
+    break;
+  case FORCE :
+    break;
+  }
+}
+
+/**************************************************************************
+PROBE - Look for an adapter, this routine's visible to the outside
+***************************************************************************/
+#define IORESOURCE_MEM 0x00000200
+#define board_found 1
+#define valid_link 0
+static int forcedeth_probe(struct dev *dev, struct pci_device *pci)
+{
+	struct nic *nic = (struct nic *) dev;
+	unsigned long addr;
+	int sz;
+	u8 *base;
+
+	if (pci->ioaddr == 0)
+		return 0;
+
+	printf("forcedeth.c: Found %s, vendor=0x%hX, device=0x%hX\n",
+	       pci->name, pci->vendor, pci->dev_id);
+
+	nic->irqno  = 0;
+	nic->ioaddr = pci->ioaddr & ~3;
+
+	/* point to private storage */
+	np = &npx;
+
+	adjust_pci_device(pci);
+
+	addr = pci_bar_start(pci, PCI_BASE_ADDRESS_0);
+	sz = pci_bar_size(pci, PCI_BASE_ADDRESS_0);
+
+	/* BASE is used throughout to address the card */
+	BASE = (unsigned long) ioremap(addr, sz);
+	if (!BASE)
+		return 0;
+	//rx_ring[0] = rx_ring;
+	//tx_ring[0] = tx_ring; 
+
+	/* read the mac address */
+	base = (u8 *) BASE;
+	np->orig_mac[0] = readl(base + NvRegMacAddrA);
+	np->orig_mac[1] = readl(base + NvRegMacAddrB);
+
+	nic->node_addr[0] = (np->orig_mac[1] >> 8) & 0xff;
+	nic->node_addr[1] = (np->orig_mac[1] >> 0) & 0xff;
+	nic->node_addr[2] = (np->orig_mac[0] >> 24) & 0xff;
+	nic->node_addr[3] = (np->orig_mac[0] >> 16) & 0xff;
+	nic->node_addr[4] = (np->orig_mac[0] >> 8) & 0xff;
+	nic->node_addr[5] = (np->orig_mac[0] >> 0) & 0xff;
+#ifdef LINUX
+	if (!is_valid_ether_addr(dev->dev_addr)) {
+		/*
+		 * Bad mac address. At least one bios sets the mac address
+		 * to 01:23:45:67:89:ab
+		 */
+		printk(KERN_ERR
+		       "%s: Invalid Mac address detected: %02x:%02x:%02x:%02x:%02x:%02x\n",
+		       pci_name(pci_dev), dev->dev_addr[0],
+		       dev->dev_addr[1], dev->dev_addr[2],
+		       dev->dev_addr[3], dev->dev_addr[4],
+		       dev->dev_addr[5]);
+		printk(KERN_ERR
+		       "Please complain to your hardware vendor. Switching to a random MAC.\n");
+		dev->dev_addr[0] = 0x00;
+		dev->dev_addr[1] = 0x00;
+		dev->dev_addr[2] = 0x6c;
+		get_random_bytes(&dev->dev_addr[3], 3);
+	}
+#endif
+	printf("%s: MAC Address %!, ", pci->name, nic->node_addr);
+
+	np->tx_flags =
+	    cpu_to_le16(NV_TX_LASTPACKET | NV_TX_LASTPACKET1 |
+			NV_TX_VALID);
+	switch (pci->dev_id) {
+	case 0x01C3:		// nforce
+		np->irqmask = NVREG_IRQMASK_WANTED_2;
+		np->irqmask |= NVREG_IRQ_TIMER;
+		break;
+	case 0x0066:		// nforce2
+		np->tx_flags |= cpu_to_le16(NV_TX_LASTPACKET1);
+		np->irqmask = NVREG_IRQMASK_WANTED_2;
+		np->irqmask |= NVREG_IRQ_TIMER;
+		break;
+	case 0x00D6:		// nforce3
+		np->tx_flags |= cpu_to_le16(NV_TX_LASTPACKET1);
+		np->irqmask = NVREG_IRQMASK_WANTED_2;
+		np->irqmask |= NVREG_IRQ_TIMER;
+
+	}
+	dprintf(("%s: forcedeth.c: subsystem: %hX:%hX bound to %s\n",
+		 pci->name, pci->vendor, pci->dev_id, pci->name));
+
+	forcedeth_reset(nic);
+//      if (board_found && valid_link)
+	/* point to NIC specific routines */
+	dev->disable = forcedeth_disable;
+	nic->poll = forcedeth_poll;
+	nic->transmit = forcedeth_transmit;
+	nic->irq    = forcedeth_irq;
+	return 1;
+//      }
+	/* else */
+}
+
+static struct pci_id forcedeth_nics[] = {
+	PCI_ROM(0x10de, 0x01C3, "nforce", "nForce Ethernet Controller"),
+	PCI_ROM(0x10de, 0x0066, "nforce2", "nForce2 Ethernet Controller"),
+	PCI_ROM(0x10de, 0x00D6, "nforce3", "nForce3 Ethernet Controller"),
+};
+
+struct pci_driver forcedeth_driver = {
+	.type = NIC_DRIVER,
+	.name = "forcedeth",
+	.probe = forcedeth_probe,
+	.ids = forcedeth_nics,
+	.id_count = sizeof(forcedeth_nics) / sizeof(forcedeth_nics[0]),
+	.class = 0,
+};
diff -Naur grub-0.97.orig/netboot/fsys_tftp.c grub-0.97/netboot/fsys_tftp.c
--- grub-0.97.orig/netboot/fsys_tftp.c	2004-04-15 11:38:40.000000000 +0000
+++ grub-0.97/netboot/fsys_tftp.c	2005-08-31 19:03:35.000000000 +0000
@@ -29,14 +29,15 @@
 /* #define TFTP_DEBUG	1 */
 
 #include <filesys.h>
+#include <shared.h>
 
-#define GRUB	1
-#include <etherboot.h>
-#include <nic.h>
+#include "grub.h"
+#include "tftp.h"
+#include "nic.h"
 
 static int retry;
 static unsigned short iport = 2000;
-static unsigned short oport;
+static unsigned short oport = 0;
 static unsigned short block, prevblock;
 static int bcounter;
 static struct tftp_t tp, saved_tp;
@@ -46,6 +47,172 @@
 static unsigned short len, saved_len;
 static char *buf;
 
+/**
+ * tftp_read
+ *
+ * Read file with _name_, data handled by _fnc_. In fact, grub never
+ * use it, we just use it to read dhcp config file.
+ */
+static int await_tftp(int ival, void *ptr __unused, 
+		      unsigned short ptype __unused, struct iphdr *ip, 
+		      struct udphdr *udp)
+{
+	if (!udp) {
+		return 0;
+	}
+	if (arptable[ARP_CLIENT].ipaddr.s_addr != ip->dest.s_addr)
+		return 0;
+	if (ntohs(udp->dest) != ival)
+		return 0;
+	return 1;
+}
+
+int tftp_file_read(const char *name, int (*fnc)(unsigned char *, unsigned int, unsigned int, int))
+{
+	struct tftpreq_t tp;
+	struct tftp_t  *tr;
+	int		rc;
+
+	retry = 0;
+	block = 0;
+	prevblock = 0;
+	bcounter = 0;
+	
+
+	rx_qdrain();
+
+	tp.opcode = htons(TFTP_RRQ);
+	/* Warning: the following assumes the layout of bootp_t.
+	   But that's fixed by the IP, UDP and BOOTP specs. */
+	len = sizeof(tp.ip) + sizeof(tp.udp) + sizeof(tp.opcode) +
+		sprintf((char *)tp.u.rrq, "%s%coctet%cblksize%c%d",
+		name, 0, 0, 0, TFTP_MAX_PACKET) + 1;
+	if (!udp_transmit(arptable[ARP_SERVER].ipaddr.s_addr, ++iport,
+			  TFTP_PORT, len, &tp))
+		return (0);
+	for (;;)
+	{
+		long timeout;
+#ifdef	CONGESTED
+		timeout = rfc2131_sleep_interval(block?TFTP_REXMT: TIMEOUT, retry);
+#else
+		timeout = rfc2131_sleep_interval(TIMEOUT, retry);
+#endif
+		if (!await_reply(await_tftp, iport, NULL, timeout))
+		{
+			if (!block && retry++ < MAX_TFTP_RETRIES)
+			{	/* maybe initial request was lost */
+				if (!udp_transmit(arptable[ARP_SERVER].ipaddr.s_addr,
+						  ++iport, TFTP_PORT, len, &tp))
+					return (0);
+				continue;
+			}
+#ifdef	CONGESTED
+			if (block && ((retry += TFTP_REXMT) < TFTP_TIMEOUT))
+			{	/* we resend our last ack */
+#ifdef	MDEBUG
+				printf("<REXMT>\n");
+#endif
+				udp_transmit(arptable[ARP_SERVER].ipaddr.s_addr,
+					     iport, oport,
+					     TFTP_MIN_PACKET, &tp);
+				continue;
+			}
+#endif
+			break;	/* timeout */
+		}
+		tr = (struct tftp_t *)&nic.packet[ETH_HLEN];
+		if (tr->opcode == ntohs(TFTP_ERROR))
+		{
+			printf("TFTP error %d (%s)\n",
+			       ntohs(tr->u.err.errcode),
+			       tr->u.err.errmsg);
+			break;
+		}
+
+		if (tr->opcode == ntohs(TFTP_OACK)) {
+			char *p = tr->u.oack.data, *e;
+
+			if (prevblock)		/* shouldn't happen */
+				continue;	/* ignore it */
+			len = ntohs(tr->udp.len) - sizeof(struct udphdr) - 2;
+			if (len > TFTP_MAX_PACKET)
+				goto noak;
+			e = p + len;
+			while (*p != '\0' && p < e) {
+/* 				if (!strcasecmp("blksize", p)) { */
+				if (!grub_strcmp("blksize", p)) {
+					p += 8;
+/* 					if ((packetsize = strtoul(p, &p, 10)) < */
+					if ((packetsize = getdec(&p)) < TFTP_DEFAULTSIZE_PACKET)
+						goto noak;
+					while (p < e && *p) p++;
+					if (p < e)
+						p++;
+				}
+				else {
+				noak:
+					tp.opcode = htons(TFTP_ERROR);
+					tp.u.err.errcode = 8;
+/*
+ *	Warning: the following assumes the layout of bootp_t.
+ *	But that's fixed by the IP, UDP and BOOTP specs.
+ */
+					len = sizeof(tp.ip) + sizeof(tp.udp) + sizeof(tp.opcode) + sizeof(tp.u.err.errcode) +
+/*
+ *	Normally bad form to omit the format string, but in this case
+ *	the string we are copying from is fixed. sprintf is just being
+ *	used as a strcpy and strlen.
+ */
+						sprintf((char *)tp.u.err.errmsg,
+						"RFC1782 error") + 1;
+					udp_transmit(arptable[ARP_SERVER].ipaddr.s_addr,
+						     iport, ntohs(tr->udp.src),
+						     len, &tp);
+					return (0);
+				}
+			}
+			if (p > e)
+				goto noak;
+			block = tp.u.ack.block = 0; /* this ensures, that */
+						/* the packet does not get */
+						/* processed as data! */
+		}
+		else if (tr->opcode == htons(TFTP_DATA)) {
+			len = ntohs(tr->udp.len) - sizeof(struct udphdr) - 4;
+			if (len > packetsize)	/* shouldn't happen */
+				continue;	/* ignore it */
+			block = ntohs(tp.u.ack.block = tr->u.data.block); }
+		else {/* neither TFTP_OACK nor TFTP_DATA */
+			break;
+		}
+
+		if ((block || bcounter) && (block != (unsigned short)(prevblock+1))) {
+			/* Block order should be continuous */
+			tp.u.ack.block = htons(block = prevblock);
+		}
+		tp.opcode = htons(TFTP_ACK);
+		oport = ntohs(tr->udp.src);
+		udp_transmit(arptable[ARP_SERVER].ipaddr.s_addr, iport,
+			     oport, TFTP_MIN_PACKET, &tp);	/* ack */
+		if ((unsigned short)(block-prevblock) != 1) {
+			/* Retransmission or OACK, don't process via callback
+			 * and don't change the value of prevblock.  */
+			continue;
+		}
+		prevblock = block;
+		retry = 0;	/* It's the right place to zero the timer? */
+		if ((rc = fnc(tr->u.data.download,
+			      ++bcounter, len, len < packetsize)) <= 0)
+			return(rc);
+		if (len < packetsize) {	/* End of data --- fnc should not have returned */
+			printf("tftp download complete, but\n");
+			return (1);
+		}
+	}
+	return (0);
+}
+
 /* Fill the buffer by receiving the data via the TFTP protocol.  */
 static int
 buf_fill (int abort)
@@ -65,9 +232,9 @@
       timeout = rfc2131_sleep_interval (TIMEOUT, retry);
 #endif
   
-      if (! await_reply (AWAIT_TFTP, iport, NULL, timeout))
+      if (! await_reply (await_tftp, iport, NULL, timeout))
 	{
-	  if (ip_abort)
+	  if (user_abort)
 	    return 0;
 
 	  if (! block && retry++ < MAX_TFTP_RETRIES)
@@ -270,13 +437,7 @@
   buf_read = 0;
   saved_filepos = 0;
 
-  /* Clear out the Rx queue first.  It contains nothing of interest,
-   * except possibly ARP requests from the DHCP/TFTP server.  We use
-   * polling throughout Etherboot, so some time may have passed since we
-   * last polled the receive queue, which may now be filled with
-   * broadcast packets.  This will cause the reply to the packets we are
-   * about to send to be lost immediately.  Not very clever.  */
-  await_reply (AWAIT_QDRAIN, 0, NULL, 0);
+  rx_qdrain();
   
 #ifdef TFTP_DEBUG
   grub_printf ("send_rrq ()\n");
diff -Naur grub-0.97.orig/netboot/grub.h grub-0.97/netboot/grub.h
--- grub-0.97.orig/netboot/grub.h	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/grub.h	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,171 @@
+#ifndef GRUB_H
+#define GRUB_H
+
+#include "osdep.h"
+#include "byteswap.h"
+#include "in.h"
+#include "ip.h"
+#include "udp.h"
+#include "if_ether.h"
+#include "latch.h"
+#include "io.h"
+#include "nic.h"
+#include <shared.h>
+
+#define K_ESC		'\033'
+#define K_EOF		'\04'  /* Ctrl-D */
+#define K_INTR		'\03'  /* Ctrl-C */
+
+#ifndef	MAX_RPC_RETRIES
+#define MAX_RPC_RETRIES		20
+#endif
+
+
+/* Inter-packet retry in ticks */
+#ifndef TIMEOUT
+#define TIMEOUT			(10*TICKS_PER_SEC)
+#endif
+
+#ifndef	NULL
+#define NULL	((void *)0)
+#endif
+
+
+#define ARP_CLIENT	0
+#define ARP_SERVER	1
+#define ARP_GATEWAY	2
+#define MAX_ARP		ARP_GATEWAY+1
+
+#define IGMP_SERVER	0
+#define MAX_IGMP	IGMP_SERVER+1
+
+#define	RARP_REQUEST	3
+#define	RARP_REPLY	4
+
+
+#define MULTICAST_MASK    0xF0000000
+#define MULTICAST_NETWORK 0xE0000000
+
+struct arptable_t {
+	in_addr ipaddr;
+	uint8_t node[6];
+};
+
+struct igmptable_t {
+	in_addr group;
+	unsigned long time;
+};
+
+#define	KERNEL_BUF	(BOOTP_DATA_ADDR->bootp_reply.bp_file)
+
+#define	FLOPPY_BOOT_LOCATION	0x7c00
+/* Must match offsets in loader.S */
+#define ROM_SEGMENT		0x1fa
+#define ROM_LENGTH		0x1fc
+
+#define	ROM_INFO_LOCATION	(FLOPPY_BOOT_LOCATION+ROM_SEGMENT)
+/* at end of floppy boot block */
+
+
+
+/* Define a type for passing info to a loaded program */
+struct ebinfo {
+	uint8_t  major, minor;	/* Version */
+	uint16_t flags;		/* Bit flags */
+};
+
+/***************************************************************************
+External prototypes
+***************************************************************************/
+extern void rx_qdrain P((void));
+extern int tftp P((const char *name, int (*)(unsigned char *, unsigned int, unsigned int, int)));
+extern int ip_transmit P((int len, const void *buf));
+extern void build_ip_hdr P((unsigned long destip, int ttl, int protocol, 
+	int option_len, int len, const void *buf));
+extern void build_udp_hdr P((unsigned long destip, 
+	unsigned int srcsock, unsigned int destsock, int ttl,
+	int len, const void *buf));
+extern int udp_transmit P((unsigned long destip, unsigned int srcsock,
+	unsigned int destsock, int len, const void *buf));
+typedef int (*reply_t)(int ival, void *ptr, unsigned short ptype, struct iphdr *ip, struct udphdr *udp);
+extern int await_reply P((reply_t reply,	int ival, void *ptr, long timeout));
+extern int decode_rfc1533 P((unsigned char *, unsigned int, unsigned int, int));
+extern void join_group(int slot, unsigned long group);
+extern void leave_group(int slot);
+#define RAND_MAX 2147483647L
+extern uint16_t ipchksum P((const void *ip, unsigned long len));
+extern uint16_t add_ipchksums P((unsigned long offset, uint16_t sum, uint16_t new));
+extern int32_t random P((void));
+extern long rfc2131_sleep_interval P((long base, int exp));
+extern long rfc1112_sleep_interval P((long base, int exp));
+#ifndef DOWNLOAD_PROTO_TFTP
+#define	tftp(fname, load_block) 0
+#endif
+extern void cleanup P((void));
+
+/* misc.c */
+extern void twiddle P((void));
+extern void sleep P((int secs));
+extern void interruptible_sleep P((int secs));
+extern void poll_interruptions P((void));
+extern int strcasecmp P((const char *a, const char *b));
+extern char *substr P((const char *a, const char *b));
+extern unsigned long strtoul P((const char *p, const char **, int base));
+extern void printf P((const char *, ...));
+extern int sprintf P((char *, const char *, ...));
+extern int inet_aton P((char *p, in_addr *i));
+extern void putchar P((int));
+extern int getchar P((void));
+extern int iskey P((void));
+
+extern void grub_printf(const char *, ...);
+extern char config_file[128];
+extern void etherboot_printf(const char *,  ...);
+extern int etherboot_sprintf(char *, const char *, ...);
+extern int getdec(char **s);
+extern void cleanup_net(void);
+extern void print_network_configuration (void);
+extern int ifconfig (char *, char *, char *, char *);
+extern struct arptable_t arptable[MAX_ARP];
+
+#undef printf
+#undef sprintf
+#define printf etherboot_printf
+#define sprintf etherboot_sprintf
+
+#ifdef DEBUG
+#define EnterFunction(func) printf("Enter: " func "\n");
+#define LeaveFunction(func) printf("Leave: " func "\n");
+#else
+#define EnterFunction(func)
+#define LeaveFunction(func)
+#endif
+
+/*
+ * Some codes from etherboot use a level in DEBUG. Define it to be
+ * zero means no debug info output, that will make them silence in
+ * compiling. Up it as you want.
+ */
+#ifndef DEBUG
+#  define DEBUG 0
+#endif
+
+/*#define RPC_DEBUG*/
+
+extern char *hostname;
+
+extern int hostnamelen;
+/* Whether network is ready */
+extern int network_ready;
+
+/* User aborted in await_reply if not zero */
+extern int user_abort;
+
+extern int rarp(void);
+extern int grub_eth_probe(void);
+extern int bootp(void);
+
+extern int dhcp(void);
+
+extern struct nic nic;
+#endif /* GRUB_H */
diff -Naur grub-0.97.orig/netboot/i386_byteswap.h grub-0.97/netboot/i386_byteswap.h
--- grub-0.97.orig/netboot/i386_byteswap.h	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/i386_byteswap.h	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,46 @@
+#ifndef ETHERBOOT_BITS_BYTESWAP_H
+#define ETHERBOOT_BITS_BYTESWAP_H
+
+#include "types.h"
+static inline uint16_t __i386_bswap_16(uint16_t x)
+{
+	__asm__("xchgb %b0,%h0\n\t"
+		: "=q" (x)
+		: "0" (x));
+	return x;
+}
+
+static inline uint32_t __i386_bswap_32(uint32_t x)
+{
+	__asm__("xchgb %b0,%h0\n\t"
+		"rorl $16,%0\n\t"
+		"xchgb %b0,%h0"
+		: "=q" (x)
+		: "0" (x));
+	return x;
+}
+
+
+#define __bswap_constant_16(x) \
+	((uint16_t)((((uint16_t)(x) & 0x00ff) << 8) | \
+		(((uint16_t)(x) & 0xff00) >> 8)))
+
+#define __bswap_constant_32(x) \
+	((uint32_t)((((uint32_t)(x) & 0x000000ffU) << 24) | \
+		(((uint32_t)(x) & 0x0000ff00U) <<  8) | \
+		(((uint32_t)(x) & 0x00ff0000U) >>  8) | \
+		(((uint32_t)(x) & 0xff000000U) >> 24)))
+
+#define __bswap_16(x) \
+	(__builtin_constant_p(x) ? \
+	__bswap_constant_16(x) : \
+	__i386_bswap_16(x))
+
+
+#define __bswap_32(x) \
+	(__builtin_constant_p(x) ? \
+	__bswap_constant_32(x) : \
+	__i386_bswap_32(x))
+
+
+#endif /* ETHERBOOT_BITS_BYTESWAP_H */
diff -Naur grub-0.97.orig/netboot/i386_elf.h grub-0.97/netboot/i386_elf.h
--- grub-0.97.orig/netboot/i386_elf.h	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/i386_elf.h	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,91 @@
+#ifndef I386_BITS_ELF_H
+#define I386_BITS_ELF_H
+
+#include "cpu.h"
+
+#ifdef CONFIG_X86_64
+/* ELF Defines for the 64bit version of the current architecture */
+#define EM_CURRENT_64	EM_X86_64
+#define EM_CURRENT_64_PRESENT ( \
+	CPU_FEATURE_P(cpu_info.x86_capability, LM) && \
+	CPU_FEATURE_P(cpu_info.x86_capability, PAE) && \
+	CPU_FEATURE_P(cpu_info.x86_capability, PSE))
+			
+#define ELF_CHECK_X86_64_ARCH(x) \
+	(EM_CURRENT_64_PRESENT && ((x).e_machine == EM_X86_64))
+#define __unused_i386
+#else
+#define ELF_CHECK_X86_64_ARCH(x) 0
+#define __unused_i386 __unused
+#endif
+
+
+/* ELF Defines for the current architecture */
+#define	EM_CURRENT	EM_386
+#define ELFDATA_CURRENT	ELFDATA2LSB
+
+#define ELF_CHECK_I386_ARCH(x) \
+	(((x).e_machine == EM_386) || ((x).e_machine == EM_486))
+
+#define ELF_CHECK_ARCH(x) \
+	((ELF_CHECK_I386_ARCH(x) || ELF_CHECK_X86_64_ARCH(x)) && \
+		((x).e_entry <= 0xffffffffUL))
+
+#ifdef  IMAGE_FREEBSD
+/*
+ * FreeBSD has this rather strange "feature" of its design.
+ * At some point in its evolution, FreeBSD started to rely
+ * externally on private/static/debug internal symbol information.
+ * That is, some of the interfaces that software uses to access
+ * and work with the FreeBSD kernel are made available not
+ * via the shared library symbol information (the .DYNAMIC section)
+ * but rather the debug symbols.  This means that any symbol, not
+ * just publicly defined symbols can be (and are) used by system
+ * tools to make the system work.  (such as top, swapinfo, swapon,
+ * etc)
+ *
+ * Even worse, however, is the fact that standard ELF loaders do
+ * not know how to load the symbols since they are not within
+ * an ELF PT_LOAD section.  The kernel needs these symbols to
+ * operate so the following changes/additions to the boot
+ * loading of EtherBoot have been made to get the kernel to load.
+ * All of the changes are within IMAGE_FREEBSD such that the
+ * extra/changed code only compiles when FREEBSD support is
+ * enabled.
+ */
+
+/*
+ * Section header for FreeBSD (debug symbol kludge!) support
+ */
+typedef struct {
+	Elf32_Word	sh_name;	/* Section name (index into the
+					   section header string table). */
+	Elf32_Word	sh_type;	/* Section type. */
+	Elf32_Word	sh_flags;	/* Section flags. */
+	Elf32_Addr	sh_addr;	/* Address in memory image. */
+	Elf32_Off	sh_offset;	/* Offset in file. */
+	Elf32_Size	sh_size;	/* Size in bytes. */
+	Elf32_Word	sh_link;	/* Index of a related section. */
+	Elf32_Word	sh_info;	/* Depends on section type. */
+	Elf32_Size	sh_addralign;	/* Alignment in bytes. */
+	Elf32_Size	sh_entsize;	/* Size of each entry in section. */
+} Elf32_Shdr;
+
+/* sh_type */
+#define SHT_SYMTAB	2		/* symbol table section */
+#define SHT_STRTAB	3		/* string table section */
+
+/*
+ * Module information subtypes (for the metadata that we need to build)
+ */
+#define MODINFO_END		0x0000		/* End of list */
+#define MODINFO_NAME		0x0001		/* Name of module (string) */
+#define MODINFO_TYPE		0x0002		/* Type of module (string) */
+#define MODINFO_METADATA	0x8000		/* Module-specfic */
+
+#define MODINFOMD_SSYM		0x0003		/* start of symbols */
+#define MODINFOMD_ESYM		0x0004		/* end of symbols */
+
+#endif	/* IMAGE_FREEBSD */
+
+#endif /* I386_BITS_ELF_H */
diff -Naur grub-0.97.orig/netboot/i386_endian.h grub-0.97/netboot/i386_endian.h
--- grub-0.97.orig/netboot/i386_endian.h	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/i386_endian.h	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,6 @@
+#ifndef ETHERBOOT_BITS_ENDIAN_H
+#define ETHERBOOT_BITS_ENDIAN_H
+
+#define __BYTE_ORDER __LITTLE_ENDIAN
+
+#endif /* ETHERBOOT_BITS_ENDIAN_H */
diff -Naur grub-0.97.orig/netboot/i386_timer.c grub-0.97/netboot/i386_timer.c
--- grub-0.97.orig/netboot/i386_timer.c	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/i386_timer.c	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,192 @@
+/* A couple of routines to implement a low-overhead timer for drivers */
+
+ /*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2, or (at
+ * your option) any later version.
+ */
+#include "grub.h"
+#include "osdep.h"
+#include "io.h"
+#include "timer.h"
+#include "latch.h"
+
+void __load_timer2(unsigned int ticks)
+{
+	/*
+	 * Now let's take care of PPC channel 2
+	 *
+	 * Set the Gate high, program PPC channel 2 for mode 0,
+	 * (interrupt on terminal count mode), binary count,
+	 * load 5 * LATCH count, (LSB and MSB) to begin countdown.
+	 *
+	 * Note some implementations have a bug where the high bits byte
+	 * of channel 2 is ignored.
+	 */
+	/* Set up the timer gate, turn off the speaker */
+	/* Set the Gate high, disable speaker */
+	outb((inb(PPC_PORTB) & ~PPCB_SPKR) | PPCB_T2GATE, PPC_PORTB);
+	/* binary, mode 0, LSB/MSB, Ch 2 */
+	outb(TIMER2_SEL|WORD_ACCESS|MODE0|BINARY_COUNT, TIMER_MODE_PORT);
+	/* LSB of ticks */
+	outb(ticks & 0xFF, TIMER2_PORT);
+	/* MSB of ticks */
+	outb(ticks >> 8, TIMER2_PORT);
+}
+
+static int __timer2_running(void)
+{
+	return ((inb(PPC_PORTB) & PPCB_T2OUT) == 0);
+}
+
+#if !defined(CONFIG_TSC_CURRTICKS)
+void setup_timers(void)
+{
+	return;
+}
+
+void load_timer2(unsigned int ticks)
+{
+	return __load_timer2(ticks);
+}
+
+int timer2_running(void)
+{
+	return __timer2_running();
+}
+
+void ndelay(unsigned int nsecs)
+{
+	waiton_timer2((nsecs * CLOCK_TICK_RATE)/1000000000);
+}
+void udelay(unsigned int usecs)
+{
+	waiton_timer2((usecs * TICKS_PER_MS)/1000);
+}
+#endif /* !defined(CONFIG_TSC_CURRTICKS) */
+
+#if defined(CONFIG_TSC_CURRTICKS)
+
+#define rdtsc(low,high) \
+     __asm__ __volatile__("rdtsc" : "=a" (low), "=d" (high))
+
+#define rdtscll(val) \
+     __asm__ __volatile__ ("rdtsc" : "=A" (val))
+
+
+/* Number of clock ticks to time with the rtc */
+#define LATCH 0xFF
+
+#define LATCHES_PER_SEC ((CLOCK_TICK_RATE + (LATCH/2))/LATCH)
+#define TICKS_PER_LATCH ((LATCHES_PER_SEC + (TICKS_PER_SEC/2))/TICKS_PER_SEC)
+
+static void sleep_latch(void)
+{
+	__load_timer2(LATCH);
+	while(__timer2_running());
+}
+
+/* ------ Calibrate the TSC ------- 
+ * Time how long it takes to excute a loop that runs in known time.
+ * And find the convertion needed to get to CLOCK_TICK_RATE
+ */
+
+
+static unsigned long long calibrate_tsc(void)
+{
+	unsigned long startlow, starthigh;
+	unsigned long endlow, endhigh;
+	
+	rdtsc(startlow,starthigh);
+	sleep_latch();
+	rdtsc(endlow,endhigh);
+
+	/* 64-bit subtract - gcc just messes up with long longs */
+	__asm__("subl %2,%0\n\t"
+		"sbbl %3,%1"
+		:"=a" (endlow), "=d" (endhigh)
+		:"g" (startlow), "g" (starthigh),
+		"0" (endlow), "1" (endhigh));
+	
+	/* Error: ECPUTOOFAST */
+	if (endhigh)
+		goto bad_ctc;
+	
+	endlow *= TICKS_PER_LATCH;
+	return endlow;
+
+	/*
+	 * The CTC wasn't reliable: we got a hit on the very first read,
+	 * or the CPU was so fast/slow that the quotient wouldn't fit in
+	 * 32 bits..
+	 */
+bad_ctc:
+	printf("bad_ctc\n");
+	return 0;
+}
+
+static unsigned long clocks_per_tick;
+void setup_timers(void)
+{
+	if (!clocks_per_tick) {
+		clocks_per_tick = calibrate_tsc();
+		/* Display the CPU Mhz to easily test if the calibration was bad */
+		printf("CPU %ld Mhz\n", (clocks_per_tick/1000 * TICKS_PER_SEC)/1000);
+	}
+}
+
+unsigned long currticks(void)
+{
+	unsigned long clocks_high, clocks_low;
+	unsigned long currticks;
+	/* Read the Time Stamp Counter */
+	rdtsc(clocks_low, clocks_high);
+
+	/* currticks = clocks / clocks_per_tick; */
+	__asm__("divl %1"
+		:"=a" (currticks)
+		:"r" (clocks_per_tick), "0" (clocks_low), "d" (clocks_high));
+
+
+	return currticks;
+}
+
+static unsigned long long timer_timeout;
+static int __timer_running(void)
+{
+	unsigned long long now;
+	rdtscll(now);
+	return now < timer_timeout;
+}
+
+void udelay(unsigned int usecs)
+{
+	unsigned long long now;
+	rdtscll(now);
+	timer_timeout = now + usecs * ((clocks_per_tick * TICKS_PER_SEC)/(1000*1000));
+	while(__timer_running());
+}
+void ndelay(unsigned int nsecs)
+{
+	unsigned long long now;
+	rdtscll(now);
+	timer_timeout = now + nsecs * ((clocks_per_tick * TICKS_PER_SEC)/(1000*1000*1000));
+	while(__timer_running());
+}
+
+void load_timer2(unsigned int timer2_ticks)
+{
+	unsigned long long now;
+	unsigned long clocks;
+	rdtscll(now);
+	clocks = timer2_ticks * ((clocks_per_tick * TICKS_PER_SEC)/CLOCK_TICK_RATE);
+	timer_timeout = now + clocks;
+}
+
+int timer2_running(void)
+{
+	return __timer_running();
+}
+
+#endif /* RTC_CURRTICKS */
diff -Naur grub-0.97.orig/netboot/i82586.c grub-0.97/netboot/i82586.c
--- grub-0.97.orig/netboot/i82586.c	2003-07-09 11:45:37.000000000 +0000
+++ grub-0.97/netboot/i82586.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,825 +0,0 @@
-/**************************************************************************
-Etherboot -  BOOTP/TFTP Bootstrap Program
-i82586 NIC driver for Etherboot
-Ken Yap, January 1998
-***************************************************************************/
-
-/*
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2, or (at
- * your option) any later version.
- */
-
-#include "etherboot.h"
-#include "nic.h"
-#include "cards.h"
-#include "timer.h"
-
-#define	udelay(n)	waiton_timer2(((n)*TICKS_PER_MS)/1000)
-
-/* Sources of information:
-
-   Donald Becker's excellent 3c507 driver in Linux
-   Intel 82596 data sheet (yes, 82596; it has a 586 compatibility mode)
-*/
-
-/* Code below mostly stolen wholesale from 3c507.c driver in Linux */
-
-/*
-		Details of the i82586.
-
-   You'll really need the databook to understand the details of this part,
-   but the outline is that the i82586 has two separate processing units.
-   Both are started from a list of three configuration tables, of which only
-   the last, the System Control Block (SCB), is used after reset-time.  The SCB
-   has the following fields:
-		Status word
-		Command word
-		Tx/Command block addr.
-		Rx block addr.
-   The command word accepts the following controls for the Tx and Rx units:
-  */
-
-#define	CUC_START	0x0100
-#define	CUC_RESUME	0x0200
-#define	CUC_SUSPEND	0x0300
-#define	RX_START	0x0010
-#define	RX_RESUME	0x0020
-#define	RX_SUSPEND	0x0030
-
-/* The Rx unit uses a list of frame descriptors and a list of data buffer
-   descriptors.  We use full-sized (1518 byte) data buffers, so there is
-   a one-to-one pairing of frame descriptors to buffer descriptors.
-
-   The Tx ("command") unit executes a list of commands that look like:
-	Status word	Written by the 82586 when the command is done.
-	Command word	Command in lower 3 bits, post-command action in upper 3
-	Link word	The address of the next command.
-	Parameters	(as needed).
-
-	Some definitions related to the Command Word are:
- */
-#define CMD_EOL		0x8000		/* The last command of the list, stop. */
-#define CMD_SUSP	0x4000		/* Suspend after doing cmd. */
-#define CMD_INTR	0x2000		/* Interrupt after doing cmd. */
-
-enum commands {
-	CmdNOp = 0, CmdSASetup = 1, CmdConfigure = 2, CmdMulticastList = 3,
-	CmdTx = 4, CmdTDR = 5, CmdDump = 6, CmdDiagnose = 7};
-
-/*
-		Details of the EtherLink16 Implementation
-
-  The 3c507 and NI5210 are generic shared-memory i82586 implementations.
-  3c507: The host can map 16K, 32K, 48K, or 64K of the 64K memory into
-  0x0[CD][08]0000, or all 64K into 0xF[02468]0000.
-  NI5210: The host can map 8k or 16k at 0x[CDE][048C]000 but we
-  assume 8k because to have 16k you cannot put a ROM on the NIC.
-  */
-
-/* Offsets from the base I/O address. */
-
-#ifdef	INCLUDE_3C507
-
-#define	SA_DATA		0	/* Station address data, or 3Com signature. */
-#define MISC_CTRL	6	/* Switch the SA_DATA banks, and bus config bits. */
-#define RESET_IRQ	10	/* Reset the latched IRQ line. */
-#define I82586_ATTN	11	/* Frob the 82586 Channel Attention line. */
-#define ROM_CONFIG	13
-#define MEM_CONFIG	14
-#define IRQ_CONFIG	15
-#define EL16_IO_EXTENT	16
-
-/* The ID port is used at boot-time to locate the ethercard. */
-#define ID_PORT		0x100
-
-#endif
-
-#ifdef	INCLUDE_NI5210
-
-#define	NI52_RESET	0  /* writing to this address, resets the i82586 */
-#define	I82586_ATTN	1  /* channel attention, kick the 586 */
-
-#endif
-
-#ifdef	INCLUDE_EXOS205
-
-#define	EXOS205_RESET	0  /* writing to this address, resets the i82586 */
-#define	I82586_ATTN	1  /* channel attention, kick the 586 */
-
-#endif
-
-/* Offsets to registers in the mailbox (SCB). */
-#define iSCB_STATUS	0x8
-#define iSCB_CMD	0xA
-#define iSCB_CBL	0xC	/* Command BLock offset. */
-#define iSCB_RFA	0xE	/* Rx Frame Area offset. */
-
-/*  Since the 3c507 maps the shared memory window so that the last byte is
-at 82586 address FFFF, the first byte is at 82586 address 0, 16K, 32K, or
-48K corresponding to window sizes of 64K, 48K, 32K and 16K respectively.
-We can account for this be setting the 'SBC Base' entry in the ISCP table
-below for all the 16 bit offset addresses, and also adding the 'SCB Base'
-value to all 24 bit physical addresses (in the SCP table and the TX and RX
-Buffer Descriptors).
-				-Mark
-*/
-
-/*
-  What follows in 'init_words[]' is the "program" that is downloaded to the
-  82586 memory.  It's mostly tables and command blocks, and starts at the
-  reset address 0xfffff6.  This is designed to be similar to the EtherExpress,
-  thus the unusual location of the SCB at 0x0008.
-
-  Even with the additional "don't care" values, doing it this way takes less
-  program space than initializing the individual tables, and I feel it's much
-  cleaner.
-
-  The databook is particularly useless for the first two structures, I had
-  to use the Crynwr driver as an example.
-
-  The memory setup is as follows:
-*/
-
-#define CONFIG_CMD	0x18
-#define SET_SA_CMD	0x24
-#define SA_OFFSET	0x2A
-#define IDLELOOP	0x30
-#define TDR_CMD		0x38
-#define TDR_TIME	0x3C
-#define DUMP_CMD	0x40
-#define DIAG_CMD	0x48
-#define SET_MC_CMD	0x4E
-#define DUMP_DATA	0x56	/* A 170 byte buffer for dump and Set-MC into. */
-
-#define TX_BUF_START	0x0100
-#define TX_BUF_SIZE	(1518+14+20+16) /* packet+header+TBD */
-
-#define RX_BUF_START	0x1000
-#define RX_BUF_SIZE	(1518+14+18)	/* packet+header+RBD */
-#define RX_BUF_END	(mem_end - mem_start - 20)
-
-/*
-  That's it: only 86 bytes to set up the beast, including every extra
-  command available.  The 170 byte buffer at DUMP_DATA is shared between the
-  Dump command (called only by the diagnostic program) and the SetMulticastList
-  command.
-
-  To complete the memory setup you only have to write the station address at
-  SA_OFFSET and create the Tx & Rx buffer lists.
-
-  The Tx command chain and buffer list is setup as follows:
-  A Tx command table, with the data buffer pointing to...
-  A Tx data buffer descriptor.  The packet is in a single buffer, rather than
-	chaining together several smaller buffers.
-  A NoOp command, which initially points to itself,
-  And the packet data.
-
-  A transmit is done by filling in the Tx command table and data buffer,
-  re-writing the NoOp command, and finally changing the offset of the last
-  command to point to the current Tx command.  When the Tx command is finished,
-  it jumps to the NoOp, when it loops until the next Tx command changes the
-  "link offset" in the NoOp.  This way the 82586 never has to go through the
-  slow restart sequence.
-
-  The Rx buffer list is set up in the obvious ring structure.  We have enough
-  memory (and low enough interrupt latency) that we can avoid the complicated
-  Rx buffer linked lists by alway associating a full-size Rx data buffer with
-  each Rx data frame.
-
-  I currently use one transmit buffer starting at TX_BUF_START (0x0100), and
-  use the rest of memory, from RX_BUF_START to RX_BUF_END, for Rx buffers.
-
-  */
-
-static unsigned short init_words[] = {
-	/*	System Configuration Pointer (SCP). */
-#if	defined(INCLUDE_3C507)
-	0x0000,					/* Set bus size to 16 bits. */
-#else
-	0x0001,					/* Set bus size to 8 bits */
-#endif
-	0,0,					/* pad words. */
-	0x0000,0x0000,				/* ISCP phys addr, set in init_82586_mem(). */
-
-	/*	Intermediate System Configuration Pointer (ISCP). */
-	0x0001,					/* Status word that's cleared when init is done. */
-	0x0008,0,0,				/* SCB offset, (skip, skip) */
-
-	/* System Control Block (SCB). */
-	0,0xf000|RX_START|CUC_START,		/* SCB status and cmd. */
-	CONFIG_CMD,				/* Command list pointer, points to Configure. */
-	RX_BUF_START,				/* Rx block list. */
-	0,0,0,0,				/* Error count: CRC, align, buffer, overrun. */
-
-	/* 0x0018: Configure command.  Change to put MAC data with packet. */
-	0, CmdConfigure,			/* Status, command. */
-	SET_SA_CMD,				/* Next command is Set Station Addr. */
-	0x0804,					/* "4" bytes of config data, 8 byte FIFO. */
-	0x2e40,					/* Magic values, including MAC data location. */
-	0,					/* Unused pad word. */
-
-	/* 0x0024: Setup station address command. */
-	0, CmdSASetup,
-	SET_MC_CMD,				/* Next command. */
-	0xaa00,0xb000,0x0bad,	/* Station address (to be filled in) */
-
-	/* 0x0030: NOP, looping back to itself.  Point to first Tx buffer to Tx. */
-	0, CmdNOp, IDLELOOP, 0 /* pad */,
-
-	/* 0x0038: A unused Time-Domain Reflectometer command. */
-	0, CmdTDR, IDLELOOP, 0,
-
-	/* 0x0040: An unused Dump State command. */
-	0, CmdDump, IDLELOOP, DUMP_DATA,
-
-	/* 0x0048: An unused Diagnose command. */
-	0, CmdDiagnose, IDLELOOP,
-
-	/* 0x004E: An empty set-multicast-list command. */
-	0, CmdMulticastList, IDLELOOP, 0,
-};
-
-/* NIC specific static variables go here */
-
-static unsigned short		ioaddr, irq, scb_base;
-static Address			mem_start, mem_end;
-static unsigned short		rx_head, rx_tail;
-
-#define	read_mem(m,s)	fmemcpy((char *)s, m, sizeof(s))
-
-static void setup_rx_buffers(struct nic *nic)
-{
-	Address			write_ptr;
-	unsigned short		cur_rx_buf;
-	static unsigned short	rx_cmd[16] = {
-		0x0000,			/* Rx status */
-		0x0000,			/* Rx command, only and last */
-		RX_BUF_START,		/* Link (will be adjusted) */
-		RX_BUF_START + 22,	/* Buffer offset (will be adjusted) */
-		0x0000, 0x0000, 0x0000,	/* Pad for dest addr */
-		0x0000, 0x0000, 0x0000,	/* Pad for source addr */
-		0x0000,			/* Pad for protocol */
-		0x0000,			/* Buffer: Actual count */
-		-1,			/* Buffer: Next (none) */
-		RX_BUF_START + 0x20,	/* Buffer: Address low (+ scb_base) (will be adjusted) */
-		0x0000,			/* Buffer: Address high */
-		0x8000 | (RX_BUF_SIZE - 0x20)
-	};
-
-	cur_rx_buf = rx_head = RX_BUF_START;
-	do {		/* While there is room for one more buffer */
-		write_ptr = mem_start + cur_rx_buf;
-		/* adjust some contents */
-		rx_cmd[1] = 0x0000;
-		rx_cmd[2] = cur_rx_buf + RX_BUF_SIZE;
-		rx_cmd[3] = cur_rx_buf + 22;
-		rx_cmd[13] = cur_rx_buf + 0x20 + scb_base;
-		memcpy((char *)write_ptr, (char *)rx_cmd, sizeof(rx_cmd));
-		rx_tail = cur_rx_buf;
-		cur_rx_buf += RX_BUF_SIZE;
-	} while (cur_rx_buf <= RX_BUF_END - RX_BUF_SIZE);
-	/* Terminate the list by setting the EOL bit and wrap ther pointer
-	   to make the list a ring. */
-	write_ptr = mem_start + rx_tail;
-	rx_cmd[1] = 0xC000;
-	rx_cmd[2] = rx_head;
-	memcpy((char *)write_ptr, (char *)rx_cmd, sizeof(unsigned short) * 3);
-}
-
-static void ack_status(void)
-{
-	unsigned short	cmd, status;
-	unsigned short	*shmem = (short *)mem_start;
-
-	cmd = (status = shmem[iSCB_STATUS>>1]) & 0xf000;
-	if (status & 0x100)		/* CU suspended? */
-		cmd |= CUC_RESUME;
-	if ((status & 0x200) == 0)	/* CU not active? */
-		cmd |= CUC_START;
-	if (status & 0x010)		/* RU suspended? */
-		cmd |= RX_RESUME;
-	else if ((status & 0x040) == 0)	/* RU not active? */
-		cmd |= RX_START;
-	if (cmd == 0)			/* Nothing to do */
-		return;
-	shmem[iSCB_CMD>>1] = cmd;
-#if	defined(DEBUG)
-	printf("Status %hX Command %hX\n", status, cmd);
-#endif
-	outb(0, ioaddr + I82586_ATTN);
-}
-
-/**************************************************************************
-RESET - Reset adapter
-***************************************************************************/
-
-static void i82586_reset(struct nic *nic)
-{
-	unsigned long	time;
-	unsigned short	*shmem = (short *)mem_start;
-
-	/* put the card in its initial state */
-
-#ifdef	INCLUDE_3C507
-	/* Enable loopback to protect the wire while starting up,
-	   and hold the 586 in reset during the memory initialisation. */
-	outb(0x20, ioaddr + MISC_CTRL);
-#endif
-
-	/* Fix the ISCP address and base. */
-	init_words[3] = scb_base;
-	init_words[7] = scb_base;
-
-	/* Write the words at 0xfff6. */
-	/* Write the words at 0x0000. */
-	/* Fill in the station address. */
-	memcpy((char *)(mem_end - 10), (char *)init_words, 10);
-	memcpy((char *)mem_start, (char *)&init_words[5], sizeof(init_words) - 10);
-	memcpy((char *)mem_start + SA_OFFSET, nic->node_addr, ETH_ALEN);
-	setup_rx_buffers(nic);
-
-#ifdef	INCLUDE_3C507
-	/* Start the 586 by releasing the reset line, but leave loopback. */
-	outb(0xA0, ioaddr + MISC_CTRL);
-#endif
-
-	/* This was time consuming to track down; you need to give two channel
-	   attention signals to reliably start up the i82586. */
-	outb(0, ioaddr + I82586_ATTN);
-	time = currticks() + TICKS_PER_SEC;	/* allow 1 second to init */
-	while (
-			shmem[iSCB_STATUS>>1] == 0)
-	{
-		if (currticks() > time)
-		{
-			printf("i82586 initialisation timed out with status %hX, cmd %hX\n",
-					shmem[iSCB_STATUS>>1], shmem[iSCB_CMD>>1]);
-			break;
-		}
-	}
-	/* Issue channel-attn -- the 82586 won't start. */
-	outb(0, ioaddr + I82586_ATTN);
-
-#ifdef	INCLUDE_3C507
-	/* Disable loopback. */
-	outb(0x80, ioaddr + MISC_CTRL);
-#endif
-#if	defined(DEBUG)
-	printf("i82586 status %hX, cmd %hX\n",
-			shmem[iSCB_STATUS>>1], shmem[iSCB_CMD>>1]);
-#endif
-}
-
-/**************************************************************************
-  POLL - Wait for a frame
- ***************************************************************************/
-static int i82586_poll(struct nic *nic)
-{
-	int		status;
-	unsigned short	rfd_cmd, next_rx_frame, data_buffer_addr,
-	frame_status, pkt_len;
-	unsigned short	*shmem = (short *)mem_start + rx_head;
-
-	/* return true if there's an ethernet packet ready to read */
-	if (
-			((frame_status = shmem[0]) & 0x8000) == 0)
-		return (0);		/* nope */
-	rfd_cmd = shmem[1];
-	next_rx_frame = shmem[2];
-	data_buffer_addr = shmem[3];
-	pkt_len = shmem[11];
-	status = 0;
-	if (rfd_cmd != 0 || data_buffer_addr != rx_head + 22
-			|| (pkt_len & 0xC000) != 0xC000)
-		printf("\nRx frame corrupt, discarded");
-	else if ((frame_status & 0x2000) == 0)
-		printf("\nRx frame had error");
-	else
-	{
-		/* We have a frame, copy it to our buffer */
-		pkt_len &= 0x3FFF;
-		memcpy(nic->packet, (char *)mem_start + rx_head + 0x20, pkt_len);
-		/* Only packets not from ourself */
-		if (memcmp(nic->packet + ETH_ALEN, nic->node_addr, ETH_ALEN) != 0)
-		{
-			nic->packetlen = pkt_len;
-			status = 1;
-		}
-	}
-	/* Clear the status word and set EOL on Rx frame */
-	shmem[0] = 0;
-	shmem[1] = 0xC000;
-	*(short *)(mem_start + rx_tail + 2) = 0;
-	rx_tail = rx_head;
-	rx_head = next_rx_frame;
-	ack_status();
-	return (status);
-}
-
-/**************************************************************************
-  TRANSMIT - Transmit a frame
- ***************************************************************************/
-static void i82586_transmit(
-		struct nic *nic,
-		const char *d,			/* Destination */
-		unsigned int t,			/* Type */
-		unsigned int s,			/* size */
-		const char *p)			/* Packet */
-{
-	Address			bptr;
-	unsigned short		type, z;
-	static unsigned short	tx_cmd[11] = {
-		0x0,			/* Tx status */
-		CmdTx,			/* Tx command */
-		TX_BUF_START+16,	/* Next command is a NoOp */
-		TX_BUF_START+8,		/* Data Buffer offset */
-		0x8000,			/* | with size */
-		0xffff,			/* No next data buffer */
-		TX_BUF_START+22,	/* + scb_base */
-		0x0,			/* Buffer address high bits (always zero) */
-		0x0,			/* Nop status */
-		CmdNOp,			/* Nop command */
-		TX_BUF_START+16		/* Next is myself */
-	};
-	unsigned short	*shmem = (short *)mem_start + TX_BUF_START;
-
-	/* send the packet to destination */
-	/* adjust some contents */
-	type = htons(t);
-	if (s < ETH_ZLEN)
-		s = ETH_ZLEN;
-	tx_cmd[4] = (s + ETH_HLEN) | 0x8000;
-	tx_cmd[6] = TX_BUF_START + 22 + scb_base;
-	bptr = mem_start + TX_BUF_START;
-	memcpy((char *)bptr, (char *)tx_cmd, sizeof(tx_cmd));
-	bptr += sizeof(tx_cmd);
-	memcpy((char *)bptr, d, ETH_ALEN);
-	bptr += ETH_ALEN;
-	memcpy((char *)bptr, nic->node_addr, ETH_ALEN);
-	bptr += ETH_ALEN;
-	memcpy((char *)bptr, (char *)&type, sizeof(type));
-	bptr += sizeof(type);
-	memcpy((char *)bptr, p, s);
-	/* Change the offset in the IDLELOOP */
-	*(unsigned short *)(mem_start + IDLELOOP + 4) = TX_BUF_START;
-	/* Wait for transmit completion */
-	while (
-			(shmem[0] & 0x2000) == 0)
-		;
-	/* Change the offset in the IDLELOOP back and
-	   change the final loop to point here */
-	*(unsigned short *)(mem_start + IDLELOOP + 4) = IDLELOOP;
-	*(unsigned short *)(mem_start + TX_BUF_START + 20) = IDLELOOP;
-	ack_status();
-}
-
-/**************************************************************************
-  DISABLE - Turn off ethernet interface
- ***************************************************************************/
-static void i82586_disable(struct nic *nic)
-{
-	unsigned short	*shmem = (short *)mem_start;
-
-#if	0
-	/* Flush the Tx and disable Rx. */
-	shmem[iSCB_CMD>>1] = RX_SUSPEND | CUC_SUSPEND;
-	outb(0, ioaddr + I82586_ATTN);
-#ifdef	INCLUDE_NI5210
-	outb(0, ioaddr + NI52_RESET);
-#endif
-#endif	/* 0 */
-}
-
-#ifdef	INCLUDE_3C507
-
-static int t507_probe1(struct nic *nic, unsigned short ioaddr)
-{
-	int			i;
-	Address			size;
-	char			mem_config;
-	char			if_port;
-
-	if (inb(ioaddr) != '*' || inb(ioaddr+1) != '3'
-		|| inb(ioaddr+2) != 'C' || inb(ioaddr+3) != 'O')
-		return (0);
-	irq = inb(ioaddr + IRQ_CONFIG) & 0x0f;
-	mem_config = inb(ioaddr + MEM_CONFIG);
-	if (mem_config & 0x20)
-	{
-		size = 65536L;
-		mem_start = 0xf00000L + (mem_config & 0x08 ? 0x080000L
-			: (((Address)mem_config & 0x3) << 17));
-	}
-	else
-	{
-		size = ((((Address)mem_config & 0x3) + 1) << 14);
-		mem_start = 0x0c0000L + (((Address)mem_config & 0x18) << 12);
-	}
-	mem_end = mem_start + size;
-	scb_base = 65536L - size;
-	if_port = inb(ioaddr + ROM_CONFIG) & 0x80;
-	/* Get station address */
-	outb(0x01, ioaddr + MISC_CTRL);
-	for (i = 0; i < ETH_ALEN; ++i)
-	{
-		nic->node_addr[i] = inb(ioaddr+i);
-	}
-	printf("\n3c507 ioaddr %#hX, IRQ %d, mem [%#X-%#X], %sternal xcvr, addr %!\n",
-		ioaddr, irq, mem_start, mem_end, if_port ? "in" : "ex", nic->node_addr);
-	return (1);
-}
-
-/**************************************************************************
-PROBE - Look for an adapter, this routine's visible to the outside
-***************************************************************************/
-
-struct nic *t507_probe(struct nic *nic, unsigned short *probe_addrs)
-{
-	static unsigned char	init_ID_done = 0;
-	unsigned short		lrs_state = 0xff;
-	static unsigned short	io_addrs[] = { 0x300, 0x320, 0x340, 0x280, 0 };
-	unsigned short		*p;
-	int			i;
-
-	if (init_ID_done == 0)
-	{
-		/* Send the ID sequence to the ID_PORT to enable the board */
-		outb(0x00, ID_PORT);
-		for (i = 0; i < 255; ++i)
-		{
-			outb(lrs_state, ID_PORT);
-			lrs_state <<= 1;
-			if (lrs_state & 0x100)
-				lrs_state ^= 0xe7;
-		}
-		outb(0x00, ID_PORT);
-		init_ID_done = 1;
-	}
-	/* if probe_addrs is 0, then routine can use a hardwired default */
-	if (probe_addrs == 0)
-		probe_addrs = io_addrs;
-	for (p = probe_addrs; (ioaddr = *p) != 0; ++p)
-		if (t507_probe1(nic, ioaddr))
-			break;
-	if (ioaddr != 0)
-	{
-		/* point to NIC specific routines */
-		i82586_reset(nic);
-		nic->reset = i82586_reset;
-		nic->poll = i82586_poll;
-		nic->transmit = i82586_transmit;
-		nic->disable = i82586_disable;
-		return nic;
-	}
-	/* else */
-	{
-		return 0;
-	}
-}
-
-#endif
-
-#ifdef	INCLUDE_NI5210
-
-static int ni5210_probe2(void)
-{
-	unsigned short		i;
-	unsigned short		shmem[10];
-
-	/* Fix the ISCP address and base. */
-	init_words[3] = scb_base;
-	init_words[7] = scb_base;
-
-	/* Write the words at 0xfff6. */
-	/* Write the words at 0x0000. */
-	memcpy((char *)(mem_end - 10), (char *)init_words, 10);
-	memcpy((char *)mem_start, (char *)&init_words[5], sizeof(init_words) - 10);
-	if (*(unsigned short *)mem_start != 1)
-		return (0);
-	outb(0, ioaddr + NI52_RESET);
-	outb(0, ioaddr + I82586_ATTN);
-	udelay(32);
-	i = 50;
-	while (
-		shmem[iSCB_STATUS>>1] == 0)
-	{
-		if (--i == 0)
-		{
-			printf("i82586 initialisation timed out with status %hX, cmd %hX\n",
-				shmem[iSCB_STATUS>>1], shmem[iSCB_CMD>>1]);
-			break;
-		}
-	}
-	/* Issue channel-attn -- the 82586 won't start. */
-	outb(0, ioaddr + I82586_ATTN);
-	if (*(unsigned short *)mem_start != 0)
-		return (0);
-	return (1);
-}
-
-static int ni5210_probe1(struct nic *nic)
-{
-	int			i;
-	static Address		mem_addrs[] = {
-		0xc0000, 0xc4000, 0xc8000, 0xcc000,
-		0xd0000, 0xd4000, 0xd8000, 0xdc000,
-		0xe0000, 0xe4000, 0xe8000, 0xec000,
-		0 };
-	Address			*p;
-
-	if (inb(ioaddr + 6) != 0x0 || inb(ioaddr + 7) != 0x55)
-		return (0);
-	scb_base = -8192;		/* assume 8k memory */
-	for (p = mem_addrs; (mem_start = *p) != 0; ++p)
-		if (mem_end = mem_start + 8192, ni5210_probe2())
-			break;
-	if (mem_start == 0)
-		return (0);
-	/* Get station address */
-	for (i = 0; i < ETH_ALEN; ++i)
-	{
-		nic->node_addr[i] = inb(ioaddr+i);
-	}
-	printf("\nNI5210 ioaddr %#hX, mem [%#X-%#X], addr %!\n",
-		ioaddr, mem_start, mem_end, nic->node_addr);
-	return (1);
-}
-
-struct nic *ni5210_probe(struct nic *nic, unsigned short *probe_addrs)
-{
-	/* missing entries are addresses usually already used */
-	static unsigned short	io_addrs[] = {
-		0x200, 0x208, 0x210, 0x218, 0x220, 0x228, 0x230, 0x238,
-		0x240, 0x248, 0x250, 0x258, 0x260, 0x268, 0x270, /*Par*/
-		0x280, 0x288, 0x290, 0x298, 0x2A0, 0x2A8, 0x2B0, 0x2B8,
-		0x2C0, 0x2C8, 0x2D0, 0x2D8, 0x2E0, 0x2E8, 0x2F0, /*Ser*/
-		0x300, 0x308, 0x310, 0x318, 0x320, 0x328, 0x330, 0x338,
-		0x340, 0x348, 0x350, 0x358, 0x360, 0x368, 0x370, /*Par*/
-		0x380, 0x388, 0x390, 0x398, 0x3A0, 0x3A8, /*Vid,Par*/
-		0x3C0, 0x3C8, 0x3D0, 0x3D8, 0x3E0, 0x3E8, /*Ser*/
-		0x0
-	};
-	unsigned short		*p;
-	int			i;
-
-	/* if probe_addrs is 0, then routine can use a hardwired default */
-	if (probe_addrs == 0)
-		probe_addrs = io_addrs;
-	for (p = probe_addrs; (ioaddr = *p) != 0; ++p)
-		if (ni5210_probe1(nic))
-			break;
-	if (ioaddr != 0)
-	{
-		/* point to NIC specific routines */
-		i82586_reset(nic);
-		nic->reset = i82586_reset;
-		nic->poll = i82586_poll;
-		nic->transmit = i82586_transmit;
-		nic->disable = i82586_disable;
-		return nic;
-	}
-	/* else */
-	{
-		return 0;
-	}
-}
-#endif
-
-#ifdef	INCLUDE_EXOS205
-
-/*
- * Code to download to I186 in EXOS205
- */
-
-static unsigned char exos_i186_init[] =
-{
-0x08,0x00,0x14,0x00,0x00,0x00,0xaa,0xfa,0x33,0xc0,0xba,0xfe,0xff,0xef,0xb8,0xf8,
-0xff,0xe7,0xa0,0xb8,0x7c,0x00,0xe7,0xa4,0xb8,0xbc,0x80,0xe7,0xa8,0x8c,0xc8,0x8e,
-0xd8,0xbb,0x2f,0x0e,0xc6,0x07,0xa5,0x33,0xc9,0xeb,0x00,0xeb,0x00,0xeb,0x00,0xe2,
-0xf8,0xbe,0x2c,0x0e,0xba,0x02,0x05,0x33,0xdb,0xb9,0x03,0x00,0xec,0x24,0x0f,0x8a,
-0xe0,0x02,0xd8,0x42,0x42,0xec,0x02,0xd8,0xd0,0xe0,0xd0,0xe0,0xd0,0xe0,0xd0,0xe0,
-0x0a,0xc4,0x88,0x04,0x42,0x42,0x46,0xe2,0xe3,0x8a,0xe3,0xd0,0xec,0xd0,0xec,0xd0,
-0xec,0xd0,0xec,0x80,0xe3,0x0f,0x02,0xe3,0x80,0xf4,0x05,0xec,0x3a,0xe0,0x74,0x05,
-0xc6,0x04,0x5a,0xeb,0xfe,0xc6,0x04,0x55,0x33,0xc0,0x8e,0xd8,0xbe,0x38,0x00,0xc7,
-0x04,0xce,0x0e,0x46,0x46,0xc7,0x04,0x00,0xff,0xfb,0xba,0x3c,0x00,0xb8,0x03,0x00,
-0xef,0x33,0xdb,0x33,0xc9,0xbd,0x04,0x0f,0x90,0x90,0x90,0x90,0xe2,0xfa,0x43,0x2e,
-0x89,0x5e,0x00,0xeb,0xf3,0x52,0xba,0x00,0x06,0xef,0x50,0x53,0x55,0xbd,0xf8,0x0e,
-0x2e,0x8b,0x5e,0x00,0x43,0x2e,0x89,0x5e,0x00,0xba,0x22,0x00,0xb8,0x00,0x80,0xef,
-0x5d,0x5b,0x58,0x5a,0xcf,0x49,0x4e,0x54,0x52,0x20,0x63,0x6e,0x74,0x2d,0x3e,0x00,
-0x00,0x4c,0x4f,0x4f,0x50,0x20,0x63,0x6e,0x74,0x2d,0x3e,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xea,0x30,0x0e,0x00,0xff,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,00
-};
-
-/* These offsets are from the end of the i186 download code */
-
-#define	OFFSET_SEMA		0x1D1
-#define	OFFSET_ADDR		0x1D7
-
-static int exos205_probe2(void)
-{
-	unsigned short		i;
-	unsigned short		shmem[10];
-
-	/* Fix the ISCP address and base. */
-	init_words[3] = scb_base;
-	init_words[7] = scb_base;
-
-	/* Write the words at 0xfff6. */
-	/* Write the words at 0x0000. */
-	memcpy((char *)(mem_end - 10), (char *)init_words, 10);
-	memcpy((char *)mem_start, (char *)&init_words[5], sizeof(init_words) - 10);
-	if (*(unsigned short *)mem_start != 1)
-		return (0);
-	outb(0, ioaddr + EXOS205_RESET);
-	outb(0, ioaddr + I82586_ATTN);
-	i = 50;
-	while (
-		shmem[iSCB_STATUS>>1] == 0)
-	{
-		if (--i == 0)
-		{
-			printf("i82586 initialisation timed out with status %hX, cmd %hX\n",
-				shmem[iSCB_STATUS>>1], shmem[iSCB_CMD>>1]);
-			break;
-		}
-	}
-	/* Issue channel-attn -- the 82586 won't start. */
-	outb(0, ioaddr + I82586_ATTN);
-	if (*(unsigned short *)mem_start != 0)
-		return (0);
-	return (1);
-}
-
-static int exos205_probe1(struct nic *nic)
-{
-	int			i;
-	/* If you know the other addresses please let me know */
-	static Address		mem_addrs[] = {
-		0xcc000, 0 };
-	Address			*p;
-
-	scb_base = -16384;		/* assume 8k memory */
-	for (p = mem_addrs; (mem_start = *p) != 0; ++p)
-		if (mem_end = mem_start + 16384, exos205_probe2())
-			break;
-	if (mem_start == 0)
-		return (0);
-	/* Get station address */
-	for (i = 0; i < ETH_ALEN; ++i)
-	{
-		nic->node_addr[i] = inb(ioaddr+i);
-	}
-	printf("\nEXOS205 ioaddr %#hX, mem [%#X-%#X], addr %!\n",
-		ioaddr, mem_start, mem_end, nic->node_addr);
-	return (1);
-}
-
-struct nic *exos205_probe(struct nic *nic, unsigned short *probe_addrs)
-{
-	/* If you know the other addresses, please let me know */
-	static unsigned short	io_addrs[] = {
-		0x310, 0x0
-	};
-	unsigned short		*p;
-	int			i;
-
-	/* if probe_addrs is 0, then routine can use a hardwired default */
-	if (probe_addrs == 0)
-		probe_addrs = io_addrs;
-	for (p = probe_addrs; (ioaddr = *p) != 0; ++p)
-		if (exos205_probe1(nic))
-			break;
-	if (ioaddr != 0)
-	{
-		/* point to NIC specific routines */
-		i82586_reset(nic);
-		nic->reset = i82586_reset;
-		nic->poll = i82586_poll;
-		nic->transmit = i82586_transmit;
-		nic->disable = i82586_disable;
-		return nic;
-	}
-	/* else */
-	{
-		return 0;
-	}
-}
-
-#endif
diff -Naur grub-0.97.orig/netboot/if_arp.h grub-0.97/netboot/if_arp.h
--- grub-0.97.orig/netboot/if_arp.h	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/if_arp.h	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,29 @@
+#ifndef	_IF_ARP_H
+#define	_IF_ARP_H
+
+#include "types.h"
+
+#define ARP_REQUEST	1
+#define ARP_REPLY	2
+
+#ifndef	MAX_ARP_RETRIES
+#define MAX_ARP_RETRIES		20
+#endif
+
+/*
+ * A pity sipaddr and tipaddr are not longword aligned or we could use
+ * in_addr. No, I don't want to use #pragma packed.
+ */
+struct arprequest {
+	uint16_t hwtype;
+	uint16_t protocol;
+	uint8_t  hwlen;
+	uint8_t  protolen;
+	uint16_t opcode;
+	uint8_t  shwaddr[6];
+	uint8_t  sipaddr[4];
+	uint8_t  thwaddr[6];
+	uint8_t  tipaddr[4];
+};
+
+#endif	/* _IF_ARP_H */
diff -Naur grub-0.97.orig/netboot/if_ether.h grub-0.97/netboot/if_ether.h
--- grub-0.97.orig/netboot/if_ether.h	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/if_ether.h	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,21 @@
+#ifndef	_IF_ETHER_H
+#define	_IF_ETHER_H
+
+/*
+   I'm moving towards the defined names in linux/if_ether.h for clarity.
+   The confusion between 60/64 and 1514/1518 arose because the NS8390
+   counts the 4 byte frame checksum in the incoming packet, but not
+   in the outgoing packet. 60/1514 are the correct numbers for most
+   if not all of the other NIC controllers.
+*/
+
+#define ETH_ALEN		6	/* Size of Ethernet address */
+#define ETH_HLEN		14	/* Size of ethernet header */
+#define	ETH_ZLEN		60	/* Minimum packet */
+#define	ETH_FRAME_LEN		1514	/* Maximum packet */
+#define ETH_DATA_ALIGN		2	/* Amount needed to align the data after an ethernet header */
+#ifndef	ETH_MAX_MTU
+#define	ETH_MAX_MTU		(ETH_FRAME_LEN-ETH_HLEN)
+#endif
+
+#endif	/* _IF_ETHER_H */
diff -Naur grub-0.97.orig/netboot/igmp.h grub-0.97/netboot/igmp.h
--- grub-0.97.orig/netboot/igmp.h	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/igmp.h	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,27 @@
+#ifndef	_IGMP_H
+#define	_IGMP_H
+
+/* Max interval between IGMP packets */
+#define IGMP_INTERVAL			(10*TICKS_PER_SEC)
+#define IGMPv1_ROUTER_PRESENT_TIMEOUT	(400*TICKS_PER_SEC)
+
+#define IGMP_QUERY	0x11
+#define IGMPv1_REPORT	0x12
+#define IGMPv2_REPORT	0x16
+#define IGMP_LEAVE	0x17
+#define GROUP_ALL_HOSTS 0xe0000001 /* 224.0.0.1 Host byte order */
+
+struct igmp {
+	uint8_t  type;
+	uint8_t  response_time;
+	uint16_t chksum;
+	in_addr group;
+};
+
+struct igmp_ip_t { /* Format of an igmp ip packet */
+	struct iphdr ip;
+	uint8_t router_alert[4]; /* Router alert option */
+	struct igmp igmp;
+};
+
+#endif	/* _IGMP_H */
diff -Naur grub-0.97.orig/netboot/in.h grub-0.97/netboot/in.h
--- grub-0.97.orig/netboot/in.h	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/in.h	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,21 @@
+#ifndef	_IN_H
+#define	_IN_H
+
+#include "types.h"
+
+#define IP		0x0800
+#define ARP		0x0806
+#define	RARP		0x8035
+
+#define IP_ICMP		1
+#define IP_IGMP		2
+#define IP_UDP		17
+
+/* Same after going through htonl */
+#define IP_BROADCAST	0xFFFFFFFF
+
+typedef struct {
+	uint32_t	s_addr;
+} in_addr;
+
+#endif	/* _IN_H */
diff -Naur grub-0.97.orig/netboot/io.h grub-0.97/netboot/io.h
--- grub-0.97.orig/netboot/io.h	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/io.h	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,239 @@
+#ifndef	IO_H
+#define IO_H
+
+
+/* Amount of relocation etherboot is experiencing */
+extern unsigned long virt_offset;
+
+/* Don't require identity mapped physical memory,
+ * osloader.c is the only valid user at the moment.
+ */
+unsigned long virt_to_phys(volatile const void *virt_addr);
+void *phys_to_virt(unsigned long phys_addr);
+
+/* virt_to_bus converts an addresss inside of etherboot [_start, _end]
+ * into a memory access cards can use.
+ */
+#define virt_to_bus virt_to_phys
+
+
+/* bus_to_virt reverses virt_to_bus, the address must be output
+ * from virt_to_bus to be valid.  This function does not work on
+ * all bus addresses.
+ */
+#define bus_to_virt phys_to_virt
+
+/* ioremap converts a random 32bit bus address into something
+ * etherboot can access.
+ */
+static inline void *ioremap(unsigned long bus_addr, unsigned long length __unused)
+{
+	return bus_to_virt(bus_addr);
+}
+
+/* iounmap cleans up anything ioremap had to setup */
+static inline void iounmap(void *virt_addr __unused)
+{
+	return;
+}
+
+/*
+ * This file contains the definitions for the x86 IO instructions
+ * inb/inw/inl/outb/outw/outl and the "string versions" of the same
+ * (insb/insw/insl/outsb/outsw/outsl). You can also use "pausing"
+ * versions of the single-IO instructions (inb_p/inw_p/..).
+ *
+ * This file is not meant to be obfuscating: it's just complicated
+ * to (a) handle it all in a way that makes gcc able to optimize it
+ * as well as possible and (b) trying to avoid writing the same thing
+ * over and over again with slight variations and possibly making a
+ * mistake somewhere.
+ */
+
+/*
+ * Thanks to James van Artsdalen for a better timing-fix than
+ * the two short jumps: using outb's to a nonexistent port seems
+ * to guarantee better timings even on fast machines.
+ *
+ * On the other hand, I'd like to be sure of a non-existent port:
+ * I feel a bit unsafe about using 0x80 (should be safe, though)
+ *
+ *		Linus
+ */
+
+#ifdef	SLOW_IO_BY_JUMPING
+#define __SLOW_DOWN_IO __asm__ __volatile__("jmp 1f\n1:\tjmp 1f\n1:")
+#else
+#define __SLOW_DOWN_IO __asm__ __volatile__("outb %al,$0x80")
+#endif
+
+#ifdef	REALLY_SLOW_IO
+#define SLOW_DOWN_IO { __SLOW_DOWN_IO; __SLOW_DOWN_IO; __SLOW_DOWN_IO; __SLOW_DOWN_IO; }
+#else
+#define SLOW_DOWN_IO __SLOW_DOWN_IO
+#endif
+
+/*
+ * readX/writeX() are used to access memory mapped devices. On some
+ * architectures the memory mapped IO stuff needs to be accessed
+ * differently. On the x86 architecture, we just read/write the
+ * memory location directly.
+ */
+#define readb(addr) (*(volatile unsigned char *) (addr))
+#define readw(addr) (*(volatile unsigned short *) (addr))
+#define readl(addr) (*(volatile unsigned int *) (addr))
+
+#define writeb(b,addr) ((*(volatile unsigned char *) (addr)) = (b))
+#define writew(b,addr) ((*(volatile unsigned short *) (addr)) = (b))
+#define writel(b,addr) ((*(volatile unsigned int *) (addr)) = (b))
+
+#define memcpy_fromio(a,b,c)	memcpy((a),(void *)(b),(c))
+#define memcpy_toio(a,b,c)	memcpy((void *)(a),(b),(c))
+
+/*
+ * Force strict CPU ordering.
+ * And yes, this is required on UP too when we're talking
+ * to devices.
+ *
+ * For now, "wmb()" doesn't actually do anything, as all
+ * Intel CPU's follow what Intel calls a *Processor Order*,
+ * in which all writes are seen in the program order even
+ * outside the CPU.
+ *
+ * I expect future Intel CPU's to have a weaker ordering,
+ * but I'd also expect them to finally get their act together
+ * and add some real memory barriers if so.
+ *
+ * Some non intel clones support out of order store. wmb() ceases to be a
+ * nop for these.
+ */
+ 
+#define mb() 	__asm__ __volatile__ ("lock; addl $0,0(%%esp)": : :"memory")
+#define rmb()	mb()
+#define wmb()	mb();
+
+
+/*
+ * Talk about misusing macros..
+ */
+
+#define __OUT1(s,x) \
+extern void __out##s(unsigned x value, unsigned short port); \
+extern inline void __out##s(unsigned x value, unsigned short port) {
+
+#define __OUT2(s,s1,s2) \
+__asm__ __volatile__ ("out" #s " %" s1 "0,%" s2 "1"
+
+#define __OUT(s,s1,x) \
+__OUT1(s,x) __OUT2(s,s1,"w") : : "a" (value), "d" (port)); } \
+__OUT1(s##c,x) __OUT2(s,s1,"") : : "a" (value), "id" (port)); } \
+__OUT1(s##_p,x) __OUT2(s,s1,"w") : : "a" (value), "d" (port)); SLOW_DOWN_IO; } \
+__OUT1(s##c_p,x) __OUT2(s,s1,"") : : "a" (value), "id" (port)); SLOW_DOWN_IO; }
+
+#define __IN1(s,x) \
+extern unsigned x __in##s(unsigned short port); \
+extern inline unsigned x __in##s(unsigned short port) { unsigned x _v;
+
+#define __IN2(s,s1,s2) \
+__asm__ __volatile__ ("in" #s " %" s2 "1,%" s1 "0"
+
+#define __IN(s,s1,x,i...) \
+__IN1(s,x) __IN2(s,s1,"w") : "=a" (_v) : "d" (port) ,##i ); return _v; } \
+__IN1(s##c,x) __IN2(s,s1,"") : "=a" (_v) : "id" (port) ,##i ); return _v; } \
+__IN1(s##_p,x) __IN2(s,s1,"w") : "=a" (_v) : "d" (port) ,##i ); SLOW_DOWN_IO; return _v; } \
+__IN1(s##c_p,x) __IN2(s,s1,"") : "=a" (_v) : "id" (port) ,##i ); SLOW_DOWN_IO; return _v; }
+
+#define __INS(s) \
+extern void ins##s(unsigned short port, void * addr, unsigned long count); \
+extern inline void ins##s(unsigned short port, void * addr, unsigned long count) \
+{ __asm__ __volatile__ ("cld ; rep ; ins" #s \
+: "=D" (addr), "=c" (count) : "d" (port),"0" (addr),"1" (count)); }
+
+#define __OUTS(s) \
+extern void outs##s(unsigned short port, const void * addr, unsigned long  count); \
+extern inline void outs##s(unsigned short port, const void * addr, unsigned long count) \
+{ __asm__ __volatile__ ("cld ; rep ; outs" #s \
+: "=S" (addr), "=c" (count) : "d" (port),"0" (addr),"1" (count)); }
+
+__IN(b,"", char)
+__IN(w,"",short)
+__IN(l,"", long)
+
+__OUT(b,"b",char)
+__OUT(w,"w",short)
+__OUT(l,,int)
+
+__INS(b)
+__INS(w)
+__INS(l)
+
+__OUTS(b)
+__OUTS(w)
+__OUTS(l)
+
+/*
+ * Note that due to the way __builtin_constant_p() works, you
+ *  - can't use it inside a inline function (it will never be true)
+ *  - you don't have to worry about side effects within the __builtin..
+ */
+#define outb(val,port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__outbc((val),(port)) : \
+	__outb((val),(port)))
+
+#define inb(port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__inbc(port) : \
+	__inb(port))
+
+#define outb_p(val,port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__outbc_p((val),(port)) : \
+	__outb_p((val),(port)))
+
+#define inb_p(port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__inbc_p(port) : \
+	__inb_p(port))
+
+#define outw(val,port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__outwc((val),(port)) : \
+	__outw((val),(port)))
+
+#define inw(port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__inwc(port) : \
+	__inw(port))
+
+#define outw_p(val,port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__outwc_p((val),(port)) : \
+	__outw_p((val),(port)))
+
+#define inw_p(port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__inwc_p(port) : \
+	__inw_p(port))
+
+#define outl(val,port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__outlc((val),(port)) : \
+	__outl((val),(port)))
+
+#define inl(port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__inlc(port) : \
+	__inl(port))
+
+#define outl_p(val,port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__outlc_p((val),(port)) : \
+	__outl_p((val),(port)))
+
+#define inl_p(port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__inlc_p(port) : \
+	__inl_p(port))
+
+#endif /* ETHERBOOT_IO_H */
diff -Naur grub-0.97.orig/netboot/ip.h grub-0.97/netboot/ip.h
--- grub-0.97.orig/netboot/ip.h	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/ip.h	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,36 @@
+#ifndef	_IP_H
+#define	_IP_H
+
+/* We need 'uint16_t' */
+#include "types.h"
+/* We need 'in_addr' */
+#include "in.h"
+
+struct iphdr {
+	uint8_t  verhdrlen;
+	uint8_t  service;
+	uint16_t len;
+	uint16_t ident;
+	uint16_t frags;
+	uint8_t  ttl;
+	uint8_t  protocol;
+	uint16_t chksum;
+	in_addr src;
+	in_addr dest;
+};
+
+extern void build_ip_hdr(unsigned long __destip, int __ttl, int __protocol, 
+			 int __option_len, int __len, const void * __buf);
+
+extern int ip_transmit(int __len, const void * __buf);
+
+extern uint16_t ipchksum(const void * __data, unsigned long __length);
+
+extern uint16_t add_ipchksums(unsigned long __offset, uint16_t __sum, 
+			      uint16_t __new);
+
+
+
+
+
+#endif	/* _IP_H */
diff -Naur grub-0.97.orig/netboot/isa.h grub-0.97/netboot/isa.h
--- grub-0.97.orig/netboot/isa.h	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/isa.h	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,27 @@
+#if !defined(ISA_H) && defined(CONFIG_ISA)
+#define ISA_H
+
+struct dev;
+
+#define ISAPNP_VENDOR(a,b,c)	(((((a)-'A'+1)&0x3f)<<2)|\
+				((((b)-'A'+1)&0x18)>>3)|((((b)-'A'+1)&7)<<13)|\
+				((((c)-'A'+1)&0x1f)<<8))
+
+#define	GENERIC_ISAPNP_VENDOR	ISAPNP_VENDOR('P','N','P')
+
+struct isa_driver
+{
+	int type;
+	const char *name;
+	int (*probe)(struct dev *, unsigned short *);
+	unsigned short *ioaddrs;
+};
+
+#define __isa_driver	__attribute__ ((unused,__section__(".drivers.isa")))
+extern const struct isa_driver isa_drivers[];
+extern const struct isa_driver isa_drivers_end[];
+
+#define ISA_ROM(IMAGE, DESCRIPTION)
+
+#endif /* ISA_H */
+
diff -Naur grub-0.97.orig/netboot/lance.c grub-0.97/netboot/lance.c
--- grub-0.97.orig/netboot/lance.c	2003-07-09 11:45:37.000000000 +0000
+++ grub-0.97/netboot/lance.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,564 +0,0 @@
-/**************************************************************************
-Etherboot -  BOOTP/TFTP Bootstrap Program
-LANCE NIC driver for Etherboot
-Large portions borrowed from the Linux LANCE driver by Donald Becker
-Ken Yap, July 1997
-***************************************************************************/
-
-/*
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2, or (at
- * your option) any later version.
- */
-
-/* to get some global routines like printf */
-#include "etherboot.h"
-/* to get the interface to the body of the program */
-#include "nic.h"
-#ifdef	INCLUDE_LANCE
-#include "pci.h"
-#endif
-#include "cards.h"
-
-/* Offsets from base I/O address */
-#if	defined(INCLUDE_NE2100) || defined(INCLUDE_LANCE)
-#define	LANCE_ETH_ADDR	0x0
-#define	LANCE_DATA	0x10
-#define	LANCE_ADDR	0x12
-#define	LANCE_RESET	0x14
-#define	LANCE_BUS_IF	0x16
-#define	LANCE_TOTAL_SIZE	0x18
-#endif
-#ifdef	INCLUDE_NI6510
-#define	LANCE_ETH_ADDR	0x8
-#define	LANCE_DATA	0x0
-#define	LANCE_ADDR	0x2
-#define	LANCE_RESET	0x4
-#define	LANCE_BUS_IF	0x6
-#define	LANCE_TOTAL_SIZE	0x10
-#endif
-
-/* lance_poll() now can use multiple Rx buffers to prevent packet loss. Set
- * Set LANCE_LOG_RX_BUFFERS to 0..7 for 1, 2, 4, 8, 16, 32, 64 or 128 Rx
- * buffers. Usually 4 (=16 Rx buffers) is a good value. (Andreas Neuhaus)
- * Decreased to 2 (=4 Rx buffers) (Ken Yap, 20010305) */
-
-#define LANCE_LOG_RX_BUFFERS	2		/* Use 2^2=4 Rx buffers */
-
-#define RX_RING_SIZE		(1 << (LANCE_LOG_RX_BUFFERS))
-#define RX_RING_MOD_MASK	(RX_RING_SIZE - 1)
-#define RX_RING_LEN_BITS	((LANCE_LOG_RX_BUFFERS) << 29)
-
-struct lance_init_block
-{
-	unsigned short	mode;
-	unsigned char	phys_addr[ETH_ALEN];
-	unsigned long	filter[2];
-	Address		rx_ring;
-	Address		tx_ring;
-};
-
-struct lance_rx_head
-{
-	union {
-		Address		base;
-		unsigned char	addr[4];
-	} u;
-	short		buf_length;	/* 2s complement */
-	short		msg_length;
-};
-
-struct lance_tx_head
-{
-	union {
-		Address		base;
-		unsigned char	addr[4];
-	} u;
-	short		buf_length;	/* 2s complement */
-	short		misc;
-};
-
-struct lance_interface
-{
-	struct lance_init_block	init_block;
-	struct lance_rx_head	rx_ring[RX_RING_SIZE];
-	struct lance_tx_head	tx_ring;
-	unsigned char		rbuf[RX_RING_SIZE][ETH_FRAME_LEN+4];
-	unsigned char		tbuf[ETH_FRAME_LEN];
-	/*
-	 * Do not alter the order of the struct members above;
-	 * the hardware depends on the correct alignment.
-	 */
-	int			rx_idx;
-};
-
-#define	LANCE_MUST_PAD		0x00000001
-#define	LANCE_ENABLE_AUTOSELECT	0x00000002
-#define	LANCE_SELECT_PHONELINE	0x00000004
-#define	LANCE_MUST_UNRESET	0x00000008
-
-/* A mapping from the chip ID number to the part number and features.
-   These are from the datasheets -- in real life the '970 version
-   reportedly has the same ID as the '965. */
-static const struct lance_chip_type
-{
-	int	id_number;
-	const char	*name;
-	int	flags;
-} chip_table[] = {
-	{0x0000, "LANCE 7990",			/* Ancient lance chip.  */
-		LANCE_MUST_PAD + LANCE_MUST_UNRESET},
-	{0x0003, "PCnet/ISA 79C960",		/* 79C960 PCnet/ISA.  */
-		LANCE_ENABLE_AUTOSELECT},
-	{0x2260, "PCnet/ISA+ 79C961",		/* 79C961 PCnet/ISA+, Plug-n-Play.  */
-		LANCE_ENABLE_AUTOSELECT},
-	{0x2420, "PCnet/PCI 79C970",		/* 79C970 or 79C974 PCnet-SCSI, PCI. */
-		LANCE_ENABLE_AUTOSELECT},
-	/* Bug: the PCnet/PCI actually uses the PCnet/VLB ID number, so just call
-		it the PCnet32. */
-	{0x2430, "PCnet32",			/* 79C965 PCnet for VL bus. */
-		LANCE_ENABLE_AUTOSELECT},
-        {0x2621, "PCnet/PCI-II 79C970A",        /* 79C970A PCInetPCI II. */
-                LANCE_ENABLE_AUTOSELECT},
-	{0x2625, "PCnet-FAST III 79C973",	/* 79C973 PCInet-FAST III. */
-		LANCE_ENABLE_AUTOSELECT},
-        {0x2626, "PCnet/HomePNA 79C978",        
-                LANCE_ENABLE_AUTOSELECT|LANCE_SELECT_PHONELINE},
-	{0x0, "PCnet (unknown)",
-		LANCE_ENABLE_AUTOSELECT},
-};
-
-/* Define a macro for converting program addresses to real addresses */
-#undef	virt_to_bus
-#define	virt_to_bus(x)		((unsigned long)x)
-
-static int			chip_version;
-static int			lance_version;
-static unsigned short		ioaddr;
-#ifndef	INCLUDE_LANCE
-static int			dma;
-#endif
-static struct lance_interface	*lp;
-
-/* additional 8 bytes for 8-byte alignment space */
-#ifdef	USE_LOWMEM_BUFFER
-#define lance ((char *)0x10000 - (sizeof(struct lance_interface)+8))
-#else
-static char			lance[sizeof(struct lance_interface)+8];
-#endif
-
-#ifndef	INCLUDE_LANCE
-/* DMA defines and helper routines */
-
-/* DMA controller registers */
-#define DMA1_CMD_REG		0x08	/* command register (w) */
-#define DMA1_STAT_REG		0x08	/* status register (r) */
-#define DMA1_REQ_REG            0x09    /* request register (w) */
-#define DMA1_MASK_REG		0x0A	/* single-channel mask (w) */
-#define DMA1_MODE_REG		0x0B	/* mode register (w) */
-#define DMA1_CLEAR_FF_REG	0x0C	/* clear pointer flip-flop (w) */
-#define DMA1_TEMP_REG           0x0D    /* Temporary Register (r) */
-#define DMA1_RESET_REG		0x0D	/* Master Clear (w) */
-#define DMA1_CLR_MASK_REG       0x0E    /* Clear Mask */
-#define DMA1_MASK_ALL_REG       0x0F    /* all-channels mask (w) */
-
-#define DMA2_CMD_REG		0xD0	/* command register (w) */
-#define DMA2_STAT_REG		0xD0	/* status register (r) */
-#define DMA2_REQ_REG            0xD2    /* request register (w) */
-#define DMA2_MASK_REG		0xD4	/* single-channel mask (w) */
-#define DMA2_MODE_REG		0xD6	/* mode register (w) */
-#define DMA2_CLEAR_FF_REG	0xD8	/* clear pointer flip-flop (w) */
-#define DMA2_TEMP_REG           0xDA    /* Temporary Register (r) */
-#define DMA2_RESET_REG		0xDA	/* Master Clear (w) */
-#define DMA2_CLR_MASK_REG       0xDC    /* Clear Mask */
-#define DMA2_MASK_ALL_REG       0xDE    /* all-channels mask (w) */
-
-
-#define DMA_MODE_READ	0x44	/* I/O to memory, no autoinit, increment, single mode */
-#define DMA_MODE_WRITE	0x48	/* memory to I/O, no autoinit, increment, single mode */
-#define DMA_MODE_CASCADE 0xC0   /* pass thru DREQ->HRQ, DACK<-HLDA only */
-
-/* enable/disable a specific DMA channel */
-static void enable_dma(unsigned int dmanr)
-{
-	if (dmanr <= 3)
-		outb_p(dmanr, DMA1_MASK_REG);
-	else
-		outb_p(dmanr & 3, DMA2_MASK_REG);
-}
-
-static void disable_dma(unsigned int dmanr)
-{
-	if (dmanr <= 3)
-		outb_p(dmanr | 4, DMA1_MASK_REG);
-	else
-		outb_p((dmanr & 3) | 4, DMA2_MASK_REG);
-}
-
-/* set mode (above) for a specific DMA channel */
-static void set_dma_mode(unsigned int dmanr, char mode)
-{
-	if (dmanr <= 3)
-		outb_p(mode | dmanr, DMA1_MODE_REG);
-	else
-		outb_p(mode | (dmanr&3), DMA2_MODE_REG);
-}
-#endif	/* !INCLUDE_LANCE */
-
-/**************************************************************************
-RESET - Reset adapter
-***************************************************************************/
-static void lance_reset(struct nic *nic)
-{
-	int		i;
-	Address		l;
-
-	/* Reset the LANCE */
-	(void)inw(ioaddr+LANCE_RESET);
-	/* Un-Reset the LANCE, needed only for the NE2100 */
-	if (chip_table[lance_version].flags & LANCE_MUST_UNRESET)
-		outw(0, ioaddr+LANCE_RESET);
-	if (chip_table[lance_version].flags & LANCE_ENABLE_AUTOSELECT)
-	{
-		/* This is 79C960 specific; Turn on auto-select of media
-		   (AUI, BNC). */
-		outw(0x2, ioaddr+LANCE_ADDR);
-		/* Don't touch 10base2 power bit. */
-		outw(inw(ioaddr+LANCE_BUS_IF) | 0x2, ioaddr+LANCE_BUS_IF);
-	}
-	/* HomePNA cards need to explicitly pick the phoneline interface.
-	 * Some of these cards have ethernet interfaces as well, this
-	 * code might require some modification for those.
-  	 */
-        if (chip_table[lance_version].flags & LANCE_SELECT_PHONELINE) {
-                short media, check ;
-                /* this is specific to HomePNA cards... */
-                outw(49, ioaddr+0x12) ;
-                media = inw(ioaddr+0x16) ;
-#ifdef DEBUG
-                printf("media was %d\n", media) ;
-#endif
-                media &= ~3 ;
-                media |= 1 ;
-#ifdef DEBUG
-                printf("media changed to %d\n", media) ;
-#endif
-                media &= ~3 ;
-                media |= 1 ;
-                outw(49, ioaddr+0x12) ;
-                outw(media, ioaddr+0x16) ;
-                outw(49, ioaddr+0x12) ;
-                check = inw(ioaddr+0x16) ;
-#ifdef DEBUG
-                printf("check %s, media was set properly\n", 
-			check ==  media ? "passed" : "FAILED" ) ; 
-#endif
-	}
- 
-	/* Re-initialise the LANCE, and start it when done. */
-	/* Set station address */
-	for (i = 0; i < ETH_ALEN; ++i)
-		lp->init_block.phys_addr[i] = nic->node_addr[i];
-	/* Preset the receive ring headers */
-	for (i=0; i<RX_RING_SIZE; i++) {
-		lp->rx_ring[i].buf_length = -ETH_FRAME_LEN-4;
-		/* OWN */
-		lp->rx_ring[i].u.base = virt_to_bus(lp->rbuf[i]) & 0xffffff;
-		/* we set the top byte as the very last thing */
-		lp->rx_ring[i].u.addr[3] = 0x80;
-	}
-	lp->rx_idx = 0;
-	lp->init_block.mode = 0x0;	/* enable Rx and Tx */
-	l = (Address)virt_to_bus(&lp->init_block);
-	outw(0x1, ioaddr+LANCE_ADDR);
-	(void)inw(ioaddr+LANCE_ADDR);
-	outw((short)l, ioaddr+LANCE_DATA);
-	outw(0x2, ioaddr+LANCE_ADDR);
-	(void)inw(ioaddr+LANCE_ADDR);
-	outw((short)(l >> 16), ioaddr+LANCE_DATA);
-	outw(0x4, ioaddr+LANCE_ADDR);
-	(void)inw(ioaddr+LANCE_ADDR);
-	outw(0x915, ioaddr+LANCE_DATA);
-	outw(0x0, ioaddr+LANCE_ADDR);
-	(void)inw(ioaddr+LANCE_ADDR);
-	outw(0x4, ioaddr+LANCE_DATA);		/* stop */
-	outw(0x1, ioaddr+LANCE_DATA);		/* init */
-	for (i = 10000; i > 0; --i)
-		if (inw(ioaddr+LANCE_DATA) & 0x100)
-			break;
-#ifdef	DEBUG
-	if (i <= 0)
-		printf("Init timed out\n");
-#endif
-	/* Apparently clearing the InitDone bit here triggers a bug
-	   in the '974. (Mark Stockton) */
-	outw(0x2, ioaddr+LANCE_DATA);		/* start */
-}
-
-/**************************************************************************
-POLL - Wait for a frame
-***************************************************************************/
-static int lance_poll(struct nic *nic)
-{
-	int		status;
-
-	status = lp->rx_ring[lp->rx_idx].u.base >> 24;
-	if (status & 0x80)
-		return (0);
-#ifdef	DEBUG
-	printf("LANCE packet received rx_ring.u.base %X mcnt %hX csr0 %hX\n",
-		lp->rx_ring[lp->rx_idx].u.base, lp->rx_ring[lp->rx_idx].msg_length,
-		inw(ioaddr+LANCE_DATA));
-#endif
-	if (status == 0x3)
-		memcpy(nic->packet, lp->rbuf[lp->rx_idx], nic->packetlen = lp->rx_ring[lp->rx_idx].msg_length);
-	/* Andrew Boyd of QNX reports that some revs of the 79C765
-	   clear the buffer length */
-	lp->rx_ring[lp->rx_idx].buf_length = -ETH_FRAME_LEN-4;
-	lp->rx_ring[lp->rx_idx].u.addr[3] |= 0x80;	/* prime for next receive */
-
-	/* I'm not sure if the following is still ok with multiple Rx buffers, but it works */
-	outw(0x0, ioaddr+LANCE_ADDR);
-	(void)inw(ioaddr+LANCE_ADDR);
-	outw(0x500, ioaddr+LANCE_DATA);		/* clear receive + InitDone */
-
-	/* Switch to the next Rx ring buffer */
-	lp->rx_idx = (lp->rx_idx + 1) & RX_RING_MOD_MASK;
-
-	return (status == 0x3);
-}
-
-/**************************************************************************
-TRANSMIT - Transmit a frame
-***************************************************************************/
-static void lance_transmit(
-	struct nic *nic,
-	const char *d,			/* Destination */
-	unsigned int t,			/* Type */
-	unsigned int s,			/* size */
-	const char *p)			/* Packet */
-{
-	unsigned long		time;
-
-	/* copy the packet to ring buffer */
-	memcpy(lp->tbuf, d, ETH_ALEN);	/* dst */
-	memcpy(&lp->tbuf[ETH_ALEN], nic->node_addr, ETH_ALEN); /* src */
-	lp->tbuf[ETH_ALEN+ETH_ALEN] = t >> 8;	/* type */
-	lp->tbuf[ETH_ALEN+ETH_ALEN+1] = t;	/* type */
-	memcpy(&lp->tbuf[ETH_HLEN], p, s);
-	s += ETH_HLEN;
-	if (chip_table[chip_version].flags & LANCE_MUST_PAD)
-		while (s < ETH_ZLEN)	/* pad to min length */
-			lp->tbuf[s++] = 0;
-	lp->tx_ring.buf_length = -s;
-	lp->tx_ring.misc = 0x0;
-	/* OWN, STP, ENP */
-	lp->tx_ring.u.base = virt_to_bus(lp->tbuf) & 0xffffff;
-	/* we set the top byte as the very last thing */
-	lp->tx_ring.u.addr[3] = 0x83;
-	/* Trigger an immediate send poll */
-	outw(0x0, ioaddr+LANCE_ADDR);
-	(void)inw(ioaddr+LANCE_ADDR);	/* as in the datasheets... */
-	/* Klaus Espenlaub: the value below was 0x48, but that enabled the
-	 * interrupt line, causing a hang if for some reasone the interrupt
-	 * controller had the LANCE interrupt enabled.  I have no idea why
-	 * nobody ran into this before...  */
-	outw(0x08, ioaddr+LANCE_DATA);
-	/* wait for transmit complete */
-	time = currticks() + TICKS_PER_SEC;		/* wait one second */
-	while (currticks() < time && (lp->tx_ring.u.base & 0x80000000) != 0)
-		;
-	if ((lp->tx_ring.u.base & 0x80000000) != 0)
-		printf("LANCE timed out on transmit\n");
-	(void)inw(ioaddr+LANCE_ADDR);
-	outw(0x200, ioaddr+LANCE_DATA);		/* clear transmit + InitDone */
-#ifdef	DEBUG
-	printf("tx_ring.u.base %X tx_ring.buf_length %hX tx_ring.misc %hX csr0 %hX\n",
-		lp->tx_ring.u.base, lp->tx_ring.buf_length, lp->tx_ring.misc,
-		inw(ioaddr+LANCE_DATA));
-#endif
-}
-
-static void lance_disable(struct nic *nic)
-{
-	(void)inw(ioaddr+LANCE_RESET);
-	if (chip_table[lance_version].flags & LANCE_MUST_UNRESET)
-		outw(0, ioaddr+LANCE_RESET);
-
-	outw(0, ioaddr+LANCE_ADDR);
-	outw(0x0004, ioaddr+LANCE_DATA);	/* stop the LANCE */
-
-#ifndef	INCLUDE_LANCE
-	disable_dma(dma);
-#endif
-}
-
-#ifdef	INCLUDE_LANCE
-static int lance_probe1(struct nic *nic, struct pci_device *pci)
-#else
-static int lance_probe1(struct nic *nic)
-#endif
-{
-	int			reset_val ;
-	unsigned int		i;
-	Address			l;
-	short			dma_channels;
-#ifndef	INCLUDE_LANCE
-	static const char	dmas[] = { 5, 6, 7, 3 };
-#endif
-
-	reset_val = inw(ioaddr+LANCE_RESET);
-	outw(reset_val, ioaddr+LANCE_RESET);
-#if	1  /* Klaus Espenlaub -- was #ifdef	INCLUDE_NE2100*/
-	outw(0x0, ioaddr+LANCE_ADDR);	/* Switch to window 0 */
-	if (inw(ioaddr+LANCE_DATA) != 0x4)
-		return (-1);
-#endif
-	outw(88, ioaddr+LANCE_ADDR);	/* Get the version of the chip */
-	if (inw(ioaddr+LANCE_ADDR) != 88)
-		lance_version = 0;
-	else
-	{
-		chip_version = inw(ioaddr+LANCE_DATA);
-		outw(89, ioaddr+LANCE_ADDR);
-		chip_version |= inw(ioaddr+LANCE_DATA) << 16;
-		if ((chip_version & 0xfff) != 0x3)
-			return (-1);
-		chip_version = (chip_version >> 12) & 0xffff;
-		for (lance_version = 1; chip_table[lance_version].id_number != 0; ++lance_version)
-			if (chip_table[lance_version].id_number == chip_version)
-				break;
-	}
-	/* make sure data structure is 8-byte aligned */
-	l = ((Address)lance + 7) & ~7;
-	lp = (struct lance_interface *)l;
-	lp->init_block.mode = 0x3;	/* disable Rx and Tx */
-	lp->init_block.filter[0] = lp->init_block.filter[1] = 0x0;
-	/* using multiple Rx buffer and a single Tx buffer */
-	lp->init_block.rx_ring = (virt_to_bus(&lp->rx_ring) & 0xffffff) | RX_RING_LEN_BITS;
-	lp->init_block.tx_ring = virt_to_bus(&lp->tx_ring) & 0xffffff;
-	l = virt_to_bus(&lp->init_block);
-	outw(0x1, ioaddr+LANCE_ADDR);
-	(void)inw(ioaddr+LANCE_ADDR);
-	outw((unsigned short)l, ioaddr+LANCE_DATA);
-	outw(0x2, ioaddr+LANCE_ADDR);
-	(void)inw(ioaddr+LANCE_ADDR);
-	outw((unsigned short)(l >> 16), ioaddr+LANCE_DATA);
-	outw(0x4, ioaddr+LANCE_ADDR);
-	(void)inw(ioaddr+LANCE_ADDR);
-	outw(0x915, ioaddr+LANCE_DATA);
-	outw(0x0, ioaddr+LANCE_ADDR);
-	(void)inw(ioaddr+LANCE_ADDR);
-	/* Get station address */
-	for (i = 0; i < ETH_ALEN; ++i) {
-		nic->node_addr[i] = inb(ioaddr+LANCE_ETH_ADDR+i);
-	}
-#ifndef	INCLUDE_LANCE
-	/* now probe for DMA channel */
-	dma_channels = ((inb(DMA1_STAT_REG) >> 4) & 0xf) |
-		(inb(DMA2_STAT_REG) & 0xf0);
-	/* need to fix when PCI provides DMA info */
-	for (i = 0; i < (sizeof(dmas)/sizeof(dmas[0])); ++i)
-	{
-		int		j;
-
-		dma = dmas[i];
-		/* Don't enable a permanently busy DMA channel,
-		   or the machine will hang */
-		if (dma_channels & (1 << dma))
-			continue;
-		outw(0x7f04, ioaddr+LANCE_DATA);	/* clear memory error bits */
-		set_dma_mode(dma, DMA_MODE_CASCADE);
-		enable_dma(dma);
-		outw(0x1, ioaddr+LANCE_DATA);		/* init */
-		for (j = 100; j > 0; --j)
-			if (inw(ioaddr+LANCE_DATA) & 0x900)
-				break;
-		if (inw(ioaddr+LANCE_DATA) & 0x100)
-			break;
-		else
-			disable_dma(dma);
-	}
-	if (i >= (sizeof(dmas)/sizeof(dmas[0])))
-		dma = 0;
-	printf("\n%s base %#X, DMA %d, addr %!\n",
-		chip_table[lance_version].name, ioaddr, dma, nic->node_addr);
-#else
-	printf(" %s base %#hX, addr %!\n", chip_table[lance_version].name, ioaddr, nic->node_addr);
-#endif
-	if (chip_table[chip_version].flags & LANCE_ENABLE_AUTOSELECT) {
-		/* Turn on auto-select of media (10baseT or BNC) so that the
-		 * user watch the LEDs. */
-		outw(0x0002, ioaddr+LANCE_ADDR);
-		/* Don't touch 10base2 power bit. */
-		outw(inw(ioaddr+LANCE_BUS_IF) | 0x0002, ioaddr+LANCE_BUS_IF);
-	}
-	return (lance_version);
-}
-
-/**************************************************************************
-PROBE - Look for an adapter, this routine's visible to the outside
-***************************************************************************/
-
-#ifdef	INCLUDE_LANCE
-struct nic *lancepci_probe(struct nic *nic, unsigned short *probe_addrs, struct pci_device *pci)
-#endif
-#ifdef	INCLUDE_NE2100
-struct nic *ne2100_probe(struct nic *nic, unsigned short *probe_addrs)
-#endif
-#ifdef	INCLUDE_NI6510
-struct nic *ni6510_probe(struct nic *nic, unsigned short *probe_addrs)
-#endif
-{
-	unsigned short		*p;
-#ifndef	INCLUDE_LANCE
-	static unsigned short	io_addrs[] = { 0x300, 0x320, 0x340, 0x360, 0 };
-#endif
-
-	/* if probe_addrs is 0, then routine can use a hardwired default */
-	if (probe_addrs == 0) {
-#ifdef	INCLUDE_LANCE
-		return 0;
-#else
-		probe_addrs = io_addrs;
-#endif
-	}
-	for (p = probe_addrs; (ioaddr = *p) != 0; ++p)
-	{
-		char	offset15, offset14 = inb(ioaddr + 14);
-		unsigned short	pci_cmd;
-
-#ifdef	INCLUDE_NE2100
-		if ((offset14 == 0x52 || offset14 == 0x57) &&
-		 ((offset15 = inb(ioaddr + 15)) == 0x57 || offset15 == 0x44))
-			if (lance_probe1(nic) >= 0)
-				break;
-#endif
-#ifdef	INCLUDE_NI6510
-		if ((offset14 == 0x00 || offset14 == 0x52) &&
-		 ((offset15 = inb(ioaddr + 15)) == 0x55 || offset15 == 0x44))
-			if (lance_probe1(nic) >= 0)
-				break;
-#endif
-#ifdef	INCLUDE_LANCE
-		adjust_pci_device(pci);
-		if (lance_probe1(nic, pci) >= 0)
-			break;
-#endif
-	}
-	/* if board found */
-	if (ioaddr != 0)
-	{
-		/* point to NIC specific routines */
-		lance_reset(nic);
-		nic->reset = lance_reset;
-		nic->poll = lance_poll;
-		nic->transmit = lance_transmit;
-		nic->disable = lance_disable;
-		return nic;
-	}
-
-	/* no board found */
-	return 0;
-}
diff -Naur grub-0.97.orig/netboot/latch.h grub-0.97/netboot/latch.h
--- grub-0.97.orig/netboot/latch.h	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/latch.h	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,10 @@
+#ifndef LATCH_H
+#define LATCH_H
+
+#define	TICKS_PER_SEC		18
+
+/* For different calibrators of the TSC move the declaration of
+ * sleep_latch and the definitions of it's length here...
+ */
+
+#endif /* LATCH_H */
diff -Naur grub-0.97.orig/netboot/linux-asm-io.h grub-0.97/netboot/linux-asm-io.h
--- grub-0.97.orig/netboot/linux-asm-io.h	2003-07-09 11:45:37.000000000 +0000
+++ grub-0.97/netboot/linux-asm-io.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,187 +0,0 @@
-#ifndef	_ASM_IO_H
-#define _ASM_IO_H
-
-/*
- * This file contains the definitions for the x86 IO instructions
- * inb/inw/inl/outb/outw/outl and the "string versions" of the same
- * (insb/insw/insl/outsb/outsw/outsl). You can also use "pausing"
- * versions of the single-IO instructions (inb_p/inw_p/..).
- *
- * This file is not meant to be obfuscating: it's just complicated
- * to (a) handle it all in a way that makes gcc able to optimize it
- * as well as possible and (b) trying to avoid writing the same thing
- * over and over again with slight variations and possibly making a
- * mistake somewhere.
- */
-
-/*
- * Thanks to James van Artsdalen for a better timing-fix than
- * the two short jumps: using outb's to a nonexistent port seems
- * to guarantee better timings even on fast machines.
- *
- * On the other hand, I'd like to be sure of a non-existent port:
- * I feel a bit unsafe about using 0x80 (should be safe, though)
- *
- *		Linus
- */
-
-#ifdef	SLOW_IO_BY_JUMPING
-#define __SLOW_DOWN_IO __asm__ __volatile__("jmp 1f\n1:\tjmp 1f\n1:")
-#else
-#define __SLOW_DOWN_IO __asm__ __volatile__("outb %al,$0x80")
-#endif
-
-#ifdef	REALLY_SLOW_IO
-#define SLOW_DOWN_IO { __SLOW_DOWN_IO; __SLOW_DOWN_IO; __SLOW_DOWN_IO; __SLOW_DOWN_IO; }
-#else
-#define SLOW_DOWN_IO __SLOW_DOWN_IO
-#endif
-
-/*
- * readX/writeX() are used to access memory mapped devices. On some
- * architectures the memory mapped IO stuff needs to be accessed
- * differently. On the x86 architecture, we just read/write the
- * memory location directly.
- */
-#define readb(addr) (*(volatile unsigned char *) (addr))
-#define readw(addr) (*(volatile unsigned short *) (addr))
-#define readl(addr) (*(volatile unsigned int *) (addr))
-
-#define writeb(b,addr) ((*(volatile unsigned char *) (addr)) = (b))
-#define writew(b,addr) ((*(volatile unsigned short *) (addr)) = (b))
-#define writel(b,addr) ((*(volatile unsigned int *) (addr)) = (b))
-
-#define memset_io(a,b,c)	memset((void *)(a),(b),(c))
-#define memcpy_fromio(a,b,c)	memcpy((a),(void *)(b),(c))
-#define memcpy_toio(a,b,c)	memcpy((void *)(a),(b),(c))
-
-/*
- * Again, i386 does not require mem IO specific function.
- */
-
-#define eth_io_copy_and_sum(a,b,c,d)	eth_copy_and_sum((a),(void *)(b),(c),(d))
-
-/*
- * Talk about misusing macros..
- */
-
-#define __OUT1(s,x) \
-extern void __out##s(unsigned x value, unsigned short port); \
-extern inline void __out##s(unsigned x value, unsigned short port) {
-
-#define __OUT2(s,s1,s2) \
-__asm__ __volatile__ ("out" #s " %" s1 "0,%" s2 "1"
-
-#define __OUT(s,s1,x) \
-__OUT1(s,x) __OUT2(s,s1,"w") : : "a" (value), "d" (port)); } \
-__OUT1(s##c,x) __OUT2(s,s1,"") : : "a" (value), "id" (port)); } \
-__OUT1(s##_p,x) __OUT2(s,s1,"w") : : "a" (value), "d" (port)); SLOW_DOWN_IO; } \
-__OUT1(s##c_p,x) __OUT2(s,s1,"") : : "a" (value), "id" (port)); SLOW_DOWN_IO; }
-
-#define __IN1(s,x) \
-extern unsigned x __in##s(unsigned short port); \
-extern inline unsigned x __in##s(unsigned short port) { unsigned x _v;
-
-#define __IN2(s,s1,s2) \
-__asm__ __volatile__ ("in" #s " %" s2 "1,%" s1 "0"
-
-#define __IN(s,s1,x,i...) \
-__IN1(s,x) __IN2(s,s1,"w") : "=a" (_v) : "d" (port) ,##i ); return _v; } \
-__IN1(s##c,x) __IN2(s,s1,"") : "=a" (_v) : "id" (port) ,##i ); return _v; } \
-__IN1(s##_p,x) __IN2(s,s1,"w") : "=a" (_v) : "d" (port) ,##i ); SLOW_DOWN_IO; return _v; } \
-__IN1(s##c_p,x) __IN2(s,s1,"") : "=a" (_v) : "id" (port) ,##i ); SLOW_DOWN_IO; return _v; }
-
-#define __INS(s) \
-extern void ins##s(unsigned short port, void * addr, unsigned long count); \
-extern inline void ins##s(unsigned short port, void * addr, unsigned long count) \
-{ __asm__ __volatile__ ("cld ; rep ; ins" #s \
-: "=D" (addr), "=c" (count) : "d" (port),"0" (addr),"1" (count)); }
-
-#define __OUTS(s) \
-extern void outs##s(unsigned short port, const void * addr, unsigned long  count); \
-extern inline void outs##s(unsigned short port, const void * addr, unsigned long count) \
-{ __asm__ __volatile__ ("cld ; rep ; outs" #s \
-: "=S" (addr), "=c" (count) : "d" (port),"0" (addr),"1" (count)); }
-
-__IN(b,"", char)
-__IN(w,"",short)
-__IN(l,"", long)
-
-__OUT(b,"b",char)
-__OUT(w,"w",short)
-__OUT(l,,int)
-
-__INS(b)
-__INS(w)
-__INS(l)
-
-__OUTS(b)
-__OUTS(w)
-__OUTS(l)
-
-/*
- * Note that due to the way __builtin_constant_p() works, you
- *  - can't use it inside a inline function (it will never be true)
- *  - you don't have to worry about side effects within the __builtin..
- */
-#define outb(val,port) \
-((__builtin_constant_p((port)) && (port) < 256) ? \
-	__outbc((val),(port)) : \
-	__outb((val),(port)))
-
-#define inb(port) \
-((__builtin_constant_p((port)) && (port) < 256) ? \
-	__inbc(port) : \
-	__inb(port))
-
-#define outb_p(val,port) \
-((__builtin_constant_p((port)) && (port) < 256) ? \
-	__outbc_p((val),(port)) : \
-	__outb_p((val),(port)))
-
-#define inb_p(port) \
-((__builtin_constant_p((port)) && (port) < 256) ? \
-	__inbc_p(port) : \
-	__inb_p(port))
-
-#define outw(val,port) \
-((__builtin_constant_p((port)) && (port) < 256) ? \
-	__outwc((val),(port)) : \
-	__outw((val),(port)))
-
-#define inw(port) \
-((__builtin_constant_p((port)) && (port) < 256) ? \
-	__inwc(port) : \
-	__inw(port))
-
-#define outw_p(val,port) \
-((__builtin_constant_p((port)) && (port) < 256) ? \
-	__outwc_p((val),(port)) : \
-	__outw_p((val),(port)))
-
-#define inw_p(port) \
-((__builtin_constant_p((port)) && (port) < 256) ? \
-	__inwc_p(port) : \
-	__inw_p(port))
-
-#define outl(val,port) \
-((__builtin_constant_p((port)) && (port) < 256) ? \
-	__outlc((val),(port)) : \
-	__outl((val),(port)))
-
-#define inl(port) \
-((__builtin_constant_p((port)) && (port) < 256) ? \
-	__inlc(port) : \
-	__inl(port))
-
-#define outl_p(val,port) \
-((__builtin_constant_p((port)) && (port) < 256) ? \
-	__outlc_p((val),(port)) : \
-	__outl_p((val),(port)))
-
-#define inl_p(port) \
-((__builtin_constant_p((port)) && (port) < 256) ? \
-	__inlc_p(port) : \
-	__inl_p(port))
-
-#endif
diff -Naur grub-0.97.orig/netboot/linux-asm-string.h grub-0.97/netboot/linux-asm-string.h
--- grub-0.97.orig/netboot/linux-asm-string.h	2003-07-09 11:45:37.000000000 +0000
+++ grub-0.97/netboot/linux-asm-string.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,291 +0,0 @@
-/*
- * Taken from Linux /usr/include/asm/string.h
- * All except memcpy, memmove, memset and memcmp removed.
- */
-
-#ifndef	_I386_STRING_H_
-#define _I386_STRING_H_
-
-/*
- * This string-include defines all string functions as inline
- * functions. Use gcc. It also assumes ds=es=data space, this should be
- * normal. Most of the string-functions are rather heavily hand-optimized,
- * see especially strtok,strstr,str[c]spn. They should work, but are not
- * very easy to understand. Everything is done entirely within the register
- * set, making the functions fast and clean. String instructions have been
- * used through-out, making for "slightly" unclear code :-)
- *
- *		NO Copyright (C) 1991, 1992 Linus Torvalds,
- *		consider these trivial functions to be PD.
- */
-
-typedef int	size_t;
-
-extern void *__memcpy(void * to, const void * from, size_t n);
-extern void *__constant_memcpy(void * to, const void * from, size_t n);
-extern void *memmove(void * dest,const void * src, size_t n);
-extern void *__memset_generic(void * s, char c,size_t count);
-extern void *__constant_c_memset(void * s, unsigned long c, size_t count);
-extern void *__constant_c_and_count_memset(void * s, unsigned long pattern, size_t count);
-
-
-extern inline void * __memcpy(void * to, const void * from, size_t n)
-{
-int d0, d1, d2;
-__asm__ __volatile__(
-	"cld\n\t"
-	"rep ; movsl\n\t"
-	"testb $2,%b4\n\t"
-	"je 1f\n\t"
-	"movsw\n"
-	"1:\ttestb $1,%b4\n\t"
-	"je 2f\n\t"
-	"movsb\n"
-	"2:"
-	: "=&c" (d0), "=&D" (d1), "=&S" (d2)
-	:"0" (n/4), "q" (n),"1" ((long) to),"2" ((long) from)
-	: "memory");
-return (to);
-}
-
-/*
- * This looks horribly ugly, but the compiler can optimize it totally,
- * as the count is constant.
- */
-extern inline void * __constant_memcpy(void * to, const void * from, size_t n)
-{
-	switch (n) {
-		case 0:
-			return to;
-		case 1:
-			*(unsigned char *)to = *(const unsigned char *)from;
-			return to;
-		case 2:
-			*(unsigned short *)to = *(const unsigned short *)from;
-			return to;
-		case 3:
-			*(unsigned short *)to = *(const unsigned short *)from;
-			*(2+(unsigned char *)to) = *(2+(const unsigned char *)from);
-			return to;
-		case 4:
-			*(unsigned long *)to = *(const unsigned long *)from;
-			return to;
-		case 6:	/* for Ethernet addresses */
-			*(unsigned long *)to = *(const unsigned long *)from;
-			*(2+(unsigned short *)to) = *(2+(const unsigned short *)from);
-			return to;
-		case 8:
-			*(unsigned long *)to = *(const unsigned long *)from;
-			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
-			return to;
-		case 12:
-			*(unsigned long *)to = *(const unsigned long *)from;
-			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
-			*(2+(unsigned long *)to) = *(2+(const unsigned long *)from);
-			return to;
-		case 16:
-			*(unsigned long *)to = *(const unsigned long *)from;
-			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
-			*(2+(unsigned long *)to) = *(2+(const unsigned long *)from);
-			*(3+(unsigned long *)to) = *(3+(const unsigned long *)from);
-			return to;
-		case 20:
-			*(unsigned long *)to = *(const unsigned long *)from;
-			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
-			*(2+(unsigned long *)to) = *(2+(const unsigned long *)from);
-			*(3+(unsigned long *)to) = *(3+(const unsigned long *)from);
-			*(4+(unsigned long *)to) = *(4+(const unsigned long *)from);
-			return to;
-	}
-#define COMMON(x) \
-__asm__ __volatile__( \
-	"cld\n\t" \
-	"rep ; movsl" \
-	x \
-	: "=&c" (d0), "=&D" (d1), "=&S" (d2) \
-	: "0" (n/4),"1" ((long) to),"2" ((long) from) \
-	: "memory");
-{
-	int d0, d1, d2;
-	switch (n % 4) {
-		case 0: COMMON(""); return to;
-		case 1: COMMON("\n\tmovsb"); return to;
-		case 2: COMMON("\n\tmovsw"); return to;
-		default: COMMON("\n\tmovsw\n\tmovsb"); return to;
-	}
-}
-
-#undef COMMON
-}
-
-#define __HAVE_ARCH_MEMCPY
-#define memcpy(t, f, n) \
-(__builtin_constant_p(n) ? \
- __constant_memcpy((t),(f),(n)) : \
- __memcpy((t),(f),(n)))
-
-#define __HAVE_ARCH_MEMMOVE
-extern inline void * memmove(void * dest,const void * src, size_t n)
-{
-int d0, d1, d2;
-if (dest<src)
-__asm__ __volatile__(
-	"cld\n\t"
-	"rep\n\t"
-	"movsb"
-	: "=&c" (d0), "=&S" (d1), "=&D" (d2)
-	:"0" (n),"1" (src),"2" (dest)
-	: "memory");
-else
-__asm__ __volatile__(
-	"std\n\t"
-	"rep\n\t"
-	"movsb\n\t"
-	"cld"
-	: "=&c" (d0), "=&S" (d1), "=&D" (d2)
-	:"0" (n),
-	 "1" (n-1+(const char *)src),
-	 "2" (n-1+(char *)dest)
-	:"memory");
-return dest;
-}
-
-#define memcmp __builtin_memcmp
-
-extern inline void * __memset_generic(void * s, char c,size_t count)
-{
-int d0, d1;
-__asm__ __volatile__(
-	"cld\n\t"
-	"rep\n\t"
-	"stosb"
-	: "=&c" (d0), "=&D" (d1)
-	:"a" (c),"1" (s),"0" (count)
-	:"memory");
-return s;
-}
-
-/* we might want to write optimized versions of these later */
-#define __constant_count_memset(s,c,count) __memset_generic((s),(c),(count))
-
-/*
- * memset(x,0,y) is a reasonably common thing to do, so we want to fill
- * things 32 bits at a time even when we don't know the size of the
- * area at compile-time..
- */
-extern inline void * __constant_c_memset(void * s, unsigned long c, size_t count)
-{
-int d0, d1;
-__asm__ __volatile__(
-	"cld\n\t"
-	"rep ; stosl\n\t"
-	"testb $2,%b3\n\t"
-	"je 1f\n\t"
-	"stosw\n"
-	"1:\ttestb $1,%b3\n\t"
-	"je 2f\n\t"
-	"stosb\n"
-	"2:"
-	: "=&c" (d0), "=&D" (d1)
-	:"a" (c), "q" (count), "0" (count/4), "1" ((long) s)
-	:"memory");
-return (s);
-}
-
-/*
- * This looks horribly ugly, but the compiler can optimize it totally,
- * as we by now know that both pattern and count is constant..
- */
-extern inline void * __constant_c_and_count_memset(void * s, unsigned long pattern, size_t count)
-{
-	switch (count) {
-		case 0:
-			return s;
-		case 1:
-			*(unsigned char *)s = pattern;
-			return s;
-		case 2:
-			*(unsigned short *)s = pattern;
-			return s;
-		case 3:
-			*(unsigned short *)s = pattern;
-			*(2+(unsigned char *)s) = pattern;
-			return s;
-		case 4:
-			*(unsigned long *)s = pattern;
-			return s;
-	}
-#define COMMON(x) \
-__asm__  __volatile__("cld\n\t" \
-	"rep ; stosl" \
-	x \
-	: "=&c" (d0), "=&D" (d1) \
-	: "a" (pattern),"0" (count/4),"1" ((long) s) \
-	: "memory")
-{
-	int d0, d1;
-	switch (count % 4) {
-		case 0: COMMON(""); return s;
-		case 1: COMMON("\n\tstosb"); return s;
-		case 2: COMMON("\n\tstosw"); return s;
-		default: COMMON("\n\tstosw\n\tstosb"); return s;
-	}
-}
-
-#undef COMMON
-}
-
-#define __constant_c_x_memset(s, c, count) \
-(__builtin_constant_p(count) ? \
- __constant_c_and_count_memset((s),(c),(count)) : \
- __constant_c_memset((s),(c),(count)))
-
-#define __memset(s, c, count) \
-(__builtin_constant_p(count) ? \
- __constant_count_memset((s),(c),(count)) : \
- __memset_generic((s),(c),(count)))
-
-#define __HAVE_ARCH_MEMSET
-#define memset(s, c, count) \
-(__builtin_constant_p(c) ? \
- __constant_c_x_memset((s),(c),(count)) : \
- __memset((s),(c),(count)))
-
-#define __HAVE_ARCH_STRNCMP
-static inline int strncmp(const char * cs,const char * ct,size_t count)
-{
-register int __res;
-int d0, d1, d2;
-__asm__ __volatile__(
-	"1:\tdecl %3\n\t"
-	"js 2f\n\t"
-	"lodsb\n\t"
-	"scasb\n\t"
-	"jne 3f\n\t"
-	"testb %%al,%%al\n\t"
-	"jne 1b\n"
-	"2:\txorl %%eax,%%eax\n\t"
-	"jmp 4f\n"
-	"3:\tsbbl %%eax,%%eax\n\t"
-	"orb $1,%%al\n"
-	"4:"
-		     :"=a" (__res), "=&S" (d0), "=&D" (d1), "=&c" (d2)
-		     :"1" (cs),"2" (ct),"3" (count));
-return __res;
-}
-
-#define __HAVE_ARCH_STRLEN
-static inline size_t strlen(const char * s)
-{
-int d0;
-register int __res;
-__asm__ __volatile__(
-	"repne\n\t"
-	"scasb\n\t"
-	"notl %0\n\t"
-	"decl %0"
-	:"=c" (__res), "=&D" (d0) :"1" (s),"a" (0), "0" (0xffffffff));
-return __res;
-}
-
-#endif
diff -Naur grub-0.97.orig/netboot/little_bswap.h grub-0.97/netboot/little_bswap.h
--- grub-0.97.orig/netboot/little_bswap.h	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/little_bswap.h	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,17 @@
+#ifndef ETHERBOOT_LITTLE_BSWAP_H
+#define ETHERBOOT_LITTLE_BSWAP_H
+
+#define ntohl(x)	__bswap_32(x)
+#define htonl(x) 	__bswap_32(x)
+#define ntohs(x) 	__bswap_16(x)
+#define htons(x) 	__bswap_16(x)
+#define cpu_to_le32(x)	(x)
+#define cpu_to_le16(x)	(x)
+#define cpu_to_be32(x)	__bswap_32(x)
+#define cpu_to_be16(x)	__bswap_16(x)
+#define le32_to_cpu(x)	(x)
+#define le16_to_cpu(x)	(x)
+#define be32_to_cpu(x)	__bswap_32(x)
+#define be16_to_cpu(x)	__bswap_16(x)
+
+#endif /* ETHERBOOT_LITTLE_BSWAP_H */
diff -Naur grub-0.97.orig/netboot/main.c grub-0.97/netboot/main.c
--- grub-0.97.orig/netboot/main.c	2004-05-20 22:19:33.000000000 +0000
+++ grub-0.97/netboot/main.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,1171 +0,0 @@
-/*
- *  GRUB  --  GRand Unified Bootloader
- *  Copyright (C) 2000,2001,2002  Free Software Foundation, Inc.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-/* Based on "src/main.c" in etherboot-5.0.5.  */
-
-/**************************************************************************
-ETHERBOOT -  BOOTP/TFTP Bootstrap Program
-
-Author: Martin Renters
-  Date: Dec/93
-  
-Literature dealing with the network protocols:
-       ARP - RFC826
-       RARP - RFC903
-       UDP - RFC768
-       BOOTP - RFC951, RFC2132 (vendor extensions)
-       DHCP - RFC2131, RFC2132 (options)
-       TFTP - RFC1350, RFC2347 (options), RFC2348 (blocksize), RFC2349 (tsize)
-       RPC - RFC1831, RFC1832 (XDR), RFC1833 (rpcbind/portmapper)
-       NFS - RFC1094, RFC1813 (v3, useful for clarifications, not implemented)
-
-**************************************************************************/
-
-#define GRUB	1
-#include <etherboot.h>
-#include <nic.h>
-
-/* #define DEBUG	1 */
-
-struct arptable_t arptable[MAX_ARP];
-
-/* Set if the user pushes Control-C.  */
-int ip_abort = 0;
-/* Set if an ethernet card is probed and IP addresses are set.  */
-int network_ready = 0;
-
-struct rom_info rom;
-
-static int vendorext_isvalid;
-static unsigned long netmask;
-static struct bootpd_t bootp_data;
-static unsigned long xid;
-static unsigned char *end_of_rfc1533 = NULL;
-
-#ifndef	NO_DHCP_SUPPORT
-#endif /* NO_DHCP_SUPPORT */
-
-/* Eth */
-static unsigned char vendorext_magic[] = {0xE4, 0x45, 0x74, 0x68};
-static const unsigned char broadcast[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
-
-#ifdef	NO_DHCP_SUPPORT
-
-static unsigned char rfc1533_cookie[5] = {RFC1533_COOKIE, RFC1533_END};
-
-#else /* ! NO_DHCP_SUPPORT */
-
-static int dhcp_reply;
-static in_addr dhcp_server = {0L};
-static in_addr dhcp_addr = {0L};
-static unsigned char rfc1533_cookie[] = {RFC1533_COOKIE};
-static unsigned char rfc1533_end[] = {RFC1533_END};
-
-static const unsigned char dhcpdiscover[] =
-{
-  RFC2132_MSG_TYPE, 1, DHCPDISCOVER,	
-  RFC2132_MAX_SIZE,2,	/* request as much as we can */
-  ETH_MAX_MTU / 256, ETH_MAX_MTU % 256,
-  RFC2132_PARAM_LIST, 4, RFC1533_NETMASK, RFC1533_GATEWAY,
-  RFC1533_HOSTNAME, RFC1533_EXTENSIONPATH
-};
-
-static const unsigned char dhcprequest[] =
-{
-  RFC2132_MSG_TYPE, 1, DHCPREQUEST,
-  RFC2132_SRV_ID, 4, 0, 0, 0, 0,
-  RFC2132_REQ_ADDR, 4, 0, 0, 0, 0,
-  RFC2132_MAX_SIZE, 2,	/* request as much as we can */
-  ETH_MAX_MTU / 256, ETH_MAX_MTU % 256,
-  /* request parameters */
-  RFC2132_PARAM_LIST,
-  /* 4 standard + 2 vendortags */
-  4 + 2,
-  /* Standard parameters */
-  RFC1533_NETMASK, RFC1533_GATEWAY,
-  RFC1533_HOSTNAME, RFC1533_EXTENSIONPATH,
-  /* Etherboot vendortags */
-  RFC1533_VENDOR_MAGIC,
-  RFC1533_VENDOR_CONFIGFILE,
-};
-
-#endif /* ! NO_DHCP_SUPPORT */
-
-static unsigned short ipchksum (unsigned short *ip, int len);
-static unsigned short udpchksum (struct iphdr *packet);
-
-void
-print_network_configuration (void)
-{
-  if (! eth_probe ())
-    grub_printf ("No ethernet card found.\n");
-  else if (! network_ready)
-    grub_printf ("Not initialized yet.\n");
-  else
-    {
-      etherboot_printf ("Address: %@\n", arptable[ARP_CLIENT].ipaddr.s_addr);
-      etherboot_printf ("Netmask: %@\n", netmask);
-      etherboot_printf ("Server: %@\n", arptable[ARP_SERVER].ipaddr.s_addr);
-      etherboot_printf ("Gateway: %@\n", arptable[ARP_GATEWAY].ipaddr.s_addr);
-    }
-}
-
-
-/**************************************************************************
-DEFAULT_NETMASK - Return default netmask for IP address
-**************************************************************************/
-static inline unsigned long 
-default_netmask (void)
-{
-  int net = ntohl (arptable[ARP_CLIENT].ipaddr.s_addr) >> 24;
-  if (net <= 127)
-    return (htonl (0xff000000));
-  else if (net < 192)
-    return (htonl (0xffff0000));
-  else
-    return (htonl (0xffffff00));
-}
-
-/* ifconfig - configure network interface.  */
-int
-ifconfig (char *ip, char *sm, char *gw, char *svr)
-{
-  in_addr tmp;
-  
-  if (sm) 
-    {
-      if (! inet_aton (sm, &tmp))
-	return 0;
-      
-      netmask = tmp.s_addr;
-    }
-  
-  if (ip) 
-    {
-      if (! inet_aton (ip, &arptable[ARP_CLIENT].ipaddr)) 
-	return 0;
-      
-      if (! netmask && ! sm) 
-	netmask = default_netmask ();
-    }
-  
-  if (gw && ! inet_aton (gw, &arptable[ARP_GATEWAY].ipaddr)) 
-    return 0;
-
-  /* Clear out the ARP entry.  */
-  grub_memset (arptable[ARP_GATEWAY].node, 0, ETH_ALEN);
-  
-  if (svr && ! inet_aton (svr, &arptable[ARP_SERVER].ipaddr)) 
-    return 0;
-
-  /* Likewise.  */
-  grub_memset (arptable[ARP_SERVER].node, 0, ETH_ALEN);
-  
-  if (ip || sm)
-    {
-      if (IP_BROADCAST == (netmask | arptable[ARP_CLIENT].ipaddr.s_addr)
-	  || netmask == (netmask | arptable[ARP_CLIENT].ipaddr.s_addr)
-	  || ! netmask)
-	network_ready = 0;
-      else
-	network_ready = 1;
-    }
-  
-  return 1;
-}
-
-
-/**************************************************************************
-UDP_TRANSMIT - Send a UDP datagram
-**************************************************************************/
-int 
-udp_transmit (unsigned long destip, unsigned int srcsock,
-	      unsigned int destsock, int len, const void *buf)
-{
-  struct iphdr *ip;
-  struct udphdr *udp;
-  struct arprequest arpreq;
-  int arpentry, i;
-  int retry;
-
-  ip = (struct iphdr *) buf;
-  udp = (struct udphdr *) ((unsigned long) buf + sizeof (struct iphdr));
-  ip->verhdrlen = 0x45;
-  ip->service = 0;
-  ip->len = htons (len);
-  ip->ident = 0;
-  ip->frags = 0;
-  ip->ttl = 60;
-  ip->protocol = IP_UDP;
-  ip->chksum = 0;
-  ip->src.s_addr = arptable[ARP_CLIENT].ipaddr.s_addr;
-  ip->dest.s_addr = destip;
-  ip->chksum = ipchksum ((unsigned short *) buf, sizeof (struct iphdr));
-  udp->src = htons (srcsock);
-  udp->dest = htons (destsock);
-  udp->len = htons (len - sizeof (struct iphdr));
-  udp->chksum = 0;
-  udp->chksum = htons (udpchksum (ip));
-
-  if (udp->chksum == 0)
-    udp->chksum = 0xffff;
-  
-  if (destip == IP_BROADCAST)
-    {
-      eth_transmit (broadcast, IP, len, buf);
-    }
-  else
-    {
-      if (((destip & netmask)
-	   != (arptable[ARP_CLIENT].ipaddr.s_addr & netmask))
-	  && arptable[ARP_GATEWAY].ipaddr.s_addr)
-	destip = arptable[ARP_GATEWAY].ipaddr.s_addr;
-      
-      for (arpentry = 0; arpentry < MAX_ARP; arpentry++)
-	if (arptable[arpentry].ipaddr.s_addr == destip)
-	  break;
-      
-      if (arpentry == MAX_ARP)
-	{
-	  etherboot_printf ("%@ is not in my arp table!\n", destip);
-	  return 0;
-	}
-      
-      for (i = 0; i < ETH_ALEN; i++)
-	if (arptable[arpentry].node[i])
-	  break;
-      
-      if (i == ETH_ALEN)
-	{
-	  /* Need to do arp request.  */
-#ifdef DEBUG
-	  grub_printf ("arp request.\n");
-#endif
-	  arpreq.hwtype = htons (1);
-	  arpreq.protocol = htons (IP);
-	  arpreq.hwlen = ETH_ALEN;
-	  arpreq.protolen = 4;
-	  arpreq.opcode = htons (ARP_REQUEST);
-	  grub_memmove (arpreq.shwaddr, arptable[ARP_CLIENT].node,
-			ETH_ALEN);
-	  grub_memmove (arpreq.sipaddr, (char *) &arptable[ARP_CLIENT].ipaddr,
-			sizeof (in_addr));
-	  grub_memset (arpreq.thwaddr, 0, ETH_ALEN);
-	  grub_memmove (arpreq.tipaddr, (char *) &destip, sizeof (in_addr));
-	  
-	  for (retry = 1; retry <= MAX_ARP_RETRIES; retry++)
-	    {
-	      long timeout;
-	      
-	      eth_transmit (broadcast, ARP, sizeof (arpreq), &arpreq);
-	      timeout = rfc2131_sleep_interval (TIMEOUT, retry);
-	      
-	      if (await_reply (AWAIT_ARP, arpentry, arpreq.tipaddr, timeout))
-		goto xmit;
-
-	      if (ip_abort)
-		return 0;
-	    }
-	  
-	  return 0;
-	}
-      
-    xmit:
-      eth_transmit (arptable[arpentry].node, IP, len, buf);
-    }
-  
-  return 1;
-}
-
-/**************************************************************************
-TFTP - Download extended BOOTP data, or kernel image
-**************************************************************************/
-static int
-tftp (const char *name, int (*fnc) (unsigned char *, int, int, int))
-{
-  int retry = 0;
-  static unsigned short iport = 2000;
-  unsigned short oport = 0;
-  unsigned short len, block = 0, prevblock = 0;
-  int bcounter = 0;
-  struct tftp_t *tr;
-  struct tftpreq_t tp;
-  int rc;
-  int packetsize = TFTP_DEFAULTSIZE_PACKET;
-  
-  /* Clear out the Rx queue first.  It contains nothing of interest,
-   * except possibly ARP requests from the DHCP/TFTP server.  We use
-   * polling throughout Etherboot, so some time may have passed since we
-   * last polled the receive queue, which may now be filled with
-   * broadcast packets.  This will cause the reply to the packets we are
-   * about to send to be lost immediately.  Not very clever.  */
-  await_reply (AWAIT_QDRAIN, 0, NULL, 0);
-  
-  tp.opcode = htons (TFTP_RRQ);
-  len = (grub_sprintf ((char *) tp.u.rrq, "%s%coctet%cblksize%c%d",
-		       name, 0, 0, 0, TFTP_MAX_PACKET)
-	 + sizeof (tp.ip) + sizeof (tp.udp) + sizeof (tp.opcode) + 1);
-  if (! udp_transmit (arptable[ARP_SERVER].ipaddr.s_addr, ++iport,
-		      TFTP_PORT, len, &tp))
-    return 0;
-  
-  for (;;)
-    {
-      long timeout;
-      
-#ifdef CONGESTED
-      timeout = rfc2131_sleep_interval (block ? TFTP_REXMT : TIMEOUT, retry);
-#else
-      timeout = rfc2131_sleep_interval (TIMEOUT, retry);
-#endif
-
-      if (! await_reply (AWAIT_TFTP, iport, NULL, timeout))
-	{
-	  if (! block && retry++ < MAX_TFTP_RETRIES)
-	    {
-	      /* Maybe initial request was lost.  */
-	      if (! udp_transmit (arptable[ARP_SERVER].ipaddr.s_addr,
-				  ++iport, TFTP_PORT, len, &tp))
-		return 0;
-	      
-	      continue;
-	    }
-	  
-#ifdef CONGESTED
-	  if (block && ((retry += TFTP_REXMT) < TFTP_TIMEOUT))
-	    {
-	      /* We resend our last ack.  */
-#ifdef MDEBUG
-	      grub_printf ("<REXMT>\n");
-#endif
-	      udp_transmit (arptable[ARP_SERVER].ipaddr.s_addr,
-			    iport, oport,
-			    TFTP_MIN_PACKET, &tp);
-	      continue;
-	    }
-#endif
-	  /* Timeout.  */
-	  break;
-	}
-      
-      tr = (struct tftp_t *) &nic.packet[ETH_HLEN];
-      if (tr->opcode == ntohs (TFTP_ERROR))
-	{
-	  grub_printf ("TFTP error %d (%s)\n",
-		       ntohs (tr->u.err.errcode),
-		       tr->u.err.errmsg);
-	  break;
-	}
-      
-      if (tr->opcode == ntohs (TFTP_OACK))
-	{
-	  char *p = tr->u.oack.data, *e;
-	  
-	  /* Shouldn't happen.  */
-	  if (prevblock)
-	    /* Ignore it.  */
-	    continue;
-	  
-	  len = ntohs (tr->udp.len) - sizeof (struct udphdr) - 2;
-	  if (len > TFTP_MAX_PACKET)
-	    goto noak;
-	  
-	  e = p + len;
-	  while (*p != '\000' && p < e)
-	    {
-	      if (! grub_strcmp ("blksize", p))
-		{
-		  p += 8;
-		  if ((packetsize = getdec (&p)) < TFTP_DEFAULTSIZE_PACKET)
-		    goto noak;
-		  
-		  while (p < e && *p)
-		    p++;
-		  
-		  if (p < e)
-		    p++;
-		}
-	      else
-		{
-		noak:
-		  tp.opcode = htons (TFTP_ERROR);
-		  tp.u.err.errcode = 8;
-		  len = (grub_sprintf ((char *) tp.u.err.errmsg,
-				       "RFC1782 error")
-			 + sizeof (tp.ip) + sizeof (tp.udp)
-			 + sizeof (tp.opcode) + sizeof (tp.u.err.errcode)
-			 + 1);
-		  udp_transmit (arptable[ARP_SERVER].ipaddr.s_addr,
-				iport, ntohs (tr->udp.src),
-				len, &tp);
-		  return 0;
-		}
-	    }
-	  
-	  if (p > e)
-	    goto noak;
-	  
-	  /* This ensures that the packet does not get processed as data!  */
-	  block = tp.u.ack.block = 0; 
-	}
-      else if (tr->opcode == ntohs (TFTP_DATA))
-	{
-	  len = ntohs (tr->udp.len) - sizeof (struct udphdr) - 4;
-	  /* Shouldn't happen.  */
-	  if (len > packetsize)
-	    /* Ignore it.  */
-	    continue;
-	  
-	  block = ntohs (tp.u.ack.block = tr->u.data.block);
-	}
-      else
-	/* Neither TFTP_OACK nor TFTP_DATA.  */
-	break;
-      
-      if ((block || bcounter) && (block != prevblock + 1))
-	/* Block order should be continuous */
-	tp.u.ack.block = htons (block = prevblock);
-      
-      /* Should be continuous.  */
-      tp.opcode = htons (TFTP_ACK);
-      oport = ntohs (tr->udp.src);
-      /* Ack.  */
-      udp_transmit (arptable[ARP_SERVER].ipaddr.s_addr, iport,
-		    oport, TFTP_MIN_PACKET, &tp);
-      
-      if ((unsigned short) (block - prevblock) != 1)
-	/* Retransmission or OACK, don't process via callback
-	 * and don't change the value of prevblock.  */
-	continue;
-      
-      prevblock = block;
-      /* Is it the right place to zero the timer?  */
-      retry = 0;
-      
-      if ((rc = fnc (tr->u.data.download,
-		     ++bcounter, len, len < packetsize)) >= 0)
-	return rc;
-
-      /* End of data.  */
-      if (len < packetsize)           
-	return 1;
-    }
-  
-  return 0;
-}
-
-/**************************************************************************
-RARP - Get my IP address and load information
-**************************************************************************/
-int 
-rarp (void)
-{
-  int retry;
-
-  /* arp and rarp requests share the same packet structure.  */
-  struct arprequest rarpreq;
-
-  /* Make sure that an ethernet is probed.  */
-  if (! eth_probe ())
-    return 0;
-
-  /* Clear the ready flag.  */
-  network_ready = 0;
-  
-  grub_memset (&rarpreq, 0, sizeof (rarpreq));
-
-  rarpreq.hwtype = htons (1);
-  rarpreq.protocol = htons (IP);
-  rarpreq.hwlen = ETH_ALEN;
-  rarpreq.protolen = 4;
-  rarpreq.opcode = htons (RARP_REQUEST);
-  grub_memmove ((char *) &rarpreq.shwaddr, arptable[ARP_CLIENT].node,
-		ETH_ALEN);
-  /* sipaddr is already zeroed out */
-  grub_memmove ((char *) &rarpreq.thwaddr, arptable[ARP_CLIENT].node,
-		ETH_ALEN);
-  /* tipaddr is already zeroed out */
-
-  for (retry = 0; retry < MAX_ARP_RETRIES; ++retry)
-    {
-      long timeout;
-      
-      eth_transmit (broadcast, RARP, sizeof (rarpreq), &rarpreq);
-
-      timeout = rfc2131_sleep_interval (TIMEOUT, retry);
-      if (await_reply (AWAIT_RARP, 0, rarpreq.shwaddr, timeout))
-	break;
-
-      if (ip_abort)
-	return 0;
-    }
-
-  if (retry < MAX_ARP_RETRIES)
-    {
-      network_ready = 1;
-      return 1;
-    }
-
-  return 0;
-}
-
-/**************************************************************************
-BOOTP - Get my IP address and load information
-**************************************************************************/
-int 
-bootp (void)
-{
-  int retry;
-#ifndef	NO_DHCP_SUPPORT
-  int reqretry;
-#endif /* ! NO_DHCP_SUPPORT */
-  struct bootpip_t ip;
-  unsigned long starttime;
-
-  /* Make sure that an ethernet is probed.  */
-  if (! eth_probe ())
-    return 0;
-
-  /* Clear the ready flag.  */
-  network_ready = 0;
-
-#ifdef DEBUG
-  grub_printf ("network is ready.\n");
-#endif
-  
-  grub_memset (&ip, 0, sizeof (struct bootpip_t));
-  ip.bp.bp_op = BOOTP_REQUEST;
-  ip.bp.bp_htype = 1;
-  ip.bp.bp_hlen = ETH_ALEN;
-  starttime = currticks ();
-  /* Use lower 32 bits of node address, more likely to be
-     distinct than the time since booting */
-  grub_memmove (&xid, &arptable[ARP_CLIENT].node[2], sizeof(xid));
-  ip.bp.bp_xid = xid += htonl (starttime);
-  grub_memmove (ip.bp.bp_hwaddr, arptable[ARP_CLIENT].node, ETH_ALEN);
-#ifdef DEBUG
-  etherboot_printf ("bp_op = %d\n", ip.bp.bp_op);
-  etherboot_printf ("bp_htype = %d\n", ip.bp.bp_htype);
-  etherboot_printf ("bp_hlen = %d\n", ip.bp.bp_hlen);
-  etherboot_printf ("bp_xid = %d\n", ip.bp.bp_xid);
-  etherboot_printf ("bp_hwaddr = %!\n", ip.bp.bp_hwaddr);
-  etherboot_printf ("bp_hops = %d\n", (int) ip.bp.bp_hops);
-  etherboot_printf ("bp_secs = %d\n", (int) ip.bp.bp_hwaddr);
-#endif
-  
-#ifdef	NO_DHCP_SUPPORT
-  /* Request RFC-style options.  */
-  grub_memmove (ip.bp.bp_vend, rfc1533_cookie, 5);
-#else
-  /* Request RFC-style options.  */
-  grub_memmove (ip.bp.bp_vend, rfc1533_cookie, sizeof rfc1533_cookie);
-  grub_memmove (ip.bp.bp_vend + sizeof rfc1533_cookie, dhcpdiscover,
-		sizeof dhcpdiscover);
-  grub_memmove (ip.bp.bp_vend + sizeof rfc1533_cookie + sizeof dhcpdiscover,
-		rfc1533_end, sizeof rfc1533_end);
-#endif /* ! NO_DHCP_SUPPORT */
-
-  for (retry = 0; retry < MAX_BOOTP_RETRIES;)
-    {
-      long timeout;
-
-#ifdef DEBUG
-      grub_printf ("retry = %d\n", retry);
-#endif
-      
-      /* Clear out the Rx queue first.  It contains nothing of
-       * interest, except possibly ARP requests from the DHCP/TFTP
-       * server.  We use polling throughout Etherboot, so some time
-       * may have passed since we last polled the receive queue,
-       * which may now be filled with broadcast packets.  This will
-       * cause the reply to the packets we are about to send to be
-       * lost immediately.  Not very clever.  */
-      await_reply (AWAIT_QDRAIN, 0, NULL, 0);
-
-      udp_transmit (IP_BROADCAST, BOOTP_CLIENT, BOOTP_SERVER,
-		    sizeof (struct bootpip_t), &ip);
-      timeout = rfc2131_sleep_interval (TIMEOUT, retry++);
-#ifdef NO_DHCP_SUPPORT
-      if (await_reply (AWAIT_BOOTP, 0, NULL, timeout))
-	{
-	  network_ready = 1;
-	  return 1;
-	}
-#else /* ! NO_DHCP_SUPPORT */
-      if (await_reply (AWAIT_BOOTP, 0, NULL, timeout))
-	{
-	  if (dhcp_reply != DHCPOFFER)
-	    {
-	      network_ready = 1;
-	      return 1;
-	    }
-
-	  dhcp_reply = 0;
-#ifdef DEBUG
-  etherboot_printf ("bp_op = %d\n", (int) ip.bp.bp_op);
-  etherboot_printf ("bp_htype = %d\n", (int) ip.bp.bp_htype);
-  etherboot_printf ("bp_hlen = %d\n", (int) ip.bp.bp_hlen);
-  etherboot_printf ("bp_xid = %d\n", (int) ip.bp.bp_xid);
-  etherboot_printf ("bp_hwaddr = %!\n", ip.bp.bp_hwaddr);
-  etherboot_printf ("bp_hops = %d\n", (int) ip.bp.bp_hops);
-  etherboot_printf ("bp_secs = %d\n", (int) ip.bp.bp_hwaddr);
-#endif
-	  grub_memmove (ip.bp.bp_vend, rfc1533_cookie, sizeof rfc1533_cookie);
-	  grub_memmove (ip.bp.bp_vend + sizeof rfc1533_cookie,
-			dhcprequest, sizeof dhcprequest);
-	  grub_memmove (ip.bp.bp_vend + sizeof rfc1533_cookie
-			+ sizeof dhcprequest,
-			rfc1533_end, sizeof rfc1533_end);
-	  grub_memmove (ip.bp.bp_vend + 9, (char *) &dhcp_server,
-			sizeof (in_addr));
-	  grub_memmove (ip.bp.bp_vend + 15, (char *) &dhcp_addr,
-			sizeof (in_addr));
-#ifdef DEBUG
-	  grub_printf ("errnum = %d\n", errnum);
-#endif
-	  for (reqretry = 0; reqretry < MAX_BOOTP_RETRIES;)
-	    {
-	      int ret;
-#ifdef DEBUG
-	      grub_printf ("reqretry = %d\n", reqretry);
-#endif
-	      
-	      ret = udp_transmit (IP_BROADCAST, BOOTP_CLIENT, BOOTP_SERVER,
-				  sizeof (struct bootpip_t), &ip);
-	      if (! ret)
-		grub_printf ("udp_transmit failed.\n");
-	      
-	      dhcp_reply = 0;
-	      timeout = rfc2131_sleep_interval (TIMEOUT, reqretry++);
-	      if (await_reply (AWAIT_BOOTP, 0, NULL, timeout))
-		if (dhcp_reply == DHCPACK)
-		  {
-		    network_ready = 1;
-		    return 1;
-		  }
-
-#ifdef DEBUG
-	      grub_printf ("dhcp_reply = %d\n", dhcp_reply);
-#endif
-	      
-	      if (ip_abort)
-		return 0;
-	    }
-	}
-#endif /* ! NO_DHCP_SUPPORT */
-      
-      if (ip_abort)
-	return 0;
-      
-      ip.bp.bp_secs = htons ((currticks () - starttime) / TICKS_PER_SEC);
-    }
-
-  /* Timeout.  */
-  return 0;
-}
-
-/**************************************************************************
-UDPCHKSUM - Checksum UDP Packet (one of the rare cases when assembly is
-            actually simpler...)
- RETURNS: checksum, 0 on checksum error. This
-          allows for using the same routine for RX and TX summing:
-          RX  if (packet->udp.chksum && udpchksum(packet))
-                  error("checksum error");
-          TX  packet->udp.chksum=0;
-              if (0==(packet->udp.chksum=udpchksum(packet)))
-                  packet->upd.chksum=0xffff;
-**************************************************************************/
-static inline void
-dosum (unsigned short *start, unsigned int len, unsigned short *sum)
-{
-  __asm__ __volatile__
-    ("clc\n"
-     "1:\tlodsw\n\t"
-     "xchg %%al,%%ah\n\t"	/* convert to host byte order */
-     "adcw %%ax,%0\n\t"		/* add carry of previous iteration */
-     "loop 1b\n\t"
-     "adcw $0,%0"		/* add carry of last iteration */
-     : "=b" (*sum), "=S"(start), "=c"(len)
-     : "0"(*sum), "1"(start), "2"(len)
-     : "ax", "cc"
-     );
-}
-
-/* UDP sum:
- * proto, src_ip, dst_ip, udp_dport, udp_sport, 2*udp_len, payload
- */
-static unsigned short
-udpchksum (struct iphdr *packet)
-{
-  int len = ntohs (packet->len);
-  unsigned short rval;
-  
-  /* add udplength + protocol number */
-  rval = (len - sizeof (struct iphdr)) + IP_UDP;
-  
-  /* pad to an even number of bytes */
-  if (len % 2) {
-    ((char *) packet)[len++] = 0;
-  }
-  
-  /* sum over src/dst ipaddr + udp packet */
-  len -= (char *) &packet->src - (char *) packet;
-  dosum ((unsigned short *) &packet->src, len >> 1, &rval);
-  
-  /* take one's complement */
-  return ~rval;
-}
-
-/**************************************************************************
-AWAIT_REPLY - Wait until we get a response for our request
-**************************************************************************/
-int 
-await_reply (int type, int ival, void *ptr, int timeout)
-{
-  unsigned long time;
-  struct iphdr *ip;
-  struct udphdr *udp;
-  struct arprequest *arpreply;
-  struct bootp_t *bootpreply;
-  unsigned short ptype;
-  unsigned int protohdrlen = (ETH_HLEN + sizeof (struct iphdr)
-			      + sizeof (struct udphdr));
-
-  /* Clear the abort flag.  */
-  ip_abort = 0;
-  
-  time = timeout + currticks ();
-  /* The timeout check is done below.  The timeout is only checked if
-   * there is no packet in the Rx queue.  This assumes that eth_poll()
-   * needs a negligible amount of time.  */
-  for (;;)
-    {
-      if (eth_poll ())
-	{
-	  /* We have something!  */
-	  
-	  /* Check for ARP - No IP hdr.  */
-	  if (nic.packetlen >= ETH_HLEN)
-	    {
-	      ptype = (((unsigned short) nic.packet[12]) << 8
-		       | ((unsigned short) nic.packet[13]));
-	    }
-	  else
-	    /* What else could we do with it?  */
-	    continue;
-	  
-	  if (nic.packetlen >= ETH_HLEN + sizeof (struct arprequest)
-	      && ptype == ARP)
-	    {
-	      unsigned long tmp;
-
-	      arpreply = (struct arprequest *) &nic.packet[ETH_HLEN];
-	      
-	      if (arpreply->opcode == htons (ARP_REPLY)
-		  && ! grub_memcmp (arpreply->sipaddr, ptr, sizeof (in_addr))
-		  && type == AWAIT_ARP)
-		{
-		  grub_memmove ((char *) arptable[ival].node,
-				arpreply->shwaddr,
-				ETH_ALEN);
-		  return 1;
-		}
-	      
-	      grub_memmove ((char *) &tmp, arpreply->tipaddr,
-			    sizeof (in_addr));
-	      
-	      if (arpreply->opcode == htons (ARP_REQUEST)
-		  && tmp == arptable[ARP_CLIENT].ipaddr.s_addr)
-		{
-		  arpreply->opcode = htons (ARP_REPLY);
-		  grub_memmove (arpreply->tipaddr, arpreply->sipaddr,
-				sizeof (in_addr));
-		  grub_memmove (arpreply->thwaddr, (char *) arpreply->shwaddr,
-				ETH_ALEN);
-		  grub_memmove (arpreply->sipaddr,
-				(char *) &arptable[ARP_CLIENT].ipaddr,
-				sizeof (in_addr));
-		  grub_memmove (arpreply->shwaddr,
-				arptable[ARP_CLIENT].node,
-				ETH_ALEN);
-		  eth_transmit (arpreply->thwaddr, ARP,
-				sizeof (struct arprequest),
-				arpreply);
-#ifdef MDEBUG
-		  grub_memmove (&tmp, arpreply->tipaddr, sizeof (in_addr));
-		  etherboot_printf ("Sent ARP reply to: %@\n", tmp);
-#endif	/* MDEBUG */
-		}
-	      
-	      continue;
-	    }
-
-	  if (type == AWAIT_QDRAIN)
-	    continue;
-	  
-	  /* Check for RARP - No IP hdr.  */
-	  if (type == AWAIT_RARP
-	      && nic.packetlen >= ETH_HLEN + sizeof (struct arprequest)
-	      && ptype == RARP)
-	    {
-	      arpreply = (struct arprequest *) &nic.packet[ETH_HLEN];
-	      
-	      if (arpreply->opcode == htons (RARP_REPLY)
-		  && ! grub_memcmp (arpreply->thwaddr, ptr, ETH_ALEN))
-		{
-		  grub_memmove ((char *) arptable[ARP_SERVER].node,
-				arpreply->shwaddr, ETH_ALEN);
-		  grub_memmove ((char *) &arptable[ARP_SERVER].ipaddr,
-				arpreply->sipaddr, sizeof (in_addr));
-		  grub_memmove ((char *) &arptable[ARP_CLIENT].ipaddr,
-				arpreply->tipaddr, sizeof (in_addr));
-		  return 1;
-		}
-	      
-	      continue;
-	    }
-
-	  /* Anything else has IP header.  */
-	  if (nic.packetlen < protohdrlen || ptype != IP)
-	    continue;
-	  
-	  ip = (struct iphdr *) &nic.packet[ETH_HLEN];
-	  if (ip->verhdrlen != 0x45
-	      || ipchksum ((unsigned short *) ip, sizeof (struct iphdr))
-	      || ip->protocol != IP_UDP)
-	    continue;
-	  
-	  /*
-	    - Till Straumann <Till.Straumann@TU-Berlin.de>
-	    added udp checksum (safer on a wireless link)
-	    added fragmentation check: I had a corrupted image
-	    in memory due to fragmented TFTP packets - took me
-	    3 days to find the cause for this :-(
-	  */
-	  
-	  /* If More Fragments bit and Fragment Offset field
-	     are non-zero then packet is fragmented */
-	  if (ip->frags & htons(0x3FFF))
-	    {
-	      grub_printf ("ALERT: got a fragmented packet - reconfigure your server\n");
-	      continue;
-	    }
-	  
-	  udp = (struct udphdr *) &nic.packet[(ETH_HLEN
-					       + sizeof (struct iphdr))];
-	  if (udp->chksum && udpchksum (ip))
-	    {
-	      grub_printf ("UDP checksum error\n");
-	      continue;
-	    }
-	  
-	  /* BOOTP ?  */
-	  bootpreply = (struct bootp_t *)
-	    &nic.packet[(ETH_HLEN + sizeof (struct iphdr)
-			 + sizeof (struct udphdr))];
-	  if (type == AWAIT_BOOTP
-#ifdef NO_DHCP_SUPPORT
-	      && (nic.packetlen
-		  >= (ETH_HLEN + sizeof (struct bootp_t) - BOOTP_VENDOR_LEN))
-#else
-	      && (nic.packetlen
-		  >= (ETH_HLEN + sizeof (struct bootp_t) - DHCP_OPT_LEN))
-#endif /* ! NO_DHCP_SUPPORT */
-	      && udp->dest == htons (BOOTP_CLIENT)
-	      && bootpreply->bp_op == BOOTP_REPLY
-	      && bootpreply->bp_xid == xid
-	      && (! grub_memcmp (broadcast, bootpreply->bp_hwaddr, ETH_ALEN)
-		  || ! grub_memcmp (arptable[ARP_CLIENT].node,
-				    bootpreply->bp_hwaddr, ETH_ALEN)))
-	    {
-#ifdef DEBUG
-	      grub_printf ("BOOTP packet was received.\n");
-#endif
-	      arptable[ARP_CLIENT].ipaddr.s_addr
-		= bootpreply->bp_yiaddr.s_addr;
-#ifndef	NO_DHCP_SUPPORT
-	      dhcp_addr.s_addr = bootpreply->bp_yiaddr.s_addr;
-#ifdef DEBUG
-	      etherboot_printf ("dhcp_addr = %@\n", dhcp_addr.s_addr);
-#endif
-#endif /* ! NO_DHCP_SUPPORT */
-	      netmask = default_netmask ();
-	      arptable[ARP_SERVER].ipaddr.s_addr
-		= bootpreply->bp_siaddr.s_addr;
-	      /* Kill arp.  */
-	      grub_memset (arptable[ARP_SERVER].node, 0, ETH_ALEN);
-	      arptable[ARP_GATEWAY].ipaddr.s_addr
-		= bootpreply->bp_giaddr.s_addr;
-	      /* Kill arp.  */
-	      grub_memset (arptable[ARP_GATEWAY].node, 0, ETH_ALEN);
-
-	      grub_memmove ((char *) BOOTP_DATA_ADDR, (char *) bootpreply,
-			    sizeof (struct bootpd_t));
-#ifdef NO_DHCP_SUPPORT
-	      decode_rfc1533 (BOOTP_DATA_ADDR->bootp_reply.bp_vend,
-			      0, BOOTP_VENDOR_LEN + MAX_BOOTP_EXTLEN, 1);
-#else
-	      decode_rfc1533 (BOOTP_DATA_ADDR->bootp_reply.bp_vend,
-			      0, DHCP_OPT_LEN + MAX_BOOTP_EXTLEN, 1);
-#endif /* ! NO_DHCP_SUPPORT */
-	      
-	      return 1;
-	    }
-	  
-	  /* TFTP ? */
-	  if (type == AWAIT_TFTP && ntohs (udp->dest) == ival)
-	    return 1;
-	}
-      else
-	{
-	  /* Check for abort key only if the Rx queue is empty -
-	   * as long as we have something to process, don't
-	   * assume that something failed.  It is unlikely that
-	   * we have no processing time left between packets.  */
-	  if (checkkey () != -1 && ASCII_CHAR (getkey ()) == CTRL_C)
-	    {
-	      ip_abort = 1;
-	      return 0;
-	    }
-	  
-	  /* Do the timeout after at least a full queue walk.  */
-	  if ((timeout == 0) || (currticks() > time))
-	    {
-	      break;
-	    }
-	}
-    }
-  
-  return 0;
-}
-
-/**************************************************************************
-DECODE_RFC1533 - Decodes RFC1533 header
-**************************************************************************/
-int
-decode_rfc1533 (unsigned char *p, int block, int len, int eof)
-{
-  static unsigned char *extdata = NULL, *extend = NULL;
-  unsigned char *extpath = NULL;
-  unsigned char *endp;
-  
-  if (block == 0)
-    {
-      end_of_rfc1533 = NULL;
-      vendorext_isvalid = 0;
-      
-      if (grub_memcmp (p, rfc1533_cookie, 4))
-	/* no RFC 1533 header found */
-	return 0;
-      
-      p += 4;
-      endp = p + len;
-    }
-  else
-    {
-      if (block == 1)
-	{
-	  if (grub_memcmp (p, rfc1533_cookie, 4))
-	    /* no RFC 1533 header found */
-	    return 0;
-	  
-	  p += 4;
-	  len -= 4;
-	}
-      
-      if (extend + len
-	  <= ((unsigned char *)
-	      &(BOOTP_DATA_ADDR->bootp_extension[MAX_BOOTP_EXTLEN])))
-	{
-	  grub_memmove (extend, p, len);
-	  extend += len;
-	}
-      else
-	{
-	  grub_printf ("Overflow in vendor data buffer! Aborting...\n");
-	  *extdata = RFC1533_END;
-	  return 0;
-	}
-      
-      p = extdata;
-      endp = extend;
-    }
-
-  if (! eof)
-    return -1;
-  
-  while (p < endp)
-    {
-      unsigned char c = *p;
-      
-      if (c == RFC1533_PAD)
-	{
-	  p++;
-	  continue;
-	}
-      else if (c == RFC1533_END)
-	{
-	  end_of_rfc1533 = endp = p;
-	  continue;
-	}
-      else if (c == RFC1533_NETMASK)
-	{
-	  grub_memmove ((char *) &netmask, p + 2, sizeof (in_addr));
-	}
-      else if (c == RFC1533_GATEWAY)
-	{
-	  /* This is a little simplistic, but it will
-	     usually be sufficient.
-	     Take only the first entry.  */
-	  if (TAG_LEN (p) >= sizeof (in_addr))
-	    grub_memmove ((char *) &arptable[ARP_GATEWAY].ipaddr, p + 2,
-			  sizeof (in_addr));
-	}
-      else if (c == RFC1533_EXTENSIONPATH)
-	extpath = p;
-#ifndef	NO_DHCP_SUPPORT
-      else if (c == RFC2132_MSG_TYPE)
-	{
-	  dhcp_reply = *(p + 2);
-	}
-      else if (c == RFC2132_SRV_ID)
-	{
-	  grub_memmove ((char *) &dhcp_server, p + 2, sizeof (in_addr));
-#ifdef DEBUG
-	  etherboot_printf ("dhcp_server = %@\n", dhcp_server.s_addr);
-#endif
-	}
-#endif /* ! NO_DHCP_SUPPORT */
-      else if (c == RFC1533_VENDOR_MAGIC
-	       && TAG_LEN(p) >= 6
-	       && ! grub_memcmp (p + 2, vendorext_magic, 4)
-	       && p[6] == RFC1533_VENDOR_MAJOR)
-	vendorext_isvalid++;
-      /* GRUB now handles its own tag. Get the name of a configuration
-	 file from the network. Cool...  */
-      else if (c == RFC1533_VENDOR_CONFIGFILE)
-	{
-	  int l = TAG_LEN (p);
-	  
-	  /* Eliminate the trailing NULs according to RFC 2132.  */
-	  while (*(p + 2 + l - 1) == '\000' && l > 0)
-	    l--;
-	  
-	  /* XXX: Should check if LEN is less than the maximum length
-	     of CONFIG_FILE. This kind of robustness will be a goal
-	     in GRUB 1.0.  */
-	  grub_memmove (config_file, p + 2, l);
-	  config_file[l] = 0;
-	}
-      
-      p += TAG_LEN (p) + 2;
-    }
-  
-  extdata = extend = endp;
-  
-  /* Perhaps we can eliminate this because we doesn't require so
-     much information, but I leave this alone.  */
-  if (block == 0 && extpath != NULL)
-    {
-      char fname[64];
-      int fnamelen = TAG_LEN (extpath);
-      
-      while (*(extpath + 2 + fnamelen - 1) == '\000' && fnamelen > 0)
-	fnamelen--;
-      
-      if (fnamelen + 1 > sizeof (fname))
-	{
-	  grub_printf ("Too long file name for Extensions Path\n");
-	  return 0;
-	}
-      else if (! fnamelen)
-	{
-	  grub_printf ("Empty file name for Extensions Path\n");
-	  return 0;
-	}
-      
-      grub_memmove (fname, extpath + 2, fnamelen);
-      fname[fnamelen] = '\000';
-      grub_printf ("Loading BOOTP-extension file: %s\n", fname);
-      tftp (fname, decode_rfc1533);
-    }
-  
-  /* Proceed with next block.  */
-  return -1;
-}
-
-/**************************************************************************
-IPCHKSUM - Checksum IP Header
-**************************************************************************/
-static unsigned short 
-ipchksum (unsigned short *ip, int len)
-{
-  unsigned long sum = 0;
-  len >>= 1;
-  while (len--)
-    {
-      sum += *(ip++);
-      if (sum > 0xFFFF)
-	sum -= 0xFFFF;
-    }
-  return (~sum) & 0x0000FFFF;
-}
-
-#define TWO_SECOND_DIVISOR (2147483647l/TICKS_PER_SEC)
-
-/**************************************************************************
-RFC2131_SLEEP_INTERVAL - sleep for expotentially longer times
-**************************************************************************/
-long
-rfc2131_sleep_interval (int base, int exp)
-{
-  static long seed = 0;
-  long q;
-  unsigned long tmo;
-  
-#ifdef BACKOFF_LIMIT
-  if (exp > BACKOFF_LIMIT)
-    exp = BACKOFF_LIMIT;
-#endif
-  if (!seed)
-    /* Initialize linear congruential generator */
-    seed = (currticks () + *((long *) &arptable[ARP_CLIENT].node)
-	    + ((short *) arptable[ARP_CLIENT].node)[2]);
-  /* simplified version of the LCG given in Bruce Schneier's
-     "Applied Cryptography" */
-  q = seed / 53668;
-  if ((seed = 40014 * (seed - 53668 * q) - 12211 *q ) < 0)
-    seed += 2147483563L;
-  tmo = (base << exp) + (TICKS_PER_SEC - (seed / TWO_SECOND_DIVISOR));
-  return tmo;
-}
-
-/**************************************************************************
-CLEANUP - shut down networking
-**************************************************************************/
-void
-cleanup_net (void)
-{
-  if (network_ready)
-    {
-      /* Stop receiving packets.  */
-      eth_disable ();
-      network_ready = 0;
-    }
-}
diff -Naur grub-0.97.orig/netboot/mii.h grub-0.97/netboot/mii.h
--- grub-0.97.orig/netboot/mii.h	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/mii.h	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,105 @@
+/*
+ * linux/mii.h: definitions for MII-compatible transceivers
+ * Originally drivers/net/sunhme.h.
+ *
+ * Copyright (C) 1996, 1999, 2001 David S. Miller (davem@redhat.com)
+ *
+ * Copied Form Linux 2.4.25 an unneeded items removed by:
+ * Timothy Legge (timlegge at etherboot dot org)
+ *
+ * 03/26/2004
+ */
+
+/* Generic MII registers. */
+
+#define MII_BMCR            0x00	/* Basic mode control register */
+#define MII_BMSR            0x01	/* Basic mode status register  */
+#define MII_PHYSID1         0x02        /* PHYS ID 1                   */
+#define MII_PHYSID2         0x03        /* PHYS ID 2                   */
+#define MII_ADVERTISE       0x04	/* Advertisement control reg   */
+#define MII_LPA             0x05	/* Link partner ability reg    */
+#define MII_EXPANSION       0x06        /* Expansion register          */
+#define MII_DCOUNTER        0x12        /* Disconnect counter          */
+#define MII_FCSCOUNTER      0x13        /* False carrier counter       */
+#define MII_NWAYTEST        0x14        /* N-way auto-neg test reg     */
+#define MII_RERRCOUNTER     0x15        /* Receive error counter       */
+#define MII_SREVISION       0x16        /* Silicon revision            */
+#define MII_RESV1           0x17        /* Reserved...                 */
+#define MII_LBRERROR        0x18        /* Lpback, rx, bypass error    */
+#define MII_PHYADDR         0x19        /* PHY address                 */
+#define MII_RESV2           0x1a        /* Reserved...                 */
+#define MII_TPISTATUS       0x1b        /* TPI status for 10mbps       */
+#define MII_NCONFIG         0x1c        /* Network interface config    */
+
+/* Basic mode control register. */
+#define BMCR_RESV               0x007f  /* Unused...                   */
+#define BMCR_CTST               0x0080  /* Collision test              */
+#define BMCR_FULLDPLX           0x0100	/* Full duplex                 */
+#define BMCR_ANRESTART          0x0200	/* Auto negotiation restart    */
+#define BMCR_ISOLATE            0x0400  /* Disconnect DP83840 from MII */
+#define BMCR_PDOWN              0x0800  /* Powerdown the DP83840       */
+#define BMCR_ANENABLE           0x1000	/* Enable auto negotiation     */
+#define BMCR_SPEED100           0x2000	/* Select 100Mbps              */
+#define BMCR_LOOPBACK           0x4000  /* TXD loopback bits           */
+#define BMCR_RESET              0x8000	/* Reset the DP83840           */
+
+/* Basic mode status register. */
+#define BMSR_ERCAP              0x0001  /* Ext-reg capability          */
+#define BMSR_JCD                0x0002  /* Jabber detected             */
+#define BMSR_LSTATUS            0x0004  /* Link status                 */
+#define BMSR_ANEGCAPABLE        0x0008  /* Able to do auto-negotiation */
+#define BMSR_RFAULT             0x0010  /* Remote fault detected       */
+#define BMSR_ANEGCOMPLETE       0x0020  /* Auto-negotiation complete   */
+#define BMSR_RESV               0x07c0  /* Unused...                   */
+#define BMSR_10HALF             0x0800  /* Can do 10mbps, half-duplex  */
+#define BMSR_10FULL             0x1000  /* Can do 10mbps, full-duplex  */
+#define BMSR_100HALF            0x2000  /* Can do 100mbps, half-duplex */
+#define BMSR_100FULL            0x4000  /* Can do 100mbps, full-duplex */
+#define BMSR_100BASE4           0x8000  /* Can do 100mbps, 4k packets  */
+
+/* Advertisement control register. */
+#define ADVERTISE_SLCT          0x001f  /* Selector bits               */
+#define ADVERTISE_CSMA          0x0001  /* Only selector supported     */
+#define ADVERTISE_10HALF        0x0020	/* Try for 10mbps half-duplex  */
+#define ADVERTISE_10FULL        0x0040	/* Try for 10mbps full-duplex  */
+#define ADVERTISE_100HALF       0x0080	/* Try for 100mbps half-duplex */
+#define ADVERTISE_100FULL       0x0100	/* Try for 100mbps full-duplex */
+#define ADVERTISE_100BASE4      0x0200  /* Try for 100mbps 4k packets  */
+#define ADVERTISE_RESV          0x1c00  /* Unused...                   */
+#define ADVERTISE_RFAULT        0x2000  /* Say we can detect faults    */
+#define ADVERTISE_LPACK         0x4000  /* Ack link partners response  */
+#define ADVERTISE_NPAGE         0x8000  /* Next page bit               */
+
+#define ADVERTISE_FULL (ADVERTISE_100FULL | ADVERTISE_10FULL | \
+			ADVERTISE_CSMA)
+#define ADVERTISE_ALL (ADVERTISE_10HALF | ADVERTISE_10FULL | \
+                      ADVERTISE_100HALF | ADVERTISE_100FULL)
+
+/* Link partner ability register. */
+#define LPA_SLCT                0x001f  /* Same as advertise selector  */
+#define LPA_10HALF              0x0020  /* Can do 10mbps half-duplex   */
+#define LPA_10FULL              0x0040  /* Can do 10mbps full-duplex   */
+#define LPA_100HALF             0x0080  /* Can do 100mbps half-duplex  */
+#define LPA_100FULL             0x0100  /* Can do 100mbps full-duplex  */
+#define LPA_100BASE4            0x0200  /* Can do 100mbps 4k packets   */
+#define LPA_RESV                0x1c00  /* Unused...                   */
+#define LPA_RFAULT              0x2000  /* Link partner faulted        */
+#define LPA_LPACK               0x4000  /* Link partner acked us       */
+#define LPA_NPAGE               0x8000  /* Next page bit               */
+
+#define LPA_DUPLEX            (LPA_10FULL | LPA_100FULL)
+#define LPA_100                       (LPA_100FULL | LPA_100HALF | LPA_100BASE4)
+
+/* Expansion register for auto-negotiation. */
+#define EXPANSION_NWAY          0x0001  /* Can do N-way auto-nego      */
+#define EXPANSION_LCWP          0x0002  /* Got new RX page code word   */
+#define EXPANSION_ENABLENPAGE   0x0004  /* This enables npage words    */
+#define EXPANSION_NPCAPABLE     0x0008  /* Link partner supports npage */
+#define EXPANSION_MFAULTS       0x0010  /* Multiple faults detected    */
+#define EXPANSION_RESV          0xffe0  /* Unused...                   */
+
+/* N-way test register. */
+#define NWAYTEST_RESV1          0x00ff  /* Unused...                   */
+#define NWAYTEST_LOOPBACK       0x0100  /* Enable loopback for N-way   */
+#define NWAYTEST_RESV2          0xfe00  /* Unused...                   */
+
diff -Naur grub-0.97.orig/netboot/misc.c grub-0.97/netboot/misc.c
--- grub-0.97.orig/netboot/misc.c	2003-07-09 11:45:37.000000000 +0000
+++ grub-0.97/netboot/misc.c	2005-08-31 19:03:35.000000000 +0000
@@ -19,37 +19,90 @@
 
 /* Based on "src/misc.c" in etherboot-5.0.5.  */
 
-#define GRUB	1
-#include <etherboot.h>
+#include "grub.h"
+#include "timer.h"
 
-void
-sleep (int secs)
+#include "nic.h"
+
+/**************************************************************************
+RANDOM - compute a random number between 0 and 2147483647L or 2147483562?
+**************************************************************************/
+int32_t random(void)
 {
-  unsigned long tmo = currticks () + secs;
+	static int32_t seed = 0;
+	int32_t q;
+	if (!seed) /* Initialize linear congruential generator */
+		seed = currticks() + *(int32_t *)&arptable[ARP_CLIENT].node
+		       + ((int16_t *)arptable[ARP_CLIENT].node)[2];
+	/* simplified version of the LCG given in Bruce Schneier's
+	   "Applied Cryptography" */
+	q = seed/53668;
+	if ((seed = 40014*(seed-53668*q) - 12211*q) < 0) seed += 2147483563L;
+	return seed;
+}
 
-  while (currticks () < tmo)
-    ;
+/**************************************************************************
+POLL INTERRUPTIONS
+**************************************************************************/
+void poll_interruptions(void)
+{
+	if (checkkey() != -1 && ASCII_CHAR(getkey()) == K_INTR) {
+		user_abort++;
+	}
 }
 
-void
-twiddle (void)
+/**************************************************************************
+SLEEP
+**************************************************************************/
+void sleep(int secs)
 {
-  static unsigned long lastticks = 0;
-  static int count = 0;
-  static const char tiddles[]="-\\|/";
-  unsigned long ticks;
+	unsigned long tmo;
 
-  if (debug)
-    {
-      if ((ticks = currticks ()) == lastticks)
-	return;
-      
-      lastticks = ticks;
-      grub_putchar (tiddles[(count++) & 3]);
-      grub_putchar ('\b');
-    }
+	for (tmo = currticks()+secs*TICKS_PER_SEC; currticks() < tmo; ) {
+		poll_interruptions();
+	}
+}
+
+/**************************************************************************
+INTERRUPTIBLE SLEEP
+**************************************************************************/
+void interruptible_sleep(int secs)
+{
+	printf("<sleep>\n");
+	return sleep(secs);
+}
+
+/**************************************************************************
+TWIDDLE
+**************************************************************************/
+void twiddle(void)
+{
+#ifdef BAR_PROGRESS
+	static int count=0;
+	static const char tiddles[]="-\\|/";
+	static unsigned long lastticks = 0;
+	unsigned long ticks;
+#endif
+#ifdef FREEBSD_PXEEMU
+	extern char pxeemu_nbp_active;
+	if(pxeemu_nbp_active != 0)
+		return;
+#endif
+#ifdef	BAR_PROGRESS
+	/* Limit the maximum rate at which characters are printed */
+	ticks = currticks();
+	if ((lastticks + (TICKS_PER_SEC/18)) > ticks)
+		return;
+	lastticks = ticks;
+
+	putchar(tiddles[(count++)&3]);
+	putchar('\b');
+#else
+	//putchar('.');
+#endif	/* BAR_PROGRESS */
 }
 
+
 /* Because Etherboot uses its own formats for the printf family,
    define separate definitions from GRUB.  */
 /**************************************************************************
@@ -264,3 +317,5 @@
   
   return ret;
 }
+
+
diff -Naur grub-0.97.orig/netboot/natsemi.c grub-0.97/netboot/natsemi.c
--- grub-0.97.orig/netboot/natsemi.c	2003-07-09 11:45:38.000000000 +0000
+++ grub-0.97/netboot/natsemi.c	2005-08-31 19:53:07.000000000 +0000
@@ -47,15 +47,15 @@
 /* Revision History */
 
 /*
+  13 Dec 2003 timlegge 1.1 Enabled Multicast Support
   29 May 2001  mdc     1.0
      Initial Release.  Tested with Netgear FA311 and FA312 boards
-*/
+*/
 /* Includes */
 
 #include "etherboot.h"
 #include "nic.h"
 #include "pci.h"
-#include "cards.h"
 
 /* defines */
 
@@ -71,21 +71,18 @@
 
 #define NUM_RX_DESC    4              /* Number of Rx descriptor registers. */
 
-typedef unsigned char  u8;
-typedef   signed char  s8;
-typedef unsigned short u16;
-typedef   signed short s16;
-typedef unsigned int   u32;
-typedef   signed int   s32;
+typedef uint8_t    u8;
+typedef int8_t     s8;
+typedef uint16_t   u16;
+typedef int16_t    s16;
+typedef uint32_t   u32;
+typedef int32_t    s32;
 
 /* helpful macroes if on a big_endian machine for changing byte order.
    not strictly needed on Intel */
-#define le16_to_cpu(val) (val)
-#define cpu_to_le32(val) (val)
 #define get_unaligned(ptr) (*(ptr))
 #define put_unaligned(val, ptr) ((void)( *(ptr) = (val) ))
 #define get_u16(ptr) (*(u16 *)(ptr))
-#define virt_to_bus(x) ((unsigned long)x)
 #define virt_to_le32desc(addr)  virt_to_bus(addr)
 
 enum pcistuff {
@@ -161,7 +158,8 @@
     AcceptMulticast    = 0x00200000, 
     AcceptAllMulticast = 0x20000000,
     AcceptAllPhys      = 0x10000000, 
-    AcceptMyPhys       = 0x08000000
+    AcceptMyPhys       = 0x08000000,
+    RxFilterEnable     = 0x80000000
 };
 
 typedef struct _BufferDesc {
@@ -207,17 +205,12 @@
 static BufferDesc txd              __attribute__ ((aligned(4)));
 static BufferDesc rxd[NUM_RX_DESC] __attribute__ ((aligned(4)));
 
-#ifdef USE_LOWMEM_BUFFER
-#define txb ((char *)0x10000 - TX_BUF_SIZE)
-#define rxb ((char *)0x10000 - NUM_RX_DESC*RX_BUF_SIZE - TX_BUF_SIZE)
-#else
 static unsigned char txb[TX_BUF_SIZE] __attribute__ ((aligned(4)));
 static unsigned char rxb[NUM_RX_DESC * RX_BUF_SIZE] __attribute__ ((aligned(4)));
-#endif
 
 /* Function Prototypes */
 
-struct nic *natsemi_probe(struct nic *nic, unsigned short *io_addrs, struct pci_device *pci);
+static int natsemi_probe(struct dev *dev, struct pci_device *pci);
 static int eeprom_read(long addr, int location);
 static int mdio_read(int phy_id, int location);
 static void natsemi_init(struct nic *nic);
@@ -228,8 +221,9 @@
 static void natsemi_set_rx_mode(struct nic *nic);
 static void natsemi_check_duplex(struct nic *nic);
 static void natsemi_transmit(struct nic *nic, const char *d, unsigned int t, unsigned int s, const char *p);
-static int  natsemi_poll(struct nic *nic);
-static void natsemi_disable(struct nic *nic);
+static int  natsemi_poll(struct nic *nic, int retrieve);
+static void natsemi_disable(struct dev *dev);
+static void natsemi_irq(struct nic *nic, irq_action_t action);
 
 /* 
  * Function: natsemi_probe
@@ -245,24 +239,28 @@
  * Returns:   struct nic *:          pointer to NIC data structure
  */
 
-struct nic *
-natsemi_probe(struct nic *nic, unsigned short *io_addrs, struct pci_device *pci)
+static int
+natsemi_probe(struct dev *dev, struct pci_device *pci)
 {
+    struct nic *nic = (struct nic *)dev;
     int i;
     int prev_eedata;
     u32 tmp;
 
-    if (io_addrs == 0 || *io_addrs == 0)
-        return NULL;
+    if (pci->ioaddr == 0)
+        return 0;
+
+    adjust_pci_device(pci);
 
     /* initialize some commonly used globals */
 	
-    ioaddr     = *io_addrs & ~3;
+    nic->irqno  = 0;
+    nic->ioaddr = pci->ioaddr & ~3;
+
+    ioaddr     = pci->ioaddr & ~3;
     vendor     = pci->vendor;
     dev_id     = pci->dev_id;
     nic_name   = pci->name;
-    
-    adjust_pci_device(pci);
 
     /* natsemi has a non-standard PM control register
      * in PCI config space.  Some boards apparently need
@@ -317,12 +315,12 @@
     /* initialize device */
     natsemi_init(nic);
 
-    nic->reset    = natsemi_init;
+    dev->disable  = natsemi_disable;
     nic->poll     = natsemi_poll;
     nic->transmit = natsemi_transmit;
-    nic->disable  = natsemi_disable;
+    nic->irq      = natsemi_irq;
 
-    return nic;
+    return 1;
 }
 
 /* Read the EEPROM and MII Management Data I/O (MDIO) interfaces.
@@ -452,7 +450,7 @@
  * Returns:   void.
  */
 static void 
-natsemi_reset(struct nic *nic)
+natsemi_reset(struct nic *nic __unused)
 {
     outl(ChipReset, ioaddr + ChipCmd);
 	
@@ -504,14 +502,14 @@
  */
 
 static void
-natsemi_init_txd(struct nic *nic)
+natsemi_init_txd(struct nic *nic __unused)
 {
     txd.link   = (u32) 0;
     txd.cmdsts = (u32) 0;
-    txd.bufptr = (u32) &txb[0];
+    txd.bufptr = virt_to_bus(&txb[0]);
 
     /* load Transmit Descriptor Register */
-    outl((u32) &txd, ioaddr + TxRingPtr); 
+    outl(virt_to_bus(&txd), ioaddr + TxRingPtr); 
     if (natsemi_debug > 1)
         printf("natsemi_init_txd: TX descriptor register loaded with: %X\n", 
                inl(ioaddr + TxRingPtr));
@@ -527,7 +525,7 @@
  */
  
 static void 
-natsemi_init_rxd(struct nic *nic) 
+natsemi_init_rxd(struct nic *nic __unused) 
 { 
     int i;
 
@@ -535,16 +533,16 @@
 
     /* init RX descriptor */
     for (i = 0; i < NUM_RX_DESC; i++) {
-        rxd[i].link   = (i+1 < NUM_RX_DESC) ? (u32) &rxd[i+1] : (u32) &rxd[0];
+        rxd[i].link   = virt_to_bus((i+1 < NUM_RX_DESC) ? &rxd[i+1] : &rxd[0]);
         rxd[i].cmdsts = (u32) RX_BUF_SIZE;
-        rxd[i].bufptr = (u32) &rxb[i*RX_BUF_SIZE];
+        rxd[i].bufptr = virt_to_bus(&rxb[i*RX_BUF_SIZE]);
         if (natsemi_debug > 1)
             printf("natsemi_init_rxd: rxd[%d]=%X link=%X cmdsts=%X bufptr=%X\n", 
                    i, &rxd[i], rxd[i].link, rxd[i].cmdsts, rxd[i].bufptr);
     }
 
     /* load Receive Descriptor Register */
-    outl((u32) &rxd[0], ioaddr + RxRingPtr);
+    outl(virt_to_bus(&rxd[0]), ioaddr + RxRingPtr);
 
     if (natsemi_debug > 1)
         printf("natsemi_init_rxd: RX descriptor register loaded with: %X\n", 
@@ -562,14 +560,15 @@
  * Returns:   void.
  */
 
-static void natsemi_set_rx_mode(struct nic *nic)
+static void natsemi_set_rx_mode(struct nic *nic __unused)
 {
-    u32 rx_mode = AcceptBroadcast | AcceptMyPhys;
+    u32 rx_mode = RxFilterEnable | AcceptBroadcast |
+	    AcceptAllMulticast | AcceptMyPhys;
 	
     outl(rx_mode, ioaddr + RxFilterAddr);
 }
 
-static void natsemi_check_duplex(struct nic *nic)
+static void natsemi_check_duplex(struct nic *nic __unused)
 {
     int duplex = inl(ioaddr + ChipConfig) & 0x20000000 ? 1 : 0;
 	
@@ -607,14 +606,14 @@
 		 unsigned int s,     /* size */
 		 const char  *p)     /* Packet */
 {
-    u32 status, to, nstype;
+    u32 to, nstype;
     u32 tx_status;
     
     /* Stop the transmitter */
     outl(TxOff, ioaddr + ChipCmd);
 
     /* load Transmit Descriptor Register */
-    outl((u32) &txd, ioaddr + TxRingPtr);
+    outl(virt_to_bus(&txd), ioaddr + TxRingPtr);
     if (natsemi_debug > 1)
         printf("natsemi_transmit: TX descriptor register loaded with: %X\n", 
                inl(ioaddr + TxRingPtr));
@@ -636,7 +635,7 @@
         txb[s++] = '\0';
 
     /* set the transmit buffer descriptor and enable Transmit State Machine */
-    txd.bufptr = (u32) &txb[0];
+    txd.bufptr = virt_to_bus(&txb[0]);
     txd.cmdsts = (u32) OWN | s;
 
     /* restart the transmitter */
@@ -647,7 +646,7 @@
 
     to = currticks() + TX_TIMEOUT;
 
-    while ((((volatile u32) tx_status=txd.cmdsts) & OWN) && (currticks() < to))
+    while ((volatile u32) ( tx_status=txd.cmdsts & OWN) && (currticks() < to))
         /* wait */ ;
 
     if (currticks() >= to) {
@@ -674,7 +673,7 @@
  */
 
 static int
-natsemi_poll(struct nic *nic)
+natsemi_poll(struct nic *nic, int retrieve)
 {
     u32 rx_status = rxd[cur_rx].cmdsts;
     int retstat = 0;
@@ -685,6 +684,8 @@
     if (!(rx_status & OWN))
         return retstat;
 
+    if ( ! retrieve ) return 1;
+
     if (natsemi_debug > 1)
         printf("natsemi_poll: got a packet: cur_rx:%d, status:%X\n",
                cur_rx, rx_status);
@@ -704,7 +705,7 @@
 
     /* return the descriptor and buffer to receive ring */
     rxd[cur_rx].cmdsts = RX_BUF_SIZE;
-    rxd[cur_rx].bufptr = (u32) &rxb[cur_rx*RX_BUF_SIZE];
+    rxd[cur_rx].bufptr = virt_to_bus(&rxb[cur_rx*RX_BUF_SIZE]);
         
     if (++cur_rx == NUM_RX_DESC)
         cur_rx = 0;
@@ -725,8 +726,12 @@
  */
 
 static void
-natsemi_disable(struct nic *nic)
+natsemi_disable(struct dev *dev)
 {
+    struct nic *nic = (struct nic *)dev;
+    /* merge reset and disable */
+    natsemi_init(nic);
+
     /* Disable interrupts using the mask. */
     outl(0, ioaddr + IntrMask);
     outl(0, ioaddr + IntrEnable);
@@ -737,3 +742,39 @@
     /* Restore PME enable bit */
     outl(SavedClkRun, ioaddr + ClkRun);
 }
+
+/* Function: natsemi_irq
+ *
+ * Description: Enable, Disable, or Force interrupts
+ *    
+ * Arguments: struct nic *nic:          NIC data structure
+ *            irq_action_t action:      requested action to perform
+ *
+ * Returns:   void.
+ */
+
+static void 
+natsemi_irq(struct nic *nic __unused, irq_action_t action __unused)
+{
+  switch ( action ) {
+  case DISABLE :
+    break;
+  case ENABLE :
+    break;
+  case FORCE :
+    break;
+  }
+}
+
+static struct pci_id natsemi_nics[] = {
+PCI_ROM(0x100b, 0x0020, "dp83815", "DP83815"),
+};
+
+struct pci_driver natsemi_driver = {
+	.type     = NIC_DRIVER,
+	.name     = "NATSEMI",
+	.probe    = natsemi_probe,
+	.ids      = natsemi_nics,
+	.id_count = sizeof(natsemi_nics)/sizeof(natsemi_nics[0]),
+	.class    = 0,
+};
diff -Naur grub-0.97.orig/netboot/nfs.h grub-0.97/netboot/nfs.h
--- grub-0.97.orig/netboot/nfs.h	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/nfs.h	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,63 @@
+#ifndef	_NFS_H
+#define	_NFS_H
+
+#define SUNRPC_PORT	111
+
+#define PROG_PORTMAP	100000
+#define PROG_NFS	100003
+#define PROG_MOUNT	100005
+
+#define MSG_CALL	0
+#define MSG_REPLY	1
+
+#define PORTMAP_GETPORT	3
+
+#define MOUNT_ADDENTRY	1
+#define MOUNT_UMOUNTALL	4
+
+#define NFS_LOOKUP	4
+#define	NFS_READLINK	5
+#define NFS_READ	6
+
+#define NFS_FHSIZE	32
+
+#define NFSERR_PERM	1
+#define NFSERR_NOENT	2
+#define NFSERR_ACCES	13
+#define	NFSERR_ISDIR	21
+#define	NFSERR_INVAL	22
+
+/* Block size used for NFS read accesses.  A RPC reply packet (including  all
+ * headers) must fit within a single Ethernet frame to avoid fragmentation.
+ * Chosen to be a power of two, as most NFS servers are optimized for this.  */
+#define NFS_READ_SIZE	1024
+
+#define NFS_MAXLINKDEPTH 16
+
+struct rpc_t {
+	struct iphdr ip;
+	struct udphdr udp;
+	union {
+		uint8_t  data[300];		/* longest RPC call must fit!!!! */
+		struct {
+			uint32_t id;
+			uint32_t type;
+			uint32_t rpcvers;
+			uint32_t prog;
+			uint32_t vers;
+			uint32_t proc;
+			uint32_t data[1];
+		} call;
+		struct {
+			uint32_t id;
+			uint32_t type;
+			uint32_t rstatus;
+			uint32_t verifier;
+			uint32_t v2;
+			uint32_t astatus;
+			uint32_t data[1];
+		} reply;
+	} u;
+};
+
+#endif	/* _NFS_H */
diff -Naur grub-0.97.orig/netboot/ni5010.c grub-0.97/netboot/ni5010.c
--- grub-0.97.orig/netboot/ni5010.c	2003-07-09 11:45:38.000000000 +0000
+++ grub-0.97/netboot/ni5010.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,371 +0,0 @@
-/**************************************************************************
-Etherboot -  BOOTP/TFTP Bootstrap Program
-Driver for NI5010.
-Code freely taken from Jan-Pascal van Best and Andreas Mohr's
-Linux NI5010 driver.
-***************************************************************************/
-
-/*
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2, or (at
- * your option) any later version.
- */
-
-/* to get some global routines like printf */
-#include "etherboot.h"
-/* to get the interface to the body of the program */
-#include "nic.h"
-/* to get our own prototype */
-#include "cards.h"
-
-/* ni5010.h file included verbatim */
-/*
- * Racal-Interlan ni5010 Ethernet definitions
- *
- * This is an extension to the Linux operating system, and is covered by the
- * same Gnu Public License that covers that work.
- *
- * copyrights (c) 1996 by Jan-Pascal van Best (jvbest@wi.leidenuniv.nl)
- *
- * I have done a look in the following sources:
- *   crynwr-packet-driver by Russ Nelson
- */
-
-#define NI5010_BUFSIZE	2048	/* number of bytes in a buffer */
-
-#define NI5010_MAGICVAL0 0x00  /* magic-values for ni5010 card */
-#define NI5010_MAGICVAL1 0x55
-#define NI5010_MAGICVAL2 0xAA
-
-#define SA_ADDR0 0x02
-#define SA_ADDR1 0x07
-#define SA_ADDR2 0x01
-
-/* The number of low I/O ports used by the ni5010 ethercard. */
-#define NI5010_IO_EXTENT       32
-
-#define PRINTK(x) if (NI5010_DEBUG) printk x
-#define PRINTK2(x) if (NI5010_DEBUG>=2) printk x
-#define PRINTK3(x) if (NI5010_DEBUG>=3) printk x
-
-/* The various IE command registers */
-#define EDLC_XSTAT	(ioaddr + 0x00)	/* EDLC transmit csr */
-#define EDLC_XCLR	(ioaddr + 0x00)	/* EDLC transmit "Clear IRQ" */
-#define EDLC_XMASK	(ioaddr + 0x01)	/* EDLC transmit "IRQ Masks" */
-#define EDLC_RSTAT	(ioaddr + 0x02)	/* EDLC receive csr */
-#define EDLC_RCLR	(ioaddr + 0x02)	/* EDLC receive "Clear IRQ" */
-#define EDLC_RMASK	(ioaddr + 0x03)	/* EDLC receive "IRQ Masks" */
-#define EDLC_XMODE	(ioaddr + 0x04)	/* EDLC transmit Mode */
-#define EDLC_RMODE	(ioaddr + 0x05)	/* EDLC receive Mode */
-#define EDLC_RESET	(ioaddr + 0x06)	/* EDLC RESET register */
-#define EDLC_TDR1	(ioaddr + 0x07)	/* "Time Domain Reflectometry" reg1 */
-#define EDLC_ADDR	(ioaddr + 0x08)	/* EDLC station address, 6 bytes */
-	 			/* 0x0E doesn't exist for r/w */
-#define EDLC_TDR2	(ioaddr + 0x0f)	/* "Time Domain Reflectometry" reg2 */
-#define IE_GP		(ioaddr + 0x10)	/* GP pointer (word register) */
-				/* 0x11 is 2nd byte of GP Pointer */
-#define IE_RCNT		(ioaddr + 0x10)	/* Count of bytes in rcv'd packet */
- 				/* 0x11 is 2nd byte of "Byte Count" */
-#define IE_MMODE	(ioaddr + 0x12)	/* Memory Mode register */
-#define IE_DMA_RST	(ioaddr + 0x13)	/* IE DMA Reset.  write only */
-#define IE_ISTAT	(ioaddr + 0x13)	/* IE Interrupt Status.  read only */
-#define IE_RBUF		(ioaddr + 0x14)	/* IE Receive Buffer port */
-#define IE_XBUF		(ioaddr + 0x15)	/* IE Transmit Buffer port */
-#define IE_SAPROM	(ioaddr + 0x16)	/* window on station addr prom */
-#define IE_RESET	(ioaddr + 0x17)	/* any write causes Board Reset */
-
-/* bits in EDLC_XSTAT, interrupt clear on write, status when read */
-#define XS_TPOK		0x80	/* transmit packet successful */
-#define XS_CS		0x40	/* carrier sense */
-#define XS_RCVD		0x20	/* transmitted packet received */
-#define XS_SHORT	0x10	/* transmission media is shorted */
-#define XS_UFLW		0x08	/* underflow.  iff failed board */
-#define XS_COLL		0x04	/* collision occurred */
-#define XS_16COLL	0x02	/* 16th collision occurred */
-#define XS_PERR		0x01	/* parity error */
-
-#define XS_CLR_UFLW	0x08	/* clear underflow */
-#define XS_CLR_COLL	0x04	/* clear collision */
-#define XS_CLR_16COLL	0x02	/* clear 16th collision */
-#define XS_CLR_PERR	0x01	/* clear parity error */
-
-/* bits in EDLC_XMASK, mask/enable transmit interrupts.  register is r/w */
-#define XM_TPOK		0x80	/* =1 to enable Xmt Pkt OK interrupts */
-#define XM_RCVD		0x20	/* =1 to enable Xmt Pkt Rcvd ints */
-#define XM_UFLW		0x08	/* =1 to enable Xmt Underflow ints */
-#define XM_COLL		0x04	/* =1 to enable Xmt Collision ints */
-#define XM_COLL16	0x02	/* =1 to enable Xmt 16th Coll ints */
-#define XM_PERR		0x01	/* =1 to enable Xmt Parity Error ints */
- 				/* note: always clear this bit */
-#define XM_ALL		(XM_TPOK | XM_RCVD | XM_UFLW | XM_COLL | XM_COLL16)
-
-/* bits in EDLC_RSTAT, interrupt clear on write, status when read */
-#define RS_PKT_OK	0x80	/* received good packet */
-#define RS_RST_PKT	0x10	/* RESET packet received */
-#define RS_RUNT		0x08	/* Runt Pkt rcvd.  Len < 64 Bytes */
-#define RS_ALIGN	0x04	/* Alignment error. not 8 bit aligned */
-#define RS_CRC_ERR	0x02	/* Bad CRC on rcvd pkt */
-#define RS_OFLW		0x01	/* overflow for rcv FIFO */
-#define RS_VALID_BITS	( RS_PKT_OK | RS_RST_PKT | RS_RUNT | RS_ALIGN | RS_CRC_ERR | RS_OFLW )
- 				/* all valid RSTAT bits */
-
-#define RS_CLR_PKT_OK	0x80	/* clear rcvd packet interrupt */
-#define RS_CLR_RST_PKT	0x10	/* clear RESET packet received */
-#define RS_CLR_RUNT	0x08	/* clear Runt Pckt received */
-#define RS_CLR_ALIGN	0x04	/* clear Alignment error */
-#define RS_CLR_CRC_ERR	0x02	/* clear CRC error */
-#define RS_CLR_OFLW	0x01	/* clear rcv FIFO Overflow */
-
-/* bits in EDLC_RMASK, mask/enable receive interrupts.  register is r/w */
-#define RM_PKT_OK	0x80	/* =1 to enable rcvd good packet ints */
-#define RM_RST_PKT	0x10	/* =1 to enable RESET packet ints */
-#define RM_RUNT		0x08	/* =1 to enable Runt Pkt rcvd ints */
-#define RM_ALIGN	0x04	/* =1 to enable Alignment error ints */
-#define RM_CRC_ERR	0x02	/* =1 to enable Bad CRC error ints */
-#define RM_OFLW		0x01	/* =1 to enable overflow error ints */
-
-/* bits in EDLC_RMODE, set Receive Packet mode.  register is r/w */
-#define RMD_TEST	0x80	/* =1 for Chip testing.  normally 0 */
-#define RMD_ADD_SIZ	0x10	/* =1 5-byte addr match.  normally 0 */
-#define RMD_EN_RUNT	0x08	/* =1 enable runt rcv.  normally 0 */
-#define RMD_EN_RST	0x04	/* =1 to rcv RESET pkt.  normally 0 */
-
-#define RMD_PROMISC	0x03	/* receive *all* packets.  unusual */
-#define RMD_MULTICAST	0x02	/* receive multicasts too.  unusual */
-#define RMD_BROADCAST	0x01	/* receive broadcasts & normal. usual */
-#define RMD_NO_PACKETS	0x00	/* don't receive any packets. unusual */
-
-/* bits in EDLC_XMODE, set Transmit Packet mode.  register is r/w */
-#define XMD_COLL_CNT	0xf0	/* coll's since success.  read-only */
-#define XMD_IG_PAR	0x08	/* =1 to ignore parity.  ALWAYS set */
-#define XMD_T_MODE	0x04	/* =1 to power xcvr. ALWAYS set this */
-#define XMD_LBC		0x02	/* =1 for loopback.  normally set */
-#define XMD_DIS_C	0x01	/* =1 disables contention. normally 0 */
-
-/* bits in EDLC_RESET, write only */
-#define RS_RESET	0x80	/* =1 to hold EDLC in reset state */
-
-/* bits in IE_MMODE, write only */
-#define MM_EN_DMA	0x80	/* =1 begin DMA xfer, Cplt clrs it */
-#define MM_EN_RCV	0x40	/* =1 allows Pkt rcv.  clr'd by rcv */
-#define MM_EN_XMT	0x20	/* =1 begin Xmt pkt.  Cplt clrs it */
-#define MM_BUS_PAGE	0x18	/* =00 ALWAYS.  Used when MUX=1 */
-#define MM_NET_PAGE	0x06	/* =00 ALWAYS.  Used when MUX=0 */
-#define MM_MUX		0x01	/* =1 means Rcv Buff on system bus */
-				/* =0 means Xmt Buff on system bus */
-
-/* bits in IE_ISTAT, read only */
-#define IS_TDIAG	0x80	/* =1 if Diagnostic problem */
-#define IS_EN_RCV	0x20	/* =1 until frame is rcv'd cplt */
-#define IS_EN_XMT	0x10	/* =1 until frame is xmt'd cplt */
-#define IS_EN_DMA	0x08	/* =1 until DMA is cplt or aborted */
-#define IS_DMA_INT	0x04	/* =0 iff DMA done interrupt. */
-#define IS_R_INT	0x02	/* =0 iff unmasked Rcv interrupt */
-#define IS_X_INT	0x01	/* =0 iff unmasked Xmt interrupt */
-
-/* NIC specific static variables go here */
-
-static unsigned short		ioaddr = 0;
-static unsigned int		bufsize_rcv = 0;
-
-#if	0
-static void show_registers(void)
-{
-	printf("XSTAT %hhX ", inb(EDLC_XSTAT));
-	printf("XMASK %hhX ", inb(EDLC_XMASK));
-	printf("RSTAT %hhX ", inb(EDLC_RSTAT));
-	printf("RMASK %hhX ", inb(EDLC_RMASK));
-	printf("RMODE %hhX ", inb(EDLC_RMODE));
-	printf("XMODE %hhX ", inb(EDLC_XMODE));
-	printf("ISTAT %hhX\n", inb(IE_ISTAT));
-}
-#endif
-
-static void reset_receiver(void)
-{
-	outw(0, IE_GP);		/* Receive packet at start of buffer */
-	outb(RS_VALID_BITS, EDLC_RCLR);	/* Clear all pending Rcv interrupts */
-	outb(MM_EN_RCV, IE_MMODE); /* Enable rcv */
-}
-
-/**************************************************************************
-RESET - Reset adapter
-***************************************************************************/
-static void ni5010_reset(struct nic *nic)
-{
-	int		i;
-
-	/* Reset the hardware here.  Don't forget to set the station address. */
-	outb(RS_RESET, EDLC_RESET);	/* Hold up EDLC_RESET while configing board */
-	outb(0, IE_RESET);	/* Hardware reset of ni5010 board */
-	outb(0, EDLC_XMASK);	/* Disable all Xmt interrupts */
-	outb(0, EDLC_RMASK);	/* Disable all Rcv interrupt */
-	outb(0xFF, EDLC_XCLR);	/* Clear all pending Xmt interrupts */
-	outb(0xFF, EDLC_RCLR);	/* Clear all pending Rcv interrupts */
-	outb(XMD_LBC, EDLC_XMODE);	/* Only loopback xmits */
-	/* Set the station address */
-	for(i = 0; i < ETH_ALEN; i++)
-		outb(nic->node_addr[i], EDLC_ADDR + i);
-	outb(XMD_IG_PAR | XMD_T_MODE | XMD_LBC, EDLC_XMODE); 
-				/* Normal packet xmit mode */
-	outb(RMD_BROADCAST, EDLC_RMODE);
-				/* Receive broadcast and normal packets */
-	reset_receiver();
-	outb(0x00, EDLC_RESET);	/* Un-reset the ni5010 */
-}
-
-/**************************************************************************
-POLL - Wait for a frame
-***************************************************************************/
-static int ni5010_poll(struct nic *nic)
-{
-	int		rcv_stat;
-
-	if (((rcv_stat = inb(EDLC_RSTAT)) & RS_VALID_BITS) != RS_PKT_OK) {
-		outb(rcv_stat, EDLC_RSTAT);	/* Clear the status */
-		return (0);
-	}
-        outb(rcv_stat, EDLC_RCLR);	/* Clear the status */
-	nic->packetlen = inw(IE_RCNT);
-	/* Read packet into buffer */
-        outb(MM_MUX, IE_MMODE);	/* Rcv buffer to system bus */
-	outw(0, IE_GP);		/* Seek to beginning of packet */
-	insb(IE_RBUF, nic->packet, nic->packetlen); 
-	return (1);
-}
-
-/**************************************************************************
-TRANSMIT - Transmit a frame
-***************************************************************************/
-static void ni5010_transmit(struct nic *nic,
-	const char *d,	/* Destination */
-	unsigned int t,	/* Type */
-	unsigned int s,	/* size */
-	const char *p)	/* Packet */
-{
-	unsigned int	len;
-	int		buf_offs, xmt_stat;
-	unsigned long	time;
-
-	len = s + ETH_HLEN;
-	if (len < ETH_ZLEN)
-		len = ETH_ZLEN;
-	buf_offs = NI5010_BUFSIZE - len;
-	outb(0, EDLC_RMASK);	/* Mask all receive interrupts */
-	outb(0, IE_MMODE);	/* Put Xmit buffer on system bus */
-	outb(0xFF, EDLC_RCLR);	/* Clear out pending rcv interrupts */
-	outw(buf_offs, IE_GP);	/* Point GP at start of packet */
-	outsb(IE_XBUF, d, ETH_ALEN);	/* Put dst in buffer */
-	outsb(IE_XBUF, nic->node_addr, ETH_ALEN);/* Put src in buffer */
-	outb(t >> 8, IE_XBUF);
-	outb(t, IE_XBUF);
-	outsb(IE_XBUF, p, s);	/* Put data in buffer */
-	while (s++ < ETH_ZLEN - ETH_HLEN)	/* Pad to min size */
-		outb(0, IE_XBUF);
-	outw(buf_offs, IE_GP);	/* Rewrite where packet starts */
-	/* should work without that outb() (Crynwr used it) */
-	/*outb(MM_MUX, IE_MMODE);*/
-	/* Xmt buffer to EDLC bus */
-	outb(MM_EN_XMT | MM_MUX, IE_MMODE);	/* Begin transmission */
-	/* wait for transmit complete */
-	while (((xmt_stat = inb(IE_ISTAT)) & IS_EN_XMT) != 0)
-		;
-	reset_receiver();	/* Immediately switch to receive */
-}
-
-/**************************************************************************
-DISABLE - Turn off ethernet interface
-***************************************************************************/
-static void ni5010_disable(struct nic *nic)
-{
-	outb(0, IE_MMODE);
-	outb(RS_RESET, EDLC_RESET);
-}
-
-static inline int rd_port(void)
-{
-	inb(IE_RBUF);
-	return inb(IE_SAPROM);
-}
-
-static int ni5010_probe1(struct nic *nic)
-{
-	int		i, boguscount = 40, data;
-
-	/* The tests are from the Linux NI5010 driver
-	   I don't understand it all, but if it works for them...  */
-	if (inb(ioaddr) == 0xFF)
-		return (0);
-	while ((rd_port() & rd_port() & rd_port()
-		& rd_port() & rd_port() & rd_port()) != 0xFF)
-	{
-		if (boguscount-- <= 0)
-			return (0);
-	}
-	for (i = 0; i < 32; i++)
-		if ((data = rd_port()) != 0xFF)
-			break;
-	if (data == 0xFF)
-		return (0);
-	if (data == SA_ADDR0 && rd_port() == SA_ADDR1 && rd_port() == SA_ADDR2) {
-		for (i = 0; i < 4; i++)
-			rd_port();
-		if (rd_port() != NI5010_MAGICVAL1 || rd_port() != NI5010_MAGICVAL2)
-			return (0);
-	} else
-		return (0);
-	for (i = 0; i < ETH_ALEN; i++) {
-		outw(i, IE_GP);
-		nic->node_addr[i] = inb(IE_SAPROM);
-	}
-	printf("\nNI5010 ioaddr %#hX, addr %!\n", ioaddr, nic->node_addr);
-/* get the size of the onboard receive buffer
- * higher addresses than bufsize are wrapped into real buffer
- * i.e. data for offs. 0x801 is written to 0x1 with a 2K onboard buffer
- */
-	if (bufsize_rcv == 0) {
-        	outb(1, IE_MMODE);      /* Put Rcv buffer on system bus */
-        	outw(0, IE_GP);		/* Point GP at start of packet */
-        	outb(0, IE_RBUF);	/* set buffer byte 0 to 0 */
-        	for (i = 1; i < 0xFF; i++) {
-                	outw(i << 8, IE_GP); /* Point GP at packet size to be tested */
-                	outb(i, IE_RBUF);
-                	outw(0x0, IE_GP); /* Point GP at start of packet */
-                	data = inb(IE_RBUF);
-                	if (data == i) break;
-        	}
-		bufsize_rcv = i << 8;
-        	outw(0, IE_GP);		/* Point GP at start of packet */
-        	outb(0, IE_RBUF);	/* set buffer byte 0 to 0 again */
-	}
-	printf("Bufsize rcv/xmt=%d/%d\n", bufsize_rcv, NI5010_BUFSIZE);
-	return (1);
-}
-
-/**************************************************************************
-PROBE - Look for an adapter, this routine's visible to the outside
-***************************************************************************/
-struct nic *ni5010_probe(struct nic *nic, unsigned short *probe_addrs)
-{
-	static unsigned short	io_addrs[] = {
-		0x300, 0x320, 0x340, 0x360, 0x380, 0x3a0, 0 };
-	unsigned short		*p;
-
-	/* if probe_addrs is 0, then use list above */
-	if (probe_addrs == 0 || *probe_addrs == 0)
-		probe_addrs = io_addrs;
-	for (p = probe_addrs; (ioaddr = *p) != 0; p++) {
-		if (ni5010_probe1(nic))
-			break;
-	}
-	if (ioaddr == 0)
-		return (0);
-	ni5010_reset(nic);
-	/* point to NIC specific routines */
-	nic->reset = ni5010_reset;
-	nic->poll = ni5010_poll;
-	nic->transmit = ni5010_transmit;
-	nic->disable = ni5010_disable;
-	return (nic);
-}
diff -Naur grub-0.97.orig/netboot/nic.c grub-0.97/netboot/nic.c
--- grub-0.97.orig/netboot/nic.c	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/nic.c	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,1198 @@
+/**************************************************************************
+Etherboot -  Network Bootstrap Program
+
+Literature dealing with the network protocols:
+	ARP - RFC826
+	RARP - RFC903
+        IP - RFC791
+	UDP - RFC768
+	BOOTP - RFC951, RFC2132 (vendor extensions)
+	DHCP - RFC2131, RFC2132 (options)
+	TFTP - RFC1350, RFC2347 (options), RFC2348 (blocksize), RFC2349 (tsize)
+	RPC - RFC1831, RFC1832 (XDR), RFC1833 (rpcbind/portmapper)
+	NFS - RFC1094, RFC1813 (v3, useful for clarifications, not implemented)
+	IGMP - RFC1112, RFC2113, RFC2365, RFC2236, RFC3171
+
+**************************************************************************/
+#include "etherboot.h"
+#include "grub.h"
+#include "nic.h"
+#include "elf.h" /* FOR EM_CURRENT */
+#include "bootp.h"
+#include "if_arp.h"
+#include "tftp.h"
+#include "timer.h"
+#include "ip.h"
+#include "udp.h"
+
+/* Currently no other module uses rom, but it is available */
+struct rom_info		rom;
+struct arptable_t	arptable[MAX_ARP];
+#if MULTICAST_LEVEL2
+unsigned long last_igmpv1 = 0;
+struct igmptable_t	igmptable[MAX_IGMP];
+#endif
+static unsigned long	netmask;
+/* Used by nfs.c */
+char *hostname = "";
+int hostnamelen = 0;
+static uint32_t xid;
+static unsigned char *end_of_rfc1533 = NULL;
+static const unsigned char broadcast[] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
+static const in_addr zeroIP = { 0L };
+static char rfc1533_venddata[MAX_RFC1533_VENDLEN];
+static unsigned char rfc1533_cookie[4] = { RFC1533_COOKIE };
+static unsigned char rfc1533_cookie_bootp[5] = { RFC1533_COOKIE, RFC1533_END };
+static unsigned char rfc1533_cookie_dhcp[] = { RFC1533_COOKIE };
+static int dhcp_reply;
+static in_addr dhcp_server = { 0L };
+static in_addr dhcp_addr = { 0L };
+
+static const unsigned char dhcpdiscover[] = {
+	RFC2132_MSG_TYPE, 1, DHCPDISCOVER,
+	RFC2132_MAX_SIZE, 2,	/* request as much as we can */
+	ETH_MAX_MTU / 256, ETH_MAX_MTU % 256,
+	/* Vendor class identifier */
+	RFC2132_VENDOR_CLASS_ID, 10, 'G', 'R', 'U', 'B', 'C', 'l', 'i', 'e', 'n', 't',
+	RFC2132_PARAM_LIST, 4, RFC1533_NETMASK, RFC1533_GATEWAY,
+	RFC1533_HOSTNAME, RFC1533_EXTENSIONPATH, RFC1533_END
+};
+static const unsigned char dhcprequest [] = {
+	RFC2132_MSG_TYPE,1,DHCPREQUEST,
+	RFC2132_SRV_ID,4,0,0,0,0,
+	RFC2132_REQ_ADDR,4,0,0,0,0,
+	RFC2132_MAX_SIZE,2,	/* request as much as we can */
+	ETH_MAX_MTU / 256, ETH_MAX_MTU % 256,
+	/* Vendor class identifier */
+	RFC2132_VENDOR_CLASS_ID, 10, 'G', 'R', 'U', 'B', 'C', 'l', 'i', 'e', 'n', 't',
+	RFC2132_PARAM_LIST,
+	/* 4 standard + 2 vendortags */
+	4 + 2,
+	/* Standard parameters */
+	RFC1533_NETMASK, RFC1533_GATEWAY,
+	RFC1533_HOSTNAME, RFC1533_EXTENSIONPATH,
+	/* Etherboot vendortags */
+	RFC1533_VENDOR_MAGIC,
+	RFC1533_VENDOR_CONFIGFILE,
+	RFC1533_END
+};
+
+/* See nic.h */
+int user_abort = 0;
+int network_ready = 0;
+
+#ifdef	REQUIRE_VCI_ETHERBOOT
+int	vci_etherboot;
+#endif
+
+static int dummy(void *unused __unused)
+{
+	return (0);
+}
+
+/* Careful.  We need an aligned buffer to avoid problems on machines
+ * that care about alignment.  To trivally align the ethernet data
+ * (the ip hdr and arp requests) we offset the packet by 2 bytes.
+ * leaving the ethernet data 16 byte aligned.  Beyond this
+ * we use memmove but this makes the common cast simple and fast.
+ */
+static char	packet[ETH_FRAME_LEN + ETH_DATA_ALIGN] __aligned;
+
+struct nic	nic =
+{
+	{
+		0,				/* dev.disable */
+		{
+			0,
+			0,
+			PCI_BUS_TYPE,
+		},				/* dev.devid */
+		0,				/* index */
+		0,				/* type */
+		PROBE_FIRST,			/* how_pobe */
+		PROBE_NONE,			/* to_probe */
+		0,				/* failsafe */
+		0,				/* type_index */
+		{},				/* state */
+	},
+	(int (*)(struct nic *, int))dummy,      /* poll */
+	(void (*)(struct nic *, const char *,
+		unsigned int, unsigned int,
+		const char *))dummy,		/* transmit */
+	(void (*)(struct nic *, irq_action_t))dummy, /* irq */
+	0,					/* flags */
+	&rom,					/* rom_info */
+	arptable[ARP_CLIENT].node,		/* node_addr */
+	packet + ETH_DATA_ALIGN,		/* packet */
+	0,					/* packetlen */
+	0,			/* ioaddr */
+	0,			/* irqno */
+	NULL,					/* priv_data */
+};
+
+
+
+int grub_eth_probe(void)
+{
+	static int probed = 0;
+	struct dev *dev;
+
+	EnterFunction("grub_eth_probe");
+
+	if (probed)
+		return 1;
+
+	network_ready = 0;
+	grub_memset((char *)arptable, 0, MAX_ARP * sizeof(struct arptable_t));
+	dev = &nic.dev;
+	dev->how_probe = -1;
+	dev->type = NIC_DRIVER;
+	dev->failsafe = 1;
+	rom = *((struct rom_info *)ROM_INFO_LOCATION);
+
+	probed = (eth_probe(dev) == PROBE_WORKED);
+
+	LeaveFunction("grub_eth_probe");
+	return probed;
+}
+
+int eth_probe(struct dev *dev)
+{
+	return probe(dev);
+}
+
+int eth_poll(int retrieve)
+{
+	return ((*nic.poll)(&nic, retrieve));
+}
+
+void eth_transmit(const char *d, unsigned int t, unsigned int s, const void *p)
+{
+	(*nic.transmit)(&nic, d, t, s, p);
+	if (t == IP) twiddle();
+}
+
+void eth_disable(void)
+{
+#ifdef MULTICAST_LEVEL2
+	int i;
+	for(i = 0; i < MAX_IGMP; i++) {
+		leave_group(i);
+	}
+#endif
+	disable(&nic.dev);
+}
+
+void eth_irq (irq_action_t action)
+{
+	(*nic.irq)(&nic,action);
+}
+
+/**************************************************************************
+IPCHKSUM - Checksum IP Header
+**************************************************************************/
+uint16_t ipchksum(const void *data, unsigned long length)
+{
+	unsigned long sum;
+	unsigned long i;
+	const uint8_t *ptr;
+
+	/* In the most straight forward way possible,
+	 * compute an ip style checksum.
+	 */
+	sum = 0;
+	ptr = data;
+	for(i = 0; i < length; i++) {
+		unsigned long value;
+		value = ptr[i];
+		if (i & 1) {
+			value <<= 8;
+		}
+		/* Add the new value */
+		sum += value;
+		/* Wrap around the carry */
+		if (sum > 0xFFFF) {
+			sum = (sum + (sum >> 16)) & 0xFFFF;
+		}
+	}
+	return (~cpu_to_le16(sum)) & 0xFFFF;
+}
+
+uint16_t add_ipchksums(unsigned long offset, uint16_t sum, uint16_t new)
+{
+	unsigned long checksum;
+	sum = ~sum & 0xFFFF;
+	new = ~new & 0xFFFF;
+	if (offset & 1) {
+		/* byte swap the sum if it came from an odd offset 
+		 * since the computation is endian independant this
+		 * works.
+		 */
+		new = bswap_16(new);
+	}
+	checksum = sum + new;
+	if (checksum > 0xFFFF) {
+		checksum -= 0xFFFF;
+	}
+	return (~checksum) & 0xFFFF;
+}
+
+/**************************************************************************
+DEFAULT_NETMASK - Return default netmask for IP address
+**************************************************************************/
+static inline unsigned long default_netmask(void)
+{
+	int net = ntohl(arptable[ARP_CLIENT].ipaddr.s_addr) >> 24;
+	if (net <= 127)
+		return(htonl(0xff000000));
+	else if (net < 192)
+		return(htonl(0xffff0000));
+	else
+		return(htonl(0xffffff00));
+}
+
+/**************************************************************************
+IP_TRANSMIT - Send an IP datagram
+**************************************************************************/
+static int await_arp(int ival, void *ptr,
+	unsigned short ptype, struct iphdr *ip __unused, struct udphdr *udp __unused)
+{
+	struct	arprequest *arpreply;
+	if (ptype != ARP)
+		return 0;
+	if (nic.packetlen < ETH_HLEN + sizeof(struct arprequest))
+		return 0;
+	arpreply = (struct arprequest *)&nic.packet[ETH_HLEN];
+
+	if (arpreply->opcode != htons(ARP_REPLY)) 
+		return 0;
+	if (memcmp(arpreply->sipaddr, ptr, sizeof(in_addr)) != 0)
+		return 0;
+	memcpy(arptable[ival].node, arpreply->shwaddr, ETH_ALEN);
+	return 1;
+}
+
+int ip_transmit(int len, const void *buf)
+{
+	unsigned long destip;
+	struct iphdr *ip;
+	struct arprequest arpreq;
+	int arpentry, i;
+	int retry;
+
+	ip = (struct iphdr *)buf;
+	destip = ip->dest.s_addr;
+	if (destip == IP_BROADCAST) {
+		eth_transmit(broadcast, IP, len, buf);
+#ifdef MULTICAST_LEVEL1 
+	} else if ((destip & htonl(MULTICAST_MASK)) == htonl(MULTICAST_NETWORK)) {
+		unsigned char multicast[6];
+		unsigned long hdestip;
+		hdestip = ntohl(destip);
+		multicast[0] = 0x01;
+		multicast[1] = 0x00;
+		multicast[2] = 0x5e;
+		multicast[3] = (hdestip >> 16) & 0x7;
+		multicast[4] = (hdestip >> 8) & 0xff;
+		multicast[5] = hdestip & 0xff;
+		eth_transmit(multicast, IP, len, buf);
+#endif
+	} else {
+		if (((destip & netmask) !=
+		     (arptable[ARP_CLIENT].ipaddr.s_addr & netmask)) &&
+		    arptable[ARP_GATEWAY].ipaddr.s_addr)
+			destip = arptable[ARP_GATEWAY].ipaddr.s_addr;
+		for(arpentry = 0; arpentry<MAX_ARP; arpentry++)
+			if (arptable[arpentry].ipaddr.s_addr == destip) break;
+		if (arpentry == MAX_ARP) {
+			printf("%@ is not in my arp table!\n", destip);
+			return(0);
+		}
+		for (i = 0; i < ETH_ALEN; i++)
+			if (arptable[arpentry].node[i])
+				break;
+		if (i == ETH_ALEN) {	/* Need to do arp request */
+			arpreq.hwtype = htons(1);
+			arpreq.protocol = htons(IP);
+			arpreq.hwlen = ETH_ALEN;
+			arpreq.protolen = 4;
+			arpreq.opcode = htons(ARP_REQUEST);
+			memcpy(arpreq.shwaddr, arptable[ARP_CLIENT].node, ETH_ALEN);
+			memcpy(arpreq.sipaddr, &arptable[ARP_CLIENT].ipaddr, sizeof(in_addr));
+			memset(arpreq.thwaddr, 0, ETH_ALEN);
+			memcpy(arpreq.tipaddr, &destip, sizeof(in_addr));
+			for (retry = 1; retry <= MAX_ARP_RETRIES; retry++) {
+				long timeout;
+				eth_transmit(broadcast, ARP, sizeof(arpreq),
+					&arpreq);
+				timeout = rfc2131_sleep_interval(TIMEOUT, retry);
+				if (await_reply(await_arp, arpentry,
+					arpreq.tipaddr, timeout)) goto xmit;
+			}
+			return(0);
+		}
+xmit:
+		eth_transmit(arptable[arpentry].node, IP, len, buf);
+	}
+	return 1;
+}
+
+void build_ip_hdr(unsigned long destip, int ttl, int protocol, int option_len,
+	int len, const void *buf)
+{
+	struct iphdr *ip;
+	ip = (struct iphdr *)buf;
+	ip->verhdrlen = 0x45;
+	ip->verhdrlen += (option_len/4);
+	ip->service = 0;
+	ip->len = htons(len);
+	ip->ident = 0;
+	ip->frags = 0; /* Should we set don't fragment? */
+	ip->ttl = ttl;
+	ip->protocol = protocol;
+	ip->chksum = 0;
+	ip->src.s_addr = arptable[ARP_CLIENT].ipaddr.s_addr;
+	ip->dest.s_addr = destip;
+	ip->chksum = ipchksum(buf, sizeof(struct iphdr) + option_len);
+}
+
+static uint16_t udpchksum(struct iphdr *ip, struct udphdr *udp)
+{
+	struct udp_pseudo_hdr pseudo;
+	uint16_t checksum;
+
+	/* Compute the pseudo header */
+	pseudo.src.s_addr  = ip->src.s_addr;
+	pseudo.dest.s_addr = ip->dest.s_addr;
+	pseudo.unused      = 0;
+	pseudo.protocol    = IP_UDP;
+	pseudo.len         = udp->len;
+
+	/* Sum the pseudo header */
+	checksum = ipchksum(&pseudo, 12);
+
+	/* Sum the rest of the udp packet */
+	checksum = add_ipchksums(12, checksum, ipchksum(udp, ntohs(udp->len)));
+	return checksum;
+}
+
+
+void build_udp_hdr(unsigned long destip, 
+	unsigned int srcsock, unsigned int destsock, int ttl,
+	int len, const void *buf)
+{
+	struct iphdr *ip;
+	struct udphdr *udp;
+	ip = (struct iphdr *)buf;
+	build_ip_hdr(destip, ttl, IP_UDP, 0, len, buf);
+	udp = (struct udphdr *)((char *)buf + sizeof(struct iphdr));
+	udp->src = htons(srcsock);
+	udp->dest = htons(destsock);
+	udp->len = htons(len - sizeof(struct iphdr));
+	udp->chksum = 0;
+	if ((udp->chksum = udpchksum(ip, udp)) == 0)
+		udp->chksum = 0xffff;
+}
+
+
+/**************************************************************************
+UDP_TRANSMIT - Send an UDP datagram
+**************************************************************************/
+int udp_transmit(unsigned long destip, unsigned int srcsock,
+	unsigned int destsock, int len, const void *buf)
+{
+	build_udp_hdr(destip, srcsock, destsock, 60, len, buf);
+	return ip_transmit(len, buf);
+}
+
+/**************************************************************************
+QDRAIN - clear the nic's receive queue
+**************************************************************************/
+static int await_qdrain(int ival __unused, void *ptr __unused,
+	unsigned short ptype __unused, 
+	struct iphdr *ip __unused, struct udphdr *udp __unused)
+{
+	return 0;
+}
+
+void rx_qdrain(void)
+{
+	/* Clear out the Rx queue first.  It contains nothing of interest,
+	 * except possibly ARP requests from the DHCP/TFTP server.  We use
+	 * polling throughout Etherboot, so some time may have passed since we
+	 * last polled the receive queue, which may now be filled with
+	 * broadcast packets.  This will cause the reply to the packets we are
+	 * about to send to be lost immediately.  Not very clever.  */
+	await_reply(await_qdrain, 0, NULL, 0);
+}
+
+/**
+ * rarp
+ *
+ * Get IP address by rarp. Just copy from etherboot
+ **/
+static int await_rarp(int ival, void *ptr, unsigned short ptype, 
+		      struct iphdr *ip, struct udphdr *udp)
+{
+	struct arprequest *arpreply;
+	if (ptype != RARP)
+		return 0;
+	if (nic.packetlen < ETH_HLEN + sizeof(struct arprequest))
+		return 0;
+	arpreply = (struct arprequest *)&nic.packet[ETH_HLEN];
+	if (arpreply->opcode != htons(RARP_REPLY))
+		return 0;
+	if (memcmp(arpreply->thwaddr, ptr, ETH_ALEN) == 0){
+		memcpy(arptable[ARP_SERVER].node, arpreply->shwaddr, ETH_ALEN);
+		memcpy(&arptable[ARP_SERVER].ipaddr, arpreply->sipaddr, sizeof(in_addr));
+		memcpy(&arptable[ARP_CLIENT].ipaddr, arpreply->tipaddr, sizeof(in_addr));
+		return 1;
+	}
+	return 0;
+}
+
+int rarp(void)
+{
+	int retry;
+
+	/* arp and rarp requests share the same packet structure. */
+	struct arprequest rarpreq;
+
+	if(!grub_eth_probe())
+		return 0;
+	network_ready = 0;
+
+	memset(&rarpreq, 0, sizeof(rarpreq));
+
+	rarpreq.hwtype = htons(1);
+	rarpreq.protocol = htons(IP);
+	rarpreq.hwlen = ETH_ALEN;
+	rarpreq.protolen = 4;
+	rarpreq.opcode = htons(RARP_REQUEST);
+	memcpy(&rarpreq.shwaddr, arptable[ARP_CLIENT].node, ETH_ALEN);
+	/* sipaddr is already zeroed out */
+	memcpy(&rarpreq.thwaddr, arptable[ARP_CLIENT].node, ETH_ALEN);
+	/* tipaddr is already zeroed out */
+
+	for (retry = 0; retry < MAX_ARP_RETRIES; ++retry) {
+		long timeout;
+		eth_transmit(broadcast, RARP, sizeof(rarpreq), &rarpreq);
+
+		timeout = rfc2131_sleep_interval(TIMEOUT, retry);
+		if (await_reply(await_rarp, 0, rarpreq.shwaddr, timeout))
+			break;
+		if (user_abort)
+			return 0;
+	}
+
+	if (retry < MAX_ARP_RETRIES) {
+		network_ready = 1;
+		return (1);
+	}
+	return (0);
+}
+
+/**
+ * bootp
+ *
+ * Get IP address by bootp, segregate from bootp in etherboot.
+ **/
+static int await_bootp(int ival __unused, void *ptr __unused,
+	unsigned short ptype __unused, struct iphdr *ip __unused, 
+	struct udphdr *udp)
+{
+	struct	bootp_t *bootpreply;
+	int len;		/* Length of vendor */
+
+	if (!udp) {
+		return 0;
+	}
+	bootpreply = (struct bootp_t *)
+		&nic.packet[ETH_HLEN + sizeof(struct iphdr) + sizeof(struct udphdr)];
+	len = nic.packetlen - (ETH_HLEN + sizeof(struct iphdr) + 
+		sizeof(struct udphdr) + sizeof(struct bootp_t) - BOOTP_VENDOR_LEN);
+	if (len < 0) {
+		return 0;
+	}
+	if (udp->dest != htons(BOOTP_CLIENT))
+		return 0;
+	if (bootpreply->bp_op != BOOTP_REPLY)
+		return 0;
+	if (bootpreply->bp_xid != xid)
+		return 0;
+	if (memcmp((char *)&bootpreply->bp_siaddr, (char *)&zeroIP, sizeof(in_addr)) == 0)
+		return 0;
+	if ((memcmp(broadcast, bootpreply->bp_hwaddr, ETH_ALEN) != 0) &&
+	    (memcmp(arptable[ARP_CLIENT].node, bootpreply->bp_hwaddr, ETH_ALEN) != 0)) {
+		return 0;
+	}
+	arptable[ARP_CLIENT].ipaddr.s_addr = bootpreply->bp_yiaddr.s_addr;
+	netmask = default_netmask();
+	arptable[ARP_SERVER].ipaddr.s_addr = bootpreply->bp_siaddr.s_addr;
+	memset(arptable[ARP_SERVER].node, 0, ETH_ALEN);  /* Kill arp */
+	arptable[ARP_GATEWAY].ipaddr.s_addr = bootpreply->bp_giaddr.s_addr;
+	memset(arptable[ARP_GATEWAY].node, 0, ETH_ALEN);  /* Kill arp */
+	/* We don't care bootpreply->bp_file, it must be 'pxegrub':-) */
+	memcpy((char *)rfc1533_venddata, (char *)(bootpreply->bp_vend), len);
+	decode_rfc1533(rfc1533_venddata, 0, len, 1);
+	return(1);
+}
+
+int bootp(void)
+{
+	int retry;
+	struct bootpip_t ip;
+	unsigned long  starttime;
+	
+	EnterFunction("bootp");
+
+	if(!grub_eth_probe())
+		return 0;
+	network_ready = 0;
+
+	memset(&ip, 0, sizeof(struct bootpip_t));
+	ip.bp.bp_op = BOOTP_REQUEST;
+	ip.bp.bp_htype = 1;
+	ip.bp.bp_hlen = ETH_ALEN;
+	starttime = currticks();
+	/* Use lower 32 bits of node address, more likely to be
+	   distinct than the time since booting */
+	memcpy(&xid, &arptable[ARP_CLIENT].node[2], sizeof(xid));
+	ip.bp.bp_xid = xid += htonl(starttime);
+	/* bp_secs defaults to zero */
+	memcpy(ip.bp.bp_hwaddr, arptable[ARP_CLIENT].node, ETH_ALEN);
+	memcpy(ip.bp.bp_vend, rfc1533_cookie_bootp, sizeof(rfc1533_cookie_bootp)); /* request RFC-style options */
+
+	for (retry = 0; retry < MAX_BOOTP_RETRIES; ) {
+		long timeout;
+
+		rx_qdrain();
+
+		udp_transmit(IP_BROADCAST, BOOTP_CLIENT, BOOTP_SERVER,
+			sizeof(struct bootpip_t), &ip);
+		timeout = rfc2131_sleep_interval(TIMEOUT, retry++);
+		if (await_reply(await_bootp, 0, NULL, timeout)){
+			network_ready = 1;
+			return(1);
+		}
+		if (user_abort)
+			return 0;
+		ip.bp.bp_secs = htons((currticks()-starttime)/TICKS_PER_SEC);
+	}
+	return(0);
+}
+
+/**
+ * dhcp
+ *
+ * Get IP address by dhcp, segregate from bootp in etherboot.
+ **/
+static int await_dhcp(int ival __unused, void *ptr __unused,
+	unsigned short ptype __unused, struct iphdr *ip __unused, 
+	struct udphdr *udp)
+{
+	struct	dhcp_t *dhcpreply;
+	int len;
+
+	if (!udp) {
+		return 0;
+	}
+	dhcpreply = (struct dhcp_t *)
+		&nic.packet[ETH_HLEN + sizeof(struct iphdr) + sizeof(struct udphdr)];
+	len = nic.packetlen - (ETH_HLEN + sizeof(struct iphdr) + 
+		sizeof(struct udphdr) + sizeof(struct dhcp_t) - DHCP_OPT_LEN);
+	if (len < 0){
+		return 0;
+	}
+	if (udp->dest != htons(BOOTP_CLIENT))
+		return 0;
+	if (dhcpreply->bp_op != BOOTP_REPLY)
+		return 0;
+	if (dhcpreply->bp_xid != xid)
+		return 0;
+	if (memcmp((char *)&dhcpreply->bp_siaddr, (char *)&zeroIP, sizeof(in_addr)) == 0)
+		return 0;
+	if ((memcmp(broadcast, dhcpreply->bp_hwaddr, ETH_ALEN) != 0) &&
+	    (memcmp(arptable[ARP_CLIENT].node, dhcpreply->bp_hwaddr, ETH_ALEN) != 0)) {
+		return 0;
+	}
+	arptable[ARP_CLIENT].ipaddr.s_addr = dhcpreply->bp_yiaddr.s_addr;
+	dhcp_addr.s_addr = dhcpreply->bp_yiaddr.s_addr;
+	netmask = default_netmask();
+	arptable[ARP_SERVER].ipaddr.s_addr = dhcpreply->bp_siaddr.s_addr;
+	memset(arptable[ARP_SERVER].node, 0, ETH_ALEN);  /* Kill arp */
+	arptable[ARP_GATEWAY].ipaddr.s_addr = dhcpreply->bp_giaddr.s_addr;
+	memset(arptable[ARP_GATEWAY].node, 0, ETH_ALEN);  /* Kill arp */
+	/* We don't care bootpreply->bp_file. It must be 'pxegrub' */
+	memcpy((char *)rfc1533_venddata, (char *)(dhcpreply->bp_vend), len);
+	decode_rfc1533(rfc1533_venddata, 0, len, 1);
+	return(1);
+}
+
+int dhcp(void)
+{
+	int retry;
+	int reqretry;
+	struct dhcpip_t ip;
+	unsigned long  starttime;
+
+	if(!grub_eth_probe())
+		return 0;
+
+	network_ready = 0;
+
+	memset(&ip, 0, sizeof(struct dhcpip_t));
+	ip.bp.bp_op = BOOTP_REQUEST;
+	ip.bp.bp_htype = 1;
+	ip.bp.bp_hlen = ETH_ALEN;
+	starttime = currticks();
+	/* Use lower 32 bits of node address, more likely to be
+	   distinct than the time since booting */
+	memcpy(&xid, &arptable[ARP_CLIENT].node[2], sizeof(xid));
+	ip.bp.bp_xid = xid += htonl(starttime);
+	memcpy(ip.bp.bp_hwaddr, arptable[ARP_CLIENT].node, ETH_ALEN);
+	memcpy(ip.bp.bp_vend, rfc1533_cookie_dhcp, sizeof rfc1533_cookie_dhcp); /* request RFC-style options */
+	memcpy(ip.bp.bp_vend + sizeof rfc1533_cookie_dhcp, dhcpdiscover, sizeof dhcpdiscover);
+
+	for (retry = 0; retry < MAX_BOOTP_RETRIES; ) {
+		long timeout;
+
+		rx_qdrain();
+
+		udp_transmit(IP_BROADCAST, BOOTP_CLIENT, BOOTP_SERVER,
+			     sizeof(struct bootpip_t), &ip);
+		timeout = rfc2131_sleep_interval(TIMEOUT, retry++);
+		if (await_reply(await_dhcp, 0, NULL, timeout)) {
+			/* If not a DHCPOFFER then must be just a
+			   BOOTP reply, be backward compatible with
+			   BOOTP then. Jscott report a bug here, but I
+			   don't know how it happened */
+			if (dhcp_reply != DHCPOFFER){
+				network_ready = 1;
+				return(1);
+			}
+			dhcp_reply = 0;
+			memcpy(ip.bp.bp_vend, rfc1533_cookie_dhcp, sizeof rfc1533_cookie_dhcp);
+			memcpy(ip.bp.bp_vend + sizeof rfc1533_cookie_dhcp, dhcprequest, sizeof dhcprequest);
+			/* Beware: the magic numbers 9 and 15 depend on
+			   the layout of dhcprequest */
+			memcpy(&ip.bp.bp_vend[9], &dhcp_server, sizeof(in_addr));
+			memcpy(&ip.bp.bp_vend[15], &dhcp_addr, sizeof(in_addr));
+			for (reqretry = 0; reqretry < MAX_BOOTP_RETRIES; ) {
+				udp_transmit(IP_BROADCAST, BOOTP_CLIENT, BOOTP_SERVER,
+					     sizeof(struct bootpip_t), &ip);
+				dhcp_reply=0;
+				timeout = rfc2131_sleep_interval(TIMEOUT, reqretry++);
+				if (await_reply(await_dhcp, 0, NULL, timeout))
+					if (dhcp_reply == DHCPACK){
+						network_ready = 1;
+						return(1);
+					}
+				if (user_abort)
+					return 0;
+			}
+		}
+		if (user_abort)
+			return 0;
+		ip.bp.bp_secs = htons((currticks()-starttime)/TICKS_PER_SEC);
+	}
+	return(0);
+}
+
+#ifdef MULTICAST_LEVEL2
+static void send_igmp_reports(unsigned long now)
+{
+	int i;
+	for(i = 0; i < MAX_IGMP; i++) {
+		if (igmptable[i].time && (now >= igmptable[i].time)) {
+			struct igmp_ip_t igmp;
+			igmp.router_alert[0] = 0x94;
+			igmp.router_alert[1] = 0x04;
+			igmp.router_alert[2] = 0;
+			igmp.router_alert[3] = 0;
+			build_ip_hdr(igmptable[i].group.s_addr, 
+				1, IP_IGMP, sizeof(igmp.router_alert), sizeof(igmp), &igmp);
+			igmp.igmp.type = IGMPv2_REPORT;
+			if (last_igmpv1 && 
+				(now < last_igmpv1 + IGMPv1_ROUTER_PRESENT_TIMEOUT)) {
+				igmp.igmp.type = IGMPv1_REPORT;
+			}
+			igmp.igmp.response_time = 0;
+			igmp.igmp.chksum = 0;
+			igmp.igmp.group.s_addr = igmptable[i].group.s_addr;
+			igmp.igmp.chksum = ipchksum(&igmp.igmp, sizeof(igmp.igmp));
+			ip_transmit(sizeof(igmp), &igmp);
+#ifdef	MDEBUG
+			printf("Sent IGMP report to: %@\n", igmp.igmp.group.s_addr);
+#endif
+			/* Don't send another igmp report until asked */
+			igmptable[i].time = 0;
+		}
+	}
+}
+
+static void process_igmp(struct iphdr *ip, unsigned long now)
+{
+	struct igmp *igmp;
+	int i;
+	unsigned iplen = 0;
+	if (!ip || (ip->protocol == IP_IGMP) ||
+		(nic.packetlen < sizeof(struct iphdr) + sizeof(struct igmp))) {
+		return;
+	}
+	iplen = (ip->verhdrlen & 0xf)*4;
+	igmp = (struct igmp *)&nic.packet[sizeof(struct iphdr)];
+	if (ipchksum(igmp, ntohs(ip->len) - iplen) != 0)
+		return;
+	if ((igmp->type == IGMP_QUERY) && 
+		(ip->dest.s_addr == htonl(GROUP_ALL_HOSTS))) {
+		unsigned long interval = IGMP_INTERVAL;
+		if (igmp->response_time == 0) {
+			last_igmpv1 = now;
+		} else {
+			interval = (igmp->response_time * TICKS_PER_SEC)/10;
+		}
+		
+#ifdef	MDEBUG
+		printf("Received IGMP query for: %@\n", igmp->group.s_addr);
+#endif			       
+		for(i = 0; i < MAX_IGMP; i++) {
+			uint32_t group = igmptable[i].group.s_addr;
+			if ((group == 0) || (group == igmp->group.s_addr)) {
+				unsigned long time;
+				time = currticks() + rfc1112_sleep_interval(interval, 0);
+				if (time < igmptable[i].time) {
+					igmptable[i].time = time;
+				}
+			}
+		}
+	}
+	if (((igmp->type == IGMPv1_REPORT) || (igmp->type == IGMPv2_REPORT)) &&
+		(ip->dest.s_addr == igmp->group.s_addr)) {
+#ifdef	MDEBUG
+		printf("Received IGMP report for: %@\n", igmp->group.s_addr);
+#endif			       
+		for(i = 0; i < MAX_IGMP; i++) {
+			if ((igmptable[i].group.s_addr == igmp->group.s_addr) &&
+				igmptable[i].time != 0) {
+				igmptable[i].time = 0;
+			}
+		}
+	}
+}
+
+void leave_group(int slot)
+{
+	/* Be very stupid and always send a leave group message if 
+	 * I have subscribed.  Imperfect but it is standards
+	 * compliant, easy and reliable to implement.
+	 *
+	 * The optimal group leave method is to only send leave when,
+	 * we were the last host to respond to a query on this group,
+	 * and igmpv1 compatibility is not enabled.
+	 */
+	if (igmptable[slot].group.s_addr) {
+		struct igmp_ip_t igmp;
+		igmp.router_alert[0] = 0x94;
+		igmp.router_alert[1] = 0x04;
+		igmp.router_alert[2] = 0;
+		igmp.router_alert[3] = 0;
+		build_ip_hdr(htonl(GROUP_ALL_HOSTS),
+			1, IP_IGMP, sizeof(igmp.router_alert), sizeof(igmp), &igmp);
+		igmp.igmp.type = IGMP_LEAVE;
+		igmp.igmp.response_time = 0;
+		igmp.igmp.chksum = 0;
+		igmp.igmp.group.s_addr = igmptable[slot].group.s_addr;
+		igmp.igmp.chksum = ipchksum(&igmp.igmp, sizeof(igmp));
+		ip_transmit(sizeof(igmp), &igmp);
+#ifdef	MDEBUG
+		printf("Sent IGMP leave for: %@\n", igmp.igmp.group.s_addr);
+#endif	
+	}
+	memset(&igmptable[slot], 0, sizeof(igmptable[0]));
+}
+
+void join_group(int slot, unsigned long group)
+{
+	/* I have already joined */
+	if (igmptable[slot].group.s_addr == group)
+		return;
+	if (igmptable[slot].group.s_addr) {
+		leave_group(slot);
+	}
+	/* Only join a group if we are given a multicast ip, this way
+	 * code can be given a non-multicast (broadcast or unicast ip)
+	 * and still work... 
+	 */
+	if ((group & htonl(MULTICAST_MASK)) == htonl(MULTICAST_NETWORK)) {
+		igmptable[slot].group.s_addr = group;
+		igmptable[slot].time = currticks();
+	}
+}
+#else
+#define send_igmp_reports(now);
+#define process_igmp(ip, now)
+#endif
+
+/**************************************************************************
+AWAIT_REPLY - Wait until we get a response for our request
+************f**************************************************************/
+int await_reply(reply_t reply, int ival, void *ptr, long timeout)
+{
+	unsigned long time, now;
+	struct	iphdr *ip;
+	unsigned iplen = 0;
+	struct	udphdr *udp;
+	unsigned short ptype;
+	int result;
+
+	user_abort = 0;
+
+	time = timeout + currticks();
+	/* The timeout check is done below.  The timeout is only checked if
+	 * there is no packet in the Rx queue.  This assumes that eth_poll()
+	 * needs a negligible amount of time.  
+	 */
+	for (;;) {
+		now = currticks();
+		send_igmp_reports(now);
+		result = eth_poll(1);
+		if (result == 0) {
+			/* We don't have anything */
+		
+			/* Check for abort key only if the Rx queue is empty -
+			 * as long as we have something to process, don't
+			 * assume that something failed.  It is unlikely that
+			 * we have no processing time left between packets.  */
+			poll_interruptions();
+			/* Do the timeout after at least a full queue walk.  */
+			if ((timeout == 0) || (currticks() > time) || user_abort == 1) {
+				break;
+			}
+			continue;
+		}
+	
+		/* We have something! */
+
+		/* Find the Ethernet packet type */
+		if (nic.packetlen >= ETH_HLEN) {
+			ptype = ((unsigned short) nic.packet[12]) << 8
+				| ((unsigned short) nic.packet[13]);
+		} else continue; /* what else could we do with it? */
+		/* Verify an IP header */
+		ip = 0;
+		if ((ptype == IP) && (nic.packetlen >= ETH_HLEN + sizeof(struct iphdr))) {
+			unsigned ipoptlen;
+			ip = (struct iphdr *)&nic.packet[ETH_HLEN];
+			if ((ip->verhdrlen < 0x45) || (ip->verhdrlen > 0x4F)) 
+				continue;
+			iplen = (ip->verhdrlen & 0xf) * 4;
+			if (ipchksum(ip, iplen) != 0)
+				continue;
+			if (ip->frags & htons(0x3FFF)) {
+				static int warned_fragmentation = 0;
+				if (!warned_fragmentation) {
+					printf("ALERT: got a fragmented packet - reconfigure your server\n");
+					warned_fragmentation = 1;
+				}
+				continue;
+			}
+			if (ntohs(ip->len) > ETH_MAX_MTU)
+				continue;
+
+			ipoptlen = iplen - sizeof(struct iphdr);
+			if (ipoptlen) {
+				/* Delete the ip options, to guarantee
+				 * good alignment, and make etherboot simpler.
+				 */
+				memmove(&nic.packet[ETH_HLEN + sizeof(struct iphdr)], 
+					&nic.packet[ETH_HLEN + iplen],
+					nic.packetlen - ipoptlen);
+				nic.packetlen -= ipoptlen;
+			}
+		}
+		udp = 0;
+		if (ip && (ip->protocol == IP_UDP) && 
+		    (nic.packetlen >= ETH_HLEN + sizeof(struct iphdr) + sizeof(struct udphdr))) {
+			udp = (struct udphdr *)&nic.packet[ETH_HLEN + sizeof(struct iphdr)];
+			
+			/* Make certain we have a reasonable packet length */
+			if (ntohs(udp->len) > (ntohs(ip->len) - iplen))
+				continue;
+
+			if (udp->chksum && udpchksum(ip, udp)) {
+				printf("UDP checksum error\n");
+				continue;
+			}
+		}
+		result = reply(ival, ptr, ptype, ip, udp);
+		if (result > 0) {
+			return result;
+		}
+		
+		/* If it isn't a packet the upper layer wants see if there is a default
+		 * action.  This allows us reply to arp and igmp queryies.
+		 */
+		if ((ptype == ARP) &&
+		    (nic.packetlen >= ETH_HLEN + sizeof(struct arprequest))) {
+			struct	arprequest *arpreply;
+			unsigned long tmp;
+			
+			arpreply = (struct arprequest *)&nic.packet[ETH_HLEN];
+			memcpy(&tmp, arpreply->tipaddr, sizeof(in_addr));
+			if ((arpreply->opcode == htons(ARP_REQUEST)) &&
+			    (tmp == arptable[ARP_CLIENT].ipaddr.s_addr)) {
+				arpreply->opcode = htons(ARP_REPLY);
+				memcpy(arpreply->tipaddr, arpreply->sipaddr, sizeof(in_addr));
+				memcpy(arpreply->thwaddr, arpreply->shwaddr, ETH_ALEN);
+				memcpy(arpreply->sipaddr, &arptable[ARP_CLIENT].ipaddr, sizeof(in_addr));
+				memcpy(arpreply->shwaddr, arptable[ARP_CLIENT].node, ETH_ALEN);
+				eth_transmit(arpreply->thwaddr, ARP,
+					     sizeof(struct  arprequest),
+					     arpreply);
+#ifdef	MDEBUG
+				memcpy(&tmp, arpreply->tipaddr, sizeof(in_addr));
+				printf("Sent ARP reply to: %@\n",tmp);
+#endif	/* MDEBUG */
+			}
+		}
+		process_igmp(ip, now);
+	}
+	return(0);
+}
+
+#ifdef	REQUIRE_VCI_ETHERBOOT
+/**************************************************************************
+FIND_VCI_ETHERBOOT - Looks for "Etherboot" in Vendor Encapsulated Identifiers
+On entry p points to byte count of VCI options
+**************************************************************************/
+static int find_vci_etherboot(unsigned char *p)
+{
+	unsigned char	*end = p + 1 + *p;
+
+	for (p++; p < end; ) {
+		if (*p == RFC2132_VENDOR_CLASS_ID) {
+			if (strncmp("Etherboot", p + 2, sizeof("Etherboot") - 1) == 0)
+				return (1);
+		} else if (*p == RFC1533_END)
+			return (0);
+		p += TAG_LEN(p) + 2;
+	}
+	return (0);
+}
+#endif	/* REQUIRE_VCI_ETHERBOOT */
+
+/**
+ * decode_rfc1533
+ *
+ * Decodes RFC1533 header
+ **/
+int decode_rfc1533(unsigned char *p, unsigned int block, unsigned int len, int eof)
+{
+	static unsigned char *extdata = NULL, *extend = NULL;
+	unsigned char        *extpath = NULL;
+	unsigned char        *endp;
+
+	if (block == 0) {
+		end_of_rfc1533 = NULL;
+		if (memcmp(p, rfc1533_cookie, sizeof(rfc1533_cookie)))
+			return(0); /* no RFC 1533 header found */
+		p += 4;
+		endp = p + len;
+	} else {
+		if (block == 1) {
+			if (memcmp(p, rfc1533_cookie, sizeof(rfc1533_cookie)))
+				return(0); /* no RFC 1533 header found */
+			p += 4;
+			len -= 4; }
+		if (extend + len <= (unsigned char *)
+		    rfc1533_venddata + sizeof(rfc1533_venddata)) {
+			memcpy(extend, p, len);
+			extend += len;
+		} else {
+			printf("Overflow in vendor data buffer! Aborting...\n");
+			*extdata = RFC1533_END;
+			return(0);
+		}
+		p = extdata; endp = extend;
+	}
+	if (!eof)
+		return 1;
+	while (p < endp) {
+		unsigned char c = *p;
+		if (c == RFC1533_PAD) {
+			p++;
+			continue;
+		}
+		else if (c == RFC1533_END) {
+			end_of_rfc1533 = endp = p;
+			continue;
+		}
+		else if (c == RFC1533_NETMASK)
+			memcpy(&netmask, p+2, sizeof(in_addr));
+		else if (c == RFC1533_GATEWAY) {
+			/* This is a little simplistic, but it will
+			   usually be sufficient.
+			   Take only the first entry */
+			if (TAG_LEN(p) >= sizeof(in_addr))
+				memcpy(&arptable[ARP_GATEWAY].ipaddr, p+2, sizeof(in_addr));
+		}
+		else if (c == RFC1533_EXTENSIONPATH)
+			extpath = p;
+		else if (c == RFC2132_MSG_TYPE)
+			dhcp_reply=*(p+2);
+		else if (c == RFC2132_SRV_ID)
+			memcpy(&dhcp_server, p+2, sizeof(in_addr));
+		else if (c == RFC1533_HOSTNAME) {
+			hostname = p + 2;
+			hostnamelen = *(p + 1);
+		}
+		else if (c == RFC1533_VENDOR_CONFIGFILE){
+			int l = TAG_LEN (p);
+	  
+			/* Eliminate the trailing NULs according to RFC 2132.  */
+			while (*(p + 2 + l - 1) == '\000' && l > 0)
+				l--;
+	  
+			/* XXX: Should check if LEN is less than the maximum length
+			   of CONFIG_FILE. This kind of robustness will be a goal
+			   in GRUB 1.0.  */
+			memcpy (config_file, p + 2, l);
+			config_file[l] = 0;
+		}
+		else {
+			;
+		}
+		p += TAG_LEN(p) + 2;
+	}
+	extdata = extend = endp;
+	if (block <= 0 && extpath != NULL) {
+		char fname[64];
+		if (TAG_LEN(extpath) >= sizeof(fname)){
+			printf("Overflow in vendor data buffer! Aborting...\n");
+			*extdata = RFC1533_END;
+			return(0);
+		}
+		memcpy(fname, extpath+2, TAG_LEN(extpath));
+		fname[(int)TAG_LEN(extpath)] = '\0';
+		printf("Loading BOOTP-extension file: %s\n",fname);
+		tftp_file_read(fname, decode_rfc1533);
+	}
+	return 1;	/* proceed with next block */
+}
+
+
+/* FIXME double check TWO_SECOND_DIVISOR */
+#define TWO_SECOND_DIVISOR (RAND_MAX/TICKS_PER_SEC)
+/**************************************************************************
+RFC2131_SLEEP_INTERVAL - sleep for expotentially longer times (base << exp) +- 1 sec)
+**************************************************************************/
+long rfc2131_sleep_interval(long base, int exp)
+{
+	unsigned long tmo;
+#ifdef BACKOFF_LIMIT
+	if (exp > BACKOFF_LIMIT)
+		exp = BACKOFF_LIMIT;
+#endif
+	tmo = (base << exp) + (TICKS_PER_SEC - (random()/TWO_SECOND_DIVISOR));
+	return tmo;
+}
+
+#ifdef MULTICAST_LEVEL2
+/**************************************************************************
+RFC1112_SLEEP_INTERVAL - sleep for expotentially longer times, up to (base << exp)
+**************************************************************************/
+long rfc1112_sleep_interval(long base, int exp)
+{
+	unsigned long divisor, tmo;
+#ifdef BACKOFF_LIMIT
+	if (exp > BACKOFF_LIMIT)
+		exp = BACKOFF_LIMIT;
+#endif
+	divisor = RAND_MAX/(base << exp);
+	tmo = random()/divisor;
+	return tmo;
+}
+#endif /* MULTICAST_LEVEL_2 */
+/* ifconfig - configure network interface.  */
+int
+ifconfig (char *ip, char *sm, char *gw, char *svr)
+{
+  in_addr tmp;
+  
+  if (sm) 
+    {
+      if (! inet_aton (sm, &tmp))
+	return 0;
+      
+      netmask = tmp.s_addr;
+    }
+  
+  if (ip) 
+    {
+      if (! inet_aton (ip, &arptable[ARP_CLIENT].ipaddr)) 
+	return 0;
+      
+      if (! netmask && ! sm) 
+	netmask = default_netmask ();
+    }
+  
+  if (gw && ! inet_aton (gw, &arptable[ARP_GATEWAY].ipaddr)) 
+    return 0;
+
+  /* Clear out the ARP entry.  */
+  grub_memset (arptable[ARP_GATEWAY].node, 0, ETH_ALEN);
+  
+  if (svr && ! inet_aton (svr, &arptable[ARP_SERVER].ipaddr)) 
+    return 0;
+
+  /* Likewise.  */
+  grub_memset (arptable[ARP_SERVER].node, 0, ETH_ALEN);
+  
+  if (ip || sm)
+    {
+      if (IP_BROADCAST == (netmask | arptable[ARP_CLIENT].ipaddr.s_addr)
+	  || netmask == (netmask | arptable[ARP_CLIENT].ipaddr.s_addr)
+	  || ! netmask)
+	network_ready = 0;
+      else
+	network_ready = 1;
+    }
+  
+  return 1;
+}
+
+/*
+ * print_network_configuration
+ *
+ * Output the network configuration. It may broke the graphic console now.:-(
+ */
+void print_network_configuration (void)
+{
+	EnterFunction("print_network_configuration");
+	if (! grub_eth_probe ())
+		grub_printf ("No ethernet card found.\n");
+	else if (! network_ready)
+		grub_printf ("Not initialized yet.\n");
+	else {
+		etherboot_printf ("Address: %@\n", arptable[ARP_CLIENT].ipaddr.s_addr);
+		etherboot_printf ("Netmask: %@\n", netmask);
+		etherboot_printf ("Server: %@\n", arptable[ARP_SERVER].ipaddr.s_addr);
+		etherboot_printf ("Gateway: %@\n", arptable[ARP_GATEWAY].ipaddr.s_addr);
+	}
+	LeaveFunction("print_network_configuration");
+}
+
+/**
+ * cleanup_net
+ *
+ * Mark network unusable, and disable NICs
+ */
+void cleanup_net (void)
+{
+	if (network_ready){
+		/* Stop receiving packets.  */
+		eth_disable ();
+		network_ready = 0;
+	}
+}
diff -Naur grub-0.97.orig/netboot/nic.h grub-0.97/netboot/nic.h
--- grub-0.97.orig/netboot/nic.h	2003-07-09 11:45:38.000000000 +0000
+++ grub-0.97/netboot/nic.h	2005-08-31 19:03:35.000000000 +0000
@@ -8,24 +8,38 @@
 #ifndef	NIC_H
 #define NIC_H
 
+#include "dev.h"
+
+typedef enum {
+	DISABLE = 0,
+	ENABLE,
+	FORCE
+} irq_action_t;
+
 /*
  *	Structure returned from eth_probe and passed to other driver
  *	functions.
  */
-
 struct nic
 {
-	void		(*reset)P((struct nic *));
-	int		(*poll)P((struct nic *));
+	struct dev	dev;  /* This must come first */
+	int		(*poll)P((struct nic *, int retrieve));
 	void		(*transmit)P((struct nic *, const char *d,
 				unsigned int t, unsigned int s, const char *p));
-	void		(*disable)P((struct nic *));
+	void		(*irq)P((struct nic *, irq_action_t));
 	int		flags;	/* driver specific flags */
 	struct rom_info	*rom_info;	/* -> rom_info from main */
 	unsigned char	*node_addr;
-	char		*packet;
+	unsigned char	*packet;
 	unsigned int	packetlen;
+	unsigned int	ioaddr;
+	unsigned char	irqno;
 	void		*priv_data;	/* driver can hang private data here */
 };
 
+extern int  eth_probe(struct dev *dev);
+extern int  eth_poll(int retrieve);
+extern void eth_transmit(const char *d, unsigned int t, unsigned int s, const void *p);
+extern void eth_disable(void);
+extern void eth_irq(irq_action_t action);
 #endif	/* NIC_H */
diff -Naur grub-0.97.orig/netboot/ns83820.c grub-0.97/netboot/ns83820.c
--- grub-0.97.orig/netboot/ns83820.c	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/ns83820.c	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,1020 @@
+/**************************************************************************
+*    ns83820.c: Etherboot device driver for the National Semiconductor 83820
+*    Written 2004 by Timothy Legge <tlegge@rogers.com>
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the License, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not, write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*    Portions of this code based on:
+*	ns83820.c by Benjamin LaHaise with contributions
+* 		for Linux kernel 2.4.x.
+*	
+*    Linux Driver Version 0.20, 20020610
+* 
+*    This development of this Etherboot driver was funded by:
+*
+*    NXTV: http://www.nxtv.com/
+*    	
+*    REVISION HISTORY:
+*    ================
+*
+*    v1.0	02-16-2004	timlegge	Initial port of Linux driver
+*    v1.1	02-19-2004	timlegge	More rohbust transmit and poll
+*    
+*    Indent Options: indent -kr -i8
+***************************************************************************/
+
+/* to get some global routines like printf */
+#include "etherboot.h"
+/* to get the interface to the body of the program */
+#include "nic.h"
+/* to get the PCI support functions, if this is a PCI NIC */
+#include "pci.h"
+
+#if ARCH == ia64		/* Support 64-bit addressing */
+#define USE_64BIT_ADDR
+#endif
+
+//#define DDEBUG
+#ifdef DDEBUG
+#define dprintf(x) printf x
+#else
+#define dprintf(x)
+#endif
+
+typedef unsigned char u8;
+typedef signed char s8;
+typedef unsigned short u16;
+typedef signed short s16;
+typedef unsigned int u32;
+typedef signed int s32;
+
+#define HZ 100
+
+/* Condensed operations for readability. */
+#define virt_to_le32desc(addr)  cpu_to_le32(virt_to_bus(addr))
+#define le32desc_to_virt(addr)  bus_to_virt(le32_to_cpu(addr))
+
+/* NIC specific static variables go here */
+
+/* Global parameters.  See MODULE_PARM near the bottom. */
+// static int ihr = 2;
+static int reset_phy = 0;
+static int lnksts = 0;		/* CFG_LNKSTS bit polarity */
+
+#if defined(CONFIG_HIGHMEM64G) || defined(__ia64__)
+#define USE_64BIT_ADDR	"+"
+#endif
+
+#if defined(USE_64BIT_ADDR)
+#define TRY_DAC	1
+#else
+#define TRY_DAC	0
+#endif
+
+/* tunables */
+#define RX_BUF_SIZE	1500	/* 8192 */
+
+/* Must not exceed ~65000. */
+#define NR_RX_DESC	64
+#define NR_TX_DESC	1
+
+		   /* not tunable *//* Extra 6 bytes for 64 bit alignment (divisable by 8) */
+#define REAL_RX_BUF_SIZE (RX_BUF_SIZE + 14 + 6)	/* rx/tx mac addr + type */
+
+#define MIN_TX_DESC_FREE	8
+
+/* register defines */
+#define CFGCS		0x04
+
+#define CR_TXE		0x00000001
+#define CR_TXD		0x00000002
+/* Ramit : Here's a tip, don't do a RXD immediately followed by an RXE
+ * The Receive engine skips one descriptor and moves
+ * onto the next one!! */
+#define CR_RXE		0x00000004
+#define CR_RXD		0x00000008
+#define CR_TXR		0x00000010
+#define CR_RXR		0x00000020
+#define CR_SWI		0x00000080
+#define CR_RST		0x00000100
+
+#define PTSCR_EEBIST_FAIL       0x00000001
+#define PTSCR_EEBIST_EN         0x00000002
+#define PTSCR_EELOAD_EN         0x00000004
+#define PTSCR_RBIST_FAIL        0x000001b8
+#define PTSCR_RBIST_DONE        0x00000200
+#define PTSCR_RBIST_EN          0x00000400
+#define PTSCR_RBIST_RST         0x00002000
+
+#define MEAR_EEDI		0x00000001
+#define MEAR_EEDO		0x00000002
+#define MEAR_EECLK		0x00000004
+#define MEAR_EESEL		0x00000008
+#define MEAR_MDIO		0x00000010
+#define MEAR_MDDIR		0x00000020
+#define MEAR_MDC		0x00000040
+
+#define ISR_TXDESC3	0x40000000
+#define ISR_TXDESC2	0x20000000
+#define ISR_TXDESC1	0x10000000
+#define ISR_TXDESC0	0x08000000
+#define ISR_RXDESC3	0x04000000
+#define ISR_RXDESC2	0x02000000
+#define ISR_RXDESC1	0x01000000
+#define ISR_RXDESC0	0x00800000
+#define ISR_TXRCMP	0x00400000
+#define ISR_RXRCMP	0x00200000
+#define ISR_DPERR	0x00100000
+#define ISR_SSERR	0x00080000
+#define ISR_RMABT	0x00040000
+#define ISR_RTABT	0x00020000
+#define ISR_RXSOVR	0x00010000
+#define ISR_HIBINT	0x00008000
+#define ISR_PHY		0x00004000
+#define ISR_PME		0x00002000
+#define ISR_SWI		0x00001000
+#define ISR_MIB		0x00000800
+#define ISR_TXURN	0x00000400
+#define ISR_TXIDLE	0x00000200
+#define ISR_TXERR	0x00000100
+#define ISR_TXDESC	0x00000080
+#define ISR_TXOK	0x00000040
+#define ISR_RXORN	0x00000020
+#define ISR_RXIDLE	0x00000010
+#define ISR_RXEARLY	0x00000008
+#define ISR_RXERR	0x00000004
+#define ISR_RXDESC	0x00000002
+#define ISR_RXOK	0x00000001
+
+#define TXCFG_CSI	0x80000000
+#define TXCFG_HBI	0x40000000
+#define TXCFG_MLB	0x20000000
+#define TXCFG_ATP	0x10000000
+#define TXCFG_ECRETRY	0x00800000
+#define TXCFG_BRST_DIS	0x00080000
+#define TXCFG_MXDMA1024	0x00000000
+#define TXCFG_MXDMA512	0x00700000
+#define TXCFG_MXDMA256	0x00600000
+#define TXCFG_MXDMA128	0x00500000
+#define TXCFG_MXDMA64	0x00400000
+#define TXCFG_MXDMA32	0x00300000
+#define TXCFG_MXDMA16	0x00200000
+#define TXCFG_MXDMA8	0x00100000
+
+#define CFG_LNKSTS	0x80000000
+#define CFG_SPDSTS	0x60000000
+#define CFG_SPDSTS1	0x40000000
+#define CFG_SPDSTS0	0x20000000
+#define CFG_DUPSTS	0x10000000
+#define CFG_TBI_EN	0x01000000
+#define CFG_MODE_1000	0x00400000
+/* Ramit : Dont' ever use AUTO_1000, it never works and is buggy.
+ * Read the Phy response and then configure the MAC accordingly */
+#define CFG_AUTO_1000	0x00200000
+#define CFG_PINT_CTL	0x001c0000
+#define CFG_PINT_DUPSTS	0x00100000
+#define CFG_PINT_LNKSTS	0x00080000
+#define CFG_PINT_SPDSTS	0x00040000
+#define CFG_TMRTEST	0x00020000
+#define CFG_MRM_DIS	0x00010000
+#define CFG_MWI_DIS	0x00008000
+#define CFG_T64ADDR	0x00004000
+#define CFG_PCI64_DET	0x00002000
+#define CFG_DATA64_EN	0x00001000
+#define CFG_M64ADDR	0x00000800
+#define CFG_PHY_RST	0x00000400
+#define CFG_PHY_DIS	0x00000200
+#define CFG_EXTSTS_EN	0x00000100
+#define CFG_REQALG	0x00000080
+#define CFG_SB		0x00000040
+#define CFG_POW		0x00000020
+#define CFG_EXD		0x00000010
+#define CFG_PESEL	0x00000008
+#define CFG_BROM_DIS	0x00000004
+#define CFG_EXT_125	0x00000002
+#define CFG_BEM		0x00000001
+
+#define EXTSTS_UDPPKT	0x00200000
+#define EXTSTS_TCPPKT	0x00080000
+#define EXTSTS_IPPKT	0x00020000
+
+#define SPDSTS_POLARITY	(CFG_SPDSTS1 | CFG_SPDSTS0 | CFG_DUPSTS | (lnksts ? CFG_LNKSTS : 0))
+
+#define MIBC_MIBS	0x00000008
+#define MIBC_ACLR	0x00000004
+#define MIBC_FRZ	0x00000002
+#define MIBC_WRN	0x00000001
+
+#define PCR_PSEN	(1 << 31)
+#define PCR_PS_MCAST	(1 << 30)
+#define PCR_PS_DA	(1 << 29)
+#define PCR_STHI_8	(3 << 23)
+#define PCR_STLO_4	(1 << 23)
+#define PCR_FFHI_8K	(3 << 21)
+#define PCR_FFLO_4K	(1 << 21)
+#define PCR_PAUSE_CNT	0xFFFE
+
+#define RXCFG_AEP	0x80000000
+#define RXCFG_ARP	0x40000000
+#define RXCFG_STRIPCRC	0x20000000
+#define RXCFG_RX_FD	0x10000000
+#define RXCFG_ALP	0x08000000
+#define RXCFG_AIRL	0x04000000
+#define RXCFG_MXDMA512	0x00700000
+#define RXCFG_DRTH	0x0000003e
+#define RXCFG_DRTH0	0x00000002
+
+#define RFCR_RFEN	0x80000000
+#define RFCR_AAB	0x40000000
+#define RFCR_AAM	0x20000000
+#define RFCR_AAU	0x10000000
+#define RFCR_APM	0x08000000
+#define RFCR_APAT	0x07800000
+#define RFCR_APAT3	0x04000000
+#define RFCR_APAT2	0x02000000
+#define RFCR_APAT1	0x01000000
+#define RFCR_APAT0	0x00800000
+#define RFCR_AARP	0x00400000
+#define RFCR_MHEN	0x00200000
+#define RFCR_UHEN	0x00100000
+#define RFCR_ULM	0x00080000
+
+#define VRCR_RUDPE	0x00000080
+#define VRCR_RTCPE	0x00000040
+#define VRCR_RIPE	0x00000020
+#define VRCR_IPEN	0x00000010
+#define VRCR_DUTF	0x00000008
+#define VRCR_DVTF	0x00000004
+#define VRCR_VTREN	0x00000002
+#define VRCR_VTDEN	0x00000001
+
+#define VTCR_PPCHK	0x00000008
+#define VTCR_GCHK	0x00000004
+#define VTCR_VPPTI	0x00000002
+#define VTCR_VGTI	0x00000001
+
+#define CR		0x00
+#define CFG		0x04
+#define MEAR		0x08
+#define PTSCR		0x0c
+#define	ISR		0x10
+#define	IMR		0x14
+#define	IER		0x18
+#define	IHR		0x1c
+#define TXDP		0x20
+#define TXDP_HI		0x24
+#define TXCFG		0x28
+#define GPIOR		0x2c
+#define RXDP		0x30
+#define RXDP_HI		0x34
+#define RXCFG		0x38
+#define PQCR		0x3c
+#define WCSR		0x40
+#define PCR		0x44
+#define RFCR		0x48
+#define RFDR		0x4c
+
+#define SRR		0x58
+
+#define VRCR		0xbc
+#define VTCR		0xc0
+#define VDR		0xc4
+#define CCSR		0xcc
+
+#define TBICR		0xe0
+#define TBISR		0xe4
+#define TANAR		0xe8
+#define TANLPAR		0xec
+#define TANER		0xf0
+#define TESR		0xf4
+
+#define TBICR_MR_AN_ENABLE	0x00001000
+#define TBICR_MR_RESTART_AN	0x00000200
+
+#define TBISR_MR_LINK_STATUS	0x00000020
+#define TBISR_MR_AN_COMPLETE	0x00000004
+
+#define TANAR_PS2 		0x00000100
+#define TANAR_PS1 		0x00000080
+#define TANAR_HALF_DUP 		0x00000040
+#define TANAR_FULL_DUP 		0x00000020
+
+#define GPIOR_GP5_OE		0x00000200
+#define GPIOR_GP4_OE		0x00000100
+#define GPIOR_GP3_OE		0x00000080
+#define GPIOR_GP2_OE		0x00000040
+#define GPIOR_GP1_OE		0x00000020
+#define GPIOR_GP3_OUT		0x00000004
+#define GPIOR_GP1_OUT		0x00000001
+
+#define LINK_AUTONEGOTIATE	0x01
+#define LINK_DOWN		0x02
+#define LINK_UP			0x04
+
+
+#define __kick_rx()	writel(CR_RXE, ns->base + CR)
+
+#define kick_rx() do { \
+	dprintf(("kick_rx: maybe kicking\n")); \
+		writel(virt_to_le32desc(&rx_ring[ns->cur_rx]), ns->base + RXDP); \
+		if (ns->next_rx == ns->next_empty) \
+			printf("uh-oh: next_rx == next_empty???\n"); \
+		__kick_rx(); \
+} while(0)
+
+
+#ifdef USE_64BIT_ADDR
+#define HW_ADDR_LEN	8
+#else
+#define HW_ADDR_LEN	4
+#endif
+
+#define CMDSTS_OWN	0x80000000
+#define CMDSTS_MORE	0x40000000
+#define CMDSTS_INTR	0x20000000
+#define CMDSTS_ERR	0x10000000
+#define CMDSTS_OK	0x08000000
+#define CMDSTS_LEN_MASK	0x0000ffff
+
+#define CMDSTS_DEST_MASK	0x01800000
+#define CMDSTS_DEST_SELF	0x00800000
+#define CMDSTS_DEST_MULTI	0x01000000
+
+#define DESC_SIZE	8	/* Should be cache line sized */
+
+#ifdef USE_64BIT_ADDR
+struct ring_desc {
+	uint64_t link;
+	uint64_t bufptr;
+	u32 cmdsts;
+	u32 extsts;		/* Extended status field */
+};
+#else
+struct ring_desc {
+	u32 link;
+	u32 bufptr;
+	u32 cmdsts;
+	u32 extsts;		/* Extended status field */
+};
+#endif
+
+/* Define the TX Descriptor */
+static struct ring_desc tx_ring[NR_TX_DESC]
+    __attribute__ ((aligned(8)));
+
+/* Create a static buffer of size REAL_RX_BUF_SIZE for each
+TX Descriptor.  All descriptors point to a
+part of this buffer */
+static unsigned char txb[NR_TX_DESC * REAL_RX_BUF_SIZE];
+
+/* Define the TX Descriptor */
+static struct ring_desc rx_ring[NR_RX_DESC]
+    __attribute__ ((aligned(8)));
+
+/* Create a static buffer of size REAL_RX_BUF_SIZE for each
+RX Descriptor   All descriptors point to a
+part of this buffer */
+static unsigned char rxb[NR_RX_DESC * REAL_RX_BUF_SIZE]
+    __attribute__ ((aligned(8)));
+
+/* Private Storage for the NIC */
+struct ns83820_private {
+	u8 *base;
+	int up;
+	long idle;
+	u32 *next_rx_desc;
+	u16 next_rx, next_empty;
+	u32 cur_rx;
+	u32 *descs;
+	unsigned ihr;
+	u32 CFG_cache;
+	u32 MEAR_cache;
+	u32 IMR_cache;
+	int linkstate;
+	u16 tx_done_idx;
+	u16 tx_idx;
+	u16 tx_intr_idx;
+	u32 phy_descs;
+	u32 *tx_descs;
+
+} nsx;
+static struct ns83820_private *ns;
+
+static void phy_intr(struct nic *nic __unused)
+{
+	static char *speeds[] =
+	    { "10", "100", "1000", "1000(?)", "1000F" };
+	u32 cfg, new_cfg;
+	u32 tbisr, tanar, tanlpar;
+	int speed, fullduplex, newlinkstate;
+
+	cfg = readl(ns->base + CFG) ^ SPDSTS_POLARITY;
+	if (ns->CFG_cache & CFG_TBI_EN) {
+		/* we have an optical transceiver */
+		tbisr = readl(ns->base + TBISR);
+		tanar = readl(ns->base + TANAR);
+		tanlpar = readl(ns->base + TANLPAR);
+		dprintf(("phy_intr: tbisr=%hX, tanar=%hX, tanlpar=%hX\n",
+			 tbisr, tanar, tanlpar));
+
+		if ((fullduplex = (tanlpar & TANAR_FULL_DUP)
+		     && (tanar & TANAR_FULL_DUP))) {
+
+			/* both of us are full duplex */
+			writel(readl(ns->base + TXCFG)
+			       | TXCFG_CSI | TXCFG_HBI | TXCFG_ATP,
+			       ns->base + TXCFG);
+			writel(readl(ns->base + RXCFG) | RXCFG_RX_FD,
+			       ns->base + RXCFG);
+			/* Light up full duplex LED */
+			writel(readl(ns->base + GPIOR) | GPIOR_GP1_OUT,
+			       ns->base + GPIOR);
+
+		} else if (((tanlpar & TANAR_HALF_DUP)
+			    && (tanar & TANAR_HALF_DUP))
+			   || ((tanlpar & TANAR_FULL_DUP)
+			       && (tanar & TANAR_HALF_DUP))
+			   || ((tanlpar & TANAR_HALF_DUP)
+			       && (tanar & TANAR_FULL_DUP))) {
+
+			/* one or both of us are half duplex */
+			writel((readl(ns->base + TXCFG)
+				& ~(TXCFG_CSI | TXCFG_HBI)) | TXCFG_ATP,
+			       ns->base + TXCFG);
+			writel(readl(ns->base + RXCFG) & ~RXCFG_RX_FD,
+			       ns->base + RXCFG);
+			/* Turn off full duplex LED */
+			writel(readl(ns->base + GPIOR) & ~GPIOR_GP1_OUT,
+			       ns->base + GPIOR);
+		}
+
+		speed = 4;	/* 1000F */
+
+	} else {
+		/* we have a copper transceiver */
+		new_cfg =
+		    ns->CFG_cache & ~(CFG_SB | CFG_MODE_1000 | CFG_SPDSTS);
+
+		if (cfg & CFG_SPDSTS1)
+			new_cfg |= CFG_MODE_1000;
+		else
+			new_cfg &= ~CFG_MODE_1000;
+
+		speed = ((cfg / CFG_SPDSTS0) & 3);
+		fullduplex = (cfg & CFG_DUPSTS);
+
+		if (fullduplex)
+			new_cfg |= CFG_SB;
+
+		if ((cfg & CFG_LNKSTS) &&
+		    ((new_cfg ^ ns->CFG_cache) & CFG_MODE_1000)) {
+			writel(new_cfg, ns->base + CFG);
+			ns->CFG_cache = new_cfg;
+		}
+
+		ns->CFG_cache &= ~CFG_SPDSTS;
+		ns->CFG_cache |= cfg & CFG_SPDSTS;
+	}
+
+	newlinkstate = (cfg & CFG_LNKSTS) ? LINK_UP : LINK_DOWN;
+
+	if (newlinkstate & LINK_UP && ns->linkstate != newlinkstate) {
+		printf("link now %s mbps, %s duplex and up.\n",
+		       speeds[speed], fullduplex ? "full" : "half");
+	} else if (newlinkstate & LINK_DOWN
+		   && ns->linkstate != newlinkstate) {
+		printf("link now down.\n");
+	}
+	ns->linkstate = newlinkstate;
+}
+static void ns83820_set_multicast(struct nic *nic __unused);
+static void ns83820_setup_rx(struct nic *nic)
+{
+	unsigned i;
+	ns->idle = 1;
+	ns->next_rx = 0;
+	ns->next_rx_desc = ns->descs;
+	ns->next_empty = 0;
+	ns->cur_rx = 0;
+
+
+	for (i = 0; i < NR_RX_DESC; i++) {
+		rx_ring[i].link = virt_to_le32desc(&rx_ring[i + 1]);
+		rx_ring[i].bufptr =
+		    virt_to_le32desc(&rxb[i * REAL_RX_BUF_SIZE]);
+		rx_ring[i].cmdsts = cpu_to_le32(REAL_RX_BUF_SIZE);
+		rx_ring[i].extsts = cpu_to_le32(0);
+	}
+//      No need to wrap the ring 
+//      rx_ring[i].link = virt_to_le32desc(&rx_ring[0]);
+	writel(0, ns->base + RXDP_HI);
+	writel(virt_to_le32desc(&rx_ring[0]), ns->base + RXDP);
+
+	dprintf(("starting receiver\n"));
+
+	writel(0x0001, ns->base + CCSR);
+	writel(0, ns->base + RFCR);
+	writel(0x7fc00000, ns->base + RFCR);
+	writel(0xffc00000, ns->base + RFCR);
+
+	ns->up = 1;
+
+	phy_intr(nic);
+
+	/* Okay, let it rip */
+	ns->IMR_cache |= ISR_PHY;
+	ns->IMR_cache |= ISR_RXRCMP;
+	//dev->IMR_cache |= ISR_RXERR;
+	//dev->IMR_cache |= ISR_RXOK;
+	ns->IMR_cache |= ISR_RXORN;
+	ns->IMR_cache |= ISR_RXSOVR;
+	ns->IMR_cache |= ISR_RXDESC;
+	ns->IMR_cache |= ISR_RXIDLE;
+	ns->IMR_cache |= ISR_TXDESC;
+	ns->IMR_cache |= ISR_TXIDLE;
+
+	// No reason to enable interupts...
+	// writel(ns->IMR_cache, ns->base + IMR);
+	// writel(1, ns->base + IER);
+	ns83820_set_multicast(nic);
+	kick_rx();
+}
+
+
+static void ns83820_do_reset(struct nic *nic __unused, u32 which)
+{
+	dprintf(("resetting chip...\n"));
+	writel(which, ns->base + CR);
+	do {
+
+	} while (readl(ns->base + CR) & which);
+	dprintf(("okay!\n"));
+}
+
+static void ns83820_reset(struct nic *nic)
+{
+	unsigned i;
+	dprintf(("ns83820_reset\n"));
+
+	writel(0, ns->base + PQCR);
+
+	ns83820_setup_rx(nic);
+
+	for (i = 0; i < NR_TX_DESC; i++) {
+		tx_ring[i].link = 0;
+		tx_ring[i].bufptr = 0;
+		tx_ring[i].cmdsts = cpu_to_le32(0);
+		tx_ring[i].extsts = cpu_to_le32(0);
+	}
+
+	ns->tx_idx = 0;
+	ns->tx_done_idx = 0;
+	writel(0, ns->base + TXDP_HI);
+	return;
+}
+static void ns83820_getmac(struct nic *nic __unused, u8 * mac)
+{
+	unsigned i;
+	for (i = 0; i < 3; i++) {
+		u32 data;
+		/* Read from the perfect match memory: this is loaded by
+		 * the chip from the EEPROM via the EELOAD self test.
+		 */
+		writel(i * 2, ns->base + RFCR);
+		data = readl(ns->base + RFDR);
+		*mac++ = data;
+		*mac++ = data >> 8;
+	}
+}
+
+static void ns83820_set_multicast(struct nic *nic __unused)
+{
+	u8 *rfcr = ns->base + RFCR;
+	u32 and_mask = 0xffffffff;
+	u32 or_mask = 0;
+	u32 val;
+
+	/* Support Multicast */
+	and_mask &= ~(RFCR_AAU | RFCR_AAM);
+	or_mask |= RFCR_AAM;
+	val = (readl(rfcr) & and_mask) | or_mask;
+	/* Ramit : RFCR Write Fix doc says RFEN must be 0 modify other bits */
+	writel(val & ~RFCR_RFEN, rfcr);
+	writel(val, rfcr);
+
+}
+static void ns83820_run_bist(struct nic *nic __unused, const char *name,
+			     u32 enable, u32 done, u32 fail)
+{
+	int timed_out = 0;
+	long start;
+	u32 status;
+	int loops = 0;
+
+	dprintf(("start %s\n", name))
+
+	    start = currticks();
+
+	writel(enable, ns->base + PTSCR);
+	for (;;) {
+		loops++;
+		status = readl(ns->base + PTSCR);
+		if (!(status & enable))
+			break;
+		if (status & done)
+			break;
+		if (status & fail)
+			break;
+		if ((currticks() - start) >= HZ) {
+			timed_out = 1;
+			break;
+		}
+	}
+
+	if (status & fail)
+		printf("%s failed! (0x%hX & 0x%hX)\n", name, status, fail);
+	else if (timed_out)
+		printf("run_bist %s timed out! (%hX)\n", name, status);
+	dprintf(("done %s in %d loops\n", name, loops));
+}
+
+/*************************************
+Check Link
+*************************************/
+static void ns83820_check_intr(struct nic *nic) {
+	int i;
+	u32 isr = readl(ns->base + ISR);
+	if(ISR_PHY & isr)
+		phy_intr(nic);
+	if(( ISR_RXIDLE | ISR_RXDESC | ISR_RXERR) & isr)
+		kick_rx();
+	for (i = 0; i < NR_RX_DESC; i++) {
+		if (rx_ring[i].cmdsts == CMDSTS_OWN) {
+//			rx_ring[i].link = virt_to_le32desc(&rx_ring[i + 1]);
+			rx_ring[i].cmdsts = cpu_to_le32(REAL_RX_BUF_SIZE);
+		}
+	}
+}
+/**************************************************************************
+POLL - Wait for a frame
+***************************************************************************/
+static int ns83820_poll(struct nic *nic, int retrieve)
+{
+	/* return true if there's an ethernet packet ready to read */
+	/* nic->packet should contain data on return */
+	/* nic->packetlen should contain length of data */
+	u32 cmdsts;
+	int entry = ns->cur_rx;
+
+	ns83820_check_intr(nic);
+
+	cmdsts = le32_to_cpu(rx_ring[entry].cmdsts);
+
+	if ( ! ( (CMDSTS_OWN & (cmdsts)) && (cmdsts != (CMDSTS_OWN)) ) )
+	  return 0;
+
+	if ( ! retrieve ) return 1;
+
+	if (! (CMDSTS_OK & cmdsts) )
+	  return 0;
+
+	nic->packetlen = cmdsts & 0xffff;
+	memcpy(nic->packet,
+	       rxb + (entry * REAL_RX_BUF_SIZE),
+	       nic->packetlen);
+	//			rx_ring[entry].link = 0;
+	rx_ring[entry].cmdsts = cpu_to_le32(CMDSTS_OWN);
+
+	ns->cur_rx = ++ns->cur_rx % NR_RX_DESC;
+
+	if (ns->cur_rx == 0)	/* We have wrapped the ring */
+	  kick_rx();
+
+	return 1;
+}
+
+static inline void kick_tx(struct nic *nic __unused)
+{
+	dprintf(("kick_tx\n"));
+	writel(CR_TXE, ns->base + CR);
+}
+
+/**************************************************************************
+TRANSMIT - Transmit a frame
+***************************************************************************/
+static void ns83820_transmit(struct nic *nic, const char *d,	/* Destination */
+			     unsigned int t,	/* Type */
+			     unsigned int s,	/* size */
+			     const char *p)
+{				/* Packet */
+	/* send the packet to destination */
+
+	u16 nstype;
+	u32 cmdsts, extsts;
+	int cur_tx = 0;
+	u32 isr = readl(ns->base + ISR);
+	if (ISR_TXIDLE & isr)
+		kick_tx(nic);
+	/* point to the current txb incase multiple tx_rings are used */
+	memcpy(txb, d, ETH_ALEN);
+	memcpy(txb + ETH_ALEN, nic->node_addr, ETH_ALEN);
+	nstype = htons((u16) t);
+	memcpy(txb + 2 * ETH_ALEN, (u8 *) & nstype, 2);
+	memcpy(txb + ETH_HLEN, p, s);
+	s += ETH_HLEN;
+	s &= 0x0FFF;
+	while (s < ETH_ZLEN)
+		txb[s++] = '\0';
+
+	/* Setup the transmit descriptor */
+	extsts = 0;
+	extsts |= EXTSTS_UDPPKT;
+
+	tx_ring[cur_tx].bufptr = virt_to_le32desc(&txb);
+	tx_ring[cur_tx].extsts = cpu_to_le32(extsts);
+
+	cmdsts = cpu_to_le32(0);
+	cmdsts |= cpu_to_le32(CMDSTS_OWN | s);
+	tx_ring[cur_tx].cmdsts = cpu_to_le32(cmdsts);
+
+	writel(virt_to_le32desc(&tx_ring[0]), ns->base + TXDP);
+	kick_tx(nic);
+}
+
+/**************************************************************************
+DISABLE - Turn off ethernet interface
+***************************************************************************/
+static void ns83820_disable(struct dev *dev)
+{
+	/* put the card in its initial state */
+	/* This function serves 3 purposes.
+	 * This disables DMA and interrupts so we don't receive
+	 *  unexpected packets or interrupts from the card after
+	 *  etherboot has finished. 
+	 * This frees resources so etherboot may use
+	 *  this driver on another interface
+	 * This allows etherboot to reinitialize the interface
+	 *  if something is something goes wrong.
+	 */
+	/* disable interrupts */
+	writel(0, ns->base + IMR);
+	writel(0, ns->base + IER);
+	readl(ns->base + IER);
+
+	ns->up = 0;
+
+	ns83820_do_reset((struct nic *) dev, CR_RST);
+
+	ns->IMR_cache &=
+	    ~(ISR_RXOK | ISR_RXDESC | ISR_RXERR | ISR_RXEARLY |
+	      ISR_RXIDLE);
+	writel(ns->IMR_cache, ns->base + IMR);
+
+	/* touch the pci bus... */
+	readl(ns->base + IMR);
+
+	/* assumes the transmitter is already disabled and reset */
+	writel(0, ns->base + RXDP_HI);
+	writel(0, ns->base + RXDP);
+}
+
+/**************************************************************************
+IRQ - Enable, Disable, or Force interrupts
+***************************************************************************/
+static void ns83820_irq(struct nic *nic __unused, irq_action_t action __unused)
+{
+  switch ( action ) {
+  case DISABLE :
+    break;
+  case ENABLE :
+    break;
+  case FORCE :
+    break;
+  }
+}
+
+/**************************************************************************
+PROBE - Look for an adapter, this routine's visible to the outside
+***************************************************************************/
+
+#define board_found 1
+#define valid_link 0
+static int ns83820_probe(struct dev *dev, struct pci_device *pci)
+{
+	struct nic *nic = (struct nic *) dev;
+	int sz;
+	long addr;
+	int using_dac = 0;
+
+	if (pci->ioaddr == 0)
+		return 0;
+
+	printf("ns83820.c: Found %s, vendor=0x%hX, device=0x%hX\n",
+	       pci->name, pci->vendor, pci->dev_id);
+
+	/* point to private storage */
+	ns = &nsx;
+
+	adjust_pci_device(pci);
+
+	addr = pci_bar_start(pci, PCI_BASE_ADDRESS_1);
+	sz = pci_bar_size(pci, PCI_BASE_ADDRESS_1);
+
+	ns->base = ioremap(addr, (1UL << 12));
+//      ns->base = ioremap(addr, sz);
+
+	if (!ns->base)
+		return 0;
+
+	nic->irqno  = 0;
+	nic->ioaddr = pci->ioaddr & ~3;
+
+	/* disable interrupts */
+	writel(0, ns->base + IMR);
+	writel(0, ns->base + IER);
+	readl(ns->base + IER);
+
+	ns->IMR_cache = 0;
+
+	ns83820_do_reset(nic, CR_RST);
+
+	/* Must reset the ram bist before running it */
+	writel(PTSCR_RBIST_RST, ns->base + PTSCR);
+	ns83820_run_bist(nic, "sram bist", PTSCR_RBIST_EN,
+			 PTSCR_RBIST_DONE, PTSCR_RBIST_FAIL);
+	ns83820_run_bist(nic, "eeprom bist", PTSCR_EEBIST_EN, 0,
+			 PTSCR_EEBIST_FAIL);
+	ns83820_run_bist(nic, "eeprom load", PTSCR_EELOAD_EN, 0, 0);
+
+	/* I love config registers */
+	ns->CFG_cache = readl(ns->base + CFG);
+
+	if ((ns->CFG_cache & CFG_PCI64_DET)) {
+		printf("%s: detected 64 bit PCI data bus.\n", pci->name);
+		/*dev->CFG_cache |= CFG_DATA64_EN; */
+		if (!(ns->CFG_cache & CFG_DATA64_EN))
+			printf
+			    ("%s: EEPROM did not enable 64 bit bus.  Disabled.\n",
+			     pci->name);
+	} else
+		ns->CFG_cache &= ~(CFG_DATA64_EN);
+
+	ns->CFG_cache &= (CFG_TBI_EN | CFG_MRM_DIS | CFG_MWI_DIS |
+			  CFG_T64ADDR | CFG_DATA64_EN | CFG_EXT_125 |
+			  CFG_M64ADDR);
+	ns->CFG_cache |=
+	    CFG_PINT_DUPSTS | CFG_PINT_LNKSTS | CFG_PINT_SPDSTS |
+	    CFG_EXTSTS_EN | CFG_EXD | CFG_PESEL;
+	ns->CFG_cache |= CFG_REQALG;
+	ns->CFG_cache |= CFG_POW;
+	ns->CFG_cache |= CFG_TMRTEST;
+
+	/* When compiled with 64 bit addressing, we must always enable
+	 * the 64 bit descriptor format.
+	 */
+#ifdef USE_64BIT_ADDR
+	ns->CFG_cache |= CFG_M64ADDR;
+#endif
+
+//FIXME: Enable section on dac or remove this
+	if (using_dac)
+		ns->CFG_cache |= CFG_T64ADDR;
+
+	/* Big endian mode does not seem to do what the docs suggest */
+	ns->CFG_cache &= ~CFG_BEM;
+
+	/* setup optical transceiver if we have one */
+	if (ns->CFG_cache & CFG_TBI_EN) {
+		dprintf(("%s: enabling optical transceiver\n", pci->name));
+		writel(readl(ns->base + GPIOR) | 0x3e8, ns->base + GPIOR);
+
+		/* setup auto negotiation feature advertisement */
+		writel(readl(ns->base + TANAR)
+		       | TANAR_HALF_DUP | TANAR_FULL_DUP,
+		       ns->base + TANAR);
+
+		/* start auto negotiation */
+		writel(TBICR_MR_AN_ENABLE | TBICR_MR_RESTART_AN,
+		       ns->base + TBICR);
+		writel(TBICR_MR_AN_ENABLE, ns->base + TBICR);
+		ns->linkstate = LINK_AUTONEGOTIATE;
+
+		ns->CFG_cache |= CFG_MODE_1000;
+	}
+	writel(ns->CFG_cache, ns->base + CFG);
+	dprintf(("CFG: %hX\n", ns->CFG_cache));
+
+	/* FIXME: reset_phy is defaulted to 0, should we reset anyway? */
+	if (reset_phy) {
+		dprintf(("%s: resetting phy\n", pci->name));
+		writel(ns->CFG_cache | CFG_PHY_RST, ns->base + CFG);
+		writel(ns->CFG_cache, ns->base + CFG);
+	}
+#if 0				/* Huh?  This sets the PCI latency register.  Should be done via 
+				 * the PCI layer.  FIXME.
+				 */
+	if (readl(dev->base + SRR))
+		writel(readl(dev->base + 0x20c) | 0xfe00,
+		       dev->base + 0x20c);
+#endif
+
+	/* Note!  The DMA burst size interacts with packet
+	 * transmission, such that the largest packet that
+	 * can be transmitted is 8192 - FLTH - burst size.
+	 * If only the transmit fifo was larger...
+	 */
+	/* Ramit : 1024 DMA is not a good idea, it ends up banging 
+	 * some DELL and COMPAQ SMP systems */
+	writel(TXCFG_CSI | TXCFG_HBI | TXCFG_ATP | TXCFG_MXDMA512
+	       | ((1600 / 32) * 0x100), ns->base + TXCFG);
+
+	/* Set Rx to full duplex, don't accept runt, errored, long or length
+	 * range errored packets.  Use 512 byte DMA.
+	 */
+	/* Ramit : 1024 DMA is not a good idea, it ends up banging 
+	 * some DELL and COMPAQ SMP systems 
+	 * Turn on ALP, only we are accpeting Jumbo Packets */
+	writel(RXCFG_AEP | RXCFG_ARP | RXCFG_AIRL | RXCFG_RX_FD
+	       | RXCFG_STRIPCRC
+	       //| RXCFG_ALP
+	       | (RXCFG_MXDMA512) | 0, ns->base + RXCFG);
+
+	/* Disable priority queueing */
+	writel(0, ns->base + PQCR);
+
+	/* Enable IP checksum validation and detetion of VLAN headers.
+	 * Note: do not set the reject options as at least the 0x102
+	 * revision of the chip does not properly accept IP fragments
+	 * at least for UDP.
+	 */
+	/* Ramit : Be sure to turn on RXCFG_ARP if VLAN's are enabled, since
+	 * the MAC it calculates the packetsize AFTER stripping the VLAN
+	 * header, and if a VLAN Tagged packet of 64 bytes is received (like
+	 * a ping with a VLAN header) then the card, strips the 4 byte VLAN
+	 * tag and then checks the packet size, so if RXCFG_ARP is not enabled,
+	 * it discrards it!.  These guys......
+	 */
+	writel(VRCR_IPEN | VRCR_VTDEN, ns->base + VRCR);
+
+	/* Enable per-packet TCP/UDP/IP checksumming */
+	writel(VTCR_PPCHK, ns->base + VTCR);
+
+	/* Ramit : Enable async and sync pause frames */
+//      writel(0, ns->base + PCR); 
+	writel((PCR_PS_MCAST | PCR_PS_DA | PCR_PSEN | PCR_FFLO_4K |
+		PCR_FFHI_8K | PCR_STLO_4 | PCR_STHI_8 | PCR_PAUSE_CNT),
+	       ns->base + PCR);
+
+	/* Disable Wake On Lan */
+	writel(0, ns->base + WCSR);
+
+	ns83820_getmac(nic, nic->node_addr);
+	printf("%! at ioaddr 0x%hX, ", nic->node_addr, ns->base);
+
+	if (using_dac) {
+		dprintf(("%s: using 64 bit addressing.\n", pci->name));
+	}
+
+	dprintf(("%s: DP83820 %d.%d: %! io=0x%hX\n",
+		 pci->name,
+		 (unsigned) readl(ns->base + SRR) >> 8,
+		 (unsigned) readl(ns->base + SRR) & 0xff,
+		 nic->node_addr, pci->ioaddr));
+
+#ifdef PHY_CODE_IS_FINISHED
+	ns83820_probe_phy(dev);
+#endif
+
+	ns83820_reset(nic);
+	/* point to NIC specific routines */
+	dev->disable  = ns83820_disable;
+	nic->poll     = ns83820_poll;
+	nic->transmit = ns83820_transmit;
+	nic->irq      = ns83820_irq;
+	return 1;
+}
+
+static struct pci_id ns83820_nics[] = {
+	PCI_ROM(0x100b, 0x0022, "ns83820", "National Semiconductor 83820"),
+};
+
+struct pci_driver ns83820_driver = {
+	.type = NIC_DRIVER,
+	.name = "NS83820/PCI",
+	.probe = ns83820_probe,
+	.ids = ns83820_nics,
+	.id_count = sizeof(ns83820_nics) / sizeof(ns83820_nics[0]),
+	.class = 0,
+};
diff -Naur grub-0.97.orig/netboot/ns8390.c grub-0.97/netboot/ns8390.c
--- grub-0.97.orig/netboot/ns8390.c	2003-07-09 11:45:38.000000000 +0000
+++ grub-0.97/netboot/ns8390.c	2005-08-31 21:13:41.000000000 +0000
@@ -13,11 +13,15 @@
   the proper functioning of this software, nor do the authors assume any
   responsibility for damages incurred with its use.
 
+Multicast support added by Timothy Legge (timlegge@users.sourceforge.net) 09/28/2003
+Relocation support added by Ken Yap (ken_yap@users.sourceforge.net) 28/12/02
 3c503 support added by Bill Paul (wpaul@ctr.columbia.edu) on 11/15/94
 SMC8416 support added by Bill Paul (wpaul@ctr.columbia.edu) on 12/25/94
 3c503 PIO support added by Jim Hague (jim.hague@acm.org) on 2/17/98
 RX overrun by Klaus Espenlaub (espenlaub@informatik.uni-ulm.de) on 3/10/99
   parts taken from the Linux 8390 driver (by Donald Becker and Paul Gortmaker)
+SMC8416 PIO support added by Andrew Bettison (andrewb@zip.com.au) on 4/3/02
+  based on the Linux 8390 driver (by Donald Becker and Paul Gortmaker)
 
 **************************************************************************/
 
@@ -26,10 +30,16 @@
 #include "ns8390.h"
 #ifdef	INCLUDE_NS8390
 #include "pci.h"
+#else
+#include "isa.h"
 #endif
-#include "cards.h"
 
-static unsigned char	eth_vendor, eth_flags, eth_laar;
+typedef int Address;
+
+static unsigned char	eth_vendor, eth_flags;
+#ifdef	INCLUDE_WD
+static unsigned char	eth_laar;
+#endif
 static unsigned short	eth_nic_base, eth_asic_base;
 static unsigned char	eth_memsize, eth_rx_start, eth_tx_start;
 static Address		eth_bmem, eth_rmem;
@@ -66,6 +76,7 @@
 #endif
 
 #if	defined(INCLUDE_WD)
+#define	ASIC_PIO	WD_IAR
 #define	eth_probe	wd_probe
 #if	defined(INCLUDE_3C503) || defined(INCLUDE_NE) || defined(INCLUDE_NS8390)
 Error you must only define one of INCLUDE_WD, INCLUDE_3C503, INCLUDE_NE, INCLUDE_NS8390
@@ -101,13 +112,16 @@
 #endif
 #endif
 
-#if	defined(INCLUDE_NE) || defined(INCLUDE_NS8390) || (defined(INCLUDE_3C503) && !defined(T503_SHMEM))
+#if	defined(INCLUDE_NE) || defined(INCLUDE_NS8390) || (defined(INCLUDE_3C503) && !defined(T503_SHMEM)) || (defined(INCLUDE_WD) && defined(WD_790_PIO))
 /**************************************************************************
 ETH_PIO_READ - Read a frame via Programmed I/O
 **************************************************************************/
 static void eth_pio_read(unsigned int src, unsigned char *dst, unsigned int cnt)
 {
-	if (eth_flags & FLAG_16BIT) { ++cnt; cnt &= ~1; }
+#ifdef	INCLUDE_WD
+	outb(src & 0xff, eth_asic_base + WD_GP2);
+	outb(src >> 8, eth_asic_base + WD_GP2);
+#else
 	outb(D8390_COMMAND_RD2 |
 		D8390_COMMAND_STA, eth_nic_base + D8390_P0_COMMAND);
 	outb(cnt, eth_nic_base + D8390_P0_RBCR0);
@@ -122,9 +136,10 @@
 	outb(src >> 8, eth_asic_base + _3COM_DAMSB);
 	outb(t503_output | _3COM_CR_START, eth_asic_base + _3COM_CR);
 #endif
+#endif
 
 	if (eth_flags & FLAG_16BIT)
-		cnt >>= 1;
+		cnt = (cnt + 1) >> 1;
 
 	while(cnt--) {
 #ifdef	INCLUDE_3C503
@@ -153,7 +168,10 @@
 #ifdef	COMPEX_RL2000_FIX
 	unsigned int x;
 #endif	/* COMPEX_RL2000_FIX */
-	if (eth_flags & FLAG_16BIT) { ++cnt; cnt &= ~1; }
+#ifdef	INCLUDE_WD
+	outb(dst & 0xff, eth_asic_base + WD_GP2);
+	outb(dst >> 8, eth_asic_base + WD_GP2);
+#else
 	outb(D8390_COMMAND_RD2 |
 		D8390_COMMAND_STA, eth_nic_base + D8390_P0_COMMAND);
 	outb(D8390_ISR_RDC, eth_nic_base + D8390_P0_ISR);
@@ -170,9 +188,10 @@
 
 	outb(t503_output | _3COM_CR_DDIR | _3COM_CR_START, eth_asic_base + _3COM_CR);
 #endif
+#endif
 
 	if (eth_flags & FLAG_16BIT)
-		cnt >>= 1;
+		cnt = (cnt + 1) >> 1;
 
 	while(cnt--)
 	{
@@ -201,17 +220,40 @@
 	if (x >= COMPEX_RL2000_TRIES)
 		printf("Warning: Compex RL2000 aborted wait!\n");
 #endif	/* COMPEX_RL2000_FIX */
+#ifndef	INCLUDE_WD
 	while((inb(eth_nic_base + D8390_P0_ISR) & D8390_ISR_RDC)
 		!= D8390_ISR_RDC);
 #endif
+#endif
 }
 #else
 /**************************************************************************
 ETH_PIO_READ - Dummy routine when NE2000 not compiled in
 **************************************************************************/
-static void eth_pio_read(unsigned int src, unsigned char *dst, unsigned int cnt) {}
+static void eth_pio_read(unsigned int src __unused, unsigned char *dst  __unused, unsigned int cnt __unused) {}
 #endif
 
+
+/**************************************************************************
+enable_multycast - Enable Multicast
+**************************************************************************/
+static void enable_multicast(unsigned short eth_nic_base) 
+{
+	unsigned char mcfilter[8];
+	int i;
+	memset(mcfilter, 0xFF, 8);
+	outb(4, eth_nic_base+D8390_P0_RCR);	
+	outb(D8390_COMMAND_RD2 + D8390_COMMAND_PS1, eth_nic_base + D8390_P0_COMMAND);
+	for(i=0;i<8;i++)
+	{
+		outb(mcfilter[i], eth_nic_base + 8 + i);
+		if(inb(eth_nic_base + 8 + i)!=mcfilter[i])
+			printf("Error SMC 83C690 Multicast filter read/write mishap %d\n",i);
+	}
+	outb(D8390_COMMAND_RD2 + D8390_COMMAND_PS0, eth_nic_base + D8390_P0_COMMAND);
+	outb(4 | 0x08, eth_nic_base+D8390_P0_RCR);
+}
+
 /**************************************************************************
 NS8390_RESET - Reset adapter
 **************************************************************************/
@@ -238,7 +280,14 @@
 	outb(eth_tx_start, eth_nic_base+D8390_P0_TPSR);
 	outb(eth_rx_start, eth_nic_base+D8390_P0_PSTART);
 #ifdef	INCLUDE_WD
-	if (eth_flags & FLAG_790) outb(0, eth_nic_base + 0x09);
+	if (eth_flags & FLAG_790) {
+#ifdef	WD_790_PIO
+		outb(0x10, eth_asic_base + 0x06); /* disable interrupts, enable PIO */
+		outb(0x01, eth_nic_base + 0x09); /* enable ring read auto-wrap */
+#else
+		outb(0, eth_nic_base + 0x09);
+#endif
+	}
 #endif
 	outb(eth_memsize, eth_nic_base+D8390_P0_PSTOP);
 	outb(eth_memsize - 1, eth_nic_base+D8390_P0_BOUND);
@@ -266,8 +315,10 @@
 		outb(D8390_COMMAND_PS0 |
 			D8390_COMMAND_RD2 | D8390_COMMAND_STA, eth_nic_base+D8390_P0_COMMAND);
 	outb(0xFF, eth_nic_base+D8390_P0_ISR);
-	outb(0, eth_nic_base+D8390_P0_TCR);
-	outb(4, eth_nic_base+D8390_P0_RCR);	/* allow broadcast frames */
+	outb(0, eth_nic_base+D8390_P0_TCR);	/* transmitter on */
+	outb(4, eth_nic_base+D8390_P0_RCR);	/* allow rx broadcast frames */
+
+	enable_multicast(eth_nic_base);
 
 #ifdef	INCLUDE_3C503
         /*
@@ -281,7 +332,7 @@
 #endif
 }
 
-static int ns8390_poll(struct nic *nic);
+static int ns8390_poll(struct nic *nic, int retrieve);
 
 #ifndef	INCLUDE_3C503
 /**************************************************************************
@@ -324,7 +375,7 @@
 
 	/* clear the RX ring, acknowledge overrun interrupt */
 	eth_drain_receiver = 1;
-	while (ns8390_poll(nic))
+	while (ns8390_poll(nic, 1))
 		/* Nothing */;
 	eth_drain_receiver = 0;
 	outb(D8390_ISR_OVW, eth_nic_base+D8390_P0_ISR);
@@ -344,50 +395,54 @@
 	unsigned int s,			/* size */
 	const char *p)			/* Packet */
 {
+#if defined(INCLUDE_3C503) || (defined(INCLUDE_WD) && ! defined(WD_790_PIO))
+	Address		eth_vmem = bus_to_virt(eth_bmem);
+#endif
 #ifdef	INCLUDE_3C503
         if (!(eth_flags & FLAG_PIO)) {
-                memcpy((char *)eth_bmem, d, ETH_ALEN);	/* dst */
-                memcpy((char *)eth_bmem+ETH_ALEN, nic->node_addr, ETH_ALEN); /* src */
-                *((char *)eth_bmem+12) = t>>8;		/* type */
-                *((char *)eth_bmem+13) = t;
-                memcpy((char *)eth_bmem+ETH_HLEN, p, s);
+                memcpy((char *)eth_vmem, d, ETH_ALEN);	/* dst */
+                memcpy((char *)eth_vmem+ETH_ALEN, nic->node_addr, ETH_ALEN); /* src */
+                *((char *)eth_vmem+12) = t>>8;		/* type */
+                *((char *)eth_vmem+13) = t;
+                memcpy((char *)eth_vmem+ETH_HLEN, p, s);
                 s += ETH_HLEN;
-                while (s < ETH_ZLEN) *((char *)eth_bmem+(s++)) = 0;
+                while (s < ETH_ZLEN) *((char *)eth_vmem+(s++)) = 0;
         }
 #endif
 
 #ifdef	INCLUDE_WD
-	/* Memory interface */
 	if (eth_flags & FLAG_16BIT) {
 		outb(eth_laar | WD_LAAR_M16EN, eth_asic_base + WD_LAAR);
 		inb(0x84);
 	}
+#ifndef	WD_790_PIO
+	/* Memory interface */
 	if (eth_flags & FLAG_790) {
 		outb(WD_MSR_MENB, eth_asic_base + WD_MSR);
 		inb(0x84);
 	}
 	inb(0x84);
-	memcpy((char *)eth_bmem, d, ETH_ALEN);	/* dst */
-	memcpy((char *)eth_bmem+ETH_ALEN, nic->node_addr, ETH_ALEN); /* src */
-	*((char *)eth_bmem+12) = t>>8;		/* type */
-	*((char *)eth_bmem+13) = t;
-	memcpy((char *)eth_bmem+ETH_HLEN, p, s);
+	memcpy((char *)eth_vmem, d, ETH_ALEN);	/* dst */
+	memcpy((char *)eth_vmem+ETH_ALEN, nic->node_addr, ETH_ALEN); /* src */
+	*((char *)eth_vmem+12) = t>>8;		/* type */
+	*((char *)eth_vmem+13) = t;
+	memcpy((char *)eth_vmem+ETH_HLEN, p, s);
 	s += ETH_HLEN;
-	while (s < ETH_ZLEN) *((char *)eth_bmem+(s++)) = 0;
+	while (s < ETH_ZLEN) *((char *)eth_vmem+(s++)) = 0;
 	if (eth_flags & FLAG_790) {
 		outb(0, eth_asic_base + WD_MSR);
 		inb(0x84);
 	}
-	if (eth_flags & FLAG_16BIT) {
-		outb(eth_laar & ~WD_LAAR_M16EN, eth_asic_base + WD_LAAR);
-		inb(0x84);
-	}
+#else
+	inb(0x84);
+#endif
 #endif
 
 #if	defined(INCLUDE_3C503)
-	if (eth_flags & FLAG_PIO) {
+	if (eth_flags & FLAG_PIO)
 #endif
-#if	defined(INCLUDE_NE) || defined(INCLUDE_NS8390) || (defined(INCLUDE_3C503) && !defined(T503_SHMEM))
+#if	defined(INCLUDE_NE) || defined(INCLUDE_NS8390) || (defined(INCLUDE_3C503) && !defined(T503_SHMEM)) || (defined(INCLUDE_WD) && defined(WD_790_PIO))
+	{
 		/* Programmed I/O */
 		unsigned short type;
 		type = (t >> 8) | (t << 8);
@@ -398,12 +453,16 @@
 		eth_pio_write(p, (eth_tx_start<<8)+ETH_HLEN, s);
 		s += ETH_HLEN;
 		if (s < ETH_ZLEN) s = ETH_ZLEN;
+	}
 #endif
 #if	defined(INCLUDE_3C503)
-	}
 #endif
 
 #ifdef	INCLUDE_WD
+	if (eth_flags & FLAG_16BIT) {
+		outb(eth_laar & ~WD_LAAR_M16EN, eth_asic_base + WD_LAAR);
+		inb(0x84);
+	}
 	if (eth_flags & FLAG_790)
 		outb(D8390_COMMAND_PS0 |
 			D8390_COMMAND_STA, eth_nic_base+D8390_P0_COMMAND);
@@ -428,7 +487,7 @@
 /**************************************************************************
 NS8390_POLL - Wait for a frame
 **************************************************************************/
-static int ns8390_poll(struct nic *nic)
+static int ns8390_poll(struct nic *nic, int retrieve)
 {
 	int ret = 0;
 	unsigned char rstat, curr, next;
@@ -453,22 +512,27 @@
 	outb(D8390_COMMAND_PS0, eth_nic_base+D8390_P0_COMMAND);
 	if (curr >= eth_memsize) curr=eth_rx_start;
 	if (curr == next) return(0);
+
+	if ( ! retrieve ) return 1;
+
 #ifdef	INCLUDE_WD
 	if (eth_flags & FLAG_16BIT) {
 		outb(eth_laar | WD_LAAR_M16EN, eth_asic_base + WD_LAAR);
 		inb(0x84);
 	}
+#ifndef	WD_790_PIO
 	if (eth_flags & FLAG_790) {
 		outb(WD_MSR_MENB, eth_asic_base + WD_MSR);
 		inb(0x84);
 	}
+#endif
 	inb(0x84);
 #endif
 	pktoff = next << 8;
 	if (eth_flags & FLAG_PIO)
 		eth_pio_read(pktoff, (char *)&pkthdr, 4);
 	else
-		memcpy(&pkthdr, (char *)eth_rmem + pktoff, 4);
+		memcpy(&pkthdr, bus_to_virt(eth_rmem + pktoff), 4);
 	pktoff += sizeof(pkthdr);
 	/* incoming length includes FCS so must sub 4 */
 	len = pkthdr.len - 4;
@@ -486,7 +550,7 @@
 			if (eth_flags & FLAG_PIO)
 				eth_pio_read(pktoff, p, frag);
 			else
-				memcpy(p, (char *)eth_rmem + pktoff, frag);
+				memcpy(p, bus_to_virt(eth_rmem + pktoff), frag);
 			pktoff = eth_rx_start << 8;
 			p += frag;
 			len -= frag;
@@ -495,14 +559,16 @@
 		if (eth_flags & FLAG_PIO)
 			eth_pio_read(pktoff, p, len);
 		else
-			memcpy(p, (char *)eth_rmem + pktoff, len);
+			memcpy(p, bus_to_virt(eth_rmem + pktoff), len);
 		ret = 1;
 	}
 #ifdef	INCLUDE_WD
+#ifndef	WD_790_PIO
 	if (eth_flags & FLAG_790) {
 		outb(0, eth_asic_base + WD_MSR);
 		inb(0x84);
 	}
+#endif
 	if (eth_flags & FLAG_16BIT) {
 		outb(eth_laar & ~WD_LAAR_M16EN, eth_asic_base + WD_LAAR);
 		inb(0x84);
@@ -519,31 +585,56 @@
 /**************************************************************************
 NS8390_DISABLE - Turn off adapter
 **************************************************************************/
-static void ns8390_disable(struct nic *nic)
+static void ns8390_disable(struct dev *dev)
 {
+	struct nic *nic = (struct nic *)dev;
+	/* reset and disable merge */
+	ns8390_reset(nic);
+}
+
+/**************************************************************************
+NS8390_IRQ - Enable, Disable, or Force interrupts
+**************************************************************************/
+static void ns8390_irq(struct nic *nic __unused, irq_action_t action __unused)
+{
+  switch ( action ) {
+  case DISABLE :
+    break;
+  case ENABLE :
+    break;
+  case FORCE :
+    break;
+  }
 }
 
 /**************************************************************************
 ETH_PROBE - Look for an adapter
 **************************************************************************/
 #ifdef	INCLUDE_NS8390
-struct nic *eth_probe(struct nic *nic, unsigned short *probe_addrs,
-		      struct pci_device *pci)
+static int eth_probe (struct dev *dev, struct pci_device *pci)
 #else
-struct nic *eth_probe(struct nic *nic, unsigned short *probe_addrs)
+static int eth_probe (struct dev *dev, unsigned short *probe_addrs __unused)
 #endif
 {
+	struct nic *nic = (struct nic *)dev;
 	int i;
-	struct wd_board *brd;
-	unsigned short chksum;
-	unsigned char c;
+#ifdef INCLUDE_NS8390
+	unsigned short pci_probe_addrs[] = { pci->ioaddr, 0 };
+	unsigned short *probe_addrs = pci_probe_addrs;
+#endif
 	eth_vendor = VENDOR_NONE;
 	eth_drain_receiver = 0;
 
+	nic->irqno  = 0;
+
 #ifdef	INCLUDE_WD
+{
 	/******************************************************************
 	Search for WD/SMC cards
 	******************************************************************/
+	struct wd_board *brd;
+	unsigned short chksum;
+	unsigned char c;
 	for (eth_asic_base = WD_LOW_BASE; eth_asic_base <= WD_HIGH_BASE;
 		eth_asic_base += 0x20) {
 		chksum = 0;
@@ -560,6 +651,9 @@
 	/* We've found a board */
 	eth_vendor = VENDOR_WD;
 	eth_nic_base = eth_asic_base + WD_NIC_ADDR;
+
+	nic->ioaddr = eth_nic_base;
+
 	c = inb(eth_asic_base+WD_BID);	/* Get board id */
 	for (brd = wd_boards; brd->name; brd++)
 		if (brd->id == c) break;
@@ -582,8 +676,9 @@
 	} else
 		eth_bmem = WD_DEFAULT_MEM;
 	if (brd->id == TYPE_SMC8216T || brd->id == TYPE_SMC8216C) {
-		*((unsigned int *)(eth_bmem + 8192)) = (unsigned int)0;
-		if (*((unsigned int *)(eth_bmem + 8192))) {
+		/* from Linux driver, 8416BT detects as 8216 sometimes */
+		unsigned int addr = inb(eth_asic_base + 0xb);
+		if (((addr >> 4) & 3) == 0) {
 			brd += 2;
 			eth_memsize = brd->memsize;
 		}
@@ -592,19 +687,27 @@
 	for (i=0; i<ETH_ALEN; i++) {
 		nic->node_addr[i] = inb(i+eth_asic_base+WD_LAR);
 	}
-	printf("\n%s base %#hx, memory %#hx, addr %!\n",
-		brd->name, eth_asic_base, eth_bmem, nic->node_addr);
+	printf("\n%s base %#hx", brd->name, eth_asic_base);
 	if (eth_flags & FLAG_790) {
+#ifdef	WD_790_PIO
+		printf(", PIO mode, addr %!\n", nic->node_addr);
+		eth_bmem = 0;
+		eth_flags |= FLAG_PIO;		/* force PIO mode */
+		outb(0, eth_asic_base+WD_MSR);
+#else
+		printf(", memory %#x, addr %!\n", eth_bmem, nic->node_addr);
 		outb(WD_MSR_MENB, eth_asic_base+WD_MSR);
 		outb((inb(eth_asic_base+0x04) |
 			0x80), eth_asic_base+0x04);
-		outb((((unsigned)eth_bmem >> 13) & 0x0F) |
-			(((unsigned)eth_bmem >> 11) & 0x40) |
+		outb(((unsigned)(eth_bmem >> 13) & 0x0F) |
+			((unsigned)(eth_bmem >> 11) & 0x40) |
 			(inb(eth_asic_base+0x0B) & 0xB0), eth_asic_base+0x0B);
 		outb((inb(eth_asic_base+0x04) &
 			~0x80), eth_asic_base+0x04);
+#endif
 	} else {
-		outb((((unsigned)eth_bmem >> 13) & 0x3F) | 0x40, eth_asic_base+WD_MSR);
+		printf(", memory %#x, addr %!\n", eth_bmem, nic->node_addr);
+		outb(((unsigned)(eth_bmem >> 13) & 0x3F) | 0x40, eth_asic_base+WD_MSR);
 	}
 	if (eth_flags & FLAG_16BIT) {
 		if (eth_flags & FLAG_790) {
@@ -624,8 +727,14 @@
 		}
 		inb(0x84);
 	}
+}
 #endif
 #ifdef	INCLUDE_3C503
+#ifdef	T503_AUI
+	nic->flags = 1;		/* aui */
+#else
+	nic->flags = 0;		/* no aui */
+#endif
         /******************************************************************
         Search for 3Com 3c503 if no WD/SMC cards
         ******************************************************************/
@@ -708,11 +817,12 @@
         /* Get our ethernet address */
 
                 outb(_3COM_CR_EALO | _3COM_CR_XSEL, eth_asic_base + _3COM_CR);
+		nic->ioaddr = eth_nic_base;
                 printf("\n3Com 3c503 base %#hx, ", eth_nic_base);
                 if (eth_flags & FLAG_PIO)
 			printf("PIO mode");
                 else
-			printf("memory %#hx", eth_bmem);
+			printf("memory %#x", eth_bmem);
                 for (i=0; i<ETH_ALEN; i++) {
                         nic->node_addr[i] = inb(eth_nic_base+i);
                 }
@@ -734,9 +844,9 @@
          */
 
 		if (!(eth_flags & FLAG_PIO)) {
-			memset((char *)eth_bmem, 0, 0x2000);
+			memset(bus_to_virt(eth_bmem), 0, 0x2000);
 			for(i = 0; i < 0x2000; ++i)
-				if (*(((char *)eth_bmem)+i)) {
+				if (*((char *)(bus_to_virt(eth_bmem+i)))) {
 					printf ("Failed to clear 3c503 shared mem.\n");
 					return (0);
 				}
@@ -749,9 +859,11 @@
         }
 #endif
 #if	defined(INCLUDE_NE) || defined(INCLUDE_NS8390)
+{
 	/******************************************************************
 	Search for NE1000/2000 if no WD/SMC or 3com cards
 	******************************************************************/
+	unsigned char c;
 	if (eth_vendor == VENDOR_NONE) {
 		char romdata[16], testbuf[32];
 		int idx;
@@ -810,23 +922,94 @@
 		for (i=0; i<ETH_ALEN; i++) {
 			nic->node_addr[i] = romdata[i + ((eth_flags & FLAG_16BIT) ? i : 0)];
 		}
+		nic->ioaddr = eth_nic_base;
 		printf("\nNE%c000 base %#hx, addr %!\n",
 			(eth_flags & FLAG_16BIT) ? '2' : '1', eth_nic_base,
 			nic->node_addr);
 	}
+}
 #endif
 	if (eth_vendor == VENDOR_NONE)
 		return(0);
         if (eth_vendor != VENDOR_3COM)
 		eth_rmem = eth_bmem;
 	ns8390_reset(nic);
-	nic->reset = ns8390_reset;
-	nic->poll = ns8390_poll;
+
+	dev->disable  = ns8390_disable; 
+	nic->poll     = ns8390_poll;
 	nic->transmit = ns8390_transmit;
-	nic->disable = ns8390_disable;
-	return(nic);
+	nic->irq      = ns8390_irq;
+
+        /* Based on PnP ISA map */
+#ifdef	INCLUDE_WD
+        dev->devid.vendor_id = htons(GENERIC_ISAPNP_VENDOR);
+        dev->devid.device_id = htons(0x812a);
+#endif
+#ifdef	INCLUDE_3C503
+        dev->devid.vendor_id = htons(GENERIC_ISAPNP_VENDOR);
+        dev->devid.device_id = htons(0x80f3);
+#endif
+#ifdef	INCLUDE_NE
+        dev->devid.vendor_id = htons(GENERIC_ISAPNP_VENDOR);
+        dev->devid.device_id = htons(0x80d6);
+#endif
+	return 1;
 }
 
+#ifdef	INCLUDE_WD
+static struct isa_driver wd_driver __isa_driver = {
+	.type    = NIC_DRIVER,
+	.name    = "WD",
+	.probe   = wd_probe,
+	.ioaddrs = 0, 
+};
+#endif
+
+#ifdef	INCLUDE_3C503
+static struct isa_driver t503_driver __isa_driver = {
+	.type    = NIC_DRIVER,
+	.name    = "3C503",
+	.probe   = t503_probe,
+	.ioaddrs = 0, 
+};
+#endif
+
+#ifdef	INCLUDE_NE
+static struct isa_driver ne_driver __isa_driver = {
+	.type    = NIC_DRIVER,
+	.name    = "NE*000",
+	.probe   = ne_probe,
+	.ioaddrs = 0, 
+};
+#endif
+
+#ifdef	INCLUDE_NS8390
+static struct pci_id nepci_nics[] = {
+/* A few NE2000 PCI clones, list not exhaustive */
+PCI_ROM(0x10ec, 0x8029, "rtl8029",      "Realtek 8029"),
+PCI_ROM(0x1186, 0x0300, "dlink-528",    "D-Link DE-528"),
+PCI_ROM(0x1050, 0x0940, "winbond940",   "Winbond NE2000-PCI"),		/* Winbond 86C940 / 89C940 */
+PCI_ROM(0x1050, 0x5a5a, "winbond940f",  "Winbond W89c940F"),		/* Winbond 89C940F */
+PCI_ROM(0x11f6, 0x1401, "compexrl2000", "Compex ReadyLink 2000"),
+PCI_ROM(0x8e2e, 0x3000, "ktiet32p2",    "KTI ET32P2"),
+PCI_ROM(0x4a14, 0x5000, "nv5000sc",     "NetVin NV5000SC"),
+PCI_ROM(0x12c3, 0x0058, "holtek80232",  "Holtek HT80232"),
+PCI_ROM(0x12c3, 0x5598, "holtek80229",  "Holtek HT80229"),
+PCI_ROM(0x10bd, 0x0e34, "surecom-ne34", "Surecom NE34"),
+PCI_ROM(0x1106, 0x0926, "via86c926",    "Via 86c926"),
+};
+
+struct pci_driver nepci_driver = {
+	.type     = NIC_DRIVER,
+	.name     = "NE2000/PCI",
+	.probe    = nepci_probe,
+	.ids      = nepci_nics,
+	.id_count = sizeof(nepci_nics)/sizeof(nepci_nics[0]),
+	.class    = 0,
+};
+
+#endif /* INCLUDE_NS8390 */
+
 /*
  * Local variables:
  *  c-basic-offset: 8
diff -Naur grub-0.97.orig/netboot/osdep.h grub-0.97/netboot/osdep.h
--- grub-0.97.orig/netboot/osdep.h	2003-07-09 11:45:38.000000000 +0000
+++ grub-0.97/netboot/osdep.h	2005-08-31 19:03:35.000000000 +0000
@@ -1,94 +1,18 @@
-#ifndef	__OSDEP_H__
-#define __OSDEP_H__
+#ifndef	_OSDEP_H
+#define _OSDEP_H
 
-/*
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2, or (at
- * your option) any later version.
- */
+#define __unused __attribute__((unused))
+#define __aligned __attribute__((aligned(16)))
 
-#define	__LITTLE_ENDIAN		/* x86 */
-
-/* Taken from /usr/include/linux/hfs_sysdep.h */
-#if defined(__BIG_ENDIAN)
-#	if !defined(__constant_htonl)
-#		define __constant_htonl(x) (x)
-#	endif
-#	if !defined(__constant_htons)
-#		define __constant_htons(x) (x)
-#	endif
-#elif defined(__LITTLE_ENDIAN)
-#	if !defined(__constant_htonl)
-#		define __constant_htonl(x) \
-        ((unsigned long int)((((unsigned long int)(x) & 0x000000ffU) << 24) | \
-                             (((unsigned long int)(x) & 0x0000ff00U) <<  8) | \
-                             (((unsigned long int)(x) & 0x00ff0000U) >>  8) | \
-                             (((unsigned long int)(x) & 0xff000000U) >> 24)))
-#	endif
-#	if !defined(__constant_htons)
-#		define __constant_htons(x) \
-        ((unsigned short int)((((unsigned short int)(x) & 0x00ff) << 8) | \
-                              (((unsigned short int)(x) & 0xff00) >> 8)))
-#	endif
-#else
-#	error "Don't know if bytes are big- or little-endian!"
-#endif
-
-#define ntohl(x) \
-(__builtin_constant_p(x) ? \
- __constant_htonl((x)) : \
- __swap32(x))
-#define htonl(x) \
-(__builtin_constant_p(x) ? \
- __constant_htonl((x)) : \
- __swap32(x))
-#define ntohs(x) \
-(__builtin_constant_p(x) ? \
- __constant_htons((x)) : \
- __swap16(x))
-#define htons(x) \
-(__builtin_constant_p(x) ? \
- __constant_htons((x)) : \
- __swap16(x))
-
-static inline unsigned long int __swap32(unsigned long int x)
-{
-	__asm__("xchgb %b0,%h0\n\t"
-		"rorl $16,%0\n\t"
-		"xchgb %b0,%h0"
-		: "=q" (x)
-		: "0" (x));
-	return x;
-}
-
-static inline unsigned short int __swap16(unsigned short int x)
-{
-	__asm__("xchgb %b0,%h0"
-		: "=q" (x)
-		: "0" (x));
-	return x;
-}
-
-/* Make routines available to all */
-#define	swap32(x)	__swap32(x)
-#define	swap16(x)	__swap16(x)
-
-#include "linux-asm-io.h"
-
-typedef	unsigned long Address;
+#include "io.h"
+#include "byteswap.h"
+#include "latch.h"
 
 /* ANSI prototyping macro */
 #ifdef	__STDC__
-#define	P(x)	x
+#  define	P(x)	x
 #else
-#define	P(x)	()
+#  define	P(x)	()
 #endif
 
 #endif
-
-/*
- * Local variables:
- *  c-basic-offset: 8
- * End:
- */
diff -Naur grub-0.97.orig/netboot/otulip.c grub-0.97/netboot/otulip.c
--- grub-0.97.orig/netboot/otulip.c	2003-07-09 11:45:38.000000000 +0000
+++ grub-0.97/netboot/otulip.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,374 +0,0 @@
-/*
-  Etherboot DEC Tulip driver
-  adapted by Ken Yap from
-
-  FreeBSD netboot DEC 21143 driver
-
-  Author: David Sharp
-    date: Nov/98
-
- Known to work on DEC DE500 using 21143-PC chipset.
- Even on cards with the same chipset there can be
- incompatablity problems with the way media selection
- and status LED settings are done.  See comments below.
-
- Some code fragments were taken from verious places,
- Ken Yap's etherboot, FreeBSD's if_de.c, and various
- Linux related files.  DEC's manuals for the 21143 and
- SROM format were very helpful.  The Linux de driver
- development page has a number of links to useful
- related information.  Have a look at:
- ftp://cesdis.gsfc.nasa.gov/pub/linux/drivers/tulip-devel.html
-
-*/
-
-#include "etherboot.h"
-#include "nic.h"
-#include "pci.h"
-#include "cards.h"
-#include "otulip.h"
-
-static unsigned short vendor, dev_id;
-static unsigned short ioaddr;
-static unsigned int *membase;
-static unsigned char srom[1024];
-
-#define BUFLEN 1536     /* must be longword divisable */
-                        /* buffers must be longword aligned */
-
-/* transmit descriptor and buffer */
-static struct txdesc txd;
-
-/* receive descriptor(s) and buffer(s) */
-#define NRXD 4
-static struct rxdesc rxd[NRXD];
-static int rxd_tail = 0;
-#ifdef	USE_LOWMEM_BUFFER
-#define rxb ((char *)0x10000 - NRXD * BUFLEN)
-#define txb ((char *)0x10000 - NRXD * BUFLEN - BUFLEN)
-#else
-static unsigned char rxb[NRXD * BUFLEN];
-static unsigned char txb[BUFLEN];
-#endif
-
-static unsigned char ehdr[ETH_HLEN];    /* buffer for ethernet header */
-
-enum tulip_offsets {
-        CSR0=0,    CSR1=0x08, CSR2=0x10, CSR3=0x18, CSR4=0x20, CSR5=0x28,
-        CSR6=0x30, CSR7=0x38, CSR8=0x40, CSR9=0x48, CSR10=0x50, CSR11=0x58,
-        CSR12=0x60, CSR13=0x68, CSR14=0x70, CSR15=0x78 };
-
-
-/***************************************************************************/
-/* 21143 specific stuff  */
-/***************************************************************************/
-
-/* XXX assume 33MHz PCI bus,  this is not very accurate and should be
-   used only with gross over estimations of required delay times unless
-   you tune UADJUST to your specific processor and I/O subsystem */
-
-#define UADJUST 870
-static void udelay(unsigned long usec) {
-  unsigned long i;
-  for (i=((usec*UADJUST)/33)+1; i>0; i--) (void) TULIP_CSR_READ(csr_0);
-}
-
-/* The following srom related code was taken from FreeBSD's if_de.c */
-/* with minor alterations to make it work here.  the Linux code is */
-/* better but this was easier to use */
-
-static void delay_300ns(void)
-{
-    int idx;
-    for (idx = (300 / 33) + 1; idx > 0; idx--)
-        (void) TULIP_CSR_READ(csr_busmode);
-}
-
-#define EMIT do { TULIP_CSR_WRITE(csr_srom_mii, csr); delay_300ns(); } while (0)
-
-static void srom_idle(void)
-{
-    unsigned bit, csr;
-
-    csr  = SROMSEL ; EMIT;
-    csr  = SROMSEL | SROMRD; EMIT;
-    csr ^= SROMCS; EMIT;
-    csr ^= SROMCLKON; EMIT;
-    /*
-     * Write 25 cycles of 0 which will force the SROM to be idle.
-     */
-    for (bit = 3 + SROM_BITWIDTH + 16; bit > 0; bit--) {
-        csr ^= SROMCLKOFF; EMIT;    /* clock low; data not valid */
-        csr ^= SROMCLKON; EMIT;     /* clock high; data valid */
-    }
-    csr ^= SROMCLKOFF; EMIT;
-    csr ^= SROMCS; EMIT;
-    csr  = 0; EMIT;
-}
-
-static void srom_read(void)
-{
-    unsigned idx;
-    const unsigned bitwidth = SROM_BITWIDTH;
-    const unsigned cmdmask = (SROMCMD_RD << bitwidth);
-    const unsigned msb = 1 << (bitwidth + 3 - 1);
-    unsigned lastidx = (1 << bitwidth) - 1;
-
-    srom_idle();
-
-    for (idx = 0; idx <= lastidx; idx++) {
-        unsigned lastbit, data, bits, bit, csr;
-        csr  = SROMSEL ;                EMIT;
-        csr  = SROMSEL | SROMRD;        EMIT;
-        csr ^= SROMCSON;                EMIT;
-        csr ^=            SROMCLKON;    EMIT;
-
-        lastbit = 0;
-        for (bits = idx|cmdmask, bit = bitwidth + 3; bit > 0; bit--, bits <<= 1)
- {
-            const unsigned thisbit = bits & msb;
-            csr ^= SROMCLKOFF; EMIT;    /* clock low; data not valid */
-            if (thisbit != lastbit) {
-                csr ^= SROMDOUT; EMIT;  /* clock low; invert data */
-            } else {
-                EMIT;
-            }
-            csr ^= SROMCLKON; EMIT;     /* clock high; data valid */
-            lastbit = thisbit;
-        }
-        csr ^= SROMCLKOFF; EMIT;
-
-        for (data = 0, bits = 0; bits < 16; bits++) {
-            data <<= 1;
-            csr ^= SROMCLKON; EMIT;     /* clock high; data valid */
-            data |= TULIP_CSR_READ(csr_srom_mii) & SROMDIN ? 1 : 0;
-            csr ^= SROMCLKOFF; EMIT;    /* clock low; data not valid */
-        }
-        srom[idx*2] = data & 0xFF;
-        srom[idx*2+1] = data >> 8;
-        csr  = SROMSEL | SROMRD; EMIT;
-        csr  = 0; EMIT;
-    }
-    srom_idle();
-}
-
-/**************************************************************************
-ETH_RESET - Reset adapter
-***************************************************************************/
-static void tulip_reset(struct nic *nic)
-{
-        int x,cnt=2;
-
-        outl(0x00000001, ioaddr + CSR0);
-        udelay(1000);
-        /* turn off reset and set cache align=16lword, burst=unlimit */
-        outl(0x01A08000, ioaddr + CSR0);
-
-	/* for some reason the media selection does not take
-           the first time se it is repeated.  */
-
-        while(cnt--) {
-        /* stop TX,RX processes */
-        if (cnt == 1)
-		outl(0x32404000, ioaddr + CSR6);
-        else
-		outl(0x32000040, ioaddr + CSR6);
-
-        /* XXX - media selection is vendor specific and hard coded right
-           here.  This should be fixed to use the hints in the SROM and
-           allow media selection by the user at runtime.  MII support
-           should also be added.  Support for chips other than the
-           21143 should be added here as well  */
-
-        /* start  set to 10Mbps half-duplex */
-
-        /* setup SIA */
-        outl(0x0, ioaddr + CSR13);              /* reset SIA */
-        outl(0x7f3f, ioaddr + CSR14);
-        outl(0x8000008, ioaddr + CSR15);
-        outl(0x0, ioaddr + CSR13);
-        outl(0x1, ioaddr + CSR13);
-        outl(0x2404000, ioaddr + CSR6);
-
-        /* initalize GP */
-        outl(0x8af0008, ioaddr + CSR15);
-        outl(0x50008, ioaddr + CSR15);
-
-        /* end  set to 10Mbps half-duplex */
-
-	if (vendor == PCI_VENDOR_ID_MACRONIX && dev_id == PCI_DEVICE_ID_MX987x5) {
-		/* do stuff for MX98715 */
-		outl(0x01a80000, ioaddr + CSR6);
-		outl(0xFFFFFFFF, ioaddr + CSR14);
-		outl(0x00001000, ioaddr + CSR12);
-	}
-
-        outl(0x0, ioaddr + CSR7);       /* disable interrupts */
-
-        /* construct setup packet which is used by the 21143 to
-           program its CAM to recognize interesting MAC addresses */
-
-        memset(&txd, 0, sizeof(struct txdesc));
-        txd.buf1addr = &txb[0];
-        txd.buf2addr = &txb[0];         /* just in case */
-        txd.buf1sz   = 192;             /* setup packet must be 192 bytes */
-        txd.buf2sz   = 0;
-        txd.control  = 0x020;           /* setup packet */
-        txd.status   = 0x80000000;      /* give ownership to 21143 */
-
-        /* construct perfect filter frame */
-        /* with mac address as first match */
-        /* and broadcast address for all others */
-
-        for(x=0;x<192;x++) txb[x] = 0xff;
-        txb[0] = nic->node_addr[0];
-        txb[1] = nic->node_addr[1];
-        txb[4] = nic->node_addr[2];
-        txb[5] = nic->node_addr[3];
-        txb[8] = nic->node_addr[4];
-        txb[9] = nic->node_addr[5];
-        outl((unsigned long)&txd, ioaddr + CSR4);        /* set xmit buf */
-        outl(0x2406000, ioaddr + CSR6);         /* start transmiter */
-
-        udelay(50000);  /* wait for the setup packet to be processed */
-
-        }
-
-        /* setup receive descriptor */
-        {
-          int x;
-          for(x=0;x<NRXD;x++) {
-            memset(&rxd[x], 0, sizeof(struct rxdesc));
-            rxd[x].buf1addr = &rxb[x * BUFLEN];
-            rxd[x].buf2addr = 0;        /* not used */
-            rxd[x].buf1sz   = BUFLEN;
-            rxd[x].buf2sz   = 0;        /* not used */
-            rxd[x].control  = 0x0;
-            rxd[x].status   = 0x80000000;       /* give ownership it to 21143 */
-          }
-          rxd[NRXD - 1].control  = 0x008;       /* Set Receive end of ring on la
-st descriptor */
-          rxd_tail = 0;
-        }
-
-        /* tell DC211XX where to find rx descriptor list */
-        outl((unsigned long)&rxd[0], ioaddr + CSR3);
-        /* start the receiver */
-        outl(0x2406002, ioaddr + CSR6);
-
-}
-
-/**************************************************************************
-ETH_TRANSMIT - Transmit a frame
-***************************************************************************/
-static const char padmap[] = {
-        0, 3, 2, 1};
-
-static void tulip_transmit(struct nic *nic, const char *d, unsigned int t, unsigned int s, const char *p)
-{
-        unsigned long time;
-
-        /* setup ethernet header */
-
-	memcpy(ehdr, d, ETH_ALEN);
-	memcpy(&ehdr[ETH_ALEN], nic->node_addr, ETH_ALEN);
-        ehdr[ETH_ALEN*2] = (t >> 8) & 0xff;
-        ehdr[ETH_ALEN*2+1] = t & 0xff;
-
-        /* setup the transmit descriptor */
-
-        memset(&txd, 0, sizeof(struct txdesc));
-
-        txd.buf1addr = &ehdr[0];        /* ethernet header */
-        txd.buf1sz   = ETH_HLEN;
-
-        txd.buf2addr = p;               /* packet to transmit */
-        txd.buf2sz   = s;
-
-        txd.control  = 0x188;           /* LS+FS+TER */
-
-        txd.status   = 0x80000000;      /* give it to 21143 */
-
-        outl(inl(ioaddr + CSR6) & ~0x00004000, ioaddr + CSR6);
-        outl((unsigned long)&txd, ioaddr + CSR4);
-        outl(inl(ioaddr + CSR6) | 0x00004000, ioaddr + CSR6);
-
-/*   Wait for transmit to complete before returning.  not well tested.
-
-        time = currticks();
-        while(txd.status & 0x80000000) {
-          if (currticks() - time > 20) {
-            printf("transmit timeout.\n");
-            break;
-          }
-        }
-*/
-
-}
-
-/**************************************************************************
-ETH_POLL - Wait for a frame
-***************************************************************************/
-static int tulip_poll(struct nic *nic)
-{
-        if (rxd[rxd_tail].status & 0x80000000) return 0;
-
-        nic->packetlen = (rxd[rxd_tail].status & 0x3FFF0000) >> 16;
-
-        /* copy packet to working buffer */
-        /* XXX - this copy could be avoided with a little more work
-           but for now we are content with it because the optimised
-           memcpy(, , ) is quite fast */
-
-        memcpy(nic->packet, rxb + rxd_tail * BUFLEN, nic->packetlen);
-
-        /* return the descriptor and buffer to recieve ring */
-        rxd[rxd_tail].status = 0x80000000;
-        rxd_tail++;
-        if (rxd_tail == NRXD) rxd_tail = 0;
-
-        return 1;
-}
-
-static void tulip_disable(struct nic *nic)
-{
-	/* nothing for the moment */
-}
-
-/**************************************************************************
-ETH_PROBE - Look for an adapter
-***************************************************************************/
-struct nic *otulip_probe(struct nic *nic, unsigned short *io_addrs, struct pci_device *pci)
-{
-        int i;
-
-	if (io_addrs == 0 || *io_addrs == 0)
-		return (0);
-	vendor = pci->vendor;
-	dev_id = pci->dev_id;
-	ioaddr = *io_addrs;
-	membase = (unsigned int *)pci->membase;
-
-        /* wakeup chip */
-        pcibios_write_config_dword(pci->bus,pci->devfn,0x40,0x00000000);
-
-        /* Stop the chip's Tx and Rx processes. */
-        /* outl(inl(ioaddr + CSR6) & ~0x2002, ioaddr + CSR6); */
-        /* Clear the missed-packet counter. */
-        /* (volatile int)inl(ioaddr + CSR8); */
-
-        srom_read();
-
-	for (i=0; i < ETH_ALEN; i++)
-		nic->node_addr[i] = srom[20+i];
-
-        printf("Tulip %! at ioaddr %#hX\n", nic->node_addr, ioaddr);
-
-        tulip_reset(nic);
-
-	nic->reset = tulip_reset;
-	nic->poll = tulip_poll;
-	nic->transmit = tulip_transmit;
-	nic->disable = tulip_disable;
-        return nic;
-}
diff -Naur grub-0.97.orig/netboot/otulip.h grub-0.97/netboot/otulip.h
--- grub-0.97.orig/netboot/otulip.h	2003-07-09 11:45:38.000000000 +0000
+++ grub-0.97/netboot/otulip.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,76 +0,0 @@
-/* mostly stolen from FreeBSD if_de.c, if_devar.h */
-
-#define TULIP_CSR_READ(csr)		(membase[csr*2])
-#define CSR_READ(csr)			(membase[csr*2])
-#define TULIP_CSR_WRITE(csr, val)	(membase[csr*2] = val)
-#define CSR_WRITE(csr, val)		(membase[csr*2] = val)
-
-#define csr_0			0
-#define csr_1			1
-#define csr_2			2
-#define csr_3			3
-#define csr_4			4
-#define csr_5			5
-#define csr_6			6
-#define csr_7			7
-#define csr_8			8
-#define csr_9			9
-#define csr_10			10
-#define csr_11			11
-#define csr_12			12
-#define csr_13			13
-#define csr_14			14
-#define csr_15			15
-
-#define csr_busmode		csr_0
-#define csr_txpoll		csr_1
-#define csr_rxpoll		csr_2
-#define csr_rxlist		csr_3
-#define csr_txlist		csr_4
-#define csr_status		csr_5
-#define csr_command		csr_6
-#define csr_intr		csr_7
-#define csr_missed_frames	csr_8
-#define csr_enetrom		csr_9		/* 21040 */
-#define csr_reserved		csr_10		/* 21040 */
-#define csr_full_duplex		csr_11		/* 21040 */
-#define csr_bootrom		csr_10		/* 21041/21140A/?? */
-#define csr_gp			csr_12		/* 21140* */
-#define csr_watchdog		csr_15		/* 21140* */
-#define csr_gp_timer		csr_11		/* 21041/21140* */
-#define csr_srom_mii		csr_9		/* 21041/21140* */
-#define csr_sia_status		csr_12		/* 2104x */
-#define csr_sia_connectivity	csr_13		/* 2104x */
-#define csr_sia_tx_rx		csr_14		/* 2104x */
-#define csr_sia_general		csr_15		/* 2104x */
-
-#define SROMSEL		0x0800
-#define SROMCS		0x0001
-#define SROMCLKON	0x0002
-#define SROMCLKOFF	0x0002
-#define SROMRD		0x4000
-#define SROMWR		0x2000
-#define SROM_BITWIDTH	6
-#define SROMCMD_RD	6
-#define SROMCSON	0x0001
-#define SROMDOUT	0x0004
-#define SROMDIN		0x0008
-
-
-struct txdesc {
-	unsigned long	status;		/* owner, status */
-	unsigned long	buf1sz:11,	/* size of buffer 1 */
-			buf2sz:11,	/* size of buffer 2 */
-			control:10;	/* control bits */
-	const unsigned char *buf1addr;	/* buffer 1 address */
-	const unsigned char *buf2addr;	/* buffer 2 address */
-};
-
-struct rxdesc {
-	unsigned long	status;		/* owner, status */
-	unsigned long	buf1sz:11,	/* size of buffer 1 */
-			buf2sz:11,	/* size of buffer 2 */
-			control:10;	/* control bits */
-	unsigned char	*buf1addr;	/* buffer 1 address */
-	unsigned char	*buf2addr;	/* buffer 2 address */
-};
diff -Naur grub-0.97.orig/netboot/pci.c grub-0.97/netboot/pci.c
--- grub-0.97.orig/netboot/pci.c	2003-07-09 11:45:38.000000000 +0000
+++ grub-0.97/netboot/pci.c	2005-08-31 19:03:35.000000000 +0000
@@ -1,15 +1,3 @@
-/*
-** Support for NE2000 PCI clones added David Monro June 1997
-** Generalised to other NICs by Ken Yap July 1997
-**
-** Most of this is taken from:
-**
-** /usr/src/linux/drivers/pci/pci.c
-** /usr/src/linux/include/linux/pci.h
-** /usr/src/linux/arch/i386/bios32.c
-** /usr/src/linux/include/linux/bios32.h
-** /usr/src/linux/drivers/net/ne.c
-*/
 
 /*
  * This program is free software; you can redistribute it and/or
@@ -18,402 +6,294 @@
  * your option) any later version.
  */
 
-#include "etherboot.h"
+#include "grub.h"
 #include "pci.h"
 
-/*#define	DEBUG	1*/
-#define DEBUG	0
-
-#ifdef	CONFIG_PCI_DIRECT
-#define  PCIBIOS_SUCCESSFUL                0x00
-
-/*
- * Functions for accessing PCI configuration space with type 1 accesses
- */
-
-#define CONFIG_CMD(bus, device_fn, where)   (0x80000000 | (bus << 16) | (device_fn << 8) | (where & ~3))
-
-int pcibios_read_config_byte(unsigned int bus, unsigned int device_fn,
-			       unsigned int where, unsigned char *value)
+unsigned long virt_offset = 0;
+unsigned long virt_to_phys(volatile const void *virt_addr)
 {
-    outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
-    *value = inb(0xCFC + (where&3));
-    return PCIBIOS_SUCCESSFUL;
+	return ((unsigned long)virt_addr) + virt_offset;
 }
 
-int pcibios_read_config_word (unsigned int bus,
-    unsigned int device_fn, unsigned int where, unsigned short *value)
+void *phys_to_virt(unsigned long phys_addr)
 {
-    outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
-    *value = inw(0xCFC + (where&2));
-    return PCIBIOS_SUCCESSFUL;
+	return (void *)(phys_addr - virt_offset);
 }
 
-int pcibios_read_config_dword (unsigned int bus, unsigned int device_fn,
-				 unsigned int where, unsigned int *value)
-{
-    outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
-    *value = inl(0xCFC);
-    return PCIBIOS_SUCCESSFUL;
-}
+#ifdef INCLUDE_3C595
+extern struct pci_driver t595_driver;
+#endif /* INCLUDE_3C595 */
 
-int pcibios_write_config_byte (unsigned int bus, unsigned int device_fn,
-				 unsigned int where, unsigned char value)
-{
-    outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
-    outb(value, 0xCFC + (where&3));
-    return PCIBIOS_SUCCESSFUL;
-}
+#ifdef INCLUDE_3C90X
+extern struct pci_driver a3c90x_driver;
+#endif /* INCLUDE_3C90X */
 
-int pcibios_write_config_word (unsigned int bus, unsigned int device_fn,
-				 unsigned int where, unsigned short value)
-{
-    outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
-    outw(value, 0xCFC + (where&2));
-    return PCIBIOS_SUCCESSFUL;
-}
+#ifdef INCLUDE_DAVICOM
+extern struct pci_driver davicom_driver;
+#endif /* INCLUDE_DAVICOM */
 
-int pcibios_write_config_dword (unsigned int bus, unsigned int device_fn, unsigned int where, unsigned int value)
-{
-    outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
-    outl(value, 0xCFC);
-    return PCIBIOS_SUCCESSFUL;
-}
+#ifdef INCLUDE_E1000
+extern struct pci_driver e1000_driver;
+#endif /* INCLUDE_E1000 */
 
-#undef CONFIG_CMD
+#ifdef INCLUDE_EEPRO100
+extern struct pci_driver eepro100_driver;
+#endif /* INCLUDE_EEPRO100 */
 
-#else	 /* CONFIG_PCI_DIRECT  not defined */
+#ifdef INCLUDE_EPIC100
+extern struct pci_driver epic100_driver;
+#endif /* INCLUDE_EPIC100 */
 
-static struct {
-	unsigned long address;
-	unsigned short segment;
-} bios32_indirect = { 0, KERN_CODE_SEG };
-
-static long pcibios_entry;
-static struct {
-	unsigned long address;
-	unsigned short segment;
-} pci_indirect = { 0, KERN_CODE_SEG };
+#ifdef INCLUDE_FORCEDETH
+extern struct pci_driver forcedeth_driver;
+#endif /* INCLUDE_FORCEDETH */
 
-static unsigned long bios32_service(unsigned long service)
-{
-	unsigned char return_code;	/* %al */
-	unsigned long address;		/* %ebx */
-	unsigned long length;		/* %ecx */
-	unsigned long entry;		/* %edx */
-	unsigned long flags;
-
-	save_flags(flags);
-	__asm__(
-#ifdef ABSOLUTE_WITHOUT_ASTERISK
-		"lcall (%%edi)"
-#else
-		"lcall *(%%edi)"
-#endif
-		: "=a" (return_code),
-		  "=b" (address),
-		  "=c" (length),
-		  "=d" (entry)
-		: "0" (service),
-		  "1" (0),
-		  "D" (&bios32_indirect));
-	restore_flags(flags);
-
-	switch (return_code) {
-		case 0:
-			return address + entry;
-		case 0x80:	/* Not present */
-			printf("bios32_service(%d) : not present\n", service);
-			return 0;
-		default: /* Shouldn't happen */
-			printf("bios32_service(%d) : returned %#X, mail drew@colorado.edu\n",
-				service, return_code);
-			return 0;
-	}
-}
+#ifdef INCLUDE_NATSEMI
+extern struct pci_driver natsemi_driver;
+#endif /* INCLUDE_NATSEMI */
 
-int pcibios_read_config_byte(unsigned int bus,
-        unsigned int device_fn, unsigned int where, unsigned char *value)
-{
-        unsigned long ret;
-        unsigned long bx = (bus << 8) | device_fn;
-        unsigned long flags;
-
-        save_flags(flags);
-        __asm__(
-#ifdef ABSOLUTE_WITHOUT_ASTERISK
-		"lcall (%%esi)\n\t"
-#else
-		"lcall *(%%esi)\n\t"
-#endif
-                "jc 1f\n\t"
-                "xor %%ah, %%ah\n"
-                "1:"
-                : "=c" (*value),
-                  "=a" (ret)
-                : "1" (PCIBIOS_READ_CONFIG_BYTE),
-                  "b" (bx),
-                  "D" ((long) where),
-                  "S" (&pci_indirect));
-        restore_flags(flags);
-        return (int) (ret & 0xff00) >> 8;
-}
+#ifdef INCLUDE_NS83820
+extern struct pci_driver ns83820_driver;
+#endif /* INCLUDE_NS83820 */
 
-int pcibios_read_config_word(unsigned int bus,
-        unsigned int device_fn, unsigned int where, unsigned short *value)
-{
-        unsigned long ret;
-        unsigned long bx = (bus << 8) | device_fn;
-        unsigned long flags;
-
-        save_flags(flags);
-        __asm__(
-#ifdef ABSOLUTE_WITHOUT_ASTERISK
-		"lcall (%%esi)\n\t"
-#else
-		"lcall *(%%esi)\n\t"
-#endif
-                "jc 1f\n\t"
-                "xor %%ah, %%ah\n"
-                "1:"
-                : "=c" (*value),
-                  "=a" (ret)
-                : "1" (PCIBIOS_READ_CONFIG_WORD),
-                  "b" (bx),
-                  "D" ((long) where),
-                  "S" (&pci_indirect));
-        restore_flags(flags);
-        return (int) (ret & 0xff00) >> 8;
-}
+#ifdef INCLUDE_NS8390
+extern struct pci_driver nepci_driver;
+#endif /* INCLUDE_NS8390 */
 
-int pcibios_read_config_dword(unsigned int bus,
-        unsigned int device_fn, unsigned int where, unsigned int *value)
-{
-        unsigned long ret;
-        unsigned long bx = (bus << 8) | device_fn;
-        unsigned long flags;
-
-        save_flags(flags);
-        __asm__(
-#ifdef ABSOLUTE_WITHOUT_ASTERISK
-		"lcall (%%esi)\n\t"
-#else
-		"lcall *(%%esi)\n\t"
-#endif
-                "jc 1f\n\t"
-                "xor %%ah, %%ah\n"
-                "1:"
-                : "=c" (*value),
-                  "=a" (ret)
-                : "1" (PCIBIOS_READ_CONFIG_DWORD),
-                  "b" (bx),
-                  "D" ((long) where),
-                  "S" (&pci_indirect));
-        restore_flags(flags);
-        return (int) (ret & 0xff00) >> 8;
-}
+#ifdef INCLUDE_PCNET32
+extern struct pci_driver pcnet32_driver;
+#endif /* INCLUDE_PCNET32 */
 
-int pcibios_write_config_byte (unsigned int bus,
-	unsigned int device_fn, unsigned int where, unsigned char value)
-{
-	unsigned long ret;
-	unsigned long bx = (bus << 8) | device_fn;
-	unsigned long flags;
-
-	save_flags(flags); cli();
-	__asm__(
-#ifdef ABSOLUTE_WITHOUT_ASTERISK
-		"lcall (%%esi)\n\t"
-#else
-		"lcall *(%%esi)\n\t"
-#endif
-		"jc 1f\n\t"
-		"xor %%ah, %%ah\n"
-		"1:"
-		: "=a" (ret)
-		: "0" (PCIBIOS_WRITE_CONFIG_BYTE),
-		  "c" (value),
-		  "b" (bx),
-		  "D" ((long) where),
-		  "S" (&pci_indirect));
-	restore_flags(flags);
-	return (int) (ret & 0xff00) >> 8;
-}
+#ifdef INCLUDE_PNIC
+extern struct pci_driver pnic_driver;
+#endif /* INCLUDE_PNIC */
 
-int pcibios_write_config_word (unsigned int bus,
-	unsigned int device_fn, unsigned int where, unsigned short value)
-{
-	unsigned long ret;
-	unsigned long bx = (bus << 8) | device_fn;
-	unsigned long flags;
-
-	save_flags(flags); cli();
-	__asm__(
-#ifdef ABSOLUTE_WITHOUT_ASTERISK
-		"lcall (%%esi)\n\t"
-#else
-		"lcall *(%%esi)\n\t"
-#endif
-		"jc 1f\n\t"
-		"xor %%ah, %%ah\n"
-		"1:"
-		: "=a" (ret)
-		: "0" (PCIBIOS_WRITE_CONFIG_WORD),
-		  "c" (value),
-		  "b" (bx),
-		  "D" ((long) where),
-		  "S" (&pci_indirect));
-	restore_flags(flags);
-	return (int) (ret & 0xff00) >> 8;
-}
+#ifdef INCLUDE_RTL8139
+extern struct pci_driver rtl8139_driver;
+#endif /* INCLUDE_RTL8139 */
 
-int pcibios_write_config_dword (unsigned int bus,
-	unsigned int device_fn, unsigned int where, unsigned int value)
-{
-	unsigned long ret;
-	unsigned long bx = (bus << 8) | device_fn;
-	unsigned long flags;
-
-	save_flags(flags); cli();
-	__asm__(
-#ifdef ABSOLUTE_WITHOUT_ASTERISK
-		"lcall (%%esi)\n\t"
-#else
-		"lcall *(%%esi)\n\t"
-#endif
-		"jc 1f\n\t"
-		"xor %%ah, %%ah\n"
-		"1:"
-		: "=a" (ret)
-		: "0" (PCIBIOS_WRITE_CONFIG_DWORD),
-		  "c" (value),
-		  "b" (bx),
-		  "D" ((long) where),
-		  "S" (&pci_indirect));
-	restore_flags(flags);
-	return (int) (ret & 0xff00) >> 8;
-}
+#ifdef INCLUDE_SIS900
+extern struct pci_driver sis900_driver;
+extern struct pci_driver sis_bridge_driver;
+#endif /* INCLUDE_SIS900 */
 
-static void check_pcibios(void)
-{
-	unsigned long signature;
-	unsigned char present_status;
-	unsigned char major_revision;
-	unsigned char minor_revision;
-	unsigned long flags;
-	int pack;
-
-	if ((pcibios_entry = bios32_service(PCI_SERVICE))) {
-		pci_indirect.address = pcibios_entry;
-
-		save_flags(flags);
-		__asm__(
-#ifdef ABSOLUTE_WITHOUT_ASTERISK
-			"lcall (%%edi)\n\t"
-#else
-			"lcall *(%%edi)\n\t"
-#endif
-			"jc 1f\n\t"
-			"xor %%ah, %%ah\n"
-			"1:\tshl $8, %%eax\n\t"
-			"movw %%bx, %%ax"
-			: "=d" (signature),
-			  "=a" (pack)
-			: "1" (PCIBIOS_PCI_BIOS_PRESENT),
-			  "D" (&pci_indirect)
-			: "bx", "cx");
-		restore_flags(flags);
-
-		present_status = (pack >> 16) & 0xff;
-		major_revision = (pack >> 8) & 0xff;
-		minor_revision = pack & 0xff;
-		if (present_status || (signature != PCI_SIGNATURE)) {
-			printf("ERROR: BIOS32 says PCI BIOS, but no PCI "
-				"BIOS????\n");
-			pcibios_entry = 0;
-		}
-#if	DEBUG
-		if (pcibios_entry) {
-			printf ("pcibios_init : PCI BIOS revision %hhX.%hhX"
-				" entry at %#X\n", major_revision,
-				minor_revision, pcibios_entry);
-		}
-#endif
-	}
-}
+#ifdef INCLUDE_SUNDANCE
+extern struct pci_driver sundance_driver;
+#endif	/* INCLUDE_SUNDANCE */
 
-static void pcibios_init(void)
-{
-	union bios32 *check;
-	unsigned char sum;
-	int i, length;
-	unsigned long bios32_entry = 0;
-
-	/*
-	 * Follow the standard procedure for locating the BIOS32 Service
-	 * directory by scanning the permissible address range from
-	 * 0xe0000 through 0xfffff for a valid BIOS32 structure.
-	 *
-	 */
+#ifdef INCLUDE_TG3
+extern struct pci_driver  tg3_driver;
+#endif /* INCLUDE_TG3 */
+
+#ifdef INCLUDE_TLAN
+extern struct pci_driver tlan_driver;
+#endif /* INCLUDE_TLAN */
+
+#ifdef INCLUDE_TULIP
+extern struct pci_driver tulip_driver;
+#endif /* INCLUDE_TULIP */
+
+#ifdef INCLUDE_UNDI
+extern struct pci_driver undi_driver;
+#endif /* INCLUDE_UNDI */
+
+#ifdef INCLUDE_VIA_RHINE
+extern struct pci_driver rhine_driver;
+#endif/* INCLUDE_VIA_RHINE */
+
+#ifdef INCLUDE_W89C840
+extern struct pci_driver w89c840_driver;
+#endif /* INCLUDE_W89C840 */
+
+#ifdef INCLUDE_R8169
+extern struct pci_driver r8169_driver;
+#endif /* INCLUDE_R8169 */
+
+static const struct pci_driver *pci_drivers[] = {
+
+#ifdef INCLUDE_3C595
+	&t595_driver,
+#endif /* INCLUDE_3C595 */
+
+#ifdef INCLUDE_3C90X
+	&a3c90x_driver,
+#endif /* INCLUDE_3C90X */
+
+#ifdef INCLUDE_DAVICOM
+	&davicom_driver,
+#endif /* INCLUDE_DAVICOM */
+
+#ifdef INCLUDE_E1000
+	&e1000_driver,
+#endif /* INCLUDE_E1000 */
+
+#ifdef INCLUDE_EEPRO100
+	&eepro100_driver,
+#endif /* INCLUDE_EEPRO100 */
+
+#ifdef INCLUDE_EPIC100
+	&epic100_driver,
+#endif /* INCLUDE_EPIC100 */
+
+#ifdef INCLUDE_FORCEDETH
+	&forcedeth_driver,
+#endif /* INCLUDE_FORCEDETH */
+
+#ifdef INCLUDE_NATSEMI
+	&natsemi_driver,
+#endif /* INCLUDE_NATSEMI */
+
+#ifdef INCLUDE_NS83820
+	&ns83820_driver,
+#endif /* INCLUDE_NS83820 */
+
+#ifdef INCLUDE_NS8390
+	&nepci_driver,
+#endif /* INCLUDE_NS8390 */
+
+#ifdef INCLUDE_PCNET32
+	&pcnet32_driver,
+#endif /* INCLUDE_PCNET32 */
+
+#ifdef INCLUDE_PNIC
+	&pnic_driver,
+#endif /* INCLUDE_PNIC */
 
-	for (check = (union bios32 *) 0xe0000; check <= (union bios32 *) 0xffff0; ++check) {
-		if (check->fields.signature != BIOS32_SIGNATURE)
+#ifdef INCLUDE_RTL8139
+	&rtl8139_driver,
+#endif /* INCLUDE_RTL8139 */
+
+#ifdef INCLUDE_SIS900
+	&sis900_driver,
+	&sis_bridge_driver,
+#endif /* INCLUDE_SIS900 */
+
+#ifdef INCLUDE_SUNDANCE
+	&sundance_driver,
+#endif /* INCLUDE_SUNDANCE */
+
+#ifdef INCLUDE_TG3
+	& tg3_driver,
+#endif /* INCLUDE_TG3 */
+
+#ifdef INCLUDE_TLAN
+	&tlan_driver,
+#endif /* INCLUDE_TLAN */
+
+#ifdef INCLUDE_TULIP
+	& tulip_driver,
+#endif /* INCLUDE_TULIP */
+
+#ifdef INCLUDE_VIA_RHINE
+	&rhine_driver,
+#endif/* INCLUDE_VIA_RHINE */
+
+#ifdef INCLUDE_W89C840
+	&w89c840_driver,
+#endif /* INCLUDE_W89C840 */
+
+#ifdef INCLUDE_R8169
+	&r8169_driver,
+#endif /* INCLUDE_R8169 */
+
+/* We must be the last one */
+#ifdef INCLUDE_UNDI
+	&undi_driver,
+#endif /* INCLUDE_UNDI */
+
+	0
+};
+
+static void scan_drivers(
+	int type, 
+	uint32_t class, uint16_t vendor, uint16_t device,
+	const struct pci_driver *last_driver, struct pci_device *dev)
+{
+	const struct pci_driver *skip_driver = last_driver;
+	/* Assume there is only one match of the correct type */
+	const struct pci_driver *driver;
+	int i, j;
+	
+	for(j = 0; pci_drivers[j] != 0; j++){
+		driver = pci_drivers[j];
+		if (driver->type != type)
 			continue;
-		length = check->fields.length * 16;
-		if (!length)
+		if (skip_driver) {
+			if (skip_driver == driver) 
+				skip_driver = 0;
 			continue;
-		sum = 0;
-		for (i = 0; i < length ; ++i)
-			sum += check->chars[i];
-		if (sum != 0)
+		}
+		for(i = 0; i < driver->id_count; i++) {
+			if ((vendor == driver->ids[i].vendor) &&
+			    (device == driver->ids[i].dev_id)) {
+				
+				dev->driver = driver;
+				dev->name   = driver->ids[i].name;
+
+				goto out;
+			}
+		}
+	}
+	if (!class) {
+		goto out;
+	}
+	for(j = 0; pci_drivers[j] != 0; j++){
+		driver = pci_drivers[j];
+		if (driver->type != type)
 			continue;
-		if (check->fields.revision != 0) {
-			printf("pcibios_init : unsupported revision %d at %#X, mail drew@colorado.edu\n",
-				check->fields.revision, check);
+		if (skip_driver) {
+			if (skip_driver == driver)
+				skip_driver = 0;
 			continue;
 		}
-#if	DEBUG
-		printf("pcibios_init : BIOS32 Service Directory "
-			"structure at %#X\n", check);
-#endif
-		if (!bios32_entry) {
-			if (check->fields.entry >= 0x100000) {
-				printf("pcibios_init: entry in high "
-					"memory, giving up\n");
-				return;
-			} else {
-				bios32_entry = check->fields.entry;
-#if	DEBUG
-				printf("pcibios_init : BIOS32 Service Directory"
-					" entry at %#X\n", bios32_entry);
-#endif
-				bios32_indirect.address = bios32_entry;
-			}
+		if (last_driver == driver)
+			continue;
+		if ((class >> 8) == driver->class) {
+			dev->driver = driver;
+			dev->name   = driver->name;
+			goto out;
 		}
 	}
-	if (bios32_entry)
-		check_pcibios();
+ out:
+	return;
 }
-#endif	/* CONFIG_PCI_DIRECT not defined*/
 
-static void scan_bus(struct pci_device *pcidev)
+void scan_pci_bus(int type, struct pci_device *dev)
 {
-	unsigned int devfn, l, bus, buses;
+	unsigned int first_bus, first_devfn;
+	const struct pci_driver *first_driver;
+	unsigned int devfn, bus, buses;
 	unsigned char hdr_type = 0;
-	unsigned short vendor, device;
-	unsigned int membase, ioaddr, romaddr;
-	int i, reg;
-	unsigned int pci_ioaddr = 0;
-
+	uint32_t class;
+	uint16_t vendor, device;
+	uint32_t l, membase, ioaddr, romaddr;
+	int reg;
+
+	EnterFunction("scan_pci_bus");
+	first_bus    = 0;
+	first_devfn  = 0;
+	first_driver = 0;
+	if (dev->driver) {
+		first_driver = dev->driver;
+		first_bus    = dev->bus;
+		first_devfn  = dev->devfn;
+		/* Re read the header type on a restart */
+		pcibios_read_config_byte(first_bus, first_devfn & ~0x7, 
+			PCI_HEADER_TYPE, &hdr_type);
+		dev->driver  = 0;
+		dev->bus     = 0;
+		dev->devfn   = 0;
+	}
+		
 	/* Scan all PCI buses, until we find our card.
-	 * We could be smart only scan the required busses but that
+	 * We could be smart only scan the required buses but that
 	 * is error prone, and tricky.
-	 * By scanning all possible pci busses in order we should find
+	 * By scanning all possible pci buses in order we should find
 	 * our card eventually. 
 	 */
 	buses=256;
-	for (bus = 0; bus < buses; ++bus) {
-		for (devfn = 0; devfn < 0xff; ++devfn) {
+	for (bus = first_bus; bus < buses; ++bus) {
+		for (devfn = first_devfn; devfn < 0xff; ++devfn, first_driver = 0) {
 			if (PCI_FUNC (devfn) == 0)
 				pcibios_read_config_byte(bus, devfn, PCI_HEADER_TYPE, &hdr_type);
 			else if (!(hdr_type & 0x80))	/* not a multi-function device */
@@ -421,61 +301,90 @@
 			pcibios_read_config_dword(bus, devfn, PCI_VENDOR_ID, &l);
 			/* some broken boards return 0 if a slot is empty: */
 			if (l == 0xffffffff || l == 0x00000000) {
-				hdr_type = 0;
 				continue;
 			}
 			vendor = l & 0xffff;
 			device = (l >> 16) & 0xffff;
 
+			pcibios_read_config_dword(bus, devfn, PCI_REVISION, &l);
+			class = (l >> 8) & 0xffffff;
 #if	DEBUG
-			printf("bus %hhX, function %hhX, vendor %hX, device %hX\n",
-				bus, devfn, vendor, device);
+		{
+			int i;
+			printf("%hhx:%hhx.%hhx [%hX/%hX] ---- ",
+				bus, PCI_SLOT(devfn), PCI_FUNC(devfn),
+				vendor, device);
+#if	DEBUG > 1
+			for(i = 0; i < 256; i++) {
+				unsigned char byte;
+				if ((i & 0xf) == 0) {
+					printf("%hhx: ", i);
+				}
+				pcibios_read_config_byte(bus, devfn, i, &byte);
+				printf("%hhx ", byte);
+				if ((i & 0xf) == 0xf) {
+					printf("\n");
+				}
+			}
+#endif
+
+		}
+#endif
+			scan_drivers(type, class, vendor, device, first_driver, dev);
+			if (!dev->driver){
+#if DEBUG
+				printf("No driver fit.\n");
 #endif
-			for (i = 0; pcidev[i].vendor != 0; i++) {
-				if (vendor != pcidev[i].vendor
-				    || device != pcidev[i].dev_id)
+				continue;
+			}
+#if DEBUG
+			printf("Get Driver:\n");
+#endif
+			dev->devfn = devfn;
+			dev->bus = bus;
+			dev->class = class;
+			dev->vendor = vendor;
+			dev->dev_id = device;
+			
+			
+			/* Get the ROM base address */
+			pcibios_read_config_dword(bus, devfn, 
+				PCI_ROM_ADDRESS, &romaddr);
+			romaddr >>= 10;
+			dev->romaddr = romaddr;
+			
+			/* Get the ``membase'' */
+			pcibios_read_config_dword(bus, devfn,
+				PCI_BASE_ADDRESS_1, &membase);
+			dev->membase = membase;
+				
+			/* Get the ``ioaddr'' */
+			for (reg = PCI_BASE_ADDRESS_0; reg <= PCI_BASE_ADDRESS_5; reg += 4) {
+				pcibios_read_config_dword(bus, devfn, reg, &ioaddr);
+				if ((ioaddr & PCI_BASE_ADDRESS_IO_MASK) == 0 || (ioaddr & PCI_BASE_ADDRESS_SPACE_IO) == 0)
 					continue;
-				pcidev[i].devfn = devfn;
-				pcidev[i].bus = bus;
-				for (reg = PCI_BASE_ADDRESS_0; reg <= PCI_BASE_ADDRESS_5; reg += 4) {
-					pcibios_read_config_dword(bus, devfn, reg, &ioaddr);
-
-					if ((ioaddr & PCI_BASE_ADDRESS_IO_MASK) == 0 || (ioaddr & PCI_BASE_ADDRESS_SPACE_IO) == 0)
-						continue;
-					/* Strip the I/O address out of the returned value */
-					ioaddr &= PCI_BASE_ADDRESS_IO_MASK;
-					/* Get the memory base address */
-					pcibios_read_config_dword(bus, devfn,
-						PCI_BASE_ADDRESS_1, &membase);
-					/* Get the ROM base address */
-					pcibios_read_config_dword(bus, devfn, PCI_ROM_ADDRESS, &romaddr);
-					romaddr >>= 10;
-					printf("Found %s at %#hx, ROM address %#hx\n",
-						pcidev[i].name, ioaddr, romaddr);
-					/* Take the first one or the one that matches in boot ROM address */
-					if (pci_ioaddr == 0 || romaddr == ((unsigned long) rom.rom_segment << 4)) {
-						pcidev[i].membase = membase;
-						pcidev[i].ioaddr = ioaddr;
-						return;
-					}
-				}
+				
+				
+				/* Strip the I/O address out of the returned value */
+				ioaddr &= PCI_BASE_ADDRESS_IO_MASK;
+				
+				/* Take the first one or the one that matches in boot ROM address */
+				dev->ioaddr = ioaddr;
 			}
+#if DEBUG > 2
+			printf("Found %s ROM address %#hx\n",
+				dev->name, romaddr);
+#endif
+			LeaveFunction("scan_pci_bus");
+			return;
 		}
+		first_devfn = 0;
 	}
+	first_bus = 0;
+	LeaveFunction("scan_pci_bus");
 }
 
-void eth_pci_init(struct pci_device *pcidev)
-{
-#ifndef	CONFIG_PCI_DIRECT
-	pcibios_init();
-	if (!pcibios_entry) {
-		printf("pci_init: no BIOS32 detected\n");
-		return;
-	}
-#endif
-	scan_bus(pcidev);
-	/* return values are in pcidev structures */
-}
+
 
 /*
  *	Set device to be a busmaster in case BIOS neglected to do so.
@@ -489,13 +398,134 @@
 	pcibios_read_config_word(p->bus, p->devfn, PCI_COMMAND, &pci_command);
 	new_command = pci_command | PCI_COMMAND_MASTER|PCI_COMMAND_IO;
 	if (pci_command != new_command) {
-		printf("The PCI BIOS has not enabled this device!\nUpdating PCI command %hX->%hX. pci_bus %hhX pci_device_fn %hhX\n",
+#if DEBUG > 0
+		printf(
+			"The PCI BIOS has not enabled this device!\n"
+			"Updating PCI command %hX->%hX. pci_bus %hhX pci_device_fn %hhX\n",
 			   pci_command, new_command, p->bus, p->devfn);
+#endif
 		pcibios_write_config_word(p->bus, p->devfn, PCI_COMMAND, new_command);
 	}
 	pcibios_read_config_byte(p->bus, p->devfn, PCI_LATENCY_TIMER, &pci_latency);
 	if (pci_latency < 32) {
-		printf("PCI latency timer (CFLT) is unreasonably low at %d. Setting to 32 clocks.\n", pci_latency);
+#if DEBUG > 0
+		printf("PCI latency timer (CFLT) is unreasonably low at %d. Setting to 32 clocks.\n", 
+			pci_latency);
+#endif
 		pcibios_write_config_byte(p->bus, p->devfn, PCI_LATENCY_TIMER, 32);
 	}
 }
+
+/*
+ * Find the start of a pci resource.
+ */
+unsigned long pci_bar_start(struct pci_device *dev, unsigned int index)
+{
+	uint32_t lo, hi;
+	unsigned long bar;
+	pci_read_config_dword(dev, index, &lo);
+	if (lo & PCI_BASE_ADDRESS_SPACE_IO) {
+		bar = lo & PCI_BASE_ADDRESS_IO_MASK;
+	} else {
+		bar = 0;
+		if ((lo & PCI_BASE_ADDRESS_MEM_TYPE_MASK) == PCI_BASE_ADDRESS_MEM_TYPE_64) {
+			pci_read_config_dword(dev, index + 4, &hi);
+			if (hi) {
+				if (sizeof(unsigned long) > sizeof(uint32_t)) {
+					bar = hi;
+					/* It's REALLY interesting:-) */
+					bar <<=32;
+				}
+				else {
+					printf("Unhandled 64bit BAR\n");
+					return -1UL;
+				}
+			}
+		}
+		bar |= lo & PCI_BASE_ADDRESS_MEM_MASK;
+	}
+	return bar + pcibios_bus_base(dev->bus);
+}
+
+/*
+ * Find the size of a pci resource.
+ */
+unsigned long pci_bar_size(struct pci_device *dev, unsigned int bar)
+{
+	uint32_t start, size;
+	/* Save the original bar */
+	pci_read_config_dword(dev, bar, &start);
+	/* Compute which bits can be set */
+	pci_write_config_dword(dev, bar, ~0);
+	pci_read_config_dword(dev, bar, &size);
+	/* Restore the original size */
+	pci_write_config_dword(dev, bar, start);
+	/* Find the significant bits */
+	if (start & PCI_BASE_ADDRESS_SPACE_IO) {
+		size &= PCI_BASE_ADDRESS_IO_MASK;
+	} else {
+		size &= PCI_BASE_ADDRESS_MEM_MASK;
+	}
+	/* Find the lowest bit set */
+	size = size & ~(size - 1);
+	return size;
+}
+
+/**
+ * pci_find_capability - query for devices' capabilities 
+ * @dev: PCI device to query
+ * @cap: capability code
+ *
+ * Tell if a device supports a given PCI capability.
+ * Returns the address of the requested capability structure within the
+ * device's PCI configuration space or 0 in case the device does not
+ * support it.  Possible values for @cap:
+ *
+ *  %PCI_CAP_ID_PM           Power Management 
+ *
+ *  %PCI_CAP_ID_AGP          Accelerated Graphics Port 
+ *
+ *  %PCI_CAP_ID_VPD          Vital Product Data 
+ *
+ *  %PCI_CAP_ID_SLOTID       Slot Identification 
+ *
+ *  %PCI_CAP_ID_MSI          Message Signalled Interrupts
+ *
+ *  %PCI_CAP_ID_CHSWP        CompactPCI HotSwap 
+ */
+int pci_find_capability(struct pci_device *dev, int cap)
+{
+	uint16_t status;
+	uint8_t pos, id;
+	uint8_t hdr_type;
+	int ttl = 48;
+
+	pci_read_config_word(dev, PCI_STATUS, &status);
+	if (!(status & PCI_STATUS_CAP_LIST))
+		return 0;
+	pci_read_config_byte(dev, PCI_HEADER_TYPE, &hdr_type);
+	switch (hdr_type & 0x7F) {
+	case PCI_HEADER_TYPE_NORMAL:
+	case PCI_HEADER_TYPE_BRIDGE:
+	default:
+		pci_read_config_byte(dev, PCI_CAPABILITY_LIST, &pos);
+		break;
+	case PCI_HEADER_TYPE_CARDBUS:
+		pci_read_config_byte(dev, PCI_CB_CAPABILITY_LIST, &pos);
+		break;
+	}
+	while (ttl-- && pos >= 0x40) {
+		pos &= ~3;
+		pci_read_config_byte(dev, pos + PCI_CAP_LIST_ID, &id);
+#if	DEBUG > 0
+		printf("Capability: %d\n", id);
+#endif
+		if (id == 0xff)
+			break;
+		if (id == cap)
+			return pos;
+		pci_read_config_byte(dev, pos + PCI_CAP_LIST_NEXT, &pos);
+	}
+	return 0;
+}
+
diff -Naur grub-0.97.orig/netboot/pci.h grub-0.97/netboot/pci.h
--- grub-0.97.orig/netboot/pci.h	2003-07-09 11:45:38.000000000 +0000
+++ grub-0.97/netboot/pci.h	2005-08-31 21:31:46.000000000 +0000
@@ -1,4 +1,4 @@
-#ifndef	PCI_H
+#if !defined(PCI_H) && defined(CONFIG_PCI)
 #define PCI_H
 
 /*
@@ -21,10 +21,19 @@
  * your option) any later version.
  */
 
+#include "pci_ids.h"
+
 #define PCI_COMMAND_IO			0x1	/* Enable response in I/O space */
 #define PCI_COMMAND_MEM			0x2	/* Enable response in mem space */
 #define PCI_COMMAND_MASTER		0x4	/* Enable bus mastering */
 #define PCI_LATENCY_TIMER		0x0d	/* 8 bits */
+#define PCI_COMMAND_SPECIAL		0x8	/* Enable response to special cycles */
+#define PCI_COMMAND_INVALIDATE		0x10	/* Use memory write and invalidate */
+#define  PCI_COMMAND_VGA_PALETTE 0x20	/* Enable palette snooping */
+#define  PCI_COMMAND_PARITY	0x40	/* Enable parity checking */
+#define  PCI_COMMAND_WAIT 	0x80	/* Enable address/data stepping */
+#define  PCI_COMMAND_SERR	0x100	/* Enable SERR */
+#define  PCI_COMMAND_FAST_BACK	0x200	/* Enable back-to-back writes */
 
 #define PCIBIOS_PCI_FUNCTION_ID         0xb1XX
 #define PCIBIOS_PCI_BIOS_PRESENT        0xb101
@@ -42,10 +51,37 @@
 #define PCI_DEVICE_ID           0x02    /* 16 bits */
 #define PCI_COMMAND             0x04    /* 16 bits */
 
+#define PCI_STATUS		0x06	/* 16 bits */
+#define  PCI_STATUS_CAP_LIST	0x10	/* Support Capability List */
+#define  PCI_STATUS_66MHZ	0x20	/* Support 66 Mhz PCI 2.1 bus */
+#define  PCI_STATUS_UDF		0x40	/* Support User Definable Features [obsolete] */
+#define  PCI_STATUS_FAST_BACK	0x80	/* Accept fast-back to back */
+#define  PCI_STATUS_PARITY	0x100	/* Detected parity error */
+#define  PCI_STATUS_DEVSEL_MASK	0x600	/* DEVSEL timing */
+#define  PCI_STATUS_DEVSEL_FAST	0x000	
+#define  PCI_STATUS_DEVSEL_MEDIUM 0x200
+#define  PCI_STATUS_DEVSEL_SLOW 0x400
+#define  PCI_STATUS_SIG_TARGET_ABORT 0x800 /* Set on target abort */
+#define  PCI_STATUS_REC_TARGET_ABORT 0x1000 /* Master ack of " */
+#define  PCI_STATUS_REC_MASTER_ABORT 0x2000 /* Set on master abort */
+#define  PCI_STATUS_SIG_SYSTEM_ERROR 0x4000 /* Set when we drive SERR */
+#define  PCI_STATUS_DETECTED_PARITY 0x8000 /* Set on parity error */
+
 #define PCI_REVISION            0x08    /* 8 bits  */
+#define PCI_REVISION_ID         0x08    /* 8 bits  */
+#define PCI_CLASS_REVISION      0x08    /* 32 bits  */
 #define PCI_CLASS_CODE          0x0b    /* 8 bits */
 #define PCI_SUBCLASS_CODE       0x0a    /* 8 bits */
 #define PCI_HEADER_TYPE         0x0e    /* 8 bits */
+#define  PCI_HEADER_TYPE_NORMAL	0
+#define  PCI_HEADER_TYPE_BRIDGE 1
+#define  PCI_HEADER_TYPE_CARDBUS 2
+
+
+/* Header type 0 (normal devices) */
+#define PCI_CARDBUS_CIS		0x28
+#define PCI_SUBSYSTEM_VENDOR_ID	0x2c
+#define PCI_SUBSYSTEM_ID	0x2e  
 
 #define PCI_BASE_ADDRESS_0      0x10    /* 32 bits */
 #define PCI_BASE_ADDRESS_1      0x14    /* 32 bits */
@@ -54,15 +90,155 @@
 #define PCI_BASE_ADDRESS_4      0x20    /* 32 bits */
 #define PCI_BASE_ADDRESS_5      0x24    /* 32 bits */
 
+#define PCI_BASE_ADDRESS_MEM_TYPE_MASK 0x06
+#define PCI_BASE_ADDRESS_MEM_TYPE_32	0x00	/* 32 bit address */
+#define PCI_BASE_ADDRESS_MEM_TYPE_1M	0x02	/* Below 1M [obsolete] */
+#define PCI_BASE_ADDRESS_MEM_TYPE_64	0x04	/* 64 bit address */
+
 #ifndef	PCI_BASE_ADDRESS_IO_MASK
 #define	PCI_BASE_ADDRESS_IO_MASK       (~0x03)
 #endif
+#ifndef	PCI_BASE_ADDRESS_MEM_MASK
+#define	PCI_BASE_ADDRESS_MEM_MASK       (~0x0f)
+#endif
 #define	PCI_BASE_ADDRESS_SPACE_IO	0x01
 #define	PCI_ROM_ADDRESS		0x30	/* 32 bits */
 #define	PCI_ROM_ADDRESS_ENABLE	0x01	/* Write 1 to enable ROM,
 					   bits 31..11 are address,
 					   10..2 are reserved */
 
+#define PCI_CAPABILITY_LIST	0x34	/* Offset of first capability list entry */
+
+#define PCI_INTERRUPT_LINE	0x3c	/* IRQ number (0-15) */
+#define PCI_INTERRUPT_PIN	0x3d	/* IRQ pin on PCI bus (A-D) */
+
+/* Header type 1 (PCI-to-PCI bridges) */
+#define PCI_PRIMARY_BUS		0x18	/* Primary bus number */
+#define PCI_SECONDARY_BUS	0x19	/* Secondary bus number */
+#define PCI_SUBORDINATE_BUS	0x1a	/* Highest bus number behind the bridge */
+#define PCI_SEC_LATENCY_TIMER	0x1b	/* Latency timer for secondary interface */
+#define PCI_IO_BASE		0x1c	/* I/O range behind the bridge */
+#define PCI_IO_LIMIT		0x1d
+#define  PCI_IO_RANGE_TYPE_MASK	0x0f	/* I/O bridging type */
+#define  PCI_IO_RANGE_TYPE_16	0x00
+#define  PCI_IO_RANGE_TYPE_32	0x01
+#define  PCI_IO_RANGE_MASK	~0x0f
+#define PCI_SEC_STATUS		0x1e	/* Secondary status register, only bit 14 used */
+#define PCI_MEMORY_BASE		0x20	/* Memory range behind */
+#define PCI_MEMORY_LIMIT	0x22
+#define  PCI_MEMORY_RANGE_TYPE_MASK 0x0f
+#define  PCI_MEMORY_RANGE_MASK	~0x0f
+#define PCI_PREF_MEMORY_BASE	0x24	/* Prefetchable memory range behind */
+#define PCI_PREF_MEMORY_LIMIT	0x26
+#define  PCI_PREF_RANGE_TYPE_MASK 0x0f
+#define  PCI_PREF_RANGE_TYPE_32	0x00
+#define  PCI_PREF_RANGE_TYPE_64	0x01
+#define  PCI_PREF_RANGE_MASK	~0x0f
+#define PCI_PREF_BASE_UPPER32	0x28	/* Upper half of prefetchable memory range */
+#define PCI_PREF_LIMIT_UPPER32	0x2c
+#define PCI_IO_BASE_UPPER16	0x30	/* Upper half of I/O addresses */
+#define PCI_IO_LIMIT_UPPER16	0x32
+/* 0x34 same as for htype 0 */
+/* 0x35-0x3b is reserved */
+#define PCI_ROM_ADDRESS1	0x38	/* Same as PCI_ROM_ADDRESS, but for htype 1 */
+/* 0x3c-0x3d are same as for htype 0 */
+#define PCI_BRIDGE_CONTROL	0x3e
+#define  PCI_BRIDGE_CTL_PARITY	0x01	/* Enable parity detection on secondary interface */
+#define  PCI_BRIDGE_CTL_SERR	0x02	/* The same for SERR forwarding */
+#define  PCI_BRIDGE_CTL_NO_ISA	0x04	/* Disable bridging of ISA ports */
+#define  PCI_BRIDGE_CTL_VGA	0x08	/* Forward VGA addresses */
+#define  PCI_BRIDGE_CTL_MASTER_ABORT 0x20  /* Report master aborts */
+#define  PCI_BRIDGE_CTL_BUS_RESET 0x40	/* Secondary bus reset */
+#define  PCI_BRIDGE_CTL_FAST_BACK 0x80	/* Fast Back2Back enabled on secondary interface */
+
+#define PCI_CB_CAPABILITY_LIST	0x14
+
+/* Capability lists */
+
+#define PCI_CAP_LIST_ID		0	/* Capability ID */
+#define  PCI_CAP_ID_PM		0x01	/* Power Management */
+#define  PCI_CAP_ID_AGP		0x02	/* Accelerated Graphics Port */
+#define  PCI_CAP_ID_VPD		0x03	/* Vital Product Data */
+#define  PCI_CAP_ID_SLOTID	0x04	/* Slot Identification */
+#define  PCI_CAP_ID_MSI		0x05	/* Message Signalled Interrupts */
+#define  PCI_CAP_ID_CHSWP	0x06	/* CompactPCI HotSwap */
+#define PCI_CAP_LIST_NEXT	1	/* Next capability in the list */
+#define PCI_CAP_FLAGS		2	/* Capability defined flags (16 bits) */
+#define PCI_CAP_SIZEOF		4
+
+/* Power Management Registers */
+
+#define PCI_PM_PMC              2       /* PM Capabilities Register */
+#define  PCI_PM_CAP_VER_MASK	0x0007	/* Version */
+#define  PCI_PM_CAP_PME_CLOCK	0x0008	/* PME clock required */
+#define  PCI_PM_CAP_RESERVED    0x0010  /* Reserved field */
+#define  PCI_PM_CAP_DSI		0x0020	/* Device specific initialization */
+#define  PCI_PM_CAP_AUX_POWER	0x01C0	/* Auxilliary power support mask */
+#define  PCI_PM_CAP_D1		0x0200	/* D1 power state support */
+#define  PCI_PM_CAP_D2		0x0400	/* D2 power state support */
+#define  PCI_PM_CAP_PME		0x0800	/* PME pin supported */
+#define  PCI_PM_CAP_PME_MASK    0xF800  /* PME Mask of all supported states */
+#define  PCI_PM_CAP_PME_D0      0x0800  /* PME# from D0 */
+#define  PCI_PM_CAP_PME_D1      0x1000  /* PME# from D1 */
+#define  PCI_PM_CAP_PME_D2      0x2000  /* PME# from D2 */
+#define  PCI_PM_CAP_PME_D3      0x4000  /* PME# from D3 (hot) */
+#define  PCI_PM_CAP_PME_D3cold  0x8000  /* PME# from D3 (cold) */
+#define PCI_PM_CTRL		4	/* PM control and status register */
+#define  PCI_PM_CTRL_STATE_MASK	0x0003	/* Current power state (D0 to D3) */
+#define  PCI_PM_CTRL_PME_ENABLE	0x0100	/* PME pin enable */
+#define  PCI_PM_CTRL_DATA_SEL_MASK	0x1e00	/* Data select (??) */
+#define  PCI_PM_CTRL_DATA_SCALE_MASK	0x6000	/* Data scale (??) */
+#define  PCI_PM_CTRL_PME_STATUS	0x8000	/* PME pin status */
+#define PCI_PM_PPB_EXTENSIONS	6	/* PPB support extensions (??) */
+#define  PCI_PM_PPB_B2_B3	0x40	/* Stop clock when in D3hot (??) */
+#define  PCI_PM_BPCC_ENABLE	0x80	/* Bus power/clock control enable (??) */
+#define PCI_PM_DATA_REGISTER	7	/* (??) */
+#define PCI_PM_SIZEOF		8
+
+/* AGP registers */
+
+#define PCI_AGP_VERSION		2	/* BCD version number */
+#define PCI_AGP_RFU		3	/* Rest of capability flags */
+#define PCI_AGP_STATUS		4	/* Status register */
+#define  PCI_AGP_STATUS_RQ_MASK	0xff000000	/* Maximum number of requests - 1 */
+#define  PCI_AGP_STATUS_SBA	0x0200	/* Sideband addressing supported */
+#define  PCI_AGP_STATUS_64BIT	0x0020	/* 64-bit addressing supported */
+#define  PCI_AGP_STATUS_FW	0x0010	/* FW transfers supported */
+#define  PCI_AGP_STATUS_RATE4	0x0004	/* 4x transfer rate supported */
+#define  PCI_AGP_STATUS_RATE2	0x0002	/* 2x transfer rate supported */
+#define  PCI_AGP_STATUS_RATE1	0x0001	/* 1x transfer rate supported */
+#define PCI_AGP_COMMAND		8	/* Control register */
+#define  PCI_AGP_COMMAND_RQ_MASK 0xff000000  /* Master: Maximum number of requests */
+#define  PCI_AGP_COMMAND_SBA	0x0200	/* Sideband addressing enabled */
+#define  PCI_AGP_COMMAND_AGP	0x0100	/* Allow processing of AGP transactions */
+#define  PCI_AGP_COMMAND_64BIT	0x0020 	/* Allow processing of 64-bit addresses */
+#define  PCI_AGP_COMMAND_FW	0x0010 	/* Force FW transfers */
+#define  PCI_AGP_COMMAND_RATE4	0x0004	/* Use 4x rate */
+#define  PCI_AGP_COMMAND_RATE2	0x0002	/* Use 2x rate */
+#define  PCI_AGP_COMMAND_RATE1	0x0001	/* Use 1x rate */
+#define PCI_AGP_SIZEOF		12
+
+/* Slot Identification */
+
+#define PCI_SID_ESR		2	/* Expansion Slot Register */
+#define  PCI_SID_ESR_NSLOTS	0x1f	/* Number of expansion slots available */
+#define  PCI_SID_ESR_FIC	0x20	/* First In Chassis Flag */
+#define PCI_SID_CHASSIS_NR	3	/* Chassis Number */
+
+/* Message Signalled Interrupts registers */
+
+#define PCI_MSI_FLAGS		2	/* Various flags */
+#define  PCI_MSI_FLAGS_64BIT	0x80	/* 64-bit addresses allowed */
+#define  PCI_MSI_FLAGS_QSIZE	0x70	/* Message queue size configured */
+#define  PCI_MSI_FLAGS_QMASK	0x0e	/* Maximum queue size available */
+#define  PCI_MSI_FLAGS_ENABLE	0x01	/* MSI feature enabled */
+#define PCI_MSI_RFU		3	/* Rest of capability flags */
+#define PCI_MSI_ADDRESS_LO	4	/* Lower 32 bits */
+#define PCI_MSI_ADDRESS_HI	8	/* Upper 32 bits (if PCI_MSI_FLAGS_64BIT set) */
+#define PCI_MSI_DATA_32		8	/* 16 bits of data for 32-bit devices */
+#define PCI_MSI_DATA_64		12	/* 16 bits of data for 64-bit devices */
+
+#define PCI_SLOT(devfn)		  ((devfn) >> 3)
 #define PCI_FUNC(devfn)           ((devfn) & 0x07)
 
 #define BIOS32_SIGNATURE        (('_' << 0) + ('3' << 8) + ('2' << 16) + ('_' << 24))
@@ -85,108 +261,97 @@
 	char chars[16];
 };
 
-#define KERN_CODE_SEG	0x8	/* This _MUST_ match start.S */
-
-/* Stuff for asm */
-#define save_flags(x) \
-__asm__ __volatile__("pushfl ; popl %0":"=g" (x): /* no input */ :"memory")
-
-#define cli() __asm__ __volatile__ ("cli": : :"memory")
-
-#define restore_flags(x) \
-__asm__ __volatile__("pushl %0 ; popfl": /* no output */ :"g" (x):"memory")
-
-#define PCI_VENDOR_ID_ADMTEK            0x1317
-#define PCI_DEVICE_ID_ADMTEK_0985       0x0985
-#define PCI_VENDOR_ID_REALTEK           0x10ec
-#define PCI_DEVICE_ID_REALTEK_8029      0x8029
-#define PCI_DEVICE_ID_REALTEK_8139      0x8139
-#define PCI_VENDOR_ID_WINBOND2          0x1050
-#define PCI_DEVICE_ID_WINBOND2_89C940   0x0940
-#define PCI_DEVICE_ID_WINBOND2_89C840   0x0840
-#define PCI_VENDOR_ID_COMPEX            0x11f6
-#define PCI_DEVICE_ID_COMPEX_RL2000     0x1401
-#define PCI_DEVICE_ID_COMPEX_RL100ATX   0x2011
-#define PCI_VENDOR_ID_KTI               0x8e2e
-#define PCI_DEVICE_ID_KTI_ET32P2        0x3000
-#define PCI_VENDOR_ID_NETVIN            0x4a14
-#define PCI_DEVICE_ID_NETVIN_NV5000SC   0x5000
-#define	PCI_VENDOR_ID_HOLTEK		0x12c3
-#define	PCI_DEVICE_ID_HOLTEK_HT80232	0x0058
-#define PCI_VENDOR_ID_3COM		0x10b7
-#define PCI_DEVICE_ID_3COM_3C590	0x5900
-#define PCI_DEVICE_ID_3COM_3C595	0x5950
-#define PCI_DEVICE_ID_3COM_3C595_1	0x5951
-#define PCI_DEVICE_ID_3COM_3C595_2	0x5952
-#define PCI_DEVICE_ID_3COM_3C900TPO	0x9000
-#define PCI_DEVICE_ID_3COM_3C900COMBO	0x9001
-#define PCI_DEVICE_ID_3COM_3C905TX	0x9050
-#define PCI_DEVICE_ID_3COM_3C905T4	0x9051
-#define PCI_DEVICE_ID_3COM_3C905B_TX	0x9055
-#define PCI_DEVICE_ID_3COM_3C905C_TXM	0x9200
-#define PCI_VENDOR_ID_INTEL		0x8086
-#define PCI_DEVICE_ID_INTEL_82557	0x1229
-#define PCI_DEVICE_ID_INTEL_82559ER	0x1209
-#define PCI_DEVICE_ID_INTEL_ID1029	0x1029
-#define PCI_DEVICE_ID_INTEL_ID1030	0x1030
-#define PCI_DEVICE_ID_INTEL_82562	0x2449
-#define PCI_VENDOR_ID_AMD		0x1022
-#define PCI_DEVICE_ID_AMD_LANCE		0x2000
-#define PCI_VENDOR_ID_AMD_HOMEPNA	0x1022
-#define PCI_DEVICE_ID_AMD_HOMEPNA	0x2001
-#define PCI_VENDOR_ID_SMC_1211          0x1113
-#define PCI_DEVICE_ID_SMC_1211          0x1211
-#define PCI_VENDOR_ID_DEC		0x1011
-#define PCI_DEVICE_ID_DEC_TULIP		0x0002
-#define PCI_DEVICE_ID_DEC_TULIP_FAST	0x0009
-#define PCI_DEVICE_ID_DEC_TULIP_PLUS	0x0014
-#define PCI_DEVICE_ID_DEC_21142		0x0019
-#define PCI_VENDOR_ID_SMC		0x10B8
-#ifndef	PCI_DEVICE_ID_SMC_EPIC100
-# define PCI_DEVICE_ID_SMC_EPIC100	0x0005
-#endif
-#define PCI_VENDOR_ID_MACRONIX		0x10d9
-#define PCI_DEVICE_ID_MX987x5		0x0531
-#define PCI_VENDOR_ID_LINKSYS		0x11AD
-#define PCI_DEVICE_ID_LC82C115		0xC115
-#define PCI_VENDOR_ID_VIATEC		0x1106
-#define PCI_DEVICE_ID_VIA_RHINE_I	0x3043
-#define PCI_DEVICE_ID_VIA_VT6102	0x3065
-#define PCI_DEVICE_ID_VIA_86C100A	0x6100
-#define PCI_VENDOR_ID_DAVICOM		0x1282
-#define	PCI_DEVICE_ID_DM9009		0x9009
-#define PCI_DEVICE_ID_DM9102		0x9102
-#define PCI_VENDOR_ID_SIS         	0x1039
-#define PCI_DEVICE_ID_SIS900     	0x0900   
-#define PCI_DEVICE_ID_SIS7016    	0x7016  
-#define	PCI_VENDOR_ID_DLINK		0x1186
-#define	PCI_DEVICE_ID_DFE530TXP		0x1300
-#define	PCI_VENDOR_ID_NS		0x100B
-#define	PCI_DEVICE_ID_DP83815		0x0020
-#define PCI_VENDOR_ID_OLICOM		0x108d
-#define PCI_DEVICE_ID_OLICOM_OC3136	0x0001
-#define PCI_DEVICE_ID_OLICOM_OC2315	0x0011
-#define PCI_DEVICE_ID_OLICOM_OC2325	0x0012
-#define PCI_DEVICE_ID_OLICOM_OC2183	0x0013
-#define PCI_DEVICE_ID_OLICOM_OC2326	0x0014
-#define PCI_DEVICE_ID_OLICOM_OC6151	0x0021
+struct pci_device;
+struct dev;
+typedef int (*pci_probe_t)(struct dev *, struct pci_device *);
 
 struct pci_device {
-	unsigned short	vendor, dev_id;
-	const char	*name;
-	unsigned int	membase;
-	unsigned short	ioaddr;
-	unsigned char	devfn;
-	unsigned char	bus;
+	uint32_t		class;
+	uint16_t		vendor, dev_id;
+	const char		*name;
+	/* membase and ioaddr are silly and depricated */
+	unsigned int		membase;
+	unsigned int		ioaddr;
+	unsigned int		romaddr;
+	unsigned char		irq;
+	unsigned char		devfn;
+	unsigned char		bus;
+	unsigned char		use_specified;
+	const struct pci_driver	*driver;
+};
+
+extern void scan_pci_bus(int type, struct pci_device *dev);
+extern void find_pci(int type, struct pci_device *dev);
+
+extern int pcibios_read_config_byte(unsigned int bus, unsigned int device_fn, unsigned int where, uint8_t *value);
+extern int pcibios_write_config_byte (unsigned int bus, unsigned int device_fn, unsigned int where, uint8_t value);
+extern int pcibios_read_config_word(unsigned int bus, unsigned int device_fn, unsigned int where, uint16_t *value);
+extern int pcibios_write_config_word (unsigned int bus, unsigned int device_fn, unsigned int where, uint16_t value);
+extern int pcibios_read_config_dword(unsigned int bus, unsigned int device_fn, unsigned int where, uint32_t *value);
+extern int pcibios_write_config_dword(unsigned int bus, unsigned int device_fn, unsigned int where, uint32_t value);
+extern unsigned long pcibios_bus_base(unsigned int bus);
+extern void adjust_pci_device(struct pci_device *p);
+
+
+static inline int 
+pci_read_config_byte(struct pci_device *dev, unsigned int where, uint8_t *value)
+{
+	return pcibios_read_config_byte(dev->bus, dev->devfn, where, value);
+}
+static inline int 
+pci_write_config_byte(struct pci_device *dev, unsigned int where, uint8_t value)
+{
+	return pcibios_write_config_byte(dev->bus, dev->devfn, where, value);
+}
+static inline int 
+pci_read_config_word(struct pci_device *dev, unsigned int where, uint16_t *value)
+{
+	return pcibios_read_config_word(dev->bus, dev->devfn, where, value);
+}
+static inline int 
+pci_write_config_word(struct pci_device *dev, unsigned int where, uint16_t value)
+{
+	return pcibios_write_config_word(dev->bus, dev->devfn, where, value);
+}
+static inline int 
+pci_read_config_dword(struct pci_device *dev, unsigned int where, uint32_t *value)
+{
+	return pcibios_read_config_dword(dev->bus, dev->devfn, where, value);
+}
+static inline int 
+pci_write_config_dword(struct pci_device *dev, unsigned int where, uint32_t value)
+{
+	return pcibios_write_config_dword(dev->bus, dev->devfn, where, value);
+}
+
+/* Helper functions to find the size of a pci bar */
+extern unsigned long pci_bar_start(struct pci_device *dev, unsigned int bar);
+extern unsigned long pci_bar_size(struct pci_device *dev, unsigned int bar);
+/* Helper function to find pci capabilities */
+extern int pci_find_capability(struct pci_device *dev, int cap);
+struct pci_id {
+	unsigned short vendor, dev_id;
+	const char *name;
+};
+
+struct dev;
+/* Most pci drivers will use this */
+struct pci_driver {
+	int type;
+	const char *name;
+	pci_probe_t probe;
+	struct pci_id *ids;
+	int id_count;
+
+/* On a few occasions the hardware is standardized enough that
+ * we only need to know the class of the device and not the exact
+ * type to drive the device correctly.  If this is the case
+ * set a class value other than 0.
+ */
+	unsigned short class;
 };
 
-extern void	eth_pci_init(struct pci_device *);
+#define PCI_ROM(VENDOR_ID, DEVICE_ID, IMAGE, DESCRIPTION) \
+	{ VENDOR_ID, DEVICE_ID, IMAGE, }
 
-extern int pcibios_read_config_byte(unsigned int bus, unsigned int device_fn, unsigned int where, unsigned char *value);
-extern int pcibios_write_config_byte (unsigned int bus, unsigned int device_fn, unsigned int where, unsigned char value);
-extern int pcibios_read_config_word(unsigned int bus, unsigned int device_fn, unsigned int where, unsigned short *value);
-extern int pcibios_write_config_word (unsigned int bus, unsigned int device_fn, unsigned int where, unsigned short value);
-extern int pcibios_read_config_dword(unsigned int bus, unsigned int device_fn, unsigned int where, unsigned int *value);
-extern int pcibios_write_config_dword(unsigned int bus, unsigned int device_fn, unsigned int where, unsigned int value);
-void adjust_pci_device(struct pci_device *p);
 #endif	/* PCI_H */
diff -Naur grub-0.97.orig/netboot/pci_ids.h grub-0.97/netboot/pci_ids.h
--- grub-0.97.orig/netboot/pci_ids.h	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/pci_ids.h	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,1809 @@
+/*
+ *	PCI Class, Vendor and Device IDs
+ *
+ *	Please keep sorted.
+ */
+
+/* Device classes and subclasses */
+
+#define PCI_CLASS_NOT_DEFINED		0x0000
+#define PCI_CLASS_NOT_DEFINED_VGA	0x0001
+
+#define PCI_BASE_CLASS_STORAGE		0x01
+#define PCI_CLASS_STORAGE_SCSI		0x0100
+#define PCI_CLASS_STORAGE_IDE		0x0101
+#define PCI_CLASS_STORAGE_FLOPPY	0x0102
+#define PCI_CLASS_STORAGE_IPI		0x0103
+#define PCI_CLASS_STORAGE_RAID		0x0104
+#define PCI_CLASS_STORAGE_OTHER		0x0180
+
+#define PCI_BASE_CLASS_NETWORK		0x02
+#define PCI_CLASS_NETWORK_ETHERNET	0x0200
+#define PCI_CLASS_NETWORK_TOKEN_RING	0x0201
+#define PCI_CLASS_NETWORK_FDDI		0x0202
+#define PCI_CLASS_NETWORK_ATM		0x0203
+#define PCI_CLASS_NETWORK_OTHER		0x0280
+
+#define PCI_BASE_CLASS_DISPLAY		0x03
+#define PCI_CLASS_DISPLAY_VGA		0x0300
+#define PCI_CLASS_DISPLAY_XGA		0x0301
+#define PCI_CLASS_DISPLAY_3D		0x0302
+#define PCI_CLASS_DISPLAY_OTHER		0x0380
+
+#define PCI_BASE_CLASS_MULTIMEDIA	0x04
+#define PCI_CLASS_MULTIMEDIA_VIDEO	0x0400
+#define PCI_CLASS_MULTIMEDIA_AUDIO	0x0401
+#define PCI_CLASS_MULTIMEDIA_PHONE	0x0402
+#define PCI_CLASS_MULTIMEDIA_OTHER	0x0480
+
+#define PCI_BASE_CLASS_MEMORY		0x05
+#define PCI_CLASS_MEMORY_RAM		0x0500
+#define PCI_CLASS_MEMORY_FLASH		0x0501
+#define PCI_CLASS_MEMORY_OTHER		0x0580
+
+#define PCI_BASE_CLASS_BRIDGE		0x06
+#define PCI_CLASS_BRIDGE_HOST		0x0600
+#define PCI_CLASS_BRIDGE_ISA		0x0601
+#define PCI_CLASS_BRIDGE_EISA		0x0602
+#define PCI_CLASS_BRIDGE_MC		0x0603
+#define PCI_CLASS_BRIDGE_PCI		0x0604
+#define PCI_CLASS_BRIDGE_PCMCIA		0x0605
+#define PCI_CLASS_BRIDGE_NUBUS		0x0606
+#define PCI_CLASS_BRIDGE_CARDBUS	0x0607
+#define PCI_CLASS_BRIDGE_RACEWAY	0x0608
+#define PCI_CLASS_BRIDGE_OTHER		0x0680
+
+#define PCI_BASE_CLASS_COMMUNICATION	0x07
+#define PCI_CLASS_COMMUNICATION_SERIAL	0x0700
+#define PCI_CLASS_COMMUNICATION_PARALLEL 0x0701
+#define PCI_CLASS_COMMUNICATION_MULTISERIAL 0x0702
+#define PCI_CLASS_COMMUNICATION_MODEM	0x0703
+#define PCI_CLASS_COMMUNICATION_OTHER	0x0780
+
+#define PCI_BASE_CLASS_SYSTEM		0x08
+#define PCI_CLASS_SYSTEM_PIC		0x0800
+#define PCI_CLASS_SYSTEM_DMA		0x0801
+#define PCI_CLASS_SYSTEM_TIMER		0x0802
+#define PCI_CLASS_SYSTEM_RTC		0x0803
+#define PCI_CLASS_SYSTEM_PCI_HOTPLUG	0x0804
+#define PCI_CLASS_SYSTEM_OTHER		0x0880
+
+#define PCI_BASE_CLASS_INPUT		0x09
+#define PCI_CLASS_INPUT_KEYBOARD	0x0900
+#define PCI_CLASS_INPUT_PEN		0x0901
+#define PCI_CLASS_INPUT_MOUSE		0x0902
+#define PCI_CLASS_INPUT_SCANNER		0x0903
+#define PCI_CLASS_INPUT_GAMEPORT	0x0904
+#define PCI_CLASS_INPUT_OTHER		0x0980
+
+#define PCI_BASE_CLASS_DOCKING		0x0a
+#define PCI_CLASS_DOCKING_GENERIC	0x0a00
+#define PCI_CLASS_DOCKING_OTHER		0x0a80
+
+#define PCI_BASE_CLASS_PROCESSOR	0x0b
+#define PCI_CLASS_PROCESSOR_386		0x0b00
+#define PCI_CLASS_PROCESSOR_486		0x0b01
+#define PCI_CLASS_PROCESSOR_PENTIUM	0x0b02
+#define PCI_CLASS_PROCESSOR_ALPHA	0x0b10
+#define PCI_CLASS_PROCESSOR_POWERPC	0x0b20
+#define PCI_CLASS_PROCESSOR_MIPS	0x0b30
+#define PCI_CLASS_PROCESSOR_CO		0x0b40
+
+#define PCI_BASE_CLASS_SERIAL		0x0c
+#define PCI_CLASS_SERIAL_FIREWIRE	0x0c00
+#define PCI_CLASS_SERIAL_ACCESS		0x0c01
+#define PCI_CLASS_SERIAL_SSA		0x0c02
+#define PCI_CLASS_SERIAL_USB		0x0c03
+#define PCI_CLASS_SERIAL_FIBER		0x0c04
+#define PCI_CLASS_SERIAL_SMBUS		0x0c05
+
+#define PCI_BASE_CLASS_INTELLIGENT	0x0e
+#define PCI_CLASS_INTELLIGENT_I2O	0x0e00
+
+#define PCI_BASE_CLASS_SATELLITE	0x0f
+#define PCI_CLASS_SATELLITE_TV		0x0f00
+#define PCI_CLASS_SATELLITE_AUDIO	0x0f01
+#define PCI_CLASS_SATELLITE_VOICE	0x0f03
+#define PCI_CLASS_SATELLITE_DATA	0x0f04
+
+#define PCI_BASE_CLASS_CRYPT		0x10
+#define PCI_CLASS_CRYPT_NETWORK		0x1000
+#define PCI_CLASS_CRYPT_ENTERTAINMENT	0x1001
+#define PCI_CLASS_CRYPT_OTHER		0x1080
+
+#define PCI_BASE_CLASS_SIGNAL_PROCESSING 0x11
+#define PCI_CLASS_SP_DPIO		0x1100
+#define PCI_CLASS_SP_OTHER		0x1180
+
+#define PCI_CLASS_OTHERS		0xff
+
+/* Vendors and devices.  Sort key: vendor first, device next. */
+
+#define PCI_VENDOR_ID_DYNALINK		0x0675
+#define PCI_DEVICE_ID_DYNALINK_IS64PH	0x1702
+
+#define PCI_VENDOR_ID_BERKOM			0x0871
+#define PCI_DEVICE_ID_BERKOM_A1T		0xffa1
+#define PCI_DEVICE_ID_BERKOM_T_CONCEPT		0xffa2
+#define PCI_DEVICE_ID_BERKOM_A4T		0xffa4
+#define PCI_DEVICE_ID_BERKOM_SCITEL_QUADRO	0xffa8
+
+#define PCI_VENDOR_ID_COMPAQ		0x0e11
+#define PCI_DEVICE_ID_COMPAQ_TOKENRING	0x0508
+#define PCI_DEVICE_ID_COMPAQ_1280	0x3033
+#define PCI_DEVICE_ID_COMPAQ_TRIFLEX	0x4000
+#define PCI_DEVICE_ID_COMPAQ_6010	0x6010
+#define PCI_DEVICE_ID_COMPAQ_SMART2P	0xae10
+#define PCI_DEVICE_ID_COMPAQ_NETEL100	0xae32
+#define PCI_DEVICE_ID_COMPAQ_NETEL10	0xae34
+#define PCI_DEVICE_ID_COMPAQ_NETFLEX3I	0xae35
+#define PCI_DEVICE_ID_COMPAQ_NETEL100D	0xae40
+#define PCI_DEVICE_ID_COMPAQ_NETEL100PI	0xae43
+#define PCI_DEVICE_ID_COMPAQ_NETEL100I	0xb011
+#define PCI_DEVICE_ID_COMPAQ_CISS	0xb060
+#define PCI_DEVICE_ID_COMPAQ_CISSB	0xb178
+#define PCI_DEVICE_ID_COMPAQ_THUNDER	0xf130
+#define PCI_DEVICE_ID_COMPAQ_NETFLEX3B	0xf150
+
+#define PCI_VENDOR_ID_NCR		0x1000
+#define PCI_VENDOR_ID_LSI_LOGIC		0x1000
+#define PCI_DEVICE_ID_NCR_53C810	0x0001
+#define PCI_DEVICE_ID_NCR_53C820	0x0002
+#define PCI_DEVICE_ID_NCR_53C825	0x0003
+#define PCI_DEVICE_ID_NCR_53C815	0x0004
+#define PCI_DEVICE_ID_LSI_53C810AP	0x0005
+#define PCI_DEVICE_ID_NCR_53C860	0x0006
+#define PCI_DEVICE_ID_LSI_53C1510	0x000a
+#define PCI_DEVICE_ID_NCR_53C896	0x000b
+#define PCI_DEVICE_ID_NCR_53C895	0x000c
+#define PCI_DEVICE_ID_NCR_53C885	0x000d
+#define PCI_DEVICE_ID_NCR_53C875	0x000f
+#define PCI_DEVICE_ID_NCR_53C1510	0x0010
+#define PCI_DEVICE_ID_LSI_53C895A	0x0012
+#define PCI_DEVICE_ID_LSI_53C875A	0x0013
+#define PCI_DEVICE_ID_LSI_53C1010_33	0x0020
+#define PCI_DEVICE_ID_LSI_53C1010_66	0x0021
+#define PCI_DEVICE_ID_LSI_53C1030	0x0030
+#define PCI_DEVICE_ID_LSI_53C1035	0x0040
+#define PCI_DEVICE_ID_NCR_53C875J	0x008f
+#define PCI_DEVICE_ID_LSI_FC909		0x0621
+#define PCI_DEVICE_ID_LSI_FC929		0x0622
+#define PCI_DEVICE_ID_LSI_FC929_LAN	0x0623
+#define PCI_DEVICE_ID_LSI_FC919		0x0624
+#define PCI_DEVICE_ID_LSI_FC919_LAN	0x0625
+#define PCI_DEVICE_ID_NCR_YELLOWFIN	0x0701
+#define PCI_DEVICE_ID_LSI_61C102	0x0901
+#define PCI_DEVICE_ID_LSI_63C815	0x1000
+
+#define PCI_VENDOR_ID_ATI		0x1002
+/* Mach64 */
+#define PCI_DEVICE_ID_ATI_68800		0x4158
+#define PCI_DEVICE_ID_ATI_215CT222	0x4354
+#define PCI_DEVICE_ID_ATI_210888CX	0x4358
+#define PCI_DEVICE_ID_ATI_215ET222	0x4554
+/* Mach64 / Rage */
+#define PCI_DEVICE_ID_ATI_215GB		0x4742
+#define PCI_DEVICE_ID_ATI_215GD		0x4744
+#define PCI_DEVICE_ID_ATI_215GI		0x4749
+#define PCI_DEVICE_ID_ATI_215GP		0x4750
+#define PCI_DEVICE_ID_ATI_215GQ		0x4751
+#define PCI_DEVICE_ID_ATI_215XL		0x4752
+#define PCI_DEVICE_ID_ATI_215GT		0x4754
+#define PCI_DEVICE_ID_ATI_215GTB	0x4755
+#define PCI_DEVICE_ID_ATI_215_IV	0x4756
+#define PCI_DEVICE_ID_ATI_215_IW	0x4757
+#define PCI_DEVICE_ID_ATI_215_IZ	0x475A
+#define PCI_DEVICE_ID_ATI_210888GX	0x4758
+#define PCI_DEVICE_ID_ATI_215_LB	0x4c42
+#define PCI_DEVICE_ID_ATI_215_LD	0x4c44
+#define PCI_DEVICE_ID_ATI_215_LG	0x4c47
+#define PCI_DEVICE_ID_ATI_215_LI	0x4c49
+#define PCI_DEVICE_ID_ATI_215_LM	0x4c4D
+#define PCI_DEVICE_ID_ATI_215_LN	0x4c4E
+#define PCI_DEVICE_ID_ATI_215_LR	0x4c52
+#define PCI_DEVICE_ID_ATI_215_LS	0x4c53
+#define PCI_DEVICE_ID_ATI_264_LT	0x4c54
+/* Mach64 VT */
+#define PCI_DEVICE_ID_ATI_264VT		0x5654
+#define PCI_DEVICE_ID_ATI_264VU		0x5655
+#define PCI_DEVICE_ID_ATI_264VV		0x5656
+/* Rage128 Pro GL */
+#define PCI_DEVICE_ID_ATI_Rage128_PA	0x5041
+#define PCI_DEVICE_ID_ATI_Rage128_PB	0x5042
+#define PCI_DEVICE_ID_ATI_Rage128_PC	0x5043
+#define PCI_DEVICE_ID_ATI_Rage128_PD	0x5044
+#define PCI_DEVICE_ID_ATI_Rage128_PE	0x5045
+#define PCI_DEVICE_ID_ATI_RAGE128_PF	0x5046
+/* Rage128 Pro VR */
+#define PCI_DEVICE_ID_ATI_RAGE128_PG	0x5047
+#define PCI_DEVICE_ID_ATI_RAGE128_PH	0x5048
+#define PCI_DEVICE_ID_ATI_RAGE128_PI	0x5049
+#define PCI_DEVICE_ID_ATI_RAGE128_PJ	0x504A
+#define PCI_DEVICE_ID_ATI_RAGE128_PK	0x504B
+#define PCI_DEVICE_ID_ATI_RAGE128_PL	0x504C
+#define PCI_DEVICE_ID_ATI_RAGE128_PM	0x504D
+#define PCI_DEVICE_ID_ATI_RAGE128_PN	0x504E
+#define PCI_DEVICE_ID_ATI_RAGE128_PO	0x504F
+#define PCI_DEVICE_ID_ATI_RAGE128_PP	0x5050
+#define PCI_DEVICE_ID_ATI_RAGE128_PQ	0x5051
+#define PCI_DEVICE_ID_ATI_RAGE128_PR	0x5052
+#define PCI_DEVICE_ID_ATI_RAGE128_TR	0x5452
+#define PCI_DEVICE_ID_ATI_RAGE128_PS	0x5053
+#define PCI_DEVICE_ID_ATI_RAGE128_PT	0x5054
+#define PCI_DEVICE_ID_ATI_RAGE128_PU	0x5055
+#define PCI_DEVICE_ID_ATI_RAGE128_PV	0x5056
+#define PCI_DEVICE_ID_ATI_RAGE128_PW	0x5057
+#define PCI_DEVICE_ID_ATI_RAGE128_PX	0x5058
+/* Rage128 GL */
+#define PCI_DEVICE_ID_ATI_RAGE128_RE	0x5245
+#define PCI_DEVICE_ID_ATI_RAGE128_RF	0x5246
+#define PCI_DEVICE_ID_ATI_RAGE128_RG	0x534b
+#define PCI_DEVICE_ID_ATI_RAGE128_RH	0x534c
+#define PCI_DEVICE_ID_ATI_RAGE128_RI	0x534d
+/* Rage128 VR */
+#define PCI_DEVICE_ID_ATI_RAGE128_RK	0x524b
+#define PCI_DEVICE_ID_ATI_RAGE128_RL	0x524c
+#define PCI_DEVICE_ID_ATI_RAGE128_RM	0x5345
+#define PCI_DEVICE_ID_ATI_RAGE128_RN	0x5346
+#define PCI_DEVICE_ID_ATI_RAGE128_RO	0x5347
+/* Rage128 M3 */
+#define PCI_DEVICE_ID_ATI_RAGE128_LE	0x4c45
+#define PCI_DEVICE_ID_ATI_RAGE128_LF	0x4c46
+/* Rage128 Pro Ultra */
+#define PCI_DEVICE_ID_ATI_RAGE128_U1	0x5446
+#define PCI_DEVICE_ID_ATI_RAGE128_U2	0x544C
+#define PCI_DEVICE_ID_ATI_RAGE128_U3	0x5452
+/* Radeon M4 */
+#define PCI_DEVICE_ID_ATI_RADEON_LE	0x4d45
+#define PCI_DEVICE_ID_ATI_RADEON_LF	0x4d46
+/* Radeon NV-100 */
+#define PCI_DEVICE_ID_ATI_RADEON_N1	0x5159
+#define PCI_DEVICE_ID_ATI_RADEON_N2	0x515a
+/* Radeon */
+#define PCI_DEVICE_ID_ATI_RADEON_RA	0x5144
+#define PCI_DEVICE_ID_ATI_RADEON_RB	0x5145
+#define PCI_DEVICE_ID_ATI_RADEON_RC	0x5146
+#define PCI_DEVICE_ID_ATI_RADEON_RD	0x5147
+
+#define PCI_VENDOR_ID_VLSI		0x1004
+#define PCI_DEVICE_ID_VLSI_82C592	0x0005
+#define PCI_DEVICE_ID_VLSI_82C593	0x0006
+#define PCI_DEVICE_ID_VLSI_82C594	0x0007
+#define PCI_DEVICE_ID_VLSI_82C597	0x0009
+#define PCI_DEVICE_ID_VLSI_82C541	0x000c
+#define PCI_DEVICE_ID_VLSI_82C543	0x000d
+#define PCI_DEVICE_ID_VLSI_82C532	0x0101
+#define PCI_DEVICE_ID_VLSI_82C534	0x0102
+#define PCI_DEVICE_ID_VLSI_82C535	0x0104
+#define PCI_DEVICE_ID_VLSI_82C147	0x0105
+#define PCI_DEVICE_ID_VLSI_VAS96011	0x0702
+
+#define PCI_VENDOR_ID_ADL		0x1005
+#define PCI_DEVICE_ID_ADL_2301		0x2301
+
+#define PCI_VENDOR_ID_NS		0x100b
+#define PCI_DEVICE_ID_NS_87415		0x0002
+#define PCI_DEVICE_ID_NS_87560_LIO	0x000e
+#define PCI_DEVICE_ID_NS_87560_USB	0x0012
+#define PCI_DEVICE_ID_NS_83815		0x0020
+#define	PCI_DEVICE_ID_DP83815		0x0020
+#define PCI_DEVICE_ID_NS_83820		0x0022
+#define PCI_DEVICE_ID_NS_87410		0xd001
+
+#define PCI_VENDOR_ID_TSENG		0x100c
+#define PCI_DEVICE_ID_TSENG_W32P_2	0x3202
+#define PCI_DEVICE_ID_TSENG_W32P_b	0x3205
+#define PCI_DEVICE_ID_TSENG_W32P_c	0x3206
+#define PCI_DEVICE_ID_TSENG_W32P_d	0x3207
+#define PCI_DEVICE_ID_TSENG_ET6000	0x3208
+
+#define PCI_VENDOR_ID_WEITEK		0x100e
+#define PCI_DEVICE_ID_WEITEK_P9000	0x9001
+#define PCI_DEVICE_ID_WEITEK_P9100	0x9100
+
+#define PCI_VENDOR_ID_DEC		0x1011
+#define PCI_DEVICE_ID_DEC_BRD		0x0001
+#define PCI_DEVICE_ID_DEC_TULIP		0x0002
+#define PCI_DEVICE_ID_DEC_TGA		0x0004
+#define PCI_DEVICE_ID_DEC_TULIP_FAST	0x0009
+#define PCI_DEVICE_ID_DEC_TGA2		0x000D
+#define PCI_DEVICE_ID_DEC_FDDI		0x000F
+#define PCI_DEVICE_ID_DEC_TULIP_PLUS	0x0014
+#define PCI_DEVICE_ID_DEC_21142		0x0019
+#define PCI_DEVICE_ID_DEC_21052		0x0021
+#define PCI_DEVICE_ID_DEC_21150		0x0022
+#define PCI_DEVICE_ID_DEC_21152		0x0024
+#define PCI_DEVICE_ID_DEC_21153		0x0025
+#define PCI_DEVICE_ID_DEC_21154		0x0026
+#define PCI_DEVICE_ID_DEC_21285		0x1065
+#define PCI_DEVICE_ID_COMPAQ_42XX	0x0046
+
+#define PCI_VENDOR_ID_CIRRUS		0x1013
+#define PCI_DEVICE_ID_CIRRUS_7548	0x0038
+#define PCI_DEVICE_ID_CIRRUS_5430	0x00a0
+#define PCI_DEVICE_ID_CIRRUS_5434_4	0x00a4
+#define PCI_DEVICE_ID_CIRRUS_5434_8	0x00a8
+#define PCI_DEVICE_ID_CIRRUS_5436	0x00ac
+#define PCI_DEVICE_ID_CIRRUS_5446	0x00b8
+#define PCI_DEVICE_ID_CIRRUS_5480	0x00bc
+#define PCI_DEVICE_ID_CIRRUS_5462	0x00d0
+#define PCI_DEVICE_ID_CIRRUS_5464	0x00d4
+#define PCI_DEVICE_ID_CIRRUS_5465	0x00d6
+#define PCI_DEVICE_ID_CIRRUS_6729	0x1100
+#define PCI_DEVICE_ID_CIRRUS_6832	0x1110
+#define PCI_DEVICE_ID_CIRRUS_7542	0x1200
+#define PCI_DEVICE_ID_CIRRUS_7543	0x1202
+#define PCI_DEVICE_ID_CIRRUS_7541	0x1204
+
+#define PCI_VENDOR_ID_IBM		0x1014
+#define PCI_DEVICE_ID_IBM_FIRE_CORAL	0x000a
+#define PCI_DEVICE_ID_IBM_TR		0x0018
+#define PCI_DEVICE_ID_IBM_82G2675	0x001d
+#define PCI_DEVICE_ID_IBM_MCA		0x0020
+#define PCI_DEVICE_ID_IBM_82351		0x0022
+#define PCI_DEVICE_ID_IBM_PYTHON	0x002d
+#define PCI_DEVICE_ID_IBM_SERVERAID	0x002e
+#define PCI_DEVICE_ID_IBM_TR_WAKE	0x003e
+#define PCI_DEVICE_ID_IBM_MPIC		0x0046
+#define PCI_DEVICE_ID_IBM_3780IDSP	0x007d
+#define PCI_DEVICE_ID_IBM_CHUKAR	0x0096
+#define	PCI_DEVICE_ID_IBM_405GP		0x0156
+#define PCI_DEVICE_ID_IBM_SERVERAIDI960	0x01bd
+#define PCI_DEVICE_ID_IBM_MPIC_2	0xffff
+
+#define PCI_VENDOR_ID_COMPEX2		0x101a // pci.ids says "AT&T GIS (NCR)"
+#define PCI_DEVICE_ID_COMPEX2_100VG	0x0005
+
+#define PCI_VENDOR_ID_WD		0x101c
+#define PCI_DEVICE_ID_WD_7197		0x3296
+
+#define PCI_VENDOR_ID_AMI		0x101e
+#define PCI_DEVICE_ID_AMI_MEGARAID3	0x1960
+#define PCI_DEVICE_ID_AMI_MEGARAID	0x9010
+#define PCI_DEVICE_ID_AMI_MEGARAID2	0x9060
+
+#define PCI_VENDOR_ID_AMD		0x1022
+
+#define PCI_DEVICE_ID_AMD_LANCE		0x2000
+#define PCI_DEVICE_ID_AMD_LANCE_HOME	0x2001
+#define PCI_DEVICE_ID_AMD_HOMEPNA	0x2001
+#define PCI_DEVICE_ID_AMD_SCSI		0x2020
+#define PCI_DEVICE_ID_AMD_FE_GATE_7006	0x7006
+#define PCI_DEVICE_ID_AMD_FE_GATE_7007	0x7007
+#define PCI_DEVICE_ID_AMD_FE_GATE_700C	0x700C
+#define PCI_DEVIDE_ID_AMD_FE_GATE_700D	0x700D
+#define PCI_DEVICE_ID_AMD_FE_GATE_700E	0x700E
+#define PCI_DEVICE_ID_AMD_FE_GATE_700F	0x700F
+#define PCI_DEVICE_ID_AMD_COBRA_7400	0x7400
+#define PCI_DEVICE_ID_AMD_COBRA_7401	0x7401
+#define PCI_DEVICE_ID_AMD_COBRA_7403	0x7403
+#define PCI_DEVICE_ID_AMD_COBRA_7404	0x7404
+#define PCI_DEVICE_ID_AMD_VIPER_7408	0x7408
+#define PCI_DEVICE_ID_AMD_VIPER_7409	0x7409
+#define PCI_DEVICE_ID_AMD_VIPER_740B	0x740B
+#define PCI_DEVICE_ID_AMD_VIPER_740C	0x740C
+#define PCI_DEVICE_ID_AMD_VIPER_7410	0x7410
+#define PCI_DEVICE_ID_AMD_VIPER_7411	0x7411
+#define PCI_DEVICE_ID_AMD_VIPER_7413	0x7413
+#define PCI_DEVICE_ID_AMD_VIPER_7414	0x7414
+#define PCI_DEVICE_ID_AMD_VIPER_7440	0x7440
+#define PCI_DEVICE_ID_AMD_VIPER_7441	0x7441
+#define PCI_DEVICE_ID_AMD_VIPER_7443	0x7443
+#define PCI_DEVICE_ID_AMD_VIPER_7448	0x7448
+#define PCI_DEVICE_ID_AMD_VIPER_7449	0x7449
+
+#define PCI_VENDOR_ID_TRIDENT		0x1023
+#define PCI_DEVICE_ID_TRIDENT_4DWAVE_DX	0x2000
+#define PCI_DEVICE_ID_TRIDENT_4DWAVE_NX	0x2001
+#define PCI_DEVICE_ID_TRIDENT_9320	0x9320
+#define PCI_DEVICE_ID_TRIDENT_9388	0x9388
+#define PCI_DEVICE_ID_TRIDENT_9397	0x9397
+#define PCI_DEVICE_ID_TRIDENT_939A	0x939A
+#define PCI_DEVICE_ID_TRIDENT_9520	0x9520
+#define PCI_DEVICE_ID_TRIDENT_9525	0x9525
+#define PCI_DEVICE_ID_TRIDENT_9420	0x9420
+#define PCI_DEVICE_ID_TRIDENT_9440	0x9440
+#define PCI_DEVICE_ID_TRIDENT_9660	0x9660
+#define PCI_DEVICE_ID_TRIDENT_9750	0x9750
+#define PCI_DEVICE_ID_TRIDENT_9850	0x9850
+#define PCI_DEVICE_ID_TRIDENT_9880	0x9880
+#define PCI_DEVICE_ID_TRIDENT_8400	0x8400
+#define PCI_DEVICE_ID_TRIDENT_8420	0x8420
+#define PCI_DEVICE_ID_TRIDENT_8500	0x8500
+
+#define PCI_VENDOR_ID_AI		0x1025
+#define PCI_DEVICE_ID_AI_M1435		0x1435
+
+#define PCI_VENDOR_ID_DELL              0x1028
+
+#define PCI_VENDOR_ID_MATROX		0x102B
+#define PCI_DEVICE_ID_MATROX_MGA_2	0x0518
+#define PCI_DEVICE_ID_MATROX_MIL	0x0519
+#define PCI_DEVICE_ID_MATROX_MYS	0x051A
+#define PCI_DEVICE_ID_MATROX_MIL_2	0x051b
+#define PCI_DEVICE_ID_MATROX_MIL_2_AGP	0x051f
+#define PCI_DEVICE_ID_MATROX_MGA_IMP	0x0d10
+#define PCI_DEVICE_ID_MATROX_G100_MM	0x1000
+#define PCI_DEVICE_ID_MATROX_G100_AGP	0x1001
+#define PCI_DEVICE_ID_MATROX_G200_PCI	0x0520
+#define PCI_DEVICE_ID_MATROX_G200_AGP	0x0521
+#define	PCI_DEVICE_ID_MATROX_G400	0x0525
+#define PCI_DEVICE_ID_MATROX_G550	0x2527
+#define PCI_DEVICE_ID_MATROX_VIA	0x4536
+
+#define PCI_VENDOR_ID_CT		0x102c
+#define PCI_DEVICE_ID_CT_65545		0x00d8
+#define PCI_DEVICE_ID_CT_65548		0x00dc
+#define PCI_DEVICE_ID_CT_65550		0x00e0
+#define PCI_DEVICE_ID_CT_65554		0x00e4
+#define PCI_DEVICE_ID_CT_65555		0x00e5
+
+#define PCI_VENDOR_ID_MIRO		0x1031
+#define PCI_DEVICE_ID_MIRO_36050	0x5601
+
+#define PCI_VENDOR_ID_NEC		0x1033
+#define PCI_DEVICE_ID_NEC_PCX2		0x0046
+#define PCI_DEVICE_ID_NEC_NILE4		0x005a
+#define PCI_DEVICE_ID_NEC_VRC5476       0x009b
+
+#define PCI_VENDOR_ID_FD		0x1036
+#define PCI_DEVICE_ID_FD_36C70		0x0000
+
+#define PCI_VENDOR_ID_SIS         	0x1039
+#define PCI_VENDOR_ID_SI		0x1039
+#define PCI_DEVICE_ID_SI_5591_AGP	0x0001
+#define PCI_DEVICE_ID_SI_6202		0x0002
+#define PCI_DEVICE_ID_SI_503		0x0008
+#define PCI_DEVICE_ID_SI_ACPI		0x0009
+#define PCI_DEVICE_ID_SI_5597_VGA	0x0200
+#define PCI_DEVICE_ID_SI_6205		0x0205
+#define PCI_DEVICE_ID_SI_501		0x0406
+#define PCI_DEVICE_ID_SI_496		0x0496
+#define PCI_DEVICE_ID_SI_300		0x0300
+#define PCI_DEVICE_ID_SI_315H		0x0310
+#define PCI_DEVICE_ID_SI_315		0x0315
+#define PCI_DEVICE_ID_SI_315PRO		0x0325
+#define PCI_DEVICE_ID_SI_530		0x0530
+#define PCI_DEVICE_ID_SI_540		0x0540
+#define PCI_DEVICE_ID_SI_550		0x0550
+#define PCI_DEVICE_ID_SI_601		0x0601
+#define PCI_DEVICE_ID_SI_620		0x0620
+#define PCI_DEVICE_ID_SI_630		0x0630
+#define PCI_DEVICE_ID_SI_635		0x0635
+#define PCI_DEVICE_ID_SI_640		0x0640
+#define PCI_DEVICE_ID_SI_645		0x0645
+#define PCI_DEVICE_ID_SI_650		0x0650
+#define PCI_DEVICE_ID_SI_730		0x0730
+#define PCI_DEVICE_ID_SI_735		0x0735
+#define PCI_DEVICE_ID_SI_740		0x0740
+#define PCI_DEVICE_ID_SI_745		0x0745
+#define PCI_DEVICE_ID_SI_750		0x0750
+#define PCI_DEVICE_ID_SI_900		0x0900
+#define PCI_DEVICE_ID_SIS900		0x0900
+#define PCI_DEVICE_ID_SI_5107		0x5107
+#define PCI_DEVICE_ID_SI_5300		0x5300
+#define PCI_DEVICE_ID_SI_540_VGA	0x5300
+#define PCI_DEVICE_ID_SI_550_VGA	0x5315
+#define PCI_DEVICE_ID_SI_5511		0x5511
+#define PCI_DEVICE_ID_SI_5513		0x5513
+#define PCI_DEVICE_ID_SI_5571		0x5571
+#define PCI_DEVICE_ID_SI_5591		0x5591
+#define PCI_DEVICE_ID_SI_5597		0x5597
+#define PCI_DEVICE_ID_SI_5598		0x5598
+#define PCI_DEVICE_ID_SI_5600		0x5600
+#define PCI_DEVICE_ID_SI_6300		0x6300
+#define PCI_DEVICE_ID_SI_630_VGA	0x6300
+#define PCI_DEVICE_ID_SI_6306		0x6306
+#define PCI_DEVICE_ID_SI_6326		0x6326
+#define PCI_DEVICE_ID_SI_7001		0x7001
+#define PCI_DEVICE_ID_SI_7016		0x7016
+#define PCI_DEVICE_ID_SIS7016    	0x7016  
+#define PCI_DEVICE_ID_SI_730_VGA	0x7300
+
+#define PCI_VENDOR_ID_HP		0x103c
+#define PCI_DEVICE_ID_HP_DONNER_GFX	0x1008
+#define PCI_DEVICE_ID_HP_TACHYON	0x1028
+#define PCI_DEVICE_ID_HP_TACHLITE	0x1029
+#define PCI_DEVICE_ID_HP_J2585A		0x1030
+#define PCI_DEVICE_ID_HP_J2585B		0x1031
+#define PCI_DEVICE_ID_HP_SAS		0x1048
+#define PCI_DEVICE_ID_HP_DIVA1		0x1049
+#define PCI_DEVICE_ID_HP_DIVA2		0x104A
+#define PCI_DEVICE_ID_HP_SP2_0		0x104B
+
+#define PCI_VENDOR_ID_PCTECH		0x1042
+#define PCI_DEVICE_ID_PCTECH_RZ1000	0x1000
+#define PCI_DEVICE_ID_PCTECH_RZ1001	0x1001
+#define PCI_DEVICE_ID_PCTECH_SAMURAI_0	0x3000
+#define PCI_DEVICE_ID_PCTECH_SAMURAI_1	0x3010
+#define PCI_DEVICE_ID_PCTECH_SAMURAI_IDE 0x3020
+
+#define PCI_VENDOR_ID_ASUSTEK		0x1043
+#define PCI_DEVICE_ID_ASUSTEK_0675	0x0675
+
+#define PCI_VENDOR_ID_DPT		0x1044
+#define PCI_DEVICE_ID_DPT		0xa400
+
+#define PCI_VENDOR_ID_OPTI		0x1045
+#define PCI_DEVICE_ID_OPTI_92C178	0xc178
+#define PCI_DEVICE_ID_OPTI_82C557	0xc557
+#define PCI_DEVICE_ID_OPTI_82C558	0xc558
+#define PCI_DEVICE_ID_OPTI_82C621	0xc621
+#define PCI_DEVICE_ID_OPTI_82C700	0xc700
+#define PCI_DEVICE_ID_OPTI_82C701	0xc701
+#define PCI_DEVICE_ID_OPTI_82C814	0xc814
+#define PCI_DEVICE_ID_OPTI_82C822	0xc822
+#define PCI_DEVICE_ID_OPTI_82C861	0xc861
+#define PCI_DEVICE_ID_OPTI_82C825	0xd568
+
+#define PCI_VENDOR_ID_ELSA		0x1048
+#define PCI_DEVICE_ID_ELSA_MICROLINK	0x1000
+#define PCI_DEVICE_ID_ELSA_QS3000	0x3000
+
+#define PCI_VENDOR_ID_ELSA		0x1048
+#define PCI_DEVICE_ID_ELSA_MICROLINK	0x1000
+#define PCI_DEVICE_ID_ELSA_QS3000	0x3000
+
+#define PCI_VENDOR_ID_SGS		0x104a
+#define PCI_DEVICE_ID_SGS_2000		0x0008
+#define PCI_DEVICE_ID_SGS_1764		0x0009
+
+#define PCI_VENDOR_ID_BUSLOGIC		      0x104B
+#define PCI_DEVICE_ID_BUSLOGIC_MULTIMASTER_NC 0x0140
+#define PCI_DEVICE_ID_BUSLOGIC_MULTIMASTER    0x1040
+#define PCI_DEVICE_ID_BUSLOGIC_FLASHPOINT     0x8130
+
+#define PCI_VENDOR_ID_TI		0x104c
+#define PCI_DEVICE_ID_TI_TVP4010	0x3d04
+#define PCI_DEVICE_ID_TI_TVP4020	0x3d07
+#define PCI_DEVICE_ID_TI_1130		0xac12
+#define PCI_DEVICE_ID_TI_1031		0xac13
+#define PCI_DEVICE_ID_TI_1131		0xac15
+#define PCI_DEVICE_ID_TI_1250		0xac16
+#define PCI_DEVICE_ID_TI_1220		0xac17
+#define PCI_DEVICE_ID_TI_1221		0xac19
+#define PCI_DEVICE_ID_TI_1210		0xac1a
+#define PCI_DEVICE_ID_TI_1410		0xac50
+#define PCI_DEVICE_ID_TI_1450		0xac1b
+#define PCI_DEVICE_ID_TI_1225		0xac1c
+#define PCI_DEVICE_ID_TI_1251A		0xac1d
+#define PCI_DEVICE_ID_TI_1211		0xac1e
+#define PCI_DEVICE_ID_TI_1251B		0xac1f
+#define PCI_DEVICE_ID_TI_4410		0xac41
+#define PCI_DEVICE_ID_TI_4451		0xac42
+#define PCI_DEVICE_ID_TI_1420		0xac51
+
+#define PCI_VENDOR_ID_SONY		0x104d
+#define PCI_DEVICE_ID_SONY_CXD3222	0x8039
+
+#define PCI_VENDOR_ID_OAK		0x104e
+#define PCI_DEVICE_ID_OAK_OTI107	0x0107
+
+/* Winbond have two vendor IDs! See 0x10ad as well */
+#define PCI_VENDOR_ID_WINBOND2		0x1050
+#define PCI_DEVICE_ID_WINBOND2_89C840   0x0840
+#define PCI_DEVICE_ID_WINBOND2_89C940	0x0940
+#define PCI_DEVICE_ID_WINBOND2_89C940F	0x5a5a
+#define PCI_DEVICE_ID_WINBOND2_6692	0x6692
+
+#define PCI_VENDOR_ID_ANIGMA		0x1051
+#define PCI_DEVICE_ID_ANIGMA_MC145575	0x0100
+  
+#define PCI_VENDOR_ID_EFAR		0x1055
+#define PCI_DEVICE_ID_EFAR_SLC90E66_1	0x9130
+#define PCI_DEVICE_ID_EFAR_SLC90E66_0	0x9460
+#define PCI_DEVICE_ID_EFAR_SLC90E66_2	0x9462
+#define PCI_DEVICE_ID_EFAR_SLC90E66_3	0x9463
+
+#define PCI_VENDOR_ID_MOTOROLA		0x1057
+#define PCI_VENDOR_ID_MOTOROLA_OOPS	0x1507
+#define PCI_DEVICE_ID_MOTOROLA_MPC105	0x0001
+#define PCI_DEVICE_ID_MOTOROLA_MPC106	0x0002
+#define PCI_DEVICE_ID_MOTOROLA_RAVEN	0x4801
+#define PCI_DEVICE_ID_MOTOROLA_FALCON	0x4802
+#define PCI_DEVICE_ID_MOTOROLA_CPX8216	0x4806
+
+#define PCI_VENDOR_ID_PROMISE		0x105a
+#define PCI_DEVICE_ID_PROMISE_20265	0x0d30
+#define PCI_DEVICE_ID_PROMISE_20267	0x4d30
+#define PCI_DEVICE_ID_PROMISE_20246	0x4d33
+#define PCI_DEVICE_ID_PROMISE_20262	0x4d38
+#define PCI_DEVICE_ID_PROMISE_20268	0x4d68
+#define PCI_DEVICE_ID_PROMISE_20268R	0x6268
+#define PCI_DEVICE_ID_PROMISE_20269	0x4d69
+#define PCI_DEVICE_ID_PROMISE_20275	0x1275
+#define PCI_DEVICE_ID_PROMISE_5300	0x5300
+
+#define PCI_VENDOR_ID_N9		0x105d
+#define PCI_DEVICE_ID_N9_I128		0x2309
+#define PCI_DEVICE_ID_N9_I128_2		0x2339
+#define PCI_DEVICE_ID_N9_I128_T2R	0x493d
+
+#define PCI_VENDOR_ID_UMC		0x1060
+#define PCI_DEVICE_ID_UMC_UM8673F	0x0101
+#define PCI_DEVICE_ID_UMC_UM8891A	0x0891
+#define PCI_DEVICE_ID_UMC_UM8886BF	0x673a
+#define PCI_DEVICE_ID_UMC_UM8886A	0x886a
+#define PCI_DEVICE_ID_UMC_UM8881F	0x8881
+#define PCI_DEVICE_ID_UMC_UM8886F	0x8886
+#define PCI_DEVICE_ID_UMC_UM9017F	0x9017
+#define PCI_DEVICE_ID_UMC_UM8886N	0xe886
+#define PCI_DEVICE_ID_UMC_UM8891N	0xe891
+
+#define PCI_VENDOR_ID_X			0x1061
+#define PCI_DEVICE_ID_X_AGX016		0x0001
+
+#define PCI_VENDOR_ID_MYLEX		0x1069
+#define PCI_DEVICE_ID_MYLEX_DAC960_P	0x0001
+#define PCI_DEVICE_ID_MYLEX_DAC960_PD	0x0002
+#define PCI_DEVICE_ID_MYLEX_DAC960_PG	0x0010
+#define PCI_DEVICE_ID_MYLEX_DAC960_LA	0x0020
+#define PCI_DEVICE_ID_MYLEX_DAC960_LP	0x0050
+#define PCI_DEVICE_ID_MYLEX_DAC960_BA	0xBA56
+
+#define PCI_VENDOR_ID_PICOP		0x1066
+#define PCI_DEVICE_ID_PICOP_PT86C52X	0x0001
+#define PCI_DEVICE_ID_PICOP_PT80C524	0x8002
+
+#define PCI_VENDOR_ID_APPLE		0x106b
+#define PCI_DEVICE_ID_APPLE_BANDIT	0x0001
+#define PCI_DEVICE_ID_APPLE_GC		0x0002
+#define PCI_DEVICE_ID_APPLE_HYDRA	0x000e
+#define PCI_DEVICE_ID_APPLE_UNI_N_FW	0x0018
+#define PCI_DEVICE_ID_APPLE_KL_USB	0x0019
+#define PCI_DEVICE_ID_APPLE_UNI_N_AGP	0x0020
+#define PCI_DEVICE_ID_APPLE_UNI_N_GMAC	0x0021
+#define PCI_DEVICE_ID_APPLE_UNI_N_FW2	0x0030
+
+#define PCI_VENDOR_ID_YAMAHA		0x1073
+#define PCI_DEVICE_ID_YAMAHA_724	0x0004
+#define PCI_DEVICE_ID_YAMAHA_724F	0x000d
+#define PCI_DEVICE_ID_YAMAHA_740	0x000a
+#define PCI_DEVICE_ID_YAMAHA_740C	0x000c
+#define PCI_DEVICE_ID_YAMAHA_744	0x0010
+#define PCI_DEVICE_ID_YAMAHA_754	0x0012
+
+#define PCI_VENDOR_ID_NEXGEN		0x1074
+#define PCI_DEVICE_ID_NEXGEN_82C501	0x4e78
+
+#define PCI_VENDOR_ID_QLOGIC		0x1077
+#define PCI_DEVICE_ID_QLOGIC_ISP1020	0x1020
+#define PCI_DEVICE_ID_QLOGIC_ISP1022	0x1022
+#define PCI_DEVICE_ID_QLOGIC_ISP2100	0x2100
+#define PCI_DEVICE_ID_QLOGIC_ISP2200	0x2200
+
+#define PCI_VENDOR_ID_CYRIX		0x1078
+#define PCI_DEVICE_ID_CYRIX_5510	0x0000
+#define PCI_DEVICE_ID_CYRIX_PCI_MASTER	0x0001
+#define PCI_DEVICE_ID_CYRIX_5520	0x0002
+#define PCI_DEVICE_ID_CYRIX_5530_LEGACY	0x0100
+#define PCI_DEVICE_ID_CYRIX_5530_SMI	0x0101
+#define PCI_DEVICE_ID_CYRIX_5530_IDE	0x0102
+#define PCI_DEVICE_ID_CYRIX_5530_AUDIO	0x0103
+#define PCI_DEVICE_ID_CYRIX_5530_VIDEO	0x0104
+
+#define PCI_VENDOR_ID_LEADTEK		0x107d
+#define PCI_DEVICE_ID_LEADTEK_805	0x0000
+
+#define PCI_VENDOR_ID_INTERPHASE	0x107e
+#define PCI_DEVICE_ID_INTERPHASE_5526	0x0004
+#define PCI_DEVICE_ID_INTERPHASE_55x6	0x0005
+#define PCI_DEVICE_ID_INTERPHASE_5575	0x0008
+
+#define PCI_VENDOR_ID_CONTAQ		0x1080
+#define PCI_DEVICE_ID_CONTAQ_82C599	0x0600
+#define PCI_DEVICE_ID_CONTAQ_82C693	0xc693
+
+#define PCI_VENDOR_ID_FOREX		0x1083
+
+#define PCI_VENDOR_ID_OLICOM		0x108d
+#define PCI_DEVICE_ID_OLICOM_OC3136	0x0001
+#define PCI_DEVICE_ID_OLICOM_OC2315	0x0011
+#define PCI_DEVICE_ID_OLICOM_OC2325	0x0012
+#define PCI_DEVICE_ID_OLICOM_OC2183	0x0013
+#define PCI_DEVICE_ID_OLICOM_OC2326	0x0014
+#define PCI_DEVICE_ID_OLICOM_OC6151	0x0021
+
+#define PCI_VENDOR_ID_SUN		0x108e
+#define PCI_DEVICE_ID_SUN_EBUS		0x1000
+#define PCI_DEVICE_ID_SUN_HAPPYMEAL	0x1001
+#define PCI_DEVICE_ID_SUN_RIO_EBUS	0x1100
+#define PCI_DEVICE_ID_SUN_RIO_GEM	0x1101
+#define PCI_DEVICE_ID_SUN_RIO_1394	0x1102
+#define PCI_DEVICE_ID_SUN_RIO_USB	0x1103
+#define PCI_DEVICE_ID_SUN_GEM		0x2bad
+#define PCI_DEVICE_ID_SUN_SIMBA		0x5000
+#define PCI_DEVICE_ID_SUN_PBM		0x8000
+#define PCI_DEVICE_ID_SUN_SCHIZO	0x8001
+#define PCI_DEVICE_ID_SUN_SABRE		0xa000
+#define PCI_DEVICE_ID_SUN_HUMMINGBIRD	0xa001
+
+#define PCI_VENDOR_ID_CMD		0x1095
+#define PCI_DEVICE_ID_CMD_640		0x0640
+#define PCI_DEVICE_ID_CMD_643		0x0643
+#define PCI_DEVICE_ID_CMD_646		0x0646
+#define PCI_DEVICE_ID_CMD_647		0x0647
+#define PCI_DEVICE_ID_CMD_648		0x0648
+#define PCI_DEVICE_ID_CMD_649		0x0649
+#define PCI_DEVICE_ID_CMD_670		0x0670
+#define PCI_DEVICE_ID_CMD_680		0x0680
+
+#define PCI_VENDOR_ID_VISION		0x1098
+#define PCI_DEVICE_ID_VISION_QD8500	0x0001
+#define PCI_DEVICE_ID_VISION_QD8580	0x0002
+
+#define PCI_VENDOR_ID_BROOKTREE		0x109e
+#define PCI_DEVICE_ID_BROOKTREE_848	0x0350
+#define PCI_DEVICE_ID_BROOKTREE_849A	0x0351
+#define PCI_DEVICE_ID_BROOKTREE_878_1	0x036e
+#define PCI_DEVICE_ID_BROOKTREE_878	0x0878
+#define PCI_DEVICE_ID_BROOKTREE_8474	0x8474
+
+#define PCI_VENDOR_ID_SIERRA		0x10a8
+#define PCI_DEVICE_ID_SIERRA_STB	0x0000
+
+#define PCI_VENDOR_ID_SGI		0x10a9
+#define PCI_DEVICE_ID_SGI_IOC3		0x0003
+
+#define PCI_VENDOR_ID_ACC		0x10aa
+#define PCI_DEVICE_ID_ACC_2056		0x0000
+
+#define PCI_VENDOR_ID_WINBOND		0x10ad
+#define PCI_DEVICE_ID_WINBOND_83769	0x0001
+#define PCI_DEVICE_ID_WINBOND_82C105	0x0105
+#define PCI_DEVICE_ID_WINBOND_83C553	0x0565
+
+#define PCI_VENDOR_ID_DATABOOK		0x10b3
+#define PCI_DEVICE_ID_DATABOOK_87144	0xb106
+
+#define PCI_VENDOR_ID_PLX		0x10b5
+#define PCI_DEVICE_ID_PLX_R685		0x1030
+#define PCI_DEVICE_ID_PLX_ROMULUS	0x106a
+#define PCI_DEVICE_ID_PLX_SPCOM800	0x1076
+#define PCI_DEVICE_ID_PLX_1077		0x1077
+#define PCI_DEVICE_ID_PLX_SPCOM200	0x1103
+#define PCI_DEVICE_ID_PLX_DJINN_ITOO	0x1151
+#define PCI_DEVICE_ID_PLX_R753		0x1152
+#define PCI_DEVICE_ID_PLX_9050		0x9050
+#define PCI_DEVICE_ID_PLX_9060		0x9060
+#define PCI_DEVICE_ID_PLX_9060ES	0x906E
+#define PCI_DEVICE_ID_PLX_9060SD	0x906D
+#define PCI_DEVICE_ID_PLX_9080		0x9080
+#define PCI_DEVICE_ID_PLX_GTEK_SERIAL2	0xa001
+
+#define PCI_VENDOR_ID_MADGE		0x10b6
+#define PCI_DEVICE_ID_MADGE_MK2		0x0002
+#define PCI_DEVICE_ID_MADGE_C155S	0x1001
+
+#define PCI_VENDOR_ID_3COM		0x10b7
+#define PCI_DEVICE_ID_3COM_3C985	0x0001
+#define PCI_DEVICE_ID_3COM_3C339	0x3390
+#define PCI_DEVICE_ID_3COM_3C590	0x5900
+#define PCI_DEVICE_ID_3COM_3C595	0x5950
+#define PCI_DEVICE_ID_3COM_3C595TX	0x5950
+#define PCI_DEVICE_ID_3COM_3C595_1	0x5951
+#define PCI_DEVICE_ID_3COM_3C595T4	0x5951
+#define PCI_DEVICE_ID_3COM_3C595_2	0x5952
+#define PCI_DEVICE_ID_3COM_3C595MII	0x5952
+#define PCI_DEVICE_ID_3COM_3C900TPO	0x9000
+#define PCI_DEVICE_ID_3COM_3C900COMBO	0x9001
+#define PCI_DEVICE_ID_3COM_3C905TX	0x9050
+#define PCI_DEVICE_ID_3COM_3C905T4	0x9051
+#define PCI_DEVICE_ID_3COM_3C905B_TX	0x9055
+#define PCI_DEVICE_ID_3COM_3C905C_TXM	0x9200
+
+#define PCI_VENDOR_ID_SMC		0x10b8
+#define PCI_DEVICE_ID_SMC_EPIC100	0x0005
+
+#define PCI_VENDOR_ID_SUNDANCE		0x13F0
+#define PCI_DEVICE_ID_SUNDANCE_ALTA	0x0201
+
+#define PCI_VENDOR_ID_AL		0x10b9
+#define PCI_DEVICE_ID_AL_M1445		0x1445
+#define PCI_DEVICE_ID_AL_M1449		0x1449
+#define PCI_DEVICE_ID_AL_M1451		0x1451
+#define PCI_DEVICE_ID_AL_M1461		0x1461
+#define PCI_DEVICE_ID_AL_M1489		0x1489
+#define PCI_DEVICE_ID_AL_M1511		0x1511
+#define PCI_DEVICE_ID_AL_M1513		0x1513
+#define PCI_DEVICE_ID_AL_M1521		0x1521
+#define PCI_DEVICE_ID_AL_M1523		0x1523
+#define PCI_DEVICE_ID_AL_M1531		0x1531
+#define PCI_DEVICE_ID_AL_M1533		0x1533
+#define PCI_DEVICE_ID_AL_M1541		0x1541
+#define PCI_DEVICE_ID_AL_M1621          0x1621
+#define PCI_DEVICE_ID_AL_M1631          0x1631
+#define PCI_DEVICE_ID_AL_M1641          0x1641
+#define PCI_DEVICE_ID_AL_M1647          0x1647
+#define PCI_DEVICE_ID_AL_M1651          0x1651
+#define PCI_DEVICE_ID_AL_M1543		0x1543
+#define PCI_DEVICE_ID_AL_M3307		0x3307
+#define PCI_DEVICE_ID_AL_M4803		0x5215
+#define PCI_DEVICE_ID_AL_M5219		0x5219
+#define PCI_DEVICE_ID_AL_M5229		0x5229
+#define PCI_DEVICE_ID_AL_M5237		0x5237
+#define PCI_DEVICE_ID_AL_M5243		0x5243
+#define PCI_DEVICE_ID_AL_M5451		0x5451
+#define PCI_DEVICE_ID_AL_M7101		0x7101
+
+#define PCI_VENDOR_ID_MITSUBISHI	0x10ba
+
+#define PCI_VENDOR_ID_SURECOM		0x10bd
+#define PCI_DEVICE_ID_SURECOM_NE34	0x0e34
+
+#define PCI_VENDOR_ID_NEOMAGIC		0x10c8
+#define PCI_DEVICE_ID_NEOMAGIC_MAGICGRAPH_NM2070 0x0001
+#define PCI_DEVICE_ID_NEOMAGIC_MAGICGRAPH_128V 0x0002
+#define PCI_DEVICE_ID_NEOMAGIC_MAGICGRAPH_128ZV 0x0003
+#define PCI_DEVICE_ID_NEOMAGIC_MAGICGRAPH_NM2160 0x0004
+#define PCI_DEVICE_ID_NEOMAGIC_MAGICMEDIA_256AV       0x0005
+#define PCI_DEVICE_ID_NEOMAGIC_MAGICGRAPH_128ZVPLUS   0x0083
+
+#define PCI_VENDOR_ID_ASP		0x10cd
+#define PCI_DEVICE_ID_ASP_ABP940	0x1200
+#define PCI_DEVICE_ID_ASP_ABP940U	0x1300
+#define PCI_DEVICE_ID_ASP_ABP940UW	0x2300
+
+#define PCI_VENDOR_ID_MACRONIX		0x10d9
+#define PCI_DEVICE_ID_MACRONIX_MX98713	0x0512
+#define PCI_DEVICE_ID_MX987x3		0x0512
+#define PCI_DEVICE_ID_MACRONIX_MX987x5	0x0531
+#define PCI_DEVICE_ID_MX987x5		0x0531
+
+#define PCI_VENDOR_ID_TCONRAD		0x10da
+#define PCI_DEVICE_ID_TCONRAD_TOKENRING	0x0508
+
+#define PCI_VENDOR_ID_CERN		0x10dc
+#define PCI_DEVICE_ID_CERN_SPSB_PMC	0x0001
+#define PCI_DEVICE_ID_CERN_SPSB_PCI	0x0002
+#define PCI_DEVICE_ID_CERN_HIPPI_DST	0x0021
+#define PCI_DEVICE_ID_CERN_HIPPI_SRC	0x0022
+
+#define PCI_VENDOR_ID_NVIDIA			0x10de
+#define PCI_DEVICE_ID_NVIDIA_TNT		0x0020
+#define PCI_DEVICE_ID_NVIDIA_TNT2		0x0028
+#define PCI_DEVICE_ID_NVIDIA_UTNT2		0x0029
+#define PCI_DEVICE_ID_NVIDIA_VTNT2		0x002C
+#define PCI_DEVICE_ID_NVIDIA_UVTNT2		0x002D
+#define PCI_DEVICE_ID_NVIDIA_ITNT2		0x00A0
+#define PCI_DEVICE_ID_NVIDIA_GEFORCE_SDR	0x0100
+#define PCI_DEVICE_ID_NVIDIA_GEFORCE_DDR	0x0101
+#define PCI_DEVICE_ID_NVIDIA_QUADRO		0x0103
+#define PCI_DEVICE_ID_NVIDIA_GEFORCE2_MX	0x0110
+#define PCI_DEVICE_ID_NVIDIA_GEFORCE2_MX2	0x0111
+#define PCI_DEVICE_ID_NVIDIA_QUADRO2_MXR	0x0113
+#define PCI_DEVICE_ID_NVIDIA_GEFORCE2_GTS	0x0150
+#define PCI_DEVICE_ID_NVIDIA_GEFORCE2_GTS2	0x0151
+#define PCI_DEVICE_ID_NVIDIA_GEFORCE2_ULTRA	0x0152
+#define PCI_DEVICE_ID_NVIDIA_QUADRO2_PRO	0x0153
+
+#define PCI_VENDOR_ID_IMS		0x10e0
+#define PCI_DEVICE_ID_IMS_8849		0x8849
+#define PCI_DEVICE_ID_IMS_TT128		0x9128
+#define PCI_DEVICE_ID_IMS_TT3D		0x9135
+
+#define PCI_VENDOR_ID_TEKRAM2		0x10e1
+#define PCI_DEVICE_ID_TEKRAM2_690c	0x690c
+
+#define PCI_VENDOR_ID_TUNDRA		0x10e3
+#define PCI_DEVICE_ID_TUNDRA_CA91C042	0x0000
+
+#define PCI_VENDOR_ID_AMCC		0x10e8
+#define PCI_DEVICE_ID_AMCC_MYRINET	0x8043
+#define PCI_DEVICE_ID_AMCC_PARASTATION	0x8062
+#define PCI_DEVICE_ID_AMCC_S5933	0x807d
+#define PCI_DEVICE_ID_AMCC_S5933_HEPC3	0x809c
+
+#define PCI_VENDOR_ID_INTERG		0x10ea
+#define PCI_DEVICE_ID_INTERG_1680	0x1680
+#define PCI_DEVICE_ID_INTERG_1682	0x1682
+#define PCI_DEVICE_ID_INTERG_2000	0x2000
+#define PCI_DEVICE_ID_INTERG_2010	0x2010
+#define PCI_DEVICE_ID_INTERG_5000	0x5000
+#define PCI_DEVICE_ID_INTERG_5050	0x5050
+
+#define PCI_VENDOR_ID_REALTEK		0x10ec
+#define PCI_DEVICE_ID_REALTEK_8029	0x8029
+#define PCI_DEVICE_ID_REALTEK_8129	0x8129
+#define PCI_DEVICE_ID_REALTEK_8139	0x8139
+
+#define PCI_VENDOR_ID_XILINX		0x10ee
+#define PCI_DEVICE_ID_TURBOPAM		0x4020
+
+#define PCI_VENDOR_ID_TRUEVISION	0x10fa
+#define PCI_DEVICE_ID_TRUEVISION_T1000	0x000c
+
+#define PCI_VENDOR_ID_INIT		0x1101
+#define PCI_DEVICE_ID_INIT_320P		0x9100
+#define PCI_DEVICE_ID_INIT_360P		0x9500
+
+#define PCI_VENDOR_ID_CREATIVE		0x1102 // duplicate: ECTIVA
+#define PCI_DEVICE_ID_CREATIVE_EMU10K1	0x0002
+
+#define PCI_VENDOR_ID_ECTIVA		0x1102 // duplicate: CREATIVE
+#define PCI_DEVICE_ID_ECTIVA_EV1938	0x8938
+
+#define PCI_VENDOR_ID_TTI		0x1103
+#define PCI_DEVICE_ID_TTI_HPT343	0x0003
+#define PCI_DEVICE_ID_TTI_HPT366	0x0004
+
+#define PCI_VENDOR_ID_VIA		0x1106
+#define PCI_VENDOR_ID_VIATEC		0x1106
+#define PCI_DEVICE_ID_VIA_8363_0	0x0305
+#define PCI_DEVICE_ID_VIA_8371_0	0x0391
+#define PCI_DEVICE_ID_VIA_8501_0	0x0501
+#define PCI_DEVICE_ID_VIA_82C505	0x0505
+#define PCI_DEVICE_ID_VIA_82C561	0x0561
+#define PCI_DEVICE_ID_VIA_82C586_1	0x0571
+#define PCI_DEVICE_ID_VIA_82C576	0x0576
+#define PCI_DEVICE_ID_VIA_82C585	0x0585
+#define PCI_DEVICE_ID_VIA_82C586_0	0x0586
+#define PCI_DEVICE_ID_VIA_82C595	0x0595
+#define PCI_DEVICE_ID_VIA_82C596	0x0596
+#define PCI_DEVICE_ID_VIA_82C597_0	0x0597
+#define PCI_DEVICE_ID_VIA_82C598_0	0x0598
+#define PCI_DEVICE_ID_VIA_8601_0	0x0601
+#define PCI_DEVICE_ID_VIA_8605_0	0x0605
+#define PCI_DEVICE_ID_VIA_82C680	0x0680
+#define PCI_DEVICE_ID_VIA_82C686	0x0686
+#define PCI_DEVICE_ID_VIA_82C691	0x0691
+#define PCI_DEVICE_ID_VIA_82C693	0x0693
+#define PCI_DEVICE_ID_VIA_82C693_1	0x0698
+#define PCI_DEVICE_ID_VIA_82C926	0x0926
+#define PCI_DEVICE_ID_VIA_82C576_1	0x1571
+#define PCI_DEVICE_ID_VIA_82C595_97	0x1595
+#define PCI_DEVICE_ID_VIA_82C586_2	0x3038
+#define PCI_DEVICE_ID_VIA_82C586_3	0x3040
+#define PCI_DEVICE_ID_VIA_RHINE_I	0x3043
+#define PCI_DEVICE_ID_VIA_6305		0x3044
+#define PCI_DEVICE_ID_VIA_82C596_3	0x3050
+#define PCI_DEVICE_ID_VIA_82C596B_3	0x3051
+#define PCI_DEVICE_ID_VIA_82C686_4	0x3057
+#define PCI_DEVICE_ID_VIA_82C686_5	0x3058
+#define PCI_DEVICE_ID_VIA_8233_5	0x3059
+#define PCI_DEVICE_ID_VIA_8233_7	0x3065
+#define PCI_DEVICE_ID_VIA_VT6102	0x3065
+#define PCI_DEVICE_ID_VIA_82C686_6	0x3068
+#define PCI_DEVICE_ID_VIA_8233_0	0x3074
+#define PCI_DEVICE_ID_VIA_VT6105	0x3106
+#define PCI_DEVICE_ID_VIA_8233C_0	0x3109
+#define PCI_DEVICE_ID_VIA_8633_0	0x3091
+#define PCI_DEVICE_ID_VIA_8367_0	0x3099
+#define PCI_DEVICE_ID_VIA_86C100A	0x6100
+#define PCI_DEVICE_ID_VIA_8231		0x8231
+#define PCI_DEVICE_ID_VIA_8231_4	0x8235
+#define PCI_DEVICE_ID_VIA_8365_1	0x8305
+#define PCI_DEVICE_ID_VIA_8371_1	0x8391
+#define PCI_DEVICE_ID_VIA_8501_1	0x8501
+#define PCI_DEVICE_ID_VIA_82C597_1	0x8597
+#define PCI_DEVICE_ID_VIA_82C598_1	0x8598
+#define PCI_DEVICE_ID_VIA_8601_1	0x8601
+#define PCI_DEVICE_ID_VIA_8505_1	0X8605
+#define PCI_DEVICE_ID_VIA_8633_1	0xB091
+#define PCI_DEVICE_ID_VIA_8367_1	0xB099
+
+#define PCI_VENDOR_ID_SIEMENS           0x110A
+#define PCI_DEVICE_ID_SIEMENS_DSCC4     0x2102
+
+#define PCI_VENDOR_ID_SMC2		0x1113
+#define PCI_DEVICE_ID_SMC2_1211TX	0x1211
+#define PCI_DEVICE_ID_SMC2_1211         0x1211
+#define PCI_DEVICE_ID_SMC2_1216         0x1216
+
+#define PCI_VENDOR_ID_VORTEX		0x1119
+#define PCI_DEVICE_ID_VORTEX_GDT60x0	0x0000
+#define PCI_DEVICE_ID_VORTEX_GDT6000B	0x0001
+#define PCI_DEVICE_ID_VORTEX_GDT6x10	0x0002
+#define PCI_DEVICE_ID_VORTEX_GDT6x20	0x0003
+#define PCI_DEVICE_ID_VORTEX_GDT6530	0x0004
+#define PCI_DEVICE_ID_VORTEX_GDT6550	0x0005
+#define PCI_DEVICE_ID_VORTEX_GDT6x17	0x0006
+#define PCI_DEVICE_ID_VORTEX_GDT6x27	0x0007
+#define PCI_DEVICE_ID_VORTEX_GDT6537	0x0008
+#define PCI_DEVICE_ID_VORTEX_GDT6557	0x0009
+#define PCI_DEVICE_ID_VORTEX_GDT6x15	0x000a
+#define PCI_DEVICE_ID_VORTEX_GDT6x25	0x000b
+#define PCI_DEVICE_ID_VORTEX_GDT6535	0x000c
+#define PCI_DEVICE_ID_VORTEX_GDT6555	0x000d
+#define PCI_DEVICE_ID_VORTEX_GDT6x17RP	0x0100
+#define PCI_DEVICE_ID_VORTEX_GDT6x27RP	0x0101
+#define PCI_DEVICE_ID_VORTEX_GDT6537RP	0x0102
+#define PCI_DEVICE_ID_VORTEX_GDT6557RP	0x0103
+#define PCI_DEVICE_ID_VORTEX_GDT6x11RP	0x0104
+#define PCI_DEVICE_ID_VORTEX_GDT6x21RP	0x0105
+#define PCI_DEVICE_ID_VORTEX_GDT6x17RP1	0x0110
+#define PCI_DEVICE_ID_VORTEX_GDT6x27RP1	0x0111
+#define PCI_DEVICE_ID_VORTEX_GDT6537RP1	0x0112
+#define PCI_DEVICE_ID_VORTEX_GDT6557RP1	0x0113
+#define PCI_DEVICE_ID_VORTEX_GDT6x11RP1	0x0114
+#define PCI_DEVICE_ID_VORTEX_GDT6x21RP1	0x0115
+#define PCI_DEVICE_ID_VORTEX_GDT6x17RP2	0x0120
+#define PCI_DEVICE_ID_VORTEX_GDT6x27RP2	0x0121
+#define PCI_DEVICE_ID_VORTEX_GDT6537RP2	0x0122
+#define PCI_DEVICE_ID_VORTEX_GDT6557RP2	0x0123
+#define PCI_DEVICE_ID_VORTEX_GDT6x11RP2	0x0124
+#define PCI_DEVICE_ID_VORTEX_GDT6x21RP2	0x0125
+
+#define PCI_VENDOR_ID_EF		0x111a
+#define PCI_DEVICE_ID_EF_ATM_FPGA	0x0000
+#define PCI_DEVICE_ID_EF_ATM_ASIC	0x0002
+
+#define PCI_VENDOR_ID_IDT		0x111d
+#define PCI_DEVICE_ID_IDT_IDT77201	0x0001
+
+#define PCI_VENDOR_ID_FORE		0x1127
+#define PCI_DEVICE_ID_FORE_PCA200PC	0x0210
+#define PCI_DEVICE_ID_FORE_PCA200E	0x0300
+
+#define PCI_VENDOR_ID_IMAGINGTECH	0x112f
+#define PCI_DEVICE_ID_IMAGINGTECH_ICPCI	0x0000
+
+#define PCI_VENDOR_ID_PHILIPS		0x1131
+#define PCI_DEVICE_ID_PHILIPS_SAA7145	0x7145
+#define PCI_DEVICE_ID_PHILIPS_SAA7146	0x7146
+#define PCI_DEVICE_ID_PHILIPS_SAA9730	0x9730
+
+#define PCI_VENDOR_ID_EICON		0x1133
+#define PCI_DEVICE_ID_EICON_DIVA20PRO	0xe001
+#define PCI_DEVICE_ID_EICON_DIVA20	0xe002
+#define PCI_DEVICE_ID_EICON_DIVA20PRO_U	0xe003
+#define PCI_DEVICE_ID_EICON_DIVA20_U	0xe004
+#define PCI_DEVICE_ID_EICON_DIVA201	0xe005
+#define PCI_DEVICE_ID_EICON_MAESTRA	0xe010
+#define PCI_DEVICE_ID_EICON_MAESTRAQ	0xe012
+#define PCI_DEVICE_ID_EICON_MAESTRAQ_U	0xe013
+#define PCI_DEVICE_ID_EICON_MAESTRAP	0xe014
+ 
+#define PCI_VENDOR_ID_CYCLONE		0x113c
+#define PCI_DEVICE_ID_CYCLONE_SDK	0x0001
+
+#define PCI_VENDOR_ID_ALLIANCE		0x1142
+#define PCI_DEVICE_ID_ALLIANCE_PROMOTIO	0x3210
+#define PCI_DEVICE_ID_ALLIANCE_PROVIDEO	0x6422
+#define PCI_DEVICE_ID_ALLIANCE_AT24	0x6424
+#define PCI_DEVICE_ID_ALLIANCE_AT3D	0x643d
+
+#define PCI_VENDOR_ID_SYSKONNECT	0x1148
+#define PCI_DEVICE_ID_SYSKONNECT_FP	0x4000
+#define PCI_DEVICE_ID_SYSKONNECT_TR	0x4200
+#define PCI_DEVICE_ID_SYSKONNECT_GE	0x4300
+
+#define PCI_VENDOR_ID_VMIC		0x114a
+#define PCI_DEVICE_ID_VMIC_VME		0x7587
+
+#define PCI_VENDOR_ID_DIGI		0x114f
+#define PCI_DEVICE_ID_DIGI_EPC		0x0002
+#define PCI_DEVICE_ID_DIGI_RIGHTSWITCH	0x0003
+#define PCI_DEVICE_ID_DIGI_XEM		0x0004
+#define PCI_DEVICE_ID_DIGI_XR		0x0005
+#define PCI_DEVICE_ID_DIGI_CX		0x0006
+#define PCI_DEVICE_ID_DIGI_XRJ		0x0009
+#define PCI_DEVICE_ID_DIGI_EPCJ		0x000a
+#define PCI_DEVICE_ID_DIGI_XR_920	0x0027
+#define PCI_DEVICE_ID_DIGI_DF_M_IOM2_E	0x0070
+#define PCI_DEVICE_ID_DIGI_DF_M_E	0x0071
+#define PCI_DEVICE_ID_DIGI_DF_M_IOM2_A	0x0072
+#define PCI_DEVICE_ID_DIGI_DF_M_A	0x0073
+
+#define PCI_VENDOR_ID_MUTECH		0x1159
+#define PCI_DEVICE_ID_MUTECH_MV1000	0x0001
+
+#define PCI_VENDOR_ID_XIRCOM		0x115d
+#define PCI_DEVICE_ID_XIRCOM_X3201_ETH	0x0003
+#define PCI_DEVICE_ID_XIRCOM_X3201_MDM	0x0103
+
+#define PCI_VENDOR_ID_RENDITION		0x1163
+#define PCI_DEVICE_ID_RENDITION_VERITE	0x0001
+#define PCI_DEVICE_ID_RENDITION_VERITE2100 0x2000
+
+#define PCI_VENDOR_ID_SERVERWORKS	  0x1166
+#define PCI_DEVICE_ID_SERVERWORKS_HE	  0x0008
+#define PCI_DEVICE_ID_SERVERWORKS_LE	  0x0009
+#define PCI_DEVICE_ID_SERVERWORKS_CIOB30  0x0010
+#define PCI_DEVICE_ID_SERVERWORKS_CMIC_HE 0x0011
+#define PCI_DEVICE_ID_SERVERWORKS_OSB4	  0x0200
+#define PCI_DEVICE_ID_SERVERWORKS_CSB5	  0x0201
+#define PCI_DEVICE_ID_SERVERWORKS_OSB4IDE 0x0211
+#define PCI_DEVICE_ID_SERVERWORKS_CSB5IDE 0x0212
+#define PCI_DEVICE_ID_SERVERWORKS_OSB4USB 0x0220
+#define PCI_DEVICE_ID_SERVERWORKS_CSB5USB PCI_DEVICE_ID_SERVERWORKS_OSB4USB
+#define PCI_DEVICE_ID_SERVERWORKS_CSB5ISA 0x0230
+
+#define PCI_VENDOR_ID_SBE		0x1176
+#define PCI_DEVICE_ID_SBE_WANXL100	0x0301
+#define PCI_DEVICE_ID_SBE_WANXL200	0x0302
+#define PCI_DEVICE_ID_SBE_WANXL400	0x0104
+
+#define PCI_VENDOR_ID_TOSHIBA		0x1179
+#define PCI_DEVICE_ID_TOSHIBA_601	0x0601
+#define PCI_DEVICE_ID_TOSHIBA_TOPIC95	0x060a
+#define PCI_DEVICE_ID_TOSHIBA_TOPIC97	0x060f
+
+#define PCI_VENDOR_ID_RICOH		0x1180
+#define PCI_DEVICE_ID_RICOH_RL5C465	0x0465
+#define PCI_DEVICE_ID_RICOH_RL5C466	0x0466
+#define PCI_DEVICE_ID_RICOH_RL5C475	0x0475
+#define PCI_DEVICE_ID_RICOH_RL5C476	0x0476
+#define PCI_DEVICE_ID_RICOH_RL5C478	0x0478
+
+#define	PCI_VENDOR_ID_DLINK		0x1186
+#define	PCI_DEVICE_ID_DFE530TXP		0x1300
+#define PCI_DEVICE_ID_DFE530TXS		0x1002
+
+#define PCI_VENDOR_ID_ARTOP		0x1191
+#define PCI_DEVICE_ID_ARTOP_ATP8400	0x0004
+#define PCI_DEVICE_ID_ARTOP_ATP850UF	0x0005
+#define PCI_DEVICE_ID_ARTOP_ATP860	0x0006
+#define PCI_DEVICE_ID_ARTOP_ATP860R	0x0007
+#define PCI_DEVICE_ID_ARTOP_AEC7610	0x8002
+#define PCI_DEVICE_ID_ARTOP_AEC7612UW	0x8010
+#define PCI_DEVICE_ID_ARTOP_AEC7612U	0x8020
+#define PCI_DEVICE_ID_ARTOP_AEC7612S	0x8030
+#define PCI_DEVICE_ID_ARTOP_AEC7612D	0x8040
+#define PCI_DEVICE_ID_ARTOP_AEC7612SUW	0x8050
+#define PCI_DEVICE_ID_ARTOP_8060	0x8060
+
+#define PCI_VENDOR_ID_ZEITNET		0x1193
+#define PCI_DEVICE_ID_ZEITNET_1221	0x0001
+#define PCI_DEVICE_ID_ZEITNET_1225	0x0002
+
+#define PCI_VENDOR_ID_OMEGA		0x119b
+#define PCI_DEVICE_ID_OMEGA_82C092G	0x1221
+
+#define PCI_VENDOR_ID_FUJITSU_ME	0x119e
+#define PCI_DEVICE_ID_FUJITSU_FS155	0x0001
+#define PCI_DEVICE_ID_FUJITSU_FS50	0x0003
+
+#define PCI_SUBVENDOR_ID_KEYSPAN	0x11a9
+#define PCI_SUBDEVICE_ID_KEYSPAN_SX2	0x5334
+
+#define PCI_VENDOR_ID_GALILEO		0x11ab
+#define PCI_DEVICE_ID_GALILEO_GT64011	0x4146
+#define PCI_DEVICE_ID_GALILEO_GT64111	0x4146
+#define PCI_DEVICE_ID_GALILEO_GT96100	0x9652
+#define PCI_DEVICE_ID_GALILEO_GT96100A	0x9653
+
+#define PCI_VENDOR_ID_LINKSYS		0x11ad
+#define PCI_VENDOR_ID_LITEON		0x11ad
+#define PCI_DEVICE_ID_LITEON_LNE100TX	0x0002
+#define PCI_DEVICE_ID_LC82C115		0xC115
+
+#define PCI_VENDOR_ID_V3		0x11b0
+#define PCI_DEVICE_ID_V3_V960		0x0001
+#define PCI_DEVICE_ID_V3_V350		0x0001
+#define PCI_DEVICE_ID_V3_V961		0x0002
+#define PCI_DEVICE_ID_V3_V351		0x0002
+
+#define PCI_VENDOR_ID_NP		0x11bc
+#define PCI_DEVICE_ID_NP_PCI_FDDI	0x0001
+
+#define PCI_VENDOR_ID_ATT		0x11c1
+#define PCI_DEVICE_ID_ATT_L56XMF	0x0440
+#define PCI_DEVICE_ID_ATT_VENUS_MODEM	0x480
+
+#define PCI_VENDOR_ID_SPECIALIX		0x11cb
+#define PCI_DEVICE_ID_SPECIALIX_IO8	0x2000
+#define PCI_DEVICE_ID_SPECIALIX_XIO	0x4000
+#define PCI_DEVICE_ID_SPECIALIX_RIO	0x8000
+#define PCI_SUBDEVICE_ID_SPECIALIX_SPEED4 0xa004
+
+#define PCI_VENDOR_ID_AURAVISION	0x11d1
+#define PCI_DEVICE_ID_AURAVISION_VXP524	0x01f7
+
+#define PCI_VENDOR_ID_ANALOG_DEVICES	0x11d4
+#define PCI_DEVICE_ID_AD1889JS		0x1889
+
+#define PCI_VENDOR_ID_IKON		0x11d5
+#define PCI_DEVICE_ID_IKON_10115	0x0115
+#define PCI_DEVICE_ID_IKON_10117	0x0117
+
+#define PCI_VENDOR_ID_ZORAN		0x11de
+#define PCI_DEVICE_ID_ZORAN_36057	0x6057
+#define PCI_DEVICE_ID_ZORAN_36120	0x6120
+
+#define PCI_VENDOR_ID_KINETIC		0x11f4
+#define PCI_DEVICE_ID_KINETIC_2915	0x2915
+
+#define PCI_VENDOR_ID_COMPEX		0x11f6
+#define PCI_DEVICE_ID_COMPEX_ENET100VG4	0x0112
+#define PCI_DEVICE_ID_COMPEX_RL2000	0x1401
+#define PCI_DEVICE_ID_COMPEX_RL100ATX   0x2011
+
+#define PCI_VENDOR_ID_RP		0x11fe
+#define PCI_DEVICE_ID_RP32INTF		0x0001
+#define PCI_DEVICE_ID_RP8INTF		0x0002
+#define PCI_DEVICE_ID_RP16INTF		0x0003
+#define PCI_DEVICE_ID_RP4QUAD		0x0004
+#define PCI_DEVICE_ID_RP8OCTA		0x0005
+#define PCI_DEVICE_ID_RP8J		0x0006
+#define PCI_DEVICE_ID_RPP4		0x000A
+#define PCI_DEVICE_ID_RPP8		0x000B
+#define PCI_DEVICE_ID_RP8M		0x000C
+
+#define PCI_VENDOR_ID_CYCLADES		0x120e
+#define PCI_DEVICE_ID_CYCLOM_Y_Lo	0x0100
+#define PCI_DEVICE_ID_CYCLOM_Y_Hi	0x0101
+#define PCI_DEVICE_ID_CYCLOM_4Y_Lo	0x0102
+#define PCI_DEVICE_ID_CYCLOM_4Y_Hi	0x0103
+#define PCI_DEVICE_ID_CYCLOM_8Y_Lo	0x0104
+#define PCI_DEVICE_ID_CYCLOM_8Y_Hi	0x0105
+#define PCI_DEVICE_ID_CYCLOM_Z_Lo	0x0200
+#define PCI_DEVICE_ID_CYCLOM_Z_Hi	0x0201
+#define PCI_DEVICE_ID_PC300_RX_2	0x0300
+#define PCI_DEVICE_ID_PC300_RX_1	0x0301
+#define PCI_DEVICE_ID_PC300_TE_2	0x0310
+#define PCI_DEVICE_ID_PC300_TE_1	0x0311
+
+#define PCI_VENDOR_ID_ESSENTIAL		0x120f
+#define PCI_DEVICE_ID_ESSENTIAL_ROADRUNNER	0x0001
+
+#define PCI_VENDOR_ID_O2		0x1217
+#define PCI_DEVICE_ID_O2_6729		0x6729
+#define PCI_DEVICE_ID_O2_6730		0x673a
+#define PCI_DEVICE_ID_O2_6832		0x6832
+#define PCI_DEVICE_ID_O2_6836		0x6836
+
+#define PCI_VENDOR_ID_3DFX		0x121a
+#define PCI_DEVICE_ID_3DFX_VOODOO	0x0001
+#define PCI_DEVICE_ID_3DFX_VOODOO2	0x0002
+#define PCI_DEVICE_ID_3DFX_BANSHEE	0x0003
+#define PCI_DEVICE_ID_3DFX_VOODOO3	0x0005
+
+#define PCI_VENDOR_ID_SIGMADES		0x1236
+#define PCI_DEVICE_ID_SIGMADES_6425	0x6401
+
+#define PCI_VENDOR_ID_CCUBE		0x123f
+
+#define PCI_VENDOR_ID_AVM		0x1244
+#define PCI_DEVICE_ID_AVM_B1		0x0700
+#define PCI_DEVICE_ID_AVM_C4		0x0800
+#define PCI_DEVICE_ID_AVM_A1		0x0a00
+#define PCI_DEVICE_ID_AVM_A1_V2		0x0e00
+#define PCI_DEVICE_ID_AVM_C2		0x1100
+#define PCI_DEVICE_ID_AVM_T1		0x1200
+
+#define PCI_VENDOR_ID_DIPIX		0x1246
+
+#define PCI_VENDOR_ID_STALLION		0x124d
+#define PCI_DEVICE_ID_STALLION_ECHPCI832 0x0000
+#define PCI_DEVICE_ID_STALLION_ECHPCI864 0x0002
+#define PCI_DEVICE_ID_STALLION_EIOPCI	0x0003
+
+#define PCI_VENDOR_ID_OPTIBASE		0x1255
+#define PCI_DEVICE_ID_OPTIBASE_FORGE	0x1110
+#define PCI_DEVICE_ID_OPTIBASE_FUSION	0x1210
+#define PCI_DEVICE_ID_OPTIBASE_VPLEX	0x2110
+#define PCI_DEVICE_ID_OPTIBASE_VPLEXCC	0x2120
+#define PCI_DEVICE_ID_OPTIBASE_VQUEST	0x2130
+
+#define PCI_VENDOR_ID_ESS		0x125d
+#define PCI_DEVICE_ID_ESS_ESS1968	0x1968
+#define PCI_DEVICE_ID_ESS_AUDIOPCI	0x1969
+#define PCI_DEVICE_ID_ESS_ESS1978	0x1978
+
+#define PCI_VENDOR_ID_HARRIS        	0x1260
+#define PCI_DEVICE_ID_HARRIS_PRISM2	0x3873
+
+#define PCI_VENDOR_ID_SATSAGEM		0x1267
+#define PCI_DEVICE_ID_SATSAGEM_NICCY	0x1016
+#define PCI_DEVICE_ID_SATSAGEM_PCR2101	0x5352
+#define PCI_DEVICE_ID_SATSAGEM_TELSATTURBO 0x5a4b
+
+#define PCI_VENDOR_ID_HUGHES		0x1273
+#define PCI_DEVICE_ID_HUGHES_DIRECPC	0x0002
+
+#define PCI_VENDOR_ID_ENSONIQ		0x1274
+#define PCI_DEVICE_ID_ENSONIQ_CT5880	0x5880
+#define PCI_DEVICE_ID_ENSONIQ_ES1370	0x5000
+#define PCI_DEVICE_ID_ENSONIQ_ES1371	0x1371
+
+#define PCI_VENDOR_ID_ROCKWELL		0x127A
+
+#define PCI_VENDOR_ID_DAVICOM		0x1282
+#define	PCI_DEVICE_ID_DM9009		0x9009
+#define PCI_DEVICE_ID_DM9102		0x9102
+
+#define PCI_VENDOR_ID_ITE		0x1283
+#define PCI_DEVICE_ID_ITE_IT8172G_AUDIO 0x0801
+#define PCI_DEVICE_ID_ITE_IT8172G	0x8172
+#define PCI_DEVICE_ID_ITE_8872		0x8872
+
+
+/* formerly Platform Tech */
+#define PCI_VENDOR_ID_ESS_OLD		0x1285
+#define PCI_DEVICE_ID_ESS_ESS0100	0x0100
+
+#define PCI_VENDOR_ID_ALTEON		0x12ae
+#define PCI_DEVICE_ID_ALTEON_ACENIC	0x0001
+
+#define PCI_VENDOR_ID_USR		0x12B9
+
+#define	PCI_VENDOR_ID_HOLTEK		0x12c3
+#define	PCI_DEVICE_ID_HOLTEK_HT80232	0x0058
+
+#define PCI_SUBVENDOR_ID_CONNECT_TECH			0x12c4
+#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH8_232		0x0001
+#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH4_232		0x0002
+#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH2_232		0x0003
+#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH8_485		0x0004
+#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH8_485_4_4	0x0005
+#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH4_485		0x0006
+#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH4_485_2_2	0x0007
+#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH2_485		0x0008
+#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH8_485_2_6	0x0009
+#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH081101V1	0x000A
+#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH041101V1	0x000B
+
+#define PCI_VENDOR_ID_PICTUREL		0x12c5
+#define PCI_DEVICE_ID_PICTUREL_PCIVST	0x0081
+
+#define PCI_VENDOR_ID_NVIDIA_SGS	0x12d2
+#define PCI_DEVICE_ID_NVIDIA_SGS_RIVA128 0x0018
+
+#define PCI_SUBVENDOR_ID_CHASE_PCIFAST		0x12E0
+#define PCI_SUBDEVICE_ID_CHASE_PCIFAST4		0x0031
+#define PCI_SUBDEVICE_ID_CHASE_PCIFAST8		0x0021
+#define PCI_SUBDEVICE_ID_CHASE_PCIFAST16	0x0011
+#define PCI_SUBDEVICE_ID_CHASE_PCIFAST16FMC	0x0041
+#define PCI_SUBVENDOR_ID_CHASE_PCIRAS		0x124D
+#define PCI_SUBDEVICE_ID_CHASE_PCIRAS4		0xF001
+#define PCI_SUBDEVICE_ID_CHASE_PCIRAS8		0xF010
+
+#define PCI_VENDOR_ID_AUREAL		0x12eb
+#define PCI_DEVICE_ID_AUREAL_VORTEX_1	0x0001
+#define PCI_DEVICE_ID_AUREAL_VORTEX_2	0x0002
+
+#define PCI_VENDOR_ID_CBOARDS		0x1307
+#define PCI_DEVICE_ID_CBOARDS_DAS1602_16 0x0001
+
+#define PCI_VENDOR_ID_SIIG		0x131f
+#define PCI_DEVICE_ID_SIIG_1S_10x_550	0x1000
+#define PCI_DEVICE_ID_SIIG_1S_10x_650	0x1001
+#define PCI_DEVICE_ID_SIIG_1S_10x_850	0x1002
+#define PCI_DEVICE_ID_SIIG_1S1P_10x_550	0x1010
+#define PCI_DEVICE_ID_SIIG_1S1P_10x_650	0x1011
+#define PCI_DEVICE_ID_SIIG_1S1P_10x_850	0x1012
+#define PCI_DEVICE_ID_SIIG_1P_10x	0x1020
+#define PCI_DEVICE_ID_SIIG_2P_10x	0x1021
+#define PCI_DEVICE_ID_SIIG_2S_10x_550	0x1030
+#define PCI_DEVICE_ID_SIIG_2S_10x_650	0x1031
+#define PCI_DEVICE_ID_SIIG_2S_10x_850	0x1032
+#define PCI_DEVICE_ID_SIIG_2S1P_10x_550	0x1034
+#define PCI_DEVICE_ID_SIIG_2S1P_10x_650	0x1035
+#define PCI_DEVICE_ID_SIIG_2S1P_10x_850	0x1036
+#define PCI_DEVICE_ID_SIIG_4S_10x_550	0x1050
+#define PCI_DEVICE_ID_SIIG_4S_10x_650	0x1051
+#define PCI_DEVICE_ID_SIIG_4S_10x_850	0x1052
+#define PCI_DEVICE_ID_SIIG_1S_20x_550	0x2000
+#define PCI_DEVICE_ID_SIIG_1S_20x_650	0x2001
+#define PCI_DEVICE_ID_SIIG_1S_20x_850	0x2002
+#define PCI_DEVICE_ID_SIIG_1P_20x	0x2020
+#define PCI_DEVICE_ID_SIIG_2P_20x	0x2021
+#define PCI_DEVICE_ID_SIIG_2S_20x_550	0x2030
+#define PCI_DEVICE_ID_SIIG_2S_20x_650	0x2031
+#define PCI_DEVICE_ID_SIIG_2S_20x_850	0x2032
+#define PCI_DEVICE_ID_SIIG_2P1S_20x_550	0x2040
+#define PCI_DEVICE_ID_SIIG_2P1S_20x_650	0x2041
+#define PCI_DEVICE_ID_SIIG_2P1S_20x_850	0x2042
+#define PCI_DEVICE_ID_SIIG_1S1P_20x_550	0x2010
+#define PCI_DEVICE_ID_SIIG_1S1P_20x_650	0x2011
+#define PCI_DEVICE_ID_SIIG_1S1P_20x_850	0x2012
+#define PCI_DEVICE_ID_SIIG_4S_20x_550	0x2050
+#define PCI_DEVICE_ID_SIIG_4S_20x_650	0x2051
+#define PCI_DEVICE_ID_SIIG_4S_20x_850	0x2052
+#define PCI_DEVICE_ID_SIIG_2S1P_20x_550	0x2060
+#define PCI_DEVICE_ID_SIIG_2S1P_20x_650	0x2061
+#define PCI_DEVICE_ID_SIIG_2S1P_20x_850	0x2062
+
+#define PCI_VENDOR_ID_ADMTEK            0x1317
+#define PCI_DEVICE_ID_ADMTEK_0985       0x0985
+
+#define PCI_VENDOR_ID_DOMEX		0x134a
+#define PCI_DEVICE_ID_DOMEX_DMX3191D	0x0001
+
+#define PCI_VENDOR_ID_QUATECH		0x135C
+#define PCI_DEVICE_ID_QUATECH_QSC100	0x0010
+#define PCI_DEVICE_ID_QUATECH_DSC100	0x0020
+#define PCI_DEVICE_ID_QUATECH_DSC200	0x0030
+#define PCI_DEVICE_ID_QUATECH_QSC200	0x0040
+#define PCI_DEVICE_ID_QUATECH_ESC100D	0x0050
+#define PCI_DEVICE_ID_QUATECH_ESC100M	0x0060
+
+#define PCI_VENDOR_ID_SEALEVEL		0x135e
+#define PCI_DEVICE_ID_SEALEVEL_U530	0x7101
+#define PCI_DEVICE_ID_SEALEVEL_UCOMM2	0x7201
+#define PCI_DEVICE_ID_SEALEVEL_UCOMM422	0x7402
+#define PCI_DEVICE_ID_SEALEVEL_UCOMM232	0x7202
+#define PCI_DEVICE_ID_SEALEVEL_COMM4	0x7401
+#define PCI_DEVICE_ID_SEALEVEL_COMM8	0x7801
+
+#define PCI_VENDOR_ID_HYPERCOPE		0x1365
+#define PCI_DEVICE_ID_HYPERCOPE_PLX	0x9050
+#define PCI_SUBDEVICE_ID_HYPERCOPE_OLD_ERGO	0x0104
+#define PCI_SUBDEVICE_ID_HYPERCOPE_ERGO		0x0106
+#define PCI_SUBDEVICE_ID_HYPERCOPE_METRO	0x0107
+#define PCI_SUBDEVICE_ID_HYPERCOPE_CHAMP2	0x0108
+#define PCI_SUBDEVICE_ID_HYPERCOPE_PLEXUS	0x0109
+
+#define PCI_VENDOR_ID_KAWASAKI		0x136b
+#define PCI_DEVICE_ID_MCHIP_KL5A72002	0xff01
+
+#define PCI_VENDOR_ID_LMC		0x1376
+#define PCI_DEVICE_ID_LMC_HSSI		0x0003
+#define PCI_DEVICE_ID_LMC_DS3		0x0004
+#define PCI_DEVICE_ID_LMC_SSI		0x0005
+#define PCI_DEVICE_ID_LMC_T1		0x0006
+
+#define PCI_VENDOR_ID_NETGEAR		0x1385
+#define PCI_DEVICE_ID_NETGEAR_MA301	0x4100
+#define PCI_DEVICE_ID_NETGEAR_GA620	0x620a
+#define PCI_DEVICE_ID_NETGEAR_GA622	0x622a
+
+#define PCI_VENDOR_ID_APPLICOM		0x1389
+#define PCI_DEVICE_ID_APPLICOM_PCIGENERIC 0x0001
+#define PCI_DEVICE_ID_APPLICOM_PCI2000IBS_CAN 0x0002
+#define PCI_DEVICE_ID_APPLICOM_PCI2000PFB 0x0003
+
+#define PCI_VENDOR_ID_MOXA		0x1393
+#define PCI_DEVICE_ID_MOXA_C104		0x1040
+#define PCI_DEVICE_ID_MOXA_C168		0x1680
+#define PCI_DEVICE_ID_MOXA_CP204J	0x2040
+#define PCI_DEVICE_ID_MOXA_C218		0x2180
+#define PCI_DEVICE_ID_MOXA_C320		0x3200
+
+#define PCI_VENDOR_ID_CCD		0x1397
+#define PCI_DEVICE_ID_CCD_2BD0		0x2bd0
+#define PCI_DEVICE_ID_CCD_B000		0xb000
+#define PCI_DEVICE_ID_CCD_B006		0xb006
+#define PCI_DEVICE_ID_CCD_B007		0xb007
+#define PCI_DEVICE_ID_CCD_B008		0xb008
+#define PCI_DEVICE_ID_CCD_B009		0xb009
+#define PCI_DEVICE_ID_CCD_B00A		0xb00a
+#define PCI_DEVICE_ID_CCD_B00B		0xb00b
+#define PCI_DEVICE_ID_CCD_B00C		0xb00c
+#define PCI_DEVICE_ID_CCD_B100		0xb100
+
+#define PCI_VENDOR_ID_MICROGATE		0x13c0
+#define PCI_DEVICE_ID_MICROGATE_USC	0x0010
+#define PCI_DEVICE_ID_MICROGATE_SCC	0x0020
+#define PCI_DEVICE_ID_MICROGATE_SCA	0x0030
+
+#define PCI_VENDOR_ID_3WARE		0x13C1
+#define PCI_DEVICE_ID_3WARE_1000	0x1000
+
+#define PCI_VENDOR_ID_ABOCOM		0x13D1
+#define PCI_DEVICE_ID_ABOCOM_2BD1       0x2BD1
+
+#define PCI_VENDOR_ID_CMEDIA		0x13f6
+#define PCI_DEVICE_ID_CMEDIA_CM8338A	0x0100
+#define PCI_DEVICE_ID_CMEDIA_CM8338B	0x0101
+#define PCI_DEVICE_ID_CMEDIA_CM8738	0x0111
+#define PCI_DEVICE_ID_CMEDIA_CM8738B	0x0112
+
+#define PCI_VENDOR_ID_LAVA		0x1407
+#define PCI_DEVICE_ID_LAVA_DSERIAL	0x0100 /* 2x 16550 */
+#define PCI_DEVICE_ID_LAVA_QUATRO_A	0x0101 /* 2x 16550, half of 4 port */
+#define PCI_DEVICE_ID_LAVA_QUATRO_B	0x0102 /* 2x 16550, half of 4 port */
+#define PCI_DEVICE_ID_LAVA_PORT_PLUS	0x0200 /* 2x 16650 */
+#define PCI_DEVICE_ID_LAVA_QUAD_A	0x0201 /* 2x 16650, half of 4 port */
+#define PCI_DEVICE_ID_LAVA_QUAD_B	0x0202 /* 2x 16650, half of 4 port */
+#define PCI_DEVICE_ID_LAVA_SSERIAL	0x0500 /* 1x 16550 */
+#define PCI_DEVICE_ID_LAVA_PORT_650	0x0600 /* 1x 16650 */
+#define PCI_DEVICE_ID_LAVA_PARALLEL	0x8000
+#define PCI_DEVICE_ID_LAVA_DUAL_PAR_A	0x8002 /* The Lava Dual Parallel is */
+#define PCI_DEVICE_ID_LAVA_DUAL_PAR_B	0x8003 /* two PCI devices on a card */
+#define PCI_DEVICE_ID_LAVA_BOCA_IOPPAR	0x8800
+
+#define PCI_VENDOR_ID_TIMEDIA		0x1409
+#define PCI_DEVICE_ID_TIMEDIA_1889	0x7168
+
+#define PCI_VENDOR_ID_OXSEMI		0x1415
+#define PCI_DEVICE_ID_OXSEMI_12PCI840	0x8403
+#define PCI_DEVICE_ID_OXSEMI_16PCI954	0x9501
+#define PCI_DEVICE_ID_OXSEMI_16PCI952	0x950A
+#define PCI_DEVICE_ID_OXSEMI_16PCI95N	0x9511
+#define PCI_DEVICE_ID_OXSEMI_16PCI954PP	0x9513
+
+#define PCI_VENDOR_ID_AIRONET		0x14b9
+#define PCI_DEVICE_ID_AIRONET_4800_1	0x0001
+#define PCI_DEVICE_ID_AIRONET_4800	0x4500 // values switched?  see
+#define PCI_DEVICE_ID_AIRONET_4500	0x4800 // drivers/net/aironet4500_card.c
+
+#define PCI_VENDOR_ID_TITAN		0x14D2
+#define PCI_DEVICE_ID_TITAN_010L	0x8001
+#define PCI_DEVICE_ID_TITAN_100L	0x8010
+#define PCI_DEVICE_ID_TITAN_110L	0x8011
+#define PCI_DEVICE_ID_TITAN_200L	0x8020
+#define PCI_DEVICE_ID_TITAN_210L	0x8021
+#define PCI_DEVICE_ID_TITAN_400L	0x8040
+#define PCI_DEVICE_ID_TITAN_800L	0x8080
+#define PCI_DEVICE_ID_TITAN_100		0xA001
+#define PCI_DEVICE_ID_TITAN_200		0xA005
+#define PCI_DEVICE_ID_TITAN_400		0xA003
+#define PCI_DEVICE_ID_TITAN_800B	0xA004
+
+#define PCI_VENDOR_ID_PANACOM		0x14d4
+#define PCI_DEVICE_ID_PANACOM_QUADMODEM	0x0400
+#define PCI_DEVICE_ID_PANACOM_DUALMODEM	0x0402
+
+#define PCI_VENDOR_ID_BROADCOM		0x14e4
+#define PCI_DEVICE_ID_TIGON3_5700	0x1644
+#define PCI_DEVICE_ID_TIGON3_5701	0x1645
+#define PCI_DEVICE_ID_TIGON3_5702	0x1646
+#define PCI_DEVICE_ID_TIGON3_5703	0x1647
+#define PCI_DEVICE_ID_TIGON3_5704	0x1648
+#define PCI_DEVICE_ID_TIGON3_5702FE	0x164d
+#define PCI_DEVICE_ID_TIGON3_5705	0x1653
+#define PCI_DEVICE_ID_TIGON3_5705_2	0x1654
+#define PCI_DEVICE_ID_TIGON3_5705M	0x165d
+#define PCI_DEVICE_ID_TIGON3_5705M_2	0x165e
+#define PCI_DEVICE_ID_TIGON3_5782	0x1696
+#define PCI_DEVICE_ID_TIGON3_5788	0x169c
+#define PCI_DEVICE_ID_TIGON3_5702X	0x16a6
+#define PCI_DEVICE_ID_TIGON3_5703X	0x16a7
+#define PCI_DEVICE_ID_TIGON3_5704S	0x16a8
+#define PCI_DEVICE_ID_TIGON3_5702A3	0x16c6
+#define PCI_DEVICE_ID_TIGON3_5703A3	0x16c7
+#define PCI_DEVICE_ID_TIGON3_5901	0x170d
+#define PCI_DEVICE_ID_TIGON3_5901_2	0x170e
+
+#define PCI_VENDOR_ID_SYBA		0x1592
+#define PCI_DEVICE_ID_SYBA_2P_EPP	0x0782
+#define PCI_DEVICE_ID_SYBA_1P_ECP	0x0783
+
+#define PCI_VENDOR_ID_MORETON		0x15aa
+#define PCI_DEVICE_ID_RASTEL_2PORT	0x2000
+
+#define PCI_VENDOR_ID_ZOLTRIX		0x15b0
+#define PCI_DEVICE_ID_ZOLTRIX_2BD0	0x2bd0 
+
+#define PCI_VENDOR_ID_PDC		0x15e9
+#define PCI_DEVICE_ID_PDC_1841		0x1841
+
+#define PCI_VENDOR_ID_SYMPHONY		0x1c1c
+#define PCI_DEVICE_ID_SYMPHONY_101	0x0001
+
+#define PCI_VENDOR_ID_TEKRAM		0x1de1
+#define PCI_DEVICE_ID_TEKRAM_DC290	0xdc29
+
+#define PCI_VENDOR_ID_3DLABS		0x3d3d
+#define PCI_DEVICE_ID_3DLABS_300SX	0x0001
+#define PCI_DEVICE_ID_3DLABS_500TX	0x0002
+#define PCI_DEVICE_ID_3DLABS_DELTA	0x0003
+#define PCI_DEVICE_ID_3DLABS_PERMEDIA	0x0004
+#define PCI_DEVICE_ID_3DLABS_MX		0x0006
+#define PCI_DEVICE_ID_3DLABS_PERMEDIA2	0x0007
+#define PCI_DEVICE_ID_3DLABS_GAMMA	0x0008
+#define PCI_DEVICE_ID_3DLABS_PERMEDIA2V	0x0009
+
+#define PCI_VENDOR_ID_AVANCE		0x4005
+#define PCI_DEVICE_ID_AVANCE_ALG2064	0x2064
+#define PCI_DEVICE_ID_AVANCE_2302	0x2302
+
+#define PCI_VENDOR_ID_AKS		0x416c
+#define PCI_DEVICE_ID_AKS_ALADDINCARD	0x0100
+#define PCI_DEVICE_ID_AKS_CPC		0x0200
+
+#define PCI_VENDOR_ID_NETVIN		0x4a14
+#define PCI_DEVICE_ID_NETVIN_NV5000SC	0x5000
+
+#define PCI_VENDOR_ID_S3		0x5333
+#define PCI_DEVICE_ID_S3_PLATO_PXS	0x0551
+#define PCI_DEVICE_ID_S3_ViRGE		0x5631
+#define PCI_DEVICE_ID_S3_TRIO		0x8811
+#define PCI_DEVICE_ID_S3_AURORA64VP	0x8812
+#define PCI_DEVICE_ID_S3_TRIO64UVP	0x8814
+#define PCI_DEVICE_ID_S3_ViRGE_VX	0x883d
+#define PCI_DEVICE_ID_S3_868		0x8880
+#define PCI_DEVICE_ID_S3_928		0x88b0
+#define PCI_DEVICE_ID_S3_864_1		0x88c0
+#define PCI_DEVICE_ID_S3_864_2		0x88c1
+#define PCI_DEVICE_ID_S3_964_1		0x88d0
+#define PCI_DEVICE_ID_S3_964_2		0x88d1
+#define PCI_DEVICE_ID_S3_968		0x88f0
+#define PCI_DEVICE_ID_S3_TRIO64V2	0x8901
+#define PCI_DEVICE_ID_S3_PLATO_PXG	0x8902
+#define PCI_DEVICE_ID_S3_ViRGE_DXGX	0x8a01
+#define PCI_DEVICE_ID_S3_ViRGE_GX2	0x8a10
+#define PCI_DEVICE_ID_S3_ViRGE_MX	0x8c01
+#define PCI_DEVICE_ID_S3_ViRGE_MXP	0x8c02
+#define PCI_DEVICE_ID_S3_ViRGE_MXPMV	0x8c03
+#define PCI_DEVICE_ID_S3_SONICVIBES	0xca00
+
+#define PCI_VENDOR_ID_DCI		0x6666
+#define PCI_DEVICE_ID_DCI_PCCOM4	0x0001
+#define PCI_DEVICE_ID_DCI_PCCOM8	0x0002
+
+#define PCI_VENDOR_ID_GENROCO		0x5555
+#define PCI_DEVICE_ID_GENROCO_HFP832	0x0003
+
+#define PCI_VENDOR_ID_INTEL		0x8086
+#define PCI_DEVICE_ID_INTEL_21145	0x0039
+#define PCI_DEVICE_ID_INTEL_82375	0x0482
+#define PCI_DEVICE_ID_INTEL_82424	0x0483
+#define PCI_DEVICE_ID_INTEL_82378	0x0484
+#define PCI_DEVICE_ID_INTEL_82430	0x0486
+#define PCI_DEVICE_ID_INTEL_82434	0x04a3
+#define PCI_DEVICE_ID_INTEL_I960	0x0960
+#define PCI_DEVICE_ID_INTEL_82542       	0x1000
+#define PCI_DEVICE_ID_INTEL_82543GC_FIBER  	0x1001
+#define PCI_DEVICE_ID_INTEL_82543GC_COPPER 	0x1004
+#define PCI_DEVICE_ID_INTEL_82544EI_COPPER 	0x1008
+#define PCI_DEVICE_ID_INTEL_82544EI_FIBER 	0x1009
+#define PCI_DEVICE_ID_INTEL_82544GC_COPPER 	0x100C
+#define PCI_DEVICE_ID_INTEL_82544GC_LOM   	0x100D
+#define PCI_DEVICE_ID_INTEL_82540EM		0x100E
+#define PCI_DEVICE_ID_INTEL_82545EM_COPPER	0x100F
+#define PCI_DEVICE_ID_INTEL_82546EB_COPPER	0x1010
+#define PCI_DEVICE_ID_INTEL_82545EM_FIBER	0x1011
+#define PCI_DEVICE_ID_INTEL_82546EB_FIBER	0x1012
+#define PCI_DEVICE_ID_INTEL_82540EM_LOM		0x1015
+#define PCI_DEVICE_ID_INTEL_ID1029	0x1029
+#define PCI_DEVICE_ID_INTEL_ID1030	0x1030
+#define PCI_DEVICE_ID_INTEL_ID1031	0x1031
+#define PCI_DEVICE_ID_INTEL_ID1038	0x1038
+#define PCI_DEVICE_ID_INTEL_ID1039	0x1039
+#define PCI_DEVICE_ID_INTEL_ID103A	0x103A
+#define PCI_DEVICE_ID_INTEL_82562ET	0x1031
+#define PCI_DEVICE_ID_INTEL_82559ER	0x1209
+#define PCI_DEVICE_ID_INTEL_82092AA_0	0x1221
+#define PCI_DEVICE_ID_INTEL_82092AA_1	0x1222
+#define PCI_DEVICE_ID_INTEL_7116	0x1223
+#define PCI_DEVICE_ID_INTEL_82596	0x1226
+#define PCI_DEVICE_ID_INTEL_82865	0x1227
+#define PCI_DEVICE_ID_INTEL_82557	0x1229
+#define PCI_DEVICE_ID_INTEL_82437	0x122d
+#define PCI_DEVICE_ID_INTEL_82371FB_0	0x122e
+#define PCI_DEVICE_ID_INTEL_82371FB_1	0x1230
+#define PCI_DEVICE_ID_INTEL_82371MX	0x1234
+#define PCI_DEVICE_ID_INTEL_82437MX	0x1235
+#define PCI_DEVICE_ID_INTEL_82441	0x1237
+#define PCI_DEVICE_ID_INTEL_82380FB	0x124b
+#define PCI_DEVICE_ID_INTEL_82439	0x1250
+#define PCI_DEVICE_ID_INTEL_80960_RP	0x1960
+#define PCI_DEVICE_ID_INTEL_82801AA_0	0x2410
+#define PCI_DEVICE_ID_INTEL_82801AA_1	0x2411
+#define PCI_DEVICE_ID_INTEL_82801AA_2	0x2412
+#define PCI_DEVICE_ID_INTEL_82801AA_3	0x2413
+#define PCI_DEVICE_ID_INTEL_82801AA_5	0x2415
+#define PCI_DEVICE_ID_INTEL_82801AA_6	0x2416
+#define PCI_DEVICE_ID_INTEL_82801AA_8	0x2418
+#define PCI_DEVICE_ID_INTEL_82801AB_0	0x2420
+#define PCI_DEVICE_ID_INTEL_82801AB_1	0x2421
+#define PCI_DEVICE_ID_INTEL_82801AB_2	0x2422
+#define PCI_DEVICE_ID_INTEL_82801AB_3	0x2423
+#define PCI_DEVICE_ID_INTEL_82801AB_5	0x2425
+#define PCI_DEVICE_ID_INTEL_82801AB_6	0x2426
+#define PCI_DEVICE_ID_INTEL_82801AB_8	0x2428
+#define PCI_DEVICE_ID_INTEL_82801BA_0	0x2440
+#define PCI_DEVICE_ID_INTEL_82801BA_1	0x2442
+#define PCI_DEVICE_ID_INTEL_82801BA_2	0x2443
+#define PCI_DEVICE_ID_INTEL_82801BA_3	0x2444
+#define PCI_DEVICE_ID_INTEL_82801BA_4	0x2445
+#define PCI_DEVICE_ID_INTEL_82801BA_5	0x2446
+#define PCI_DEVICE_ID_INTEL_82801BA_6	0x2448
+#define PCI_DEVICE_ID_INTEL_82801BA_7	0x2449
+#define PCI_DEVICE_ID_INTEL_82562	0x2449
+#define PCI_DEVICE_ID_INTEL_82801BA_8	0x244a
+#define PCI_DEVICE_ID_INTEL_82801BA_9	0x244b
+#define PCI_DEVICE_ID_INTEL_82801BA_10	0x244c
+#define PCI_DEVICE_ID_INTEL_82801BA_11	0x244e
+#define PCI_DEVICE_ID_INTEL_82801CA_0	0x2480
+#define PCI_DEVICE_ID_INTEL_82801CA_2	0x2482
+#define PCI_DEVICE_ID_INTEL_82801CA_3	0x2483
+#define PCI_DEVICE_ID_INTEL_82801CA_4	0x2484
+#define PCI_DEVICE_ID_INTEL_82801CA_5	0x2485
+#define PCI_DEVICE_ID_INTEL_82801CA_6	0x2486
+#define PCI_DEVICE_ID_INTEL_82801CA_7	0x2487
+#define PCI_DEVICE_ID_INTEL_82801CA_10	0x248a
+#define PCI_DEVICE_ID_INTEL_82801CA_11	0x248b
+#define PCI_DEVICE_ID_INTEL_82801CA_12	0x248c
+#define PCI_DEVICE_ID_INTEL_80310	0x530d
+#define PCI_DEVICE_ID_INTEL_82371SB_0	0x7000
+#define PCI_DEVICE_ID_INTEL_82371SB_1	0x7010
+#define PCI_DEVICE_ID_INTEL_82371SB_2	0x7020
+#define PCI_DEVICE_ID_INTEL_82437VX	0x7030
+#define PCI_DEVICE_ID_INTEL_82439TX	0x7100
+#define PCI_DEVICE_ID_INTEL_82371AB_0	0x7110
+#define PCI_DEVICE_ID_INTEL_82371AB	0x7111
+#define PCI_DEVICE_ID_INTEL_82371AB_2	0x7112
+#define PCI_DEVICE_ID_INTEL_82371AB_3	0x7113
+#define PCI_DEVICE_ID_INTEL_82810_MC1	0x7120
+#define PCI_DEVICE_ID_INTEL_82810_IG1	0x7121
+#define PCI_DEVICE_ID_INTEL_82810_MC3	0x7122
+#define PCI_DEVICE_ID_INTEL_82810_IG3	0x7123
+#define PCI_DEVICE_ID_INTEL_82443LX_0	0x7180
+#define PCI_DEVICE_ID_INTEL_82443LX_1	0x7181
+#define PCI_DEVICE_ID_INTEL_82443BX_0	0x7190
+#define PCI_DEVICE_ID_INTEL_82443BX_1	0x7191
+#define PCI_DEVICE_ID_INTEL_82443BX_2	0x7192
+#define PCI_DEVICE_ID_INTEL_82443MX_0	0x7198
+#define PCI_DEVICE_ID_INTEL_82443MX_1	0x7199
+#define PCI_DEVICE_ID_INTEL_82443MX_2	0x719a
+#define PCI_DEVICE_ID_INTEL_82443MX_3	0x719b
+#define PCI_DEVICE_ID_INTEL_82372FB_0	0x7600
+#define PCI_DEVICE_ID_INTEL_82372FB_1	0x7601
+#define PCI_DEVICE_ID_INTEL_82372FB_2	0x7602
+#define PCI_DEVICE_ID_INTEL_82372FB_3	0x7603
+#define PCI_DEVICE_ID_INTEL_82454GX	0x84c4
+#define PCI_DEVICE_ID_INTEL_82450GX	0x84c5
+#define PCI_DEVICE_ID_INTEL_82451NX	0x84ca
+
+#define PCI_VENDOR_ID_COMPUTONE		0x8e0e
+#define PCI_DEVICE_ID_COMPUTONE_IP2EX	0x0291
+#define PCI_DEVICE_ID_COMPUTONE_PG	0x0302
+#define PCI_SUBVENDOR_ID_COMPUTONE	0x8e0e
+#define PCI_SUBDEVICE_ID_COMPUTONE_PG4	0x0001
+#define PCI_SUBDEVICE_ID_COMPUTONE_PG8	0x0002
+#define PCI_SUBDEVICE_ID_COMPUTONE_PG6	0x0003
+
+#define PCI_VENDOR_ID_KTI		0x8e2e
+#define PCI_DEVICE_ID_KTI_ET32P2	0x3000
+
+#define PCI_VENDOR_ID_ADAPTEC		0x9004
+#define PCI_DEVICE_ID_ADAPTEC_7810	0x1078
+#define PCI_DEVICE_ID_ADAPTEC_7821	0x2178
+#define PCI_DEVICE_ID_ADAPTEC_38602	0x3860
+#define PCI_DEVICE_ID_ADAPTEC_7850	0x5078
+#define PCI_DEVICE_ID_ADAPTEC_7855	0x5578
+#define PCI_DEVICE_ID_ADAPTEC_5800	0x5800
+#define PCI_DEVICE_ID_ADAPTEC_3860	0x6038
+#define PCI_DEVICE_ID_ADAPTEC_1480A	0x6075
+#define PCI_DEVICE_ID_ADAPTEC_7860	0x6078
+#define PCI_DEVICE_ID_ADAPTEC_7861	0x6178
+#define PCI_DEVICE_ID_ADAPTEC_7870	0x7078
+#define PCI_DEVICE_ID_ADAPTEC_7871	0x7178
+#define PCI_DEVICE_ID_ADAPTEC_7872	0x7278
+#define PCI_DEVICE_ID_ADAPTEC_7873	0x7378
+#define PCI_DEVICE_ID_ADAPTEC_7874	0x7478
+#define PCI_DEVICE_ID_ADAPTEC_7895	0x7895
+#define PCI_DEVICE_ID_ADAPTEC_7880	0x8078
+#define PCI_DEVICE_ID_ADAPTEC_7881	0x8178
+#define PCI_DEVICE_ID_ADAPTEC_7882	0x8278
+#define PCI_DEVICE_ID_ADAPTEC_7883	0x8378
+#define PCI_DEVICE_ID_ADAPTEC_7884	0x8478
+#define PCI_DEVICE_ID_ADAPTEC_7885	0x8578
+#define PCI_DEVICE_ID_ADAPTEC_7886	0x8678
+#define PCI_DEVICE_ID_ADAPTEC_7887	0x8778
+#define PCI_DEVICE_ID_ADAPTEC_7888	0x8878
+#define PCI_DEVICE_ID_ADAPTEC_1030	0x8b78
+
+#define PCI_VENDOR_ID_ADAPTEC2		0x9005
+#define PCI_DEVICE_ID_ADAPTEC2_2940U2	0x0010
+#define PCI_DEVICE_ID_ADAPTEC2_2930U2	0x0011
+#define PCI_DEVICE_ID_ADAPTEC2_7890B	0x0013
+#define PCI_DEVICE_ID_ADAPTEC2_7890	0x001f
+#define PCI_DEVICE_ID_ADAPTEC2_3940U2	0x0050
+#define PCI_DEVICE_ID_ADAPTEC2_3950U2D	0x0051
+#define PCI_DEVICE_ID_ADAPTEC2_7896	0x005f
+#define PCI_DEVICE_ID_ADAPTEC2_7892A	0x0080
+#define PCI_DEVICE_ID_ADAPTEC2_7892B	0x0081
+#define PCI_DEVICE_ID_ADAPTEC2_7892D	0x0083
+#define PCI_DEVICE_ID_ADAPTEC2_7892P	0x008f
+#define PCI_DEVICE_ID_ADAPTEC2_7899A	0x00c0
+#define PCI_DEVICE_ID_ADAPTEC2_7899B	0x00c1
+#define PCI_DEVICE_ID_ADAPTEC2_7899D	0x00c3
+#define PCI_DEVICE_ID_ADAPTEC2_7899P	0x00cf
+
+#define PCI_VENDOR_ID_ATRONICS		0x907f
+#define PCI_DEVICE_ID_ATRONICS_2015	0x2015
+
+#define PCI_VENDOR_ID_HOLTEK2		0x9412
+#define PCI_DEVICE_ID_HOLTEK2_6565	0x6565
+
+#define PCI_VENDOR_ID_NETMOS		0x9710
+#define PCI_DEVICE_ID_NETMOS_9735	0x9735
+#define PCI_DEVICE_ID_NETMOS_9835	0x9835
+
+#define PCI_SUBVENDOR_ID_EXSYS		0xd84d
+#define PCI_SUBDEVICE_ID_EXSYS_4014	0x4014
+
+#define PCI_VENDOR_ID_TIGERJET		0xe159
+#define PCI_DEVICE_ID_TIGERJET_300	0x0001
+#define PCI_DEVICE_ID_TIGERJET_100	0x0002
+
+#define PCI_VENDOR_ID_ARK		0xedd8
+#define PCI_DEVICE_ID_ARK_STING		0xa091
+#define PCI_DEVICE_ID_ARK_STINGARK	0xa099
+#define PCI_DEVICE_ID_ARK_2000MT	0xa0a1
+
diff -Naur grub-0.97.orig/netboot/pci_io.c grub-0.97/netboot/pci_io.c
--- grub-0.97.orig/netboot/pci_io.c	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/pci_io.c	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,431 @@
+/*
+** Support for NE2000 PCI clones added David Monro June 1997
+** Generalised to other NICs by Ken Yap July 1997
+**
+** Most of this is taken from:
+**
+** /usr/src/linux/drivers/pci/pci.c
+** /usr/src/linux/include/linux/pci.h
+** /usr/src/linux/arch/i386/bios32.c
+** /usr/src/linux/include/linux/bios32.h
+** /usr/src/linux/drivers/net/ne.c
+*/
+#define PCBIOS
+#include "grub.h"
+#include "pci.h"
+
+#ifdef	CONFIG_PCI_DIRECT
+#define  PCIBIOS_SUCCESSFUL                0x00
+
+#define DEBUG 0
+
+/*
+ * Functions for accessing PCI configuration space with type 1 accesses
+ */
+
+#define CONFIG_CMD(bus, device_fn, where)   (0x80000000 | (bus << 16) | (device_fn << 8) | (where & ~3))
+
+int pcibios_read_config_byte(unsigned int bus, unsigned int device_fn,
+			       unsigned int where, uint8_t *value)
+{
+    outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
+    *value = inb(0xCFC + (where&3));
+    return PCIBIOS_SUCCESSFUL;
+}
+
+int pcibios_read_config_word (unsigned int bus,
+    unsigned int device_fn, unsigned int where, uint16_t *value)
+{
+    outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
+    *value = inw(0xCFC + (where&2));
+    return PCIBIOS_SUCCESSFUL;
+}
+
+int pcibios_read_config_dword (unsigned int bus, unsigned int device_fn,
+				 unsigned int where, uint32_t *value)
+{
+    outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
+    *value = inl(0xCFC);
+    return PCIBIOS_SUCCESSFUL;
+}
+
+int pcibios_write_config_byte (unsigned int bus, unsigned int device_fn,
+				 unsigned int where, uint8_t value)
+{
+    outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
+    outb(value, 0xCFC + (where&3));
+    return PCIBIOS_SUCCESSFUL;
+}
+
+int pcibios_write_config_word (unsigned int bus, unsigned int device_fn,
+				 unsigned int where, uint16_t value)
+{
+    outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
+    outw(value, 0xCFC + (where&2));
+    return PCIBIOS_SUCCESSFUL;
+}
+
+int pcibios_write_config_dword (unsigned int bus, unsigned int device_fn, unsigned int where, uint32_t value)
+{
+    outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
+    outl(value, 0xCFC);
+    return PCIBIOS_SUCCESSFUL;
+}
+
+#undef CONFIG_CMD
+
+#else	 /* CONFIG_PCI_DIRECT  not defined */
+
+#if !defined(PCBIOS)
+#error "The pcibios can only be used when the PCBIOS support is compiled in"
+#endif
+
+
+#define KERN_CODE_SEG 0X8
+/* Stuff for asm */
+#define save_flags(x) \
+__asm__ __volatile__("pushfl ; popl %0":"=g" (x): /* no input */ :"memory")
+
+#define cli() __asm__ __volatile__ ("cli": : :"memory")
+
+#define restore_flags(x) \
+__asm__ __volatile__("pushl %0 ; popfl": /* no output */ :"g" (x):"memory")
+
+
+
+static struct {
+	unsigned long address;
+	unsigned short segment;
+} bios32_indirect = { 0, KERN_CODE_SEG };
+
+static long pcibios_entry = 0;
+static struct {
+	unsigned long address;
+	unsigned short segment;
+} pci_indirect = { 0, KERN_CODE_SEG };
+
+static unsigned long bios32_service(unsigned long service)
+{
+	unsigned char return_code;	/* %al */
+	unsigned long address;		/* %ebx */
+	unsigned long length;		/* %ecx */
+	unsigned long entry;		/* %edx */
+	unsigned long flags;
+
+	save_flags(flags);
+	__asm__(
+#ifdef ABSOLUTE_WITHOUT_ASTERISK
+		"lcall (%%edi)"
+#else
+		"lcall *(%%edi)"
+#endif
+		: "=a" (return_code),
+		  "=b" (address),
+		  "=c" (length),
+		  "=d" (entry)
+		: "0" (service),
+		  "1" (0),
+		  "D" (&bios32_indirect));
+	restore_flags(flags);
+
+	switch (return_code) {
+		case 0:
+			return address + entry;
+		case 0x80:	/* Not present */
+			printf("bios32_service(%d) : not present\n", service);
+			return 0;
+		default: /* Shouldn't happen */
+			printf("bios32_service(%d) : returned %#X, mail drew@colorado.edu\n",
+				service, return_code);
+			return 0;
+	}
+}
+
+int pcibios_read_config_byte(unsigned int bus,
+        unsigned int device_fn, unsigned int where, uint8_t *value)
+{
+        unsigned long ret;
+        unsigned long bx = (bus << 8) | device_fn;
+        unsigned long flags;
+
+        save_flags(flags);
+        __asm__(
+#ifdef ABSOLUTE_WITHOUT_ASTERISK
+		"lcall (%%esi)\n\t"
+#else
+		"lcall *(%%esi)\n\t"
+#endif
+                "jc 1f\n\t"
+                "xor %%ah, %%ah\n"
+                "1:"
+                : "=c" (*value),
+                  "=a" (ret)
+                : "1" (PCIBIOS_READ_CONFIG_BYTE),
+                  "b" (bx),
+                  "D" ((long) where),
+                  "S" (&pci_indirect));
+        restore_flags(flags);
+        return (int) (ret & 0xff00) >> 8;
+}
+
+int pcibios_read_config_word(unsigned int bus,
+        unsigned int device_fn, unsigned int where, uint16_t *value)
+{
+        unsigned long ret;
+        unsigned long bx = (bus << 8) | device_fn;
+        unsigned long flags;
+
+        save_flags(flags);
+        __asm__(
+#ifdef ABSOLUTE_WITHOUT_ASTERISK
+		"lcall (%%esi)\n\t"
+#else
+		"lcall *(%%esi)\n\t"
+#endif
+                "jc 1f\n\t"
+                "xor %%ah, %%ah\n"
+                "1:"
+                : "=c" (*value),
+                  "=a" (ret)
+                : "1" (PCIBIOS_READ_CONFIG_WORD),
+                  "b" (bx),
+                  "D" ((long) where),
+                  "S" (&pci_indirect));
+        restore_flags(flags);
+        return (int) (ret & 0xff00) >> 8;
+}
+
+int pcibios_read_config_dword(unsigned int bus,
+        unsigned int device_fn, unsigned int where, uint32_t *value)
+{
+        unsigned long ret;
+        unsigned long bx = (bus << 8) | device_fn;
+        unsigned long flags;
+
+        save_flags(flags);
+        __asm__(
+#ifdef ABSOLUTE_WITHOUT_ASTERISK
+		"lcall (%%esi)\n\t"
+#else
+		"lcall *(%%esi)\n\t"
+#endif
+                "jc 1f\n\t"
+                "xor %%ah, %%ah\n"
+                "1:"
+                : "=c" (*value),
+                  "=a" (ret)
+                : "1" (PCIBIOS_READ_CONFIG_DWORD),
+                  "b" (bx),
+                  "D" ((long) where),
+                  "S" (&pci_indirect));
+        restore_flags(flags);
+        return (int) (ret & 0xff00) >> 8;
+}
+
+int pcibios_write_config_byte (unsigned int bus,
+	unsigned int device_fn, unsigned int where, uint8_t value)
+{
+	unsigned long ret;
+	unsigned long bx = (bus << 8) | device_fn;
+	unsigned long flags;
+
+	save_flags(flags); cli();
+	__asm__(
+#ifdef ABSOLUTE_WITHOUT_ASTERISK
+		"lcall (%%esi)\n\t"
+#else
+		"lcall *(%%esi)\n\t"
+#endif
+		"jc 1f\n\t"
+		"xor %%ah, %%ah\n"
+		"1:"
+		: "=a" (ret)
+		: "0" (PCIBIOS_WRITE_CONFIG_BYTE),
+		  "c" (value),
+		  "b" (bx),
+		  "D" ((long) where),
+		  "S" (&pci_indirect));
+	restore_flags(flags);
+	return (int) (ret & 0xff00) >> 8;
+}
+
+int pcibios_write_config_word (unsigned int bus,
+	unsigned int device_fn, unsigned int where, uint16_t value)
+{
+	unsigned long ret;
+	unsigned long bx = (bus << 8) | device_fn;
+	unsigned long flags;
+
+	save_flags(flags); cli();
+	__asm__(
+#ifdef ABSOLUTE_WITHOUT_ASTERISK
+		"lcall (%%esi)\n\t"
+#else
+		"lcall *(%%esi)\n\t"
+#endif
+		"jc 1f\n\t"
+		"xor %%ah, %%ah\n"
+		"1:"
+		: "=a" (ret)
+		: "0" (PCIBIOS_WRITE_CONFIG_WORD),
+		  "c" (value),
+		  "b" (bx),
+		  "D" ((long) where),
+		  "S" (&pci_indirect));
+	restore_flags(flags);
+	return (int) (ret & 0xff00) >> 8;
+}
+
+int pcibios_write_config_dword (unsigned int bus,
+	unsigned int device_fn, unsigned int where, uint32_t value)
+{
+	unsigned long ret;
+	unsigned long bx = (bus << 8) | device_fn;
+	unsigned long flags;
+
+	save_flags(flags); cli();
+	__asm__(
+#ifdef ABSOLUTE_WITHOUT_ASTERISK
+		"lcall (%%esi)\n\t"
+#else
+		"lcall *(%%esi)\n\t"
+#endif
+		"jc 1f\n\t"
+		"xor %%ah, %%ah\n"
+		"1:"
+		: "=a" (ret)
+		: "0" (PCIBIOS_WRITE_CONFIG_DWORD),
+		  "c" (value),
+		  "b" (bx),
+		  "D" ((long) where),
+		  "S" (&pci_indirect));
+	restore_flags(flags);
+	return (int) (ret & 0xff00) >> 8;
+}
+
+static void check_pcibios(void)
+{
+	unsigned long signature;
+	unsigned char present_status;
+	unsigned char major_revision;
+	unsigned char minor_revision;
+	unsigned long flags;
+	int pack;
+
+	if ((pcibios_entry = bios32_service(PCI_SERVICE))) {
+		pci_indirect.address = pcibios_entry;
+
+		save_flags(flags);
+		__asm__(
+#ifdef ABSOLUTE_WITHOUT_ASTERISK
+			"lcall (%%edi)\n\t"
+#else
+			"lcall *(%%edi)\n\t"
+#endif
+			"jc 1f\n\t"
+			"xor %%ah, %%ah\n"
+			"1:\tshl $8, %%eax\n\t"
+			"movw %%bx, %%ax"
+			: "=d" (signature),
+			  "=a" (pack)
+			: "1" (PCIBIOS_PCI_BIOS_PRESENT),
+			  "D" (&pci_indirect)
+			: "bx", "cx");
+		restore_flags(flags);
+
+		present_status = (pack >> 16) & 0xff;
+		major_revision = (pack >> 8) & 0xff;
+		minor_revision = pack & 0xff;
+		if (present_status || (signature != PCI_SIGNATURE)) {
+			printf("ERROR: BIOS32 says PCI BIOS, but no PCI "
+				"BIOS????\n");
+			pcibios_entry = 0;
+		}
+#if	DEBUG
+		if (pcibios_entry) {
+			printf ("pcibios_init : PCI BIOS revision %hhX.%hhX"
+				" entry at %#X\n", major_revision,
+				minor_revision, pcibios_entry);
+		}
+#endif
+	}
+}
+
+static void pcibios_init(void)
+{
+	union bios32 *check;
+	unsigned char sum;
+	int i, length;
+	unsigned long bios32_entry = 0;
+
+	EnterFunction("pcibios_init");
+	/*
+	 * Follow the standard procedure for locating the BIOS32 Service
+	 * directory by scanning the permissible address range from
+	 * 0xe0000 through 0xfffff for a valid BIOS32 structure.
+	 *
+	 */
+
+	for (check = (union bios32 *) 0xe0000; check <= (union bios32 *) 0xffff0; ++check) {
+		if (check->fields.signature != BIOS32_SIGNATURE)
+			continue;
+		length = check->fields.length * 16;
+		if (!length)
+			continue;
+		sum = 0;
+		for (i = 0; i < length ; ++i)
+			sum += check->chars[i];
+		if (sum != 0)
+			continue;
+		if (check->fields.revision != 0) {
+			printf("pcibios_init : unsupported revision %d at %#X, mail drew@colorado.edu\n",
+				check->fields.revision, check);
+			continue;
+		}
+#if	DEBUG
+		printf("pcibios_init : BIOS32 Service Directory "
+			"structure at %#X\n", check);
+#endif
+		if (!bios32_entry) {
+			if (check->fields.entry >= 0x100000) {
+				printf("pcibios_init: entry in high "
+					"memory, giving up\n");
+				return;
+			} else {
+				bios32_entry = check->fields.entry;
+#if	DEBUG
+				printf("pcibios_init : BIOS32 Service Directory"
+					" entry at %#X\n", bios32_entry);
+#endif
+				bios32_indirect.address = bios32_entry;
+			}
+		}
+	}
+	if (bios32_entry)
+		check_pcibios();
+	LeaveFunction("pcibios_init");
+}
+
+#endif	/* CONFIG_PCI_DIRECT not defined*/
+
+unsigned long pcibios_bus_base(unsigned int bus __unused)
+{
+	/* architecturally this must be 0 */
+	return 0;
+}
+
+void find_pci(int type, struct pci_device *dev)
+{
+	EnterFunction("find_pci");
+#ifndef	CONFIG_PCI_DIRECT
+	if (!pcibios_entry) {
+		pcibios_init();
+	}
+	if (!pcibios_entry) {
+		printf("pci_init: no BIOS32 detected\n");
+		return;
+	}
+#endif
+	LeaveFunction("find_pci");
+	return scan_pci_bus(type, dev);
+}
diff -Naur grub-0.97.orig/netboot/pcnet32.c grub-0.97/netboot/pcnet32.c
--- grub-0.97.orig/netboot/pcnet32.c	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/pcnet32.c	2005-08-31 22:57:50.000000000 +0000
@@ -0,0 +1,1004 @@
+/**************************************************************************
+*
+*    pcnet32.c -- Etherboot device driver for the AMD PCnet32
+*    Written 2003-2003 by Timothy Legge <tlegge@rogers.com>
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the License, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not, write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*    Portions of this code based on:
+*		pcnet32.c: An AMD PCnet32 ethernet driver for linux:
+*
+*	(C) 1996-1999 Thomas Bogendoerfer
+*		See Linux Driver for full information
+*	
+*	The transmit and poll functions were written with reference to:
+*	lance.c - LANCE NIC driver for Etherboot written by Ken Yap 
+*	
+*	Linux Driver Version 1.27a, 10.02.2002
+* 
+* 
+*    REVISION HISTORY:
+*    ================
+*    v1.0	08-06-2003	timlegge	Initial port of Linux driver
+*    v1.1	08-23-2003	timlegge	Add multicast support
+*    v1.2	01-17-2004	timlegge	Initial driver output cleanup
+*    v1.3	03-29-2004	timlegge	More driver cleanup
+*    
+*    Indent Options: indent -kr -i8
+***************************************************************************/
+
+/* to get some global routines like printf */
+#include "etherboot.h"
+/* to get the interface to the body of the program */
+#include "nic.h"
+/* to get the PCI support functions, if this is a PCI NIC */
+#include "pci.h"
+/* Include the time functions */
+#include "timer.h"
+#include "mii.h"
+/* void hex_dump(const char *data, const unsigned int len); */
+
+/* Etherboot Specific definations */
+#define drv_version "v1.3"
+#define drv_date "03-29-2004"
+
+typedef unsigned char u8;
+typedef signed char s8;
+typedef unsigned short u16;
+typedef signed short s16;
+typedef unsigned int u32;
+typedef signed int s32;
+
+static u32 ioaddr;		/* Globally used for the card's io address */
+
+#ifdef EDEBUG
+#define dprintf(x) printf x
+#else
+#define dprintf(x)
+#endif
+
+/* Condensed operations for readability. */
+#define virt_to_le32desc(addr)  cpu_to_le32(virt_to_bus(addr))
+#define le32desc_to_virt(addr)  bus_to_virt(le32_to_cpu(addr))
+
+/* End Etherboot Specific */
+
+int cards_found /* __initdata */ ;
+
+#ifdef REMOVE
+/* FIXME: Remove these they are probably pointless */
+
+/* 
+ * VLB I/O addresses 
+ */
+static unsigned int pcnet32_portlist[] /*__initdata */  =
+{ 0x300, 0x320, 0x340, 0x360, 0 };
+
+static int pcnet32_debug = 1;
+static int tx_start = 1;	/* Mapping -- 0:20, 1:64, 2:128, 3:~220 (depends on chip vers) */
+static int pcnet32vlb;		/* check for VLB cards ? */
+
+static struct net_device *pcnet32_dev;
+
+static int max_interrupt_work = 80;
+static int rx_copybreak = 200;
+#endif
+#define PCNET32_PORT_AUI      0x00
+#define PCNET32_PORT_10BT     0x01
+#define PCNET32_PORT_GPSI     0x02
+#define PCNET32_PORT_MII      0x03
+
+#define PCNET32_PORT_PORTSEL  0x03
+#define PCNET32_PORT_ASEL     0x04
+#define PCNET32_PORT_100      0x40
+#define PCNET32_PORT_FD	      0x80
+
+#define PCNET32_DMA_MASK 0xffffffff
+
+/*
+ * table to translate option values from tulip
+ * to internal options
+ */
+static unsigned char options_mapping[] = {
+	PCNET32_PORT_ASEL,	/*  0 Auto-select      */
+	PCNET32_PORT_AUI,	/*  1 BNC/AUI          */
+	PCNET32_PORT_AUI,	/*  2 AUI/BNC          */
+	PCNET32_PORT_ASEL,	/*  3 not supported    */
+	PCNET32_PORT_10BT | PCNET32_PORT_FD,	/*  4 10baseT-FD       */
+	PCNET32_PORT_ASEL,	/*  5 not supported    */
+	PCNET32_PORT_ASEL,	/*  6 not supported    */
+	PCNET32_PORT_ASEL,	/*  7 not supported    */
+	PCNET32_PORT_ASEL,	/*  8 not supported    */
+	PCNET32_PORT_MII,	/*  9 MII 10baseT      */
+	PCNET32_PORT_MII | PCNET32_PORT_FD,	/* 10 MII 10baseT-FD   */
+	PCNET32_PORT_MII,	/* 11 MII (autosel)    */
+	PCNET32_PORT_10BT,	/* 12 10BaseT          */
+	PCNET32_PORT_MII | PCNET32_PORT_100,	/* 13 MII 100BaseTx    */
+	PCNET32_PORT_MII | PCNET32_PORT_100 | PCNET32_PORT_FD,	/* 14 MII 100BaseTx-FD */
+	PCNET32_PORT_ASEL	/* 15 not supported    */
+};
+
+#define MAX_UNITS 8		/* More are supported, limit only on options */
+static int options[MAX_UNITS];
+static int full_duplex[MAX_UNITS];
+
+/*
+ *				Theory of Operation
+ * 
+ * This driver uses the same software structure as the normal lance
+ * driver. So look for a verbose description in lance.c. The differences
+ * to the normal lance driver is the use of the 32bit mode of PCnet32
+ * and PCnetPCI chips. Because these chips are 32bit chips, there is no
+ * 16MB limitation and we don't need bounce buffers.
+ */
+
+
+
+/*
+ * Set the number of Tx and Rx buffers, using Log_2(# buffers).
+ * Reasonable default values are 4 Tx buffers, and 16 Rx buffers.
+ * That translates to 2 (4 == 2^^2) and 4 (16 == 2^^4).
+ */
+#ifndef PCNET32_LOG_TX_BUFFERS
+#define PCNET32_LOG_TX_BUFFERS 1
+#define PCNET32_LOG_RX_BUFFERS 2
+#endif
+
+#define TX_RING_SIZE		(1 << (PCNET32_LOG_TX_BUFFERS))
+#define TX_RING_MOD_MASK	(TX_RING_SIZE - 1)
+/* FIXME: Fix this to allow multiple tx_ring descriptors */
+#define TX_RING_LEN_BITS	0x0000	/*PCNET32_LOG_TX_BUFFERS) << 12) */
+
+#define RX_RING_SIZE		(1 << (PCNET32_LOG_RX_BUFFERS))
+#define RX_RING_MOD_MASK	(RX_RING_SIZE - 1)
+#define RX_RING_LEN_BITS	((PCNET32_LOG_RX_BUFFERS) << 4)
+
+#define PKT_BUF_SZ		1544
+
+/* Offsets from base I/O address. */
+#define PCNET32_WIO_RDP		0x10
+#define PCNET32_WIO_RAP		0x12
+#define PCNET32_WIO_RESET	0x14
+#define PCNET32_WIO_BDP		0x16
+
+#define PCNET32_DWIO_RDP	0x10
+#define PCNET32_DWIO_RAP	0x14
+#define PCNET32_DWIO_RESET	0x18
+#define PCNET32_DWIO_BDP	0x1C
+
+#define PCNET32_TOTAL_SIZE	0x20
+
+/* Buffers for the tx and Rx */
+
+/* Create a static buffer of size PKT_BUF_SZ for each
+TX Descriptor.  All descriptors point to a
+part of this buffer */
+static unsigned char txb[PKT_BUF_SZ * TX_RING_SIZE];
+//    __attribute__ ((aligned(16)));
+
+/* Create a static buffer of size PKT_BUF_SZ for each
+RX Descriptor   All descriptors point to a
+part of this buffer */
+static unsigned char rxb[RX_RING_SIZE * PKT_BUF_SZ];
+//    __attribute__ ((aligned(16)));
+
+/* The PCNET32 Rx and Tx ring descriptors. */
+struct pcnet32_rx_head {
+	u32 base;
+	s16 buf_length;
+	s16 status;
+	u32 msg_length;
+	u32 reserved;
+};
+
+struct pcnet32_tx_head {
+	u32 base;
+	s16 length;
+	s16 status;
+	u32 misc;
+	u32 reserved;
+};
+
+/* The PCNET32 32-Bit initialization block, described in databook. */
+struct pcnet32_init_block {
+	u16 mode;
+	u16 tlen_rlen;
+	u8 phys_addr[6];
+	u16 reserved;
+	u32 filter[2];
+	/* Receive and transmit ring base, along with extra bits. */
+	u32 rx_ring;
+	u32 tx_ring;
+};
+/* PCnet32 access functions */
+struct pcnet32_access {
+	u16(*read_csr) (unsigned long, int);
+	void (*write_csr) (unsigned long, int, u16);
+	 u16(*read_bcr) (unsigned long, int);
+	void (*write_bcr) (unsigned long, int, u16);
+	 u16(*read_rap) (unsigned long);
+	void (*write_rap) (unsigned long, u16);
+	void (*reset) (unsigned long);
+};
+
+/* Define the TX Descriptor */
+static struct pcnet32_tx_head tx_ring[TX_RING_SIZE]
+    __attribute__ ((aligned(16)));
+
+
+/* Define the RX Descriptor */
+static struct pcnet32_rx_head rx_ring[RX_RING_SIZE]
+    __attribute__ ((aligned(16)));
+
+/* May need to be moved to mii.h */
+struct mii_if_info {
+	int phy_id;
+	int advertising;
+	unsigned int full_duplex:1;	/* is full duplex? */
+};
+
+/*
+ * The first three fields of pcnet32_private are read by the ethernet device 
+ * so we allocate the structure should be allocated by pci_alloc_consistent().
+ */
+#define MII_CNT 4
+struct pcnet32_private {
+	struct pcnet32_init_block init_block;
+	struct pci_dev *pci_dev;	/* Pointer to the associated pci device structure */
+	const char *name;
+	/* The saved address of a sent-in-place packet/buffer, for skfree(). */
+	struct sk_buff *tx_skbuff[TX_RING_SIZE];
+	struct sk_buff *rx_skbuff[RX_RING_SIZE];
+	struct pcnet32_access a;
+	unsigned int cur_rx, cur_tx;	/* The next free ring entry */
+	char tx_full;
+	int options;
+	int shared_irq:1,	/* shared irq possible */
+	 ltint:1,		/* enable TxDone-intr inhibitor */
+	 dxsuflo:1,		/* disable transmit stop on uflo */
+	 mii:1;			/* mii port available */
+	struct mii_if_info mii_if;
+	unsigned char phys[MII_CNT];
+	struct net_device *next;
+	int full_duplex:1;
+} lpx;
+
+static struct pcnet32_private *lp;
+
+static int mdio_read(struct nic *nic __unused, int phy_id, int reg_num);
+#if 0
+static void mdio_write(struct nic *nic __unused, int phy_id, int reg_num,
+		       int val);
+#endif
+enum pci_flags_bit {
+	PCI_USES_IO = 1, PCI_USES_MEM = 2, PCI_USES_MASTER = 4,
+	PCI_ADDR0 = 0x10 << 0, PCI_ADDR1 = 0x10 << 1, PCI_ADDR2 =
+	    0x10 << 2, PCI_ADDR3 = 0x10 << 3,
+};
+
+
+static u16 pcnet32_wio_read_csr(unsigned long addr, int index)
+{
+	outw(index, addr + PCNET32_WIO_RAP);
+	return inw(addr + PCNET32_WIO_RDP);
+}
+
+static void pcnet32_wio_write_csr(unsigned long addr, int index, u16 val)
+{
+	outw(index, addr + PCNET32_WIO_RAP);
+	outw(val, addr + PCNET32_WIO_RDP);
+}
+
+static u16 pcnet32_wio_read_bcr(unsigned long addr, int index)
+{
+	outw(index, addr + PCNET32_WIO_RAP);
+	return inw(addr + PCNET32_WIO_BDP);
+}
+
+static void pcnet32_wio_write_bcr(unsigned long addr, int index, u16 val)
+{
+	outw(index, addr + PCNET32_WIO_RAP);
+	outw(val, addr + PCNET32_WIO_BDP);
+}
+
+static u16 pcnet32_wio_read_rap(unsigned long addr)
+{
+	return inw(addr + PCNET32_WIO_RAP);
+}
+
+static void pcnet32_wio_write_rap(unsigned long addr, u16 val)
+{
+	outw(val, addr + PCNET32_WIO_RAP);
+}
+
+static void pcnet32_wio_reset(unsigned long addr)
+{
+	inw(addr + PCNET32_WIO_RESET);
+}
+
+static int pcnet32_wio_check(unsigned long addr)
+{
+	outw(88, addr + PCNET32_WIO_RAP);
+	return (inw(addr + PCNET32_WIO_RAP) == 88);
+}
+
+static struct pcnet32_access pcnet32_wio = {
+      read_csr:pcnet32_wio_read_csr,
+      write_csr:pcnet32_wio_write_csr,
+      read_bcr:pcnet32_wio_read_bcr,
+      write_bcr:pcnet32_wio_write_bcr,
+      read_rap:pcnet32_wio_read_rap,
+      write_rap:pcnet32_wio_write_rap,
+      reset:pcnet32_wio_reset
+};
+
+static u16 pcnet32_dwio_read_csr(unsigned long addr, int index)
+{
+	outl(index, addr + PCNET32_DWIO_RAP);
+	return (inl(addr + PCNET32_DWIO_RDP) & 0xffff);
+}
+
+static void pcnet32_dwio_write_csr(unsigned long addr, int index, u16 val)
+{
+	outl(index, addr + PCNET32_DWIO_RAP);
+	outl(val, addr + PCNET32_DWIO_RDP);
+}
+
+static u16 pcnet32_dwio_read_bcr(unsigned long addr, int index)
+{
+	outl(index, addr + PCNET32_DWIO_RAP);
+	return (inl(addr + PCNET32_DWIO_BDP) & 0xffff);
+}
+
+static void pcnet32_dwio_write_bcr(unsigned long addr, int index, u16 val)
+{
+	outl(index, addr + PCNET32_DWIO_RAP);
+	outl(val, addr + PCNET32_DWIO_BDP);
+}
+
+static u16 pcnet32_dwio_read_rap(unsigned long addr)
+{
+	return (inl(addr + PCNET32_DWIO_RAP) & 0xffff);
+}
+
+static void pcnet32_dwio_write_rap(unsigned long addr, u16 val)
+{
+	outl(val, addr + PCNET32_DWIO_RAP);
+}
+
+static void pcnet32_dwio_reset(unsigned long addr)
+{
+	inl(addr + PCNET32_DWIO_RESET);
+}
+
+static int pcnet32_dwio_check(unsigned long addr)
+{
+	outl(88, addr + PCNET32_DWIO_RAP);
+	return ((inl(addr + PCNET32_DWIO_RAP) & 0xffff) == 88);
+}
+
+static struct pcnet32_access pcnet32_dwio = {
+      read_csr:pcnet32_dwio_read_csr,
+      write_csr:pcnet32_dwio_write_csr,
+      read_bcr:pcnet32_dwio_read_bcr,
+      write_bcr:pcnet32_dwio_write_bcr,
+      read_rap:pcnet32_dwio_read_rap,
+      write_rap:pcnet32_dwio_write_rap,
+      reset:pcnet32_dwio_reset
+};
+
+
+/* Initialize the PCNET32 Rx and Tx rings. */
+static int pcnet32_init_ring(struct nic *nic)
+{
+	int i;
+
+	lp->tx_full = 0;
+	lp->cur_rx = lp->cur_tx = 0;
+
+	for (i = 0; i < RX_RING_SIZE; i++) {
+		rx_ring[i].base = (u32) virt_to_le32desc(&rxb[i]);
+		rx_ring[i].buf_length = le16_to_cpu(-PKT_BUF_SZ);
+		rx_ring[i].status = le16_to_cpu(0x8000);
+	}
+
+	/* The Tx buffer address is filled in as needed, but we do need to clear
+	   the upper ownership bit. */
+	for (i = 0; i < TX_RING_SIZE; i++) {
+		tx_ring[i].base = 0;
+		tx_ring[i].status = 0;
+	}
+
+
+	lp->init_block.tlen_rlen =
+	    le16_to_cpu(TX_RING_LEN_BITS | RX_RING_LEN_BITS);
+	for (i = 0; i < 6; i++)
+		lp->init_block.phys_addr[i] = nic->node_addr[i];
+	lp->init_block.rx_ring = (u32) virt_to_le32desc(&rx_ring[0]);
+	lp->init_block.tx_ring = (u32) virt_to_le32desc(&tx_ring[0]);
+	return 0;
+}
+
+/**************************************************************************
+RESET - Reset adapter
+***************************************************************************/
+static void pcnet32_reset(struct nic *nic)
+{
+	/* put the card in its initial state */
+	u16 val;
+	int i;
+
+	/* Reset the PCNET32 */
+	lp->a.reset(ioaddr);
+
+	/* switch pcnet32 to 32bit mode */
+	lp->a.write_bcr(ioaddr, 20, 2);
+
+	/* set/reset autoselect bit */
+	val = lp->a.read_bcr(ioaddr, 2) & ~2;
+	if (lp->options & PCNET32_PORT_ASEL)
+		val |= 2;
+	lp->a.write_bcr(ioaddr, 2, val);
+	/* handle full duplex setting */
+	if (lp->full_duplex) {
+		val = lp->a.read_bcr(ioaddr, 9) & ~3;
+		if (lp->options & PCNET32_PORT_FD) {
+			val |= 1;
+			if (lp->options ==
+			    (PCNET32_PORT_FD | PCNET32_PORT_AUI))
+				val |= 2;
+		} else if (lp->options & PCNET32_PORT_ASEL) {
+			/* workaround of xSeries250, turn on for 79C975 only */
+			i = ((lp->a.
+			      read_csr(ioaddr,
+				       88) | (lp->a.read_csr(ioaddr,
+							     89) << 16)) >>
+			     12) & 0xffff;
+			if (i == 0x2627)
+				val |= 3;
+		}
+		lp->a.write_bcr(ioaddr, 9, val);
+	}
+
+	/* set/reset GPSI bit in test register */
+	val = lp->a.read_csr(ioaddr, 124) & ~0x10;
+	if ((lp->options & PCNET32_PORT_PORTSEL) == PCNET32_PORT_GPSI)
+		val |= 0x10;
+	lp->a.write_csr(ioaddr, 124, val);
+
+	if (lp->mii && !(lp->options & PCNET32_PORT_ASEL)) {
+		val = lp->a.read_bcr(ioaddr, 32) & ~0x38;	/* disable Auto Negotiation, set 10Mpbs, HD */
+		if (lp->options & PCNET32_PORT_FD)
+			val |= 0x10;
+		if (lp->options & PCNET32_PORT_100)
+			val |= 0x08;
+		lp->a.write_bcr(ioaddr, 32, val);
+	} else {
+		if (lp->options & PCNET32_PORT_ASEL) {	/* enable auto negotiate, setup, disable fd */
+			val = lp->a.read_bcr(ioaddr, 32) & ~0x98;
+			val |= 0x20;
+			lp->a.write_bcr(ioaddr, 32, val);
+		}
+	}
+
+#ifdef DO_DXSUFLO
+	if (lp->dxsuflo) {	/* Disable transmit stop on underflow */
+		val = lp->a.read_csr(ioaddr, 3);
+		val |= 0x40;
+		lp->a.write_csr(ioaddr, 3, val);
+	}
+#endif
+
+	if (lp->ltint) {	/* Enable TxDone-intr inhibitor */
+		val = lp->a.read_csr(ioaddr, 5);
+		val |= (1 << 14);
+		lp->a.write_csr(ioaddr, 5, val);
+	}
+	lp->init_block.mode =
+	    le16_to_cpu((lp->options & PCNET32_PORT_PORTSEL) << 7);
+	lp->init_block.filter[0] = 0xffffffff;
+	lp->init_block.filter[1] = 0xffffffff;
+
+	pcnet32_init_ring(nic);
+
+
+	/* Re-initialize the PCNET32, and start it when done. */
+	lp->a.write_csr(ioaddr, 1,
+			(virt_to_bus(&lp->init_block)) & 0xffff);
+	lp->a.write_csr(ioaddr, 2, (virt_to_bus(&lp->init_block)) >> 16);
+	lp->a.write_csr(ioaddr, 4, 0x0915);
+	lp->a.write_csr(ioaddr, 0, 0x0001);
+
+
+	i = 0;
+	while (i++ < 100)
+		if (lp->a.read_csr(ioaddr, 0) & 0x0100)
+			break;
+	/* 
+	 * We used to clear the InitDone bit, 0x0100, here but Mark Stockton
+	 * reports that doing so triggers a bug in the '974.
+	 */
+	lp->a.write_csr(ioaddr, 0, 0x0042);
+
+	dprintf(("pcnet32 open, csr0 %hX.\n", lp->a.read_csr(ioaddr, 0)));
+
+}
+
+/**************************************************************************
+POLL - Wait for a frame
+***************************************************************************/
+static int pcnet32_poll(struct nic *nic __unused, int retrieve)
+{
+	/* return true if there's an ethernet packet ready to read */
+	/* nic->packet should contain data on return */
+	/* nic->packetlen should contain length of data */
+
+	int status;
+	int entry;
+
+	entry = lp->cur_rx & RX_RING_MOD_MASK;
+	status = ((short) le16_to_cpu(rx_ring[entry].status) >> 8);
+
+	if (status < 0)
+		return 0;
+
+	if ( ! retrieve ) return 1;
+
+	if (status == 0x03) {
+		nic->packetlen =
+		    (le32_to_cpu(rx_ring[entry].msg_length) & 0xfff) - 4;
+		memcpy(nic->packet, &rxb[entry], nic->packetlen);
+
+		/* Andrew Boyd of QNX reports that some revs of the 79C765
+		 * clear the buffer length */
+		rx_ring[entry].buf_length = le16_to_cpu(-PKT_BUF_SZ);
+		rx_ring[entry].status |= le16_to_cpu(0x8000);	/* prime for next receive */
+		/* Switch to the next Rx ring buffer */
+		lp->cur_rx++;
+
+	} else {
+		return 0;
+	}
+
+	return 1;
+}
+
+/**************************************************************************
+TRANSMIT - Transmit a frame
+***************************************************************************/
+static void pcnet32_transmit(struct nic *nic __unused, const char *d,	/* Destination */
+			     unsigned int t,	/* Type */
+			     unsigned int s,	/* size */
+			     const char *p)
+{				/* Packet */
+	/* send the packet to destination */
+	unsigned long time;
+	u8 *ptxb;
+	u16 nstype;
+	u16 status;
+	int entry = 0;		/*lp->cur_tx & TX_RING_MOD_MASK; */
+
+	status = 0x8300;
+	/* point to the current txb incase multiple tx_rings are used */
+	ptxb = txb + (lp->cur_tx * PKT_BUF_SZ);
+
+	/* copy the packet to ring buffer */
+	memcpy(ptxb, d, ETH_ALEN);	/* dst */
+	memcpy(ptxb + ETH_ALEN, nic->node_addr, ETH_ALEN);	/* src */
+	nstype = htons((u16) t);	/* type */
+	memcpy(ptxb + 2 * ETH_ALEN, (u8 *) & nstype, 2);	/* type */
+	memcpy(ptxb + ETH_HLEN, p, s);
+
+	s += ETH_HLEN;
+	while (s < ETH_ZLEN)	/* pad to min length */
+		ptxb[s++] = '\0';
+
+	tx_ring[entry].length = le16_to_cpu(-s);
+	tx_ring[entry].misc = 0x00000000;
+	tx_ring[entry].base = (u32) virt_to_le32desc(ptxb);
+
+	/* we set the top byte as the very last thing */
+	tx_ring[entry].status = le16_to_cpu(status);
+
+
+	/* Trigger an immediate send poll */
+	lp->a.write_csr(ioaddr, 0, 0x0048);
+
+	/* wait for transmit complete */
+	lp->cur_tx = 0;		/* (lp->cur_tx + 1); */
+	time = currticks() + TICKS_PER_SEC;	/* wait one second */
+	while (currticks() < time &&
+	       ((short) le16_to_cpu(tx_ring[entry].status) < 0));
+
+	if ((short) le16_to_cpu(tx_ring[entry].status) < 0)
+		printf("PCNET32 timed out on transmit\n");
+
+	/* Stop pointing at the current txb
+	 * otherwise the card continues to send the packet */
+	tx_ring[entry].base = 0;
+
+}
+
+/**************************************************************************
+DISABLE - Turn off ethernet interface
+***************************************************************************/
+static void pcnet32_disable(struct dev *dev __unused)
+{
+	/* Stop the PCNET32 here -- it ocassionally polls memory if we don't */
+	lp->a.write_csr(ioaddr, 0, 0x0004);
+
+	/*
+	 * Switch back to 16-bit mode to avoid problesm with dumb 
+	 * DOS packet driver after a warm reboot
+	 */
+	lp->a.write_bcr(ioaddr, 20, 4);
+}
+
+/**************************************************************************
+IRQ - Enable, Disable, or Force interrupts
+***************************************************************************/
+static void pcnet32_irq(struct nic *nic __unused, irq_action_t action __unused)
+{
+  switch ( action ) {
+  case DISABLE :
+    break;
+  case ENABLE :
+    break;
+  case FORCE :
+    break;
+  }
+}
+
+/**************************************************************************
+PROBE - Look for an adapter, this routine's visible to the outside
+You should omit the last argument struct pci_device * for a non-PCI NIC
+***************************************************************************/
+static int pcnet32_probe(struct dev *dev, struct pci_device *pci)
+{
+	struct nic *nic = (struct nic *) dev;
+	int i, media;
+	int fdx, mii, fset, dxsuflo, ltint;
+	int chip_version;
+	char *chipname;
+	struct pcnet32_access *a = NULL;
+	u8 promaddr[6];
+
+	int shared = 1;
+	if (pci->ioaddr == 0)
+		return 0;
+
+	/* BASE is used throughout to address the card */
+	ioaddr = pci->ioaddr;
+	printf("pcnet32.c: Found %s, Vendor=0x%hX Device=0x%hX\n",
+	       pci->name, pci->vendor, pci->dev_id);
+
+	nic->irqno  = 0;
+	nic->ioaddr = pci->ioaddr & ~3;
+
+	/* reset the chip */
+	pcnet32_wio_reset(ioaddr);
+
+	/* NOTE: 16-bit check is first, otherwise some older PCnet chips fail */
+	if (pcnet32_wio_read_csr(ioaddr, 0) == 4
+	    && pcnet32_wio_check(ioaddr)) {
+		a = &pcnet32_wio;
+	} else {
+		pcnet32_dwio_reset(ioaddr);
+		if (pcnet32_dwio_read_csr(ioaddr, 0) == 4
+		    && pcnet32_dwio_check(ioaddr)) {
+			a = &pcnet32_dwio;
+		} else
+			return 0;
+	}
+
+	chip_version =
+	    a->read_csr(ioaddr, 88) | (a->read_csr(ioaddr, 89) << 16);
+
+	dprintf(("PCnet chip version is %0xhX\n", chip_version));
+	if ((chip_version & 0xfff) != 0x003)
+		return 0;
+
+	/* initialize variables */
+	fdx = mii = fset = dxsuflo = ltint = 0;
+	chip_version = (chip_version >> 12) & 0xffff;
+
+	switch (chip_version) {
+	case 0x2420:
+		chipname = "PCnet/PCI 79C970";	/* PCI */
+		break;
+	case 0x2430:
+		if (shared)
+			chipname = "PCnet/PCI 79C970";	/* 970 gives the wrong chip id back */
+		else
+			chipname = "PCnet/32 79C965";	/* 486/VL bus */
+		break;
+	case 0x2621:
+		chipname = "PCnet/PCI II 79C970A";	/* PCI */
+		fdx = 1;
+		break;
+	case 0x2623:
+		chipname = "PCnet/FAST 79C971";	/* PCI */
+		fdx = 1;
+		mii = 1;
+		fset = 1;
+		ltint = 1;
+		break;
+	case 0x2624:
+		chipname = "PCnet/FAST+ 79C972";	/* PCI */
+		fdx = 1;
+		mii = 1;
+		fset = 1;
+		break;
+	case 0x2625:
+		chipname = "PCnet/FAST III 79C973";	/* PCI */
+		fdx = 1;
+		mii = 1;
+		break;
+	case 0x2626:
+		chipname = "PCnet/Home 79C978";	/* PCI */
+		fdx = 1;
+		/* 
+		 * This is based on specs published at www.amd.com.  This section
+		 * assumes that a card with a 79C978 wants to go into 1Mb HomePNA
+		 * mode.  The 79C978 can also go into standard ethernet, and there
+		 * probably should be some sort of module option to select the
+		 * mode by which the card should operate
+		 */
+		/* switch to home wiring mode */
+		media = a->read_bcr(ioaddr, 49);
+
+		printf("media reset to %#x.\n", media);
+		a->write_bcr(ioaddr, 49, media);
+		break;
+	case 0x2627:
+		chipname = "PCnet/FAST III 79C975";	/* PCI */
+		fdx = 1;
+		mii = 1;
+		break;
+	default:
+		printf("PCnet version %#x, no PCnet32 chip.\n",
+		       chip_version);
+		return 0;
+	}
+
+	/*
+	 *  On selected chips turn on the BCR18:NOUFLO bit. This stops transmit
+	 *  starting until the packet is loaded. Strike one for reliability, lose
+	 *  one for latency - although on PCI this isnt a big loss. Older chips 
+	 *  have FIFO's smaller than a packet, so you can't do this.
+	 */
+
+	if (fset) {
+		a->write_bcr(ioaddr, 18,
+			     (a->read_bcr(ioaddr, 18) | 0x0800));
+		a->write_csr(ioaddr, 80,
+			     (a->read_csr(ioaddr, 80) & 0x0C00) | 0x0c00);
+		dxsuflo = 1;
+		ltint = 1;
+	}
+
+	dprintf(("%s at %hX,", chipname, ioaddr));
+
+	/* read PROM address */
+	for (i = 0; i < 6; i++)
+		promaddr[i] = inb(ioaddr + i);
+
+	/* Update the nic structure with the MAC Address */
+	for (i = 0; i < ETH_ALEN; i++) {
+		nic->node_addr[i] = promaddr[i];
+	}
+	/* Print out some hardware info */
+	printf("%s: %! at ioaddr %hX, ", pci->name, nic->node_addr,
+	       ioaddr);
+
+	/* Set to pci bus master */
+	adjust_pci_device(pci);
+
+	/* point to private storage */
+	lp = &lpx;
+
+#if EBDEBUG
+	if (((chip_version + 1) & 0xfffe) == 0x2624) {	/* Version 0x2623 or 0x2624 */
+		i = a->read_csr(ioaddr, 80) & 0x0C00;	/* Check tx_start_pt */
+		dprintf(("    tx_start_pt(0x%hX):", i));
+		switch (i >> 10) {
+		case 0:
+			dprintf(("  20 bytes,"));
+			break;
+		case 1:
+			dprintf(("  64 bytes,"));
+			break;
+		case 2:
+			dprintf((" 128 bytes,"));
+			break;
+		case 3:
+			dprintf(("~220 bytes,"));
+			break;
+		}
+		i = a->read_bcr(ioaddr, 18);	/* Check Burst/Bus control */
+		dprintf((" BCR18(%hX):", i & 0xffff));
+		if (i & (1 << 5))
+			dprintf(("BurstWrEn "));
+		if (i & (1 << 6))
+			dprintf(("BurstRdEn "));
+		if (i & (1 << 7))
+			dprintf(("DWordIO "));
+		if (i & (1 << 11))
+			dprintf(("NoUFlow "));
+		i = a->read_bcr(ioaddr, 25);
+		dprintf(("    SRAMSIZE=0x%hX,", i << 8));
+		i = a->read_bcr(ioaddr, 26);
+		dprintf((" SRAM_BND=0x%hX,", i << 8));
+		i = a->read_bcr(ioaddr, 27);
+		if (i & (1 << 14))
+			dprintf(("LowLatRx"));
+	}
+#endif
+	lp->name = chipname;
+	lp->shared_irq = shared;
+	lp->full_duplex = fdx;
+	lp->dxsuflo = dxsuflo;
+	lp->ltint = ltint;
+	lp->mii = mii;
+	/* FIXME: Fix Options for only one card */
+	if ((cards_found >= MAX_UNITS)
+	    || ((unsigned int) options[cards_found] > sizeof(options_mapping)))
+		lp->options = PCNET32_PORT_ASEL;
+	else
+		lp->options = options_mapping[options[cards_found]];
+
+	if (fdx && !(lp->options & PCNET32_PORT_ASEL) &&
+	    ((cards_found >= MAX_UNITS) || full_duplex[cards_found]))
+		lp->options |= PCNET32_PORT_FD;
+
+	if (!a) {
+		printf("No access methods\n");
+		return 0;
+	}
+	lp->a = *a;
+
+	/* detect special T1/E1 WAN card by checking for MAC address */
+	if (nic->node_addr[0] == 0x00 && nic->node_addr[1] == 0xe0
+	    && nic->node_addr[2] == 0x75)
+		lp->options = PCNET32_PORT_FD | PCNET32_PORT_GPSI;
+
+	lp->init_block.mode = le16_to_cpu(0x0003);	/* Disable Rx and Tx. */
+	lp->init_block.tlen_rlen =
+	    le16_to_cpu(TX_RING_LEN_BITS | RX_RING_LEN_BITS);
+	for (i = 0; i < 6; i++)
+		lp->init_block.phys_addr[i] = nic->node_addr[i];
+	lp->init_block.filter[0] = 0xffffffff;
+	lp->init_block.filter[1] = 0xffffffff;
+	lp->init_block.rx_ring = virt_to_bus(&rx_ring);
+	lp->init_block.tx_ring = virt_to_bus(&tx_ring);
+
+	/* switch pcnet32 to 32bit mode */
+	a->write_bcr(ioaddr, 20, 2);
+
+
+	a->write_csr(ioaddr, 1, (virt_to_bus(&lp->init_block)) & 0xffff);
+	a->write_csr(ioaddr, 2, (virt_to_bus(&lp->init_block)) >> 16);
+
+	/* 
+	 * To auto-IRQ we enable the initialization-done and DMA error
+	 * interrupts. For ISA boards we get a DMA error, but VLB and PCI
+	 * boards will work.
+	 */
+	/* Trigger an initialization just for the interrupt. */
+
+	a->write_csr(ioaddr, 0, 0x41);
+	mdelay(1);
+
+	cards_found++;
+
+	/* point to NIC specific routines */
+	pcnet32_reset(nic);
+	if (1) {
+	        int tmp;
+		int phy, phy_idx = 0;
+		u16 mii_lpa;
+		lp->phys[0] = 1;	/* Default Setting */
+		for (phy = 1; phy < 32 && phy_idx < MII_CNT; phy++) {
+			int mii_status = mdio_read(nic, phy, MII_BMSR);
+			if (mii_status != 0xffff && mii_status != 0x0000) {
+				lp->phys[phy_idx++] = phy;
+				lp->mii_if.advertising =
+				    mdio_read(nic, phy, MII_ADVERTISE);
+				if ((mii_status & 0x0040) == 0) {
+				  tmp = phy;
+				  dprintf (("MII PHY found at address %d, status " 
+					    "%hX advertising %hX\n", phy, mii_status, 
+					    lp->mii_if.advertising));
+				}
+			}
+		}
+		if (phy_idx == 0)
+			printf("No MII transceiver found!\n");
+		lp->mii_if.phy_id = lp->phys[0];
+
+		lp->mii_if.advertising =
+		    mdio_read(nic, lp->phys[0], MII_ADVERTISE);
+
+		mii_lpa = mdio_read(nic, lp->phys[0], MII_LPA);
+		lp->mii_if.advertising &= mii_lpa;
+		if (lp->mii_if.advertising & ADVERTISE_100FULL)
+			printf("100Mbps Full-Duplex\n");
+		else if (lp->mii_if.advertising & ADVERTISE_100HALF)
+			printf("100Mbps Half-Duplex\n");
+		else if (lp->mii_if.advertising & ADVERTISE_10FULL)
+			printf("10Mbps Full-Duplex\n");
+		else if (lp->mii_if.advertising & ADVERTISE_10HALF)
+			printf("10Mbps Half-Duplex\n");
+		else
+			printf("\n");
+	}
+
+	nic->poll     = pcnet32_poll;
+	nic->transmit = pcnet32_transmit;
+	dev->disable  = pcnet32_disable;
+	nic->irq      = pcnet32_irq;
+
+	return 1;
+}
+static int mdio_read(struct nic *nic __unused, int phy_id, int reg_num)
+{
+	u16 val_out;
+	int phyaddr;
+
+	if (!lp->mii)
+		return 0;
+
+	phyaddr = lp->a.read_bcr(ioaddr, 33);
+
+	lp->a.write_bcr(ioaddr, 33,
+			((phy_id & 0x1f) << 5) | (reg_num & 0x1f));
+	val_out = lp->a.read_bcr(ioaddr, 34);
+	lp->a.write_bcr(ioaddr, 33, phyaddr);
+
+	return val_out;
+}
+
+#if 0
+static void mdio_write(struct nic *nic __unused, int phy_id, int reg_num,
+		       int val)
+{
+	int phyaddr;
+
+	if (!lp->mii)
+		return;
+
+	phyaddr = lp->a.read_bcr(ioaddr, 33);
+
+	lp->a.write_bcr(ioaddr, 33,
+			((phy_id & 0x1f) << 5) | (reg_num & 0x1f));
+	lp->a.write_bcr(ioaddr, 34, val);
+	lp->a.write_bcr(ioaddr, 33, phyaddr);
+}
+#endif
+
+static struct pci_id pcnet32_nics[] = {
+	PCI_ROM(0x1022, 0x2000, "lancepci", "AMD Lance/PCI"),
+	PCI_ROM(0x1022, 0x2625, "pcnetfastiii", "AMD Lance/PCI PCNet/32"),
+	PCI_ROM(0x1022, 0x2001, "amdhomepna", "AMD Lance/HomePNA"),
+};
+
+struct pci_driver pcnet32_driver = {
+	.type = NIC_DRIVER,
+	.name = "PCNET32/PCI",
+	.probe = pcnet32_probe,
+	.ids = pcnet32_nics,
+	.id_count = sizeof(pcnet32_nics) / sizeof(pcnet32_nics[0]),
+	.class = 0,
+};
diff -Naur grub-0.97.orig/netboot/pic8259.c grub-0.97/netboot/pic8259.c
--- grub-0.97.orig/netboot/pic8259.c	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/pic8259.c	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,267 @@
+/*
+ * Basic support for controlling the 8259 Programmable Interrupt Controllers.
+ *
+ * Initially written by Michael Brown (mcb30).
+ */
+
+#include <etherboot.h>
+#include <pic8259.h>
+
+#ifdef DEBUG_IRQ
+#define DBG(...) printf ( __VA_ARGS__ )
+#else
+#define DBG(...)
+#endif
+
+/* Current locations of trivial IRQ handler.  These will change at
+ * runtime when relocation is used; the handler needs to be copied to
+ * base memory before being installed.
+ */
+void (*trivial_irq_handler)P((void)) = _trivial_irq_handler;
+uint16_t volatile *trivial_irq_trigger_count = &_trivial_irq_trigger_count;
+segoff_t *trivial_irq_chain_to = &_trivial_irq_chain_to;
+uint8_t *trivial_irq_chain = &_trivial_irq_chain;
+irq_t trivial_irq_installed_on = IRQ_NONE;
+
+/* Previous trigger count for trivial IRQ handler */
+static uint16_t trivial_irq_previous_trigger_count = 0;
+
+/* Install a handler for the specified IRQ.  Address of previous
+ * handler will be stored in previous_handler.  Enabled/disabled state
+ * of IRQ will be preserved across call, therefore if the handler does
+ * chaining, ensure that either (a) IRQ is disabled before call, or
+ * (b) previous_handler points directly to the place that the handler
+ * picks up its chain-to address.
+ */
+
+int install_irq_handler ( irq_t irq, segoff_t *handler,
+			  uint8_t *previously_enabled,
+			  segoff_t *previous_handler ) {
+	segoff_t *irq_vector = IRQ_VECTOR ( irq );
+	*previously_enabled = irq_enabled ( irq );
+
+	if ( irq > IRQ_MAX ) {
+		DBG ( "Invalid IRQ number %d\n" );
+		return 0;
+	}
+
+	previous_handler->segment = irq_vector->segment;
+	previous_handler->offset = irq_vector->offset;
+	if ( *previously_enabled ) disable_irq ( irq );
+	DBG ( "Installing handler at %hx:%hx for IRQ %d, leaving %s\n",
+		  handler->segment, handler->offset, irq,
+		  ( *previously_enabled ? "enabled" : "disabled" ) );
+	DBG ( "...(previous handler at %hx:%hx)\n",
+		  previous_handler->segment, previous_handler->offset );
+	irq_vector->segment = handler->segment;
+	irq_vector->offset = handler->offset;
+	if ( *previously_enabled ) enable_irq ( irq );
+	return 1;
+}
+
+/* Remove handler for the specified IRQ.  Routine checks that another
+ * handler has not been installed that chains to handler before
+ * uninstalling handler.  Enabled/disabled state of the IRQ will be
+ * restored to that specified by previously_enabled.
+ */
+
+int remove_irq_handler ( irq_t irq, segoff_t *handler,
+			 uint8_t *previously_enabled,
+			 segoff_t *previous_handler ) {
+	segoff_t *irq_vector = IRQ_VECTOR ( irq );
+
+	if ( irq > IRQ_MAX ) {
+		DBG ( "Invalid IRQ number %d\n" );
+		return 0;
+	}
+	if ( ( irq_vector->segment != handler->segment ) ||
+	     ( irq_vector->offset != handler->offset ) ) {
+		DBG ( "Cannot remove handler for IRQ %d\n" );
+		return 0;
+	}
+
+	DBG ( "Removing handler for IRQ %d\n", irq );
+	disable_irq ( irq );
+	irq_vector->segment = previous_handler->segment;
+	irq_vector->offset = previous_handler->offset;
+	if ( *previously_enabled ) enable_irq ( irq );
+	return 1;
+}
+
+/* Install the trivial IRQ handler.  This routine installs the
+ * handler, tests it and enables the IRQ.
+ */
+
+int install_trivial_irq_handler ( irq_t irq ) {
+	segoff_t trivial_irq_handler_segoff = SEGOFF(trivial_irq_handler);
+	
+	if ( trivial_irq_installed_on != IRQ_NONE ) {
+		DBG ( "Can install trivial IRQ handler only once\n" );
+		return 0;
+	}
+	if ( SEGMENT(trivial_irq_handler) > 0xffff ) {
+		DBG ( "Trivial IRQ handler not in base memory\n" );
+		return 0;
+	}
+
+	DBG ( "Installing trivial IRQ handler on IRQ %d\n", irq );
+	if ( ! install_irq_handler ( irq, &trivial_irq_handler_segoff,
+				     trivial_irq_chain,
+				     trivial_irq_chain_to ) )
+		return 0;
+	trivial_irq_installed_on = irq;
+
+	DBG ( "Testing trivial IRQ handler\n" );
+	disable_irq ( irq );
+	*trivial_irq_trigger_count = 0;
+	trivial_irq_previous_trigger_count = 0;
+	fake_irq ( irq );
+	if ( ! trivial_irq_triggered ( irq ) ) {
+		DBG ( "Installation of trivial IRQ handler failed\n" );
+		remove_trivial_irq_handler ( irq );
+		return 0;
+	}
+	DBG ( "Trivial IRQ handler installed successfully\n" );
+	enable_irq ( irq );
+	return 1;
+}
+
+/* Remove the trivial IRQ handler.
+ */
+
+int remove_trivial_irq_handler ( irq_t irq ) {
+	segoff_t trivial_irq_handler_segoff = SEGOFF(trivial_irq_handler);
+
+	if ( trivial_irq_installed_on == IRQ_NONE ) return 1;
+	if ( irq != trivial_irq_installed_on ) {
+		DBG ( "Cannot uninstall trivial IRQ handler from IRQ %d; "
+		      "is installed on IRQ %d\n", irq,
+		      trivial_irq_installed_on );
+		return 0;
+	}
+
+	if ( ! remove_irq_handler ( irq, &trivial_irq_handler_segoff,
+				    trivial_irq_chain,
+				    trivial_irq_chain_to ) )
+		return 0;
+
+	if ( trivial_irq_triggered ( trivial_irq_installed_on ) ) {
+		DBG ( "Sending EOI for unwanted trivial IRQ\n" );
+		send_specific_eoi ( trivial_irq_installed_on );
+	}
+
+	trivial_irq_installed_on = IRQ_NONE;
+	return 1;
+}
+
+/* Safe method to detect whether or not trivial IRQ has been
+ * triggered.  Using this call avoids potential race conditions.  This
+ * call will return success only once per trigger.
+ */
+
+int trivial_irq_triggered ( irq_t irq ) {
+	uint16_t trivial_irq_this_trigger_count = *trivial_irq_trigger_count;
+	int triggered = ( trivial_irq_this_trigger_count -
+			  trivial_irq_previous_trigger_count );
+	
+	/* irq is not used at present, but we have it in the API for
+	 * future-proofing; in case we want the facility to have
+	 * multiple trivial IRQ handlers installed simultaneously.
+	 *
+	 * Avoid compiler warning about unused variable.
+	 */
+	if ( irq == IRQ_NONE ) {};
+	
+	trivial_irq_previous_trigger_count = trivial_irq_this_trigger_count;
+	return triggered ? 1 : 0;
+}
+
+/* Copy trivial IRQ handler to a new location.  Typically used to copy
+ * the handler into base memory; when relocation is being used we need
+ * to do this before installing the handler.
+ *
+ * Call with target=NULL in order to restore the handler to its
+ * original location.
+ */
+
+int copy_trivial_irq_handler ( void *target, size_t target_size ) {
+	irq_t currently_installed_on = trivial_irq_installed_on;
+	uint32_t offset = ( target == NULL ? 0 :
+			    target - &_trivial_irq_handler_start );
+
+	if (( target != NULL ) && ( target_size < TRIVIAL_IRQ_HANDLER_SIZE )) {
+		DBG ( "Insufficient space to copy trivial IRQ handler\n" );
+		return 0;
+	}
+
+	if ( currently_installed_on != IRQ_NONE ) {
+		DBG ("WARNING: relocating trivial IRQ handler while in use\n");
+		if ( ! remove_trivial_irq_handler ( currently_installed_on ) )
+			return 0;
+	}
+
+	/* Do the actual copy */
+	if ( target != NULL ) {
+		DBG ( "Copying trivial IRQ handler to %hx:%hx\n",
+		      SEGMENT(target), OFFSET(target) );
+		memcpy ( target, &_trivial_irq_handler_start,
+			 TRIVIAL_IRQ_HANDLER_SIZE );
+	} else {
+		DBG ( "Restoring trivial IRQ handler to original location\n" );
+	}
+	/* Update all the pointers to structures within the handler */
+	trivial_irq_handler = ( void (*)P((void)) )
+		( (void*)_trivial_irq_handler + offset );
+	trivial_irq_trigger_count = (uint16_t*)
+		( (void*)&_trivial_irq_trigger_count + offset );
+	trivial_irq_chain_to = (segoff_t*)
+		( (void*)&_trivial_irq_chain_to + offset );
+	trivial_irq_chain = (uint8_t*)
+		( (void*)&_trivial_irq_chain + offset );
+
+	if ( currently_installed_on != IRQ_NONE ) {
+		if ( ! install_trivial_irq_handler ( currently_installed_on ) )
+			return 0;
+	}
+	return 1;
+}
+
+/* Send non-specific EOI(s).  This seems to be inherently unsafe.
+ */
+
+void send_nonspecific_eoi ( irq_t irq ) {
+	DBG ( "Sending non-specific EOI for IRQ %d\n", irq );
+	if ( irq >= IRQ_PIC_CUTOFF ) {
+		outb ( ICR_EOI_NON_SPECIFIC, PIC2_ICR );
+	}		
+	outb ( ICR_EOI_NON_SPECIFIC, PIC1_ICR );
+}
+
+/* Send specific EOI(s).
+ */
+
+void send_specific_eoi ( irq_t irq ) {
+	DBG ( "Sending specific EOI for IRQ %d\n", irq );
+	outb ( ICR_EOI_SPECIFIC | ICR_VALUE(irq), ICR_REG(irq) );
+	if ( irq >= IRQ_PIC_CUTOFF ) {
+		outb ( ICR_EOI_SPECIFIC | ICR_VALUE(CHAINED_IRQ),
+		       ICR_REG(CHAINED_IRQ) );
+	}
+}
+
+/* Dump current 8259 status: enabled IRQs and handler addresses.
+ */
+
+#ifdef DEBUG_IRQ
+void dump_irq_status ( void ) {
+	int irq = 0;
+	
+	for ( irq = 0; irq < 16; irq++ ) {
+		if ( irq_enabled ( irq ) ) {
+			printf ( "IRQ%d enabled, ISR at %hx:%hx\n", irq,
+				 IRQ_VECTOR(irq)->segment,
+				 IRQ_VECTOR(irq)->offset );
+		}
+	}
+}
+#endif
diff -Naur grub-0.97.orig/netboot/pic8259.h grub-0.97/netboot/pic8259.h
--- grub-0.97.orig/netboot/pic8259.h	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/pic8259.h	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,99 @@
+/*
+ * Basic support for controlling the 8259 Programmable Interrupt Controllers.
+ *
+ * Initially written by Michael Brown (mcb30).
+ */
+
+#ifndef PIC8259_H
+#define PIC8259_H
+
+/* For segoff_t */
+#include <segoff.h>
+
+#define IRQ_PIC_CUTOFF (8)
+
+/* 8259 register locations */
+#define PIC1_ICW1 (0x20)
+#define PIC1_OCW2 (0x20)
+#define PIC1_OCW3 (0x20)
+#define PIC1_ICR (0x20)
+#define PIC1_IRR (0x20)
+#define PIC1_ISR (0x20)
+#define PIC1_ICW2 (0x21)
+#define PIC1_ICW3 (0x21)
+#define PIC1_ICW4 (0x21)
+#define PIC1_IMR (0x21)
+#define PIC2_ICW1 (0xa0)
+#define PIC2_OCW2 (0xa0)
+#define PIC2_OCW3 (0xa0)
+#define PIC2_ICR (0xa0)
+#define PIC2_IRR (0xa0)
+#define PIC2_ISR (0xa0)
+#define PIC2_ICW2 (0xa1)
+#define PIC2_ICW3 (0xa1)
+#define PIC2_ICW4 (0xa1)
+#define PIC2_IMR (0xa1)
+
+/* Register command values */
+#define OCW3_ID (0x08)
+#define OCW3_READ_IRR (0x03)
+#define OCW3_READ_ISR (0x02)
+#define ICR_EOI_NON_SPECIFIC (0x20)
+#define ICR_EOI_NOP (0x40)
+#define ICR_EOI_SPECIFIC (0x60)
+#define ICR_EOI_SET_PRIORITY (0xc0)
+
+/* Macros to enable/disable IRQs */
+#define IMR_REG(x) ( (x) < IRQ_PIC_CUTOFF ? PIC1_IMR : PIC2_IMR )
+#define IMR_BIT(x) ( 1 << ( (x) % IRQ_PIC_CUTOFF ) )
+#define irq_enabled(x) ( ( inb ( IMR_REG(x) ) & IMR_BIT(x) ) == 0 )
+#define enable_irq(x) outb ( inb( IMR_REG(x) ) & ~IMR_BIT(x), IMR_REG(x) )
+#define disable_irq(x) outb ( inb( IMR_REG(x) ) | IMR_BIT(x), IMR_REG(x) )
+
+/* Macros for acknowledging IRQs */
+#define ICR_REG(x) ( (x) < IRQ_PIC_CUTOFF ? PIC1_ICR : PIC2_ICR )
+#define ICR_VALUE(x) ( (x) % IRQ_PIC_CUTOFF )
+#define CHAINED_IRQ 2
+
+/* Utility macros to convert IRQ numbers to INT numbers and INT vectors  */
+#define IRQ_INT(x) ( (x)<IRQ_PIC_CUTOFF ? (x)+0x08 : (x)-IRQ_PIC_CUTOFF+0x70 )
+#define INT_VECTOR(x) ( (segoff_t*) phys_to_virt( 4 * (x) ) )
+#define IRQ_VECTOR(x) ( INT_VECTOR ( IRQ_INT(x) ) )
+
+/* Other constants */
+typedef uint8_t irq_t;
+#define IRQ_MAX (15)
+#define IRQ_NONE (0xff)
+
+/* Labels in assembly code (in pcbios.S)
+ */
+extern void _trivial_irq_handler_start;
+extern void _trivial_irq_handler ( void );
+extern volatile uint16_t _trivial_irq_trigger_count;
+extern segoff_t _trivial_irq_chain_to;
+extern uint8_t _trivial_irq_chain;
+extern void _trivial_irq_handler_end;
+#define TRIVIAL_IRQ_HANDLER_SIZE \
+	((uint32_t)( &_trivial_irq_handler_end - &_trivial_irq_handler_start ))
+
+/* Function prototypes
+ */
+int install_irq_handler ( irq_t irq, segoff_t *handler,
+			  uint8_t *previously_enabled,
+			  segoff_t *previous_handler );
+int remove_irq_handler ( irq_t irq, segoff_t *handler,
+			 uint8_t *previously_enabled,
+			 segoff_t *previous_handler );
+int install_trivial_irq_handler ( irq_t irq );
+int remove_trivial_irq_handler ( irq_t irq );
+int trivial_irq_triggered ( irq_t irq );
+int copy_trivial_irq_handler ( void *target, size_t target_size );
+void send_non_specific_eoi ( irq_t irq );
+void send_specific_eoi ( irq_t irq );
+#ifdef DEBUG_IRQ
+void dump_irq_status ( void );
+#else
+#define dump_irq_status()
+#endif
+
+#endif /* PIC8259_H */
diff -Naur grub-0.97.orig/netboot/pnic.c grub-0.97/netboot/pnic.c
--- grub-0.97.orig/netboot/pnic.c	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/pnic.c	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,267 @@
+/**************************************************************************
+Etherboot -  BOOTP/TFTP Bootstrap Program
+Bochs Pseudo NIC driver for Etherboot
+***************************************************************************/
+
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2, or (at
+ * your option) any later version.
+ *
+ * See pnic_api.h for an explanation of the Bochs Pseudo NIC.
+ */
+
+/* to get some global routines like printf */
+#include "etherboot.h"
+/* to get the interface to the body of the program */
+#include "nic.h"
+/* to get the PCI support functions, if this is a PCI NIC */
+#include "pci.h"
+
+/* PNIC API */
+#include "pnic_api.h"
+
+/* Private data structure */
+typedef struct {
+	uint16_t api_version;
+} pnic_priv_data_t;
+
+/* Function prototypes */
+static int pnic_api_check ( uint16_t api_version );
+
+/* NIC specific static variables go here */
+static uint8_t tx_buffer[ETH_FRAME_LEN];
+
+/* 
+ * Utility functions: issue a PNIC command, retrieve result.  Use
+ * pnic_command_quiet if you don't want failure codes to be
+ * automatically printed.  Returns the PNIC status code.
+ * 
+ * Set output_length to NULL only if you expect to receive exactly
+ * output_max_length bytes, otherwise it'll complain that you didn't
+ * get enough data (on the assumption that if you not interested in
+ * discovering the output length then you're expecting a fixed amount
+ * of data).
+ */
+
+static uint16_t pnic_command_quiet ( struct nic *nic, uint16_t command,
+				     void *input, uint16_t input_length,
+				     void *output, uint16_t output_max_length,
+				     uint16_t *output_length ) {
+	int i;
+	uint16_t status;
+	uint16_t _output_length;
+
+	if ( input != NULL ) {
+		/* Write input length */
+		outw ( input_length, nic->ioaddr + PNIC_REG_LEN );
+		/* Write input data */
+		for ( i = 0; i < input_length; i++ ) {
+			outb( ((char*)input)[i], nic->ioaddr + PNIC_REG_DATA );
+		}
+	}
+	/* Write command */
+	outw ( command, nic->ioaddr + PNIC_REG_CMD );
+	/* Retrieve status */
+	status = inw ( nic->ioaddr + PNIC_REG_STAT );
+	/* Retrieve output length */
+	_output_length = inw ( nic->ioaddr + PNIC_REG_LEN );
+	if ( output_length == NULL ) {
+		if ( _output_length != output_max_length ) {
+			printf ( "pnic_command %#hx: wrong data length "
+				 "returned (expected %d, got %d)\n", command,
+				 output_max_length, _output_length );
+		}
+	} else {
+		*output_length = _output_length;
+	}
+	if ( output != NULL ) {
+		if ( _output_length > output_max_length ) {
+			printf ( "pnic_command %#hx: output buffer too small "
+				 "(have %d, need %d)\n", command,
+				 output_max_length, _output_length );
+			_output_length = output_max_length;
+		}
+		/* Retrieve output data */
+		for ( i = 0; i < _output_length; i++ ) {
+			((char*)output)[i] =
+				inb ( nic->ioaddr + PNIC_REG_DATA );
+		}
+	}
+	return status;
+}
+
+static uint16_t pnic_command ( struct nic *nic, uint16_t command,
+			       void *input, uint16_t input_length,
+			       void *output, uint16_t output_max_length,
+			       uint16_t *output_length ) {
+	pnic_priv_data_t *priv = (pnic_priv_data_t*)nic->priv_data;
+	uint16_t status = pnic_command_quiet ( nic, command,
+					       input, input_length,
+					       output, output_max_length,
+					       output_length );
+	if ( status == PNIC_STATUS_OK ) return status;
+	printf ( "PNIC command %#hx (len %#hx) failed with status %#hx\n",
+		 command, input_length, status );
+	if ( priv->api_version ) pnic_api_check(priv->api_version);
+	return status;
+}
+
+/* Check API version matches that of NIC */
+static int pnic_api_check ( uint16_t api_version ) {
+	if ( api_version != PNIC_API_VERSION ) {
+		printf ( "Warning: API version mismatch! "
+			 "(NIC's is %d.%d, ours is %d.%d)\n",
+			 api_version >> 8, api_version & 0xff,
+			 PNIC_API_VERSION >> 8, PNIC_API_VERSION & 0xff );
+	}
+	if ( api_version < PNIC_API_VERSION ) {
+		printf ( "*** You may need to update your copy of Bochs ***\n" );
+	}
+	return ( api_version == PNIC_API_VERSION );
+}
+
+/**************************************************************************
+POLL - Wait for a frame
+***************************************************************************/
+static int pnic_poll(struct nic *nic, int retrieve)
+{
+	uint16_t length;
+	uint16_t qlen;
+
+	/* Check receive queue length to see if there's anything to
+	 * get.  Necessary since once we've called PNIC_CMD_RECV we
+	 * have to read out the packet, otherwise it's lost forever.
+	 */
+	if ( pnic_command ( nic, PNIC_CMD_RECV_QLEN, NULL, 0,
+			    &qlen, sizeof(qlen), NULL )
+	     != PNIC_STATUS_OK ) return ( 0 );
+	if ( qlen == 0 ) return ( 0 );
+
+	/* There is a packet ready.  Return 1 if we're only checking. */
+	if ( ! retrieve ) return ( 1 );
+
+	/* Retrieve the packet */
+	if ( pnic_command ( nic, PNIC_CMD_RECV, NULL, 0,
+			    nic->packet, ETH_FRAME_LEN, &length )
+	     != PNIC_STATUS_OK ) return ( 0 );
+	nic->packetlen = length;
+	return ( 1 );
+}
+
+/**************************************************************************
+TRANSMIT - Transmit a frame
+***************************************************************************/
+static void pnic_transmit(
+	struct nic *nic,
+	const char *dest,		/* Destination */
+	unsigned int type,		/* Type */
+	unsigned int size,		/* size */
+	const char *data)		/* Packet */
+{
+	unsigned int nstype = htons ( type );
+
+	if ( ( ETH_HLEN + size ) >= ETH_FRAME_LEN ) {
+		printf ( "pnic_transmit: packet too large\n" );
+		return;
+	}
+
+	/* Assemble packet */
+	memcpy ( tx_buffer, dest, ETH_ALEN );
+	memcpy ( tx_buffer + ETH_ALEN, nic->node_addr, ETH_ALEN );
+	memcpy ( tx_buffer + 2 * ETH_ALEN, &nstype, 2 );
+	memcpy ( tx_buffer + ETH_HLEN, data, size );
+
+	pnic_command ( nic, PNIC_CMD_XMIT, tx_buffer, ETH_HLEN + size,
+		       NULL, 0, NULL );
+}
+
+/**************************************************************************
+DISABLE - Turn off ethernet interface
+***************************************************************************/
+static void pnic_disable(struct dev *dev)
+{
+	struct nic *nic = (struct nic *)dev;
+	pnic_command ( nic, PNIC_CMD_RESET, NULL, 0, NULL, 0, NULL );
+}
+
+/**************************************************************************
+IRQ - Handle card interrupt status
+***************************************************************************/
+static void pnic_irq ( struct nic *nic, irq_action_t action )
+{
+	uint8_t enabled;
+
+	switch ( action ) {
+	case DISABLE :
+	case ENABLE :
+		enabled = ( action == ENABLE ? 1 : 0 );
+		pnic_command ( nic, PNIC_CMD_MASK_IRQ,
+			       &enabled, sizeof(enabled), NULL, 0, NULL );
+		break;
+	case FORCE :
+		pnic_command ( nic, PNIC_CMD_FORCE_IRQ,
+			       NULL, 0, NULL, 0, NULL );
+		break;
+	}
+}
+
+/**************************************************************************
+PROBE - Look for an adapter, this routine's visible to the outside
+***************************************************************************/
+
+static int pnic_probe(struct dev *dev, struct pci_device *pci)
+{
+	struct nic *nic = (struct nic *)dev;
+	static pnic_priv_data_t priv;
+	uint16_t status;
+
+	printf(" - ");
+
+	/* Clear private data structure and chain it in */
+	memset ( &priv, 0, sizeof(priv) );
+	nic->priv_data = &priv;
+
+	/* Mask the bit that says "this is an io addr" */
+	nic->ioaddr = pci->ioaddr & ~3;
+	nic->irqno = pci->irq;
+	/* Not sure what this does, but the rtl8139 driver does it */
+	adjust_pci_device(pci);
+
+	status = pnic_command_quiet( nic, PNIC_CMD_API_VER, NULL, 0,
+				     &priv.api_version,
+				     sizeof(priv.api_version), NULL );
+	if ( status != PNIC_STATUS_OK ) {
+		printf ( "PNIC failed installation check, code %#hx\n",
+			 status );
+		return 0;
+	}
+	pnic_api_check(priv.api_version);
+	status = pnic_command ( nic, PNIC_CMD_READ_MAC, NULL, 0,
+				nic->node_addr, ETH_ALEN, NULL );
+	printf ( "Detected Bochs Pseudo NIC MAC %! (API v%d.%d) at %#hx\n",
+		 nic->node_addr, priv.api_version>>8, priv.api_version&0xff,
+		 nic->ioaddr );
+
+	/* point to NIC specific routines */
+	dev->disable  = pnic_disable;
+	nic->poll     = pnic_poll;
+	nic->transmit = pnic_transmit;
+	nic->irq      = pnic_irq;
+	return 1;
+}
+
+static struct pci_id pnic_nics[] = {
+/* genrules.pl doesn't let us use macros for PCI IDs...*/
+PCI_ROM(0xfefe, 0xefef, "pnic", "Bochs Pseudo NIC Adaptor"),
+};
+
+struct pci_driver pnic_driver = {
+	.type     = NIC_DRIVER,
+	.name     = "PNIC",
+	.probe    = pnic_probe,
+	.ids      = pnic_nics,
+	.id_count = sizeof(pnic_nics)/sizeof(pnic_nics[0]),
+	.class    = 0,
+};
diff -Naur grub-0.97.orig/netboot/pnic_api.h grub-0.97/netboot/pnic_api.h
--- grub-0.97.orig/netboot/pnic_api.h	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/pnic_api.h	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,59 @@
+/*
+ * Constants etc. for the Bochs/Etherboot pseudo-NIC
+ * 
+ * This header file must be valid C and C++.
+ *
+ * Operation of the pseudo-NIC (PNIC) is pretty simple.  To write a
+ * command plus data, first write the length of the data to
+ * PNIC_REG_LEN, then write the data a byte at a type to
+ * PNIC_REG_DATA, then write the command code to PNIC_REG_CMD.  The
+ * status will be available from PNIC_REG_STAT.  The length of any
+ * data returned will be in PNIC_REG_LEN and can be read a byte at a
+ * time from PNIC_REG_DATA.
+ */
+
+/*
+ * PCI parameters
+ */
+#define PNIC_PCI_VENDOR	0xfefe	/* Hopefully these won't clash with */
+#define PNIC_PCI_DEVICE 0xefef	/* any real PCI device IDs.         */
+
+/*
+ * 'Hardware' register addresses, offset from io_base
+ */
+#define PNIC_REG_CMD	0x00	/* Command register, 2 bytes, write only */
+#define PNIC_REG_STAT	0x00	/* Status register, 2 bytes, read only */
+#define PNIC_REG_LEN	0x02	/* Length register, 2 bytes, read-write */
+#define PNIC_REG_DATA	0x04	/* Data port, 1 byte, read-write */
+/*
+ * PNIC_MAX_REG used in Bochs to claim i/o space
+ */
+#define PNIC_MAX_REG	0x04
+
+/*
+ * Command code definitions: write these into PNIC_REG_CMD
+ */
+#define PNIC_CMD_NOOP		0x0000
+#define PNIC_CMD_API_VER	0x0001
+#define PNIC_CMD_READ_MAC	0x0002
+#define PNIC_CMD_RESET		0x0003
+#define PNIC_CMD_XMIT		0x0004
+#define PNIC_CMD_RECV		0x0005
+#define PNIC_CMD_RECV_QLEN	0x0006
+#define PNIC_CMD_MASK_IRQ	0x0007
+#define PNIC_CMD_FORCE_IRQ	0x0008
+
+/*
+ * Status code definitions: read these from PNIC_REG_STAT
+ *
+ * We avoid using status codes that might be confused with
+ * randomly-read data (e.g. 0x0000, 0xffff etc.)
+ */
+#define PNIC_STATUS_OK		0x4f4b		/* 'OK' */
+#define PNIC_STATUS_UNKNOWN_CMD	0x3f3f		/* '??' */
+
+/*
+ * Other miscellaneous information
+ */
+
+#define PNIC_API_VERSION	0x0101		/* 1.1 */
diff -Naur grub-0.97.orig/netboot/pxe.h grub-0.97/netboot/pxe.h
--- grub-0.97.orig/netboot/pxe.h	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/pxe.h	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,521 @@
+/*
+ * Copyright (c) 2000 Alfred Perlstein <alfred@freebsd.org>
+ * All rights reserved.
+ * Copyright (c) 2000 Paul Saab <ps@freebsd.org>
+ * All rights reserved.
+ * Copyright (c) 2000 John Baldwin <jhb@freebsd.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD: src/sys/boot/i386/libi386/pxe.h,v 1.4.2.2 2000/09/10 02:52:18 ps Exp $
+ */
+
+/*
+ * The typedefs and structures declared in this file
+ * clearly violate style(9), the reason for this is to conform to the
+ * typedefs/structure-names used in the Intel literature to avoid confusion.
+ *
+ * It's for your own good. :)
+ */
+
+/* SEGOFF16_t defined in separate header for Etherboot
+ */
+#include <segoff.h>
+
+/* It seems that intel didn't think about ABI,
+ * either that or 16bit ABI != 32bit ABI (which seems reasonable)
+ * I have to thank Intel for the hair loss I incurred trying to figure
+ * out why PXE was mis-reading structures I was passing it (at least
+ * from my point of view)
+ *
+ * Solution: use gcc's '__attribute__ ((packed))' to correctly align
+ * structures passed into PXE
+ * Question: does this really work for PXE's expected ABI?
+ */
+#define	PACKED		__attribute__ ((packed))
+
+#define	S_SIZE(s)	s, sizeof(s) - 1
+
+#define	IP_STR		"%d.%d.%d.%d"
+#define	IP_ARGS(ip)					\
+	(int)(ip >> 24) & 0xff, (int)(ip >> 16) & 0xff, \
+	(int)(ip >> 8) & 0xff, (int)ip & 0xff
+
+#define	MAC_STR		"%02x:%02x:%02x:%02x:%02x:%02x"
+#define	MAC_ARGS(mac)					\
+	mac[0], mac[1], mac[2], mac[3], mac[4], mac[5] 
+
+#define	PXENFSROOTPATH	"/pxeroot"
+
+typedef struct {
+	uint16_t		Seg_Addr;
+	uint32_t		Phy_Addr;
+	uint16_t		Seg_Size;
+} PACKED SEGDESC_t; /* PACKED is required, otherwise gcc pads this out to 12
+		       bytes - mbrown@fensystems.co.uk (mcb30) 17/5/03 */
+
+typedef	uint16_t		SEGSEL_t;
+typedef	uint16_t		PXENV_STATUS_t;
+typedef	uint32_t		IP4_t;
+typedef	uint32_t		ADDR32_t;
+typedef	uint16_t		UDP_PORT_t;
+
+#define	MAC_ADDR_LEN		16
+typedef	uint8_t			MAC_ADDR[MAC_ADDR_LEN];
+
+/* PXENV+ */
+typedef struct {
+	uint8_t		Signature[6];	/* 'PXENV+' */
+	uint16_t	Version;	/* MSB = major, LSB = minor */
+	uint8_t		Length;		/* structure length */
+	uint8_t		Checksum;	/* checksum pad */
+	SEGOFF16_t	RMEntry;	/* SEG:OFF to PXE entry point */
+	/* don't use PMOffset and PMSelector (from the 2.1 PXE manual) */
+	uint32_t	PMOffset;	/* Protected mode entry */
+	SEGSEL_t	PMSelector;	/* Protected mode selector */
+	SEGSEL_t	StackSeg;	/* Stack segment address */
+	uint16_t	StackSize;	/* Stack segment size (bytes) */
+	SEGSEL_t	BC_CodeSeg;	/* BC Code segment address */
+	uint16_t	BC_CodeSize;	/* BC Code segment size (bytes) */
+	SEGSEL_t	BC_DataSeg;	/* BC Data segment address */
+	uint16_t	BC_DataSize;	/* BC Data segment size (bytes) */
+	SEGSEL_t	UNDIDataSeg;	/* UNDI Data segment address */
+	uint16_t	UNDIDataSize;	/* UNDI Data segment size (bytes) */
+	SEGSEL_t	UNDICodeSeg;	/* UNDI Code segment address */
+	uint16_t	UNDICodeSize;	/* UNDI Code segment size (bytes) */
+	SEGOFF16_t	PXEPtr;		/* SEG:OFF to !PXE struct, 
+					   only present when Version > 2.1 */
+} PACKED pxenv_t;
+
+/* !PXE */
+typedef struct {
+	uint8_t		Signature[4];
+	uint8_t		StructLength;
+	uint8_t		StructCksum;
+	uint8_t		StructRev;
+	uint8_t		reserved_1;
+	SEGOFF16_t	UNDIROMID;
+	SEGOFF16_t	BaseROMID;
+	SEGOFF16_t	EntryPointSP;
+	SEGOFF16_t	EntryPointESP;
+	SEGOFF16_t	StatusCallout;
+	uint8_t		reserved_2;
+	uint8_t		SegDescCn;
+	SEGSEL_t	FirstSelector;
+	SEGDESC_t	Stack;
+	SEGDESC_t	UNDIData;
+	SEGDESC_t	UNDICode;
+	SEGDESC_t	UNDICodeWrite;
+	SEGDESC_t	BC_Data;
+	SEGDESC_t	BC_Code;
+	SEGDESC_t	BC_CodeWrite;
+} PACKED pxe_t;
+
+#define	PXENV_START_UNDI		0x0000
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint16_t	ax;
+	uint16_t	bx;
+	uint16_t	dx;
+	uint16_t	di;
+	uint16_t	es;
+} PACKED t_PXENV_START_UNDI;
+
+#define	PXENV_UNDI_STARTUP		0x0001
+typedef struct {
+	PXENV_STATUS_t	Status;
+} PACKED t_PXENV_UNDI_STARTUP;
+
+#define	PXENV_UNDI_CLEANUP		0x0002
+typedef struct {
+	PXENV_STATUS_t	Status;
+} PACKED t_PXENV_UNDI_CLEANUP;
+
+#define	PXENV_UNDI_INITIALIZE		0x0003
+typedef struct {
+	PXENV_STATUS_t	Status;
+	ADDR32_t	ProtocolIni;	/* Phys addr of a copy of the driver module */
+	uint8_t		reserved[8];
+} PACKED t_PXENV_UNDI_INITIALIZE;
+
+
+#define	MAXNUM_MCADDR		8
+typedef struct {
+	uint16_t	MCastAddrCount;
+	MAC_ADDR	McastAddr[MAXNUM_MCADDR];
+} PACKED t_PXENV_UNDI_MCAST_ADDRESS;
+
+#define	PXENV_UNDI_RESET_ADAPTER	0x0004		
+typedef struct {
+	PXENV_STATUS_t	Status;
+	t_PXENV_UNDI_MCAST_ADDRESS R_Mcast_Buf;
+} PACKED t_PXENV_UNDI_RESET;
+
+#define	PXENV_UNDI_SHUTDOWN		0x0005
+typedef struct {
+	PXENV_STATUS_t	Status;
+} PACKED t_PXENV_UNDI_SHUTDOWN;
+
+#define	PXENV_UNDI_OPEN			0x0006
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint16_t	OpenFlag;
+	uint16_t	PktFilter;
+#	define FLTR_DIRECTED	0x0001
+#	define FLTR_BRDCST	0x0002
+#	define FLTR_PRMSCS	0x0003
+#	define FLTR_SRC_RTG	0x0004
+
+	t_PXENV_UNDI_MCAST_ADDRESS R_Mcast_Buf;
+} PACKED t_PXENV_UNDI_OPEN;
+
+#define	PXENV_UNDI_CLOSE		0x0007
+typedef struct {
+	PXENV_STATUS_t	Status;
+} PACKED t_PXENV_UNDI_CLOSE;
+
+#define	PXENV_UNDI_TRANSMIT		0x0008
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint8_t		Protocol;
+#	define P_UNKNOWN	0
+#	define P_IP		1
+#	define P_ARP		2
+#	define P_RARP		3
+
+	uint8_t		XmitFlag;
+#	define XMT_DESTADDR	0x0000
+#	define XMT_BROADCAST	0x0001
+
+	SEGOFF16_t	DestAddr;
+	SEGOFF16_t	TBD;
+	uint32_t	Reserved[2];
+} PACKED t_PXENV_UNDI_TRANSMIT;
+
+#define	MAX_DATA_BLKS		8
+typedef struct {
+	uint16_t	ImmedLength;
+	SEGOFF16_t	Xmit;
+	uint16_t	DataBlkCount;
+	struct	DataBlk {
+		uint8_t		TDPtrType;
+		uint8_t		TDRsvdByte;
+		uint16_t	TDDataLen;
+		SEGOFF16_t	TDDataPtr;
+	} DataBlock[MAX_DATA_BLKS];
+} PACKED t_PXENV_UNDI_TBD;
+
+#define	PXENV_UNDI_SET_MCAST_ADDRESS	0x0009
+typedef struct {
+	PXENV_STATUS_t	Status;
+	t_PXENV_UNDI_MCAST_ADDRESS R_Mcast_Buf;
+} PACKED t_PXENV_UNDI_SET_MCAST_ADDR;
+
+#define	PXENV_UNDI_SET_STATION_ADDRESS	0x000A
+typedef struct {
+	PXENV_STATUS_t	Status;
+	MAC_ADDR	StationAddress;		/* Temp MAC addres to use */
+} PACKED t_PXENV_UNDI_SET_STATION_ADDRESS;
+
+#define	PXENV_UNDI_SET_PACKET_FILTER	0x000B
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint8_t		filter;			/* see UNDI_OPEN (0x0006) */
+} PACKED t_PXENV_UNDI_SET_PACKET_FILTER;
+
+#define	PXENV_UNDI_GET_INFORMATION	0x000C
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint16_t	BaseIo;			/* Adapter base I/O address */
+	uint16_t	IntNumber;		/* Adapter IRQ number */
+	uint16_t	MaxTranUnit;		/* Adapter maximum transmit unit */
+	uint16_t	HwType;			/* Type of protocol at the hardware addr */
+#	define ETHER_TYPE	1
+#	define EXP_ETHER_TYPE	2
+#	define IEEE_TYPE	6
+#	define ARCNET_TYPE	7
+
+	uint16_t	HwAddrLen;		/* Length of hardware address */
+	MAC_ADDR	CurrentNodeAddress;	/* Current hardware address */
+	MAC_ADDR	PermNodeAddress;	/* Permanent hardware address */
+	SEGSEL_t	ROMAddress;		/* Real mode ROM segment address */
+	uint16_t	RxBufCt;		/* Receive queue length */
+	uint16_t	TxBufCt;		/* Transmit queue length */
+} PACKED t_PXENV_UNDI_GET_INFORMATION;
+
+#define	PXENV_UNDI_GET_STATISTICS	0x000D
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint32_t	XmitGoodFrames;		/* Number of successful transmissions */
+	uint32_t	RcvGoodFrames;		/* Number of good frames received */
+	uint32_t	RcvCRCErrors;		/* Number of frames with CRC errors */
+	uint32_t	RcvResourceErrors;	/* Number of frames dropped */
+} PACKED t_PXENV_UNDI_GET_STATISTICS;
+
+#define	PXENV_UNDI_CLEAR_STATISTICS	0x000E
+typedef struct {
+	PXENV_STATUS_t	Status;
+} PACKED t_PXENV_UNDI_CLEAR_STATISTICS;
+
+#define	PXENV_UNDI_INITIATE_DIAGS	0x000F
+typedef struct {
+	PXENV_STATUS_t	Status;
+} PACKED t_PXENV_UNDI_INITIATE_DIAGS;
+
+#define	PXENV_UNDI_FORCE_INTERRUPT	0x0010
+typedef struct {
+	PXENV_STATUS_t	Status;
+} PACKED t_PXENV_UNDI_FORCE_INTERRUPT;
+
+#define	PXENV_UNDI_GET_MCAST_ADDRESS	0x0011
+typedef struct {
+	PXENV_STATUS_t	Status;
+	IP4_t		InetAddr;		/* IP mulicast address */
+	MAC_ADDR	MediaAddr;		/* MAC multicast address */
+} PACKED t_PXENV_UNDI_GET_MCAST_ADDR;
+
+#define	PXENV_UNDI_GET_NIC_TYPE		0x0012
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint8_t		NicType;		/* Type of NIC */
+#	define PCI_NIC		2
+#	define PnP_NIC		3
+#	define CardBus_NIC	4
+
+	union {
+		struct {
+			uint16_t	Vendor_ID;
+			uint16_t	Dev_ID;
+			uint8_t		Base_Class;
+			uint8_t		Sub_Class;
+			uint8_t		Prog_Intf;
+			uint8_t		Rev;
+			uint16_t	BusDevFunc;
+			uint16_t	SubVendor_ID;
+			uint16_t	SubDevice_ID;
+		} pci, cardbus;
+		struct {
+			uint32_t	EISA_Dev_ID;
+			uint8_t		Base_Class;
+			uint8_t		Sub_Class;
+			uint8_t		Prog_Intf;
+			uint16_t	CardSelNum;
+		} pnp;
+	} info;
+} PACKED t_PXENV_UNDI_GET_NIC_TYPE;
+
+#define	PXENV_UNDI_GET_IFACE_INFO	0x0013
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint8_t		IfaceType[16];		/* Name of MAC type in ASCII. */
+	uint32_t	LinkSpeed;		/* Defined in NDIS 2.0 spec */
+	uint32_t	ServiceFlags;		/* Defined in NDIS 2.0 spec */
+	uint32_t	Reserved[4];		/* must be 0 */
+} PACKED t_PXENV_UNDI_GET_IFACE_INFO;
+
+#define	PXENV_UNDI_ISR			0x0014
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint16_t	FuncFlag;		/* PXENV_UNDI_ISR_OUT_xxx */
+	uint16_t	BufferLength;		/* Length of Frame */
+	uint16_t	FrameLength;		/* Total length of reciever frame */
+	uint16_t	FrameHeaderLength;	/* Length of the media header in Frame */
+	SEGOFF16_t	Frame;			/* receive buffer */
+	uint8_t		ProtType;		/* Protocol type */
+	uint8_t		PktType;		/* Packet Type */
+#	define PXENV_UNDI_ISR_IN_START		1
+#	define PXENV_UNDI_ISR_IN_PROCESS	2
+#	define PXENV_UNDI_ISR_IN_GET_NEXT	3
+
+	/* one of these will be returned for PXENV_UNDI_ISR_IN_START */
+#	define PXENV_UNDI_ISR_OUT_OURS		0
+#	define PXENV_UNDI_ISR_OUT_NOT_OURS	1
+
+	/*
+	 * one of these will bre returnd for PXEND_UNDI_ISR_IN_PROCESS
+	 * and PXENV_UNDI_ISR_IN_GET_NEXT
+	 */
+#	define PXENV_UNDI_ISR_OUT_DONE		0
+#	define PXENV_UNDI_ISR_OUT_TRANSMIT	2
+#	define PXENV_UNDI_ISR_OUT_RECEIVE	3
+#	define PXENV_UNDI_ISR_OUT_BUSY		4
+} PACKED t_PXENV_UNDI_ISR;
+
+#define	PXENV_STOP_UNDI			0x0015
+typedef struct {
+	PXENV_STATUS_t	Status;
+} PACKED t_PXENV_STOP_UNDI;
+
+#define	PXENV_TFTP_OPEN			0x0020
+typedef struct {
+	PXENV_STATUS_t	Status;
+	IP4_t		ServerIPAddress;
+	IP4_t		GatewayIPAddress;
+	uint8_t		FileName[128];
+	UDP_PORT_t	TFTPPort;
+	uint16_t	PacketSize;
+} PACKED t_PXENV_TFTP_OPEN;
+
+#define	PXENV_TFTP_CLOSE		0x0021
+typedef struct {
+	PXENV_STATUS_t	Status;
+} PACKED t_PXENV_TFTP_CLOSE;
+
+#define	PXENV_TFTP_READ			0x0022
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint16_t	PacketNumber;
+	uint16_t	BufferSize;
+	SEGOFF16_t	Buffer;
+} PACKED t_PXENV_TFTP_READ;
+
+#define	PXENV_TFTP_READ_FILE		0x0023
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint8_t		FileName[128];
+	uint32_t	BufferSize;
+	ADDR32_t	Buffer;
+	IP4_t		ServerIPAddress;
+	IP4_t		GatewayIPAdress;
+	IP4_t		McastIPAdress;
+	UDP_PORT_t	TFTPClntPort;
+	UDP_PORT_t	TFTPSrvPort;
+	uint16_t	TFTPOpenTimeOut;
+	uint16_t	TFTPReopenDelay;
+} PACKED t_PXENV_TFTP_READ_FILE;
+
+#define	PXENV_TFTP_GET_FSIZE		0x0025
+typedef struct {
+	PXENV_STATUS_t	Status;
+	IP4_t		ServerIPAddress;
+	IP4_t		GatewayIPAdress;
+	uint8_t		FileName[128];
+	uint32_t	FileSize;
+} PACKED t_PXENV_TFTP_GET_FSIZE;
+
+#define	PXENV_UDP_OPEN			0x0030
+typedef struct {
+	PXENV_STATUS_t	Status;
+	IP4_t		src_ip;		/* IP address of this station */
+} PACKED t_PXENV_UDP_OPEN;
+
+#define	PXENV_UDP_CLOSE			0x0031
+typedef struct {
+	PXENV_STATUS_t	status;
+} PACKED t_PXENV_UDP_CLOSE;
+
+#define	PXENV_UDP_READ			0x0032
+typedef struct {
+	PXENV_STATUS_t	status;
+	IP4_t		src_ip;		/* IP of sender */
+	IP4_t		dest_ip;	/* Only accept packets sent to this IP */
+	UDP_PORT_t	s_port;		/* UDP source port of sender */
+	UDP_PORT_t	d_port;		/* Only accept packets sent to this port */
+	uint16_t	buffer_size;	/* Size of the packet buffer */
+	SEGOFF16_t	buffer;		/* SEG:OFF to the packet buffer */
+} PACKED t_PXENV_UDP_READ;
+
+#define	PXENV_UDP_WRITE			0x0033
+typedef struct {
+	PXENV_STATUS_t	status;
+	IP4_t		ip;		/* dest ip addr */
+	IP4_t		gw;		/* ip gateway */
+	UDP_PORT_t	src_port;	/* source udp port */
+	UDP_PORT_t	dst_port;	/* destination udp port */
+	uint16_t	buffer_size;	/* Size of the packet buffer */
+	SEGOFF16_t	buffer;		/* SEG:OFF to the packet buffer */
+} PACKED t_PXENV_UDP_WRITE;
+
+#define	PXENV_UNLOAD_STACK		0x0070
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint8_t		reserved[10];
+} PACKED t_PXENV_UNLOAD_STACK;
+
+
+#define	PXENV_GET_CACHED_INFO		0x0071
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint16_t	PacketType;	/* type (defined right here) */
+#	define PXENV_PACKET_TYPE_DHCP_DISCOVER  1
+#	define PXENV_PACKET_TYPE_DHCP_ACK       2
+#	define PXENV_PACKET_TYPE_BINL_REPLY     3
+	uint16_t	BufferSize;	/* max to copy, leave at 0 for pointer */
+	SEGOFF16_t	Buffer;		/* copy to, leave at 0 for pointer */
+	uint16_t	BufferLimit;	/* max size of buffer in BC dataseg ? */
+} PACKED t_PXENV_GET_CACHED_INFO;
+
+
+/* structure filled in by PXENV_GET_CACHED_INFO 
+ * (how we determine which IP we downloaded the initial bootstrap from)
+ * words can't describe...
+ */
+typedef struct {
+	uint8_t		opcode;
+#	define BOOTP_REQ	1
+#	define BOOTP_REP	2
+	uint8_t		Hardware;	/* hardware type */
+	uint8_t		Hardlen;	/* hardware addr len */
+	uint8_t		Gatehops;	/* zero it */
+	uint32_t	ident;		/* random number chosen by client */
+	uint16_t	seconds;	/* seconds since did initial bootstrap */
+	uint16_t	Flags;		/* seconds since did initial bootstrap */
+#	define BOOTP_BCAST	0x8000		/* ? */
+	IP4_t		cip;		/* Client IP */
+	IP4_t		yip;		/* Your IP */
+	IP4_t		sip;		/* IP to use for next boot stage */
+	IP4_t		gip;		/* Relay IP ? */
+	MAC_ADDR	CAddr;		/* Client hardware address */
+	uint8_t		Sname[64];	/* Server's hostname (Optional) */
+	uint8_t		bootfile[128];	/* boot filename */
+	union {
+#		if 1
+#		define BOOTP_DHCPVEND  1024    /* DHCP extended vendor field size */
+#		else
+#		define BOOTP_DHCPVEND  312	/* DHCP standard vendor field size */
+#		endif
+		uint8_t		d[BOOTP_DHCPVEND];	/* raw array of vendor/dhcp options */
+		struct {
+			uint8_t		magic[4];	/* DHCP magic cookie */
+#			ifndef		VM_RFC1048
+#			define		VM_RFC1048	0x63825363L	/* ? */
+#			endif
+			uint32_t	flags;		/* bootp flags/opcodes */
+			uint8_t		pad[56];	/* I don't think intel knows what a
+							   union does... */
+		} v;
+	} vendor;
+} PACKED BOOTPLAYER;
+
+#define	PXENV_RESTART_TFTP		0x0073
+#define	t_PXENV_RESTART_TFTP		t_PXENV_TFTP_READ_FILE
+
+#define	PXENV_START_BASE		0x0075
+typedef struct {
+	PXENV_STATUS_t	Status;
+} PACKED t_PXENV_START_BASE;
+
+#define	PXENV_STOP_BASE			0x0076
+typedef struct {
+	PXENV_STATUS_t	Status;
+} PACKED t_PXENV_STOP_BASE;
diff -Naur grub-0.97.orig/netboot/r8169.c grub-0.97/netboot/r8169.c
--- grub-0.97.orig/netboot/r8169.c	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/r8169.c	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,854 @@
+/**************************************************************************
+*    r8169.c: Etherboot device driver for the RealTek RTL-8169 Gigabit
+*    Written 2003 by Timothy Legge <tlegge@rogers.com>
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the License, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not, write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*    Portions of this code based on:
+*	r8169.c: A RealTek RTL-8169 Gigabit Ethernet driver 
+* 		for Linux kernel 2.4.x.
+*
+*    Written 2002 ShuChen <shuchen@realtek.com.tw>
+*	  See Linux Driver for full information
+*	
+*    Linux Driver Version 1.27a, 10.02.2002
+* 
+*    Thanks to:
+*    	Jean Chen of RealTek Semiconductor Corp. for
+*    	providing the evaluation NIC used to develop 
+*    	this driver.  RealTek's support for Etherboot 
+*    	is appreciated.
+*    	
+*    REVISION HISTORY:
+*    ================
+*
+*    v1.0	11-26-2003	timlegge	Initial port of Linux driver
+*    v1.5	01-17-2004	timlegge	Initial driver output cleanup
+*    v1.6	03-27-2004	timlegge	Additional Cleanup
+*    
+*    Indent Options: indent -kr -i8
+***************************************************************************/
+
+/* to get some global routines like printf */
+#include "etherboot.h"
+/* to get the interface to the body of the program */
+#include "nic.h"
+/* to get the PCI support functions, if this is a PCI NIC */
+#include "pci.h"
+#include "timer.h"
+
+#define drv_version "v1.6"
+#define drv_date "03-27-2004"
+
+typedef unsigned char u8;
+typedef signed char s8;
+typedef unsigned short u16;
+typedef signed short s16;
+typedef unsigned int u32;
+typedef signed int s32;
+
+#define HZ 1000
+
+static u32 ioaddr;
+
+#ifdef EDEBUG
+#define dprintf(x) printf x
+#else
+#define dprintf(x)
+#endif
+
+/* Condensed operations for readability. */
+#define virt_to_le32desc(addr)  cpu_to_le32(virt_to_bus(addr))
+#define le32desc_to_virt(addr)  bus_to_virt(le32_to_cpu(addr))
+
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+
+/* media options 
+        _10_Half = 0x01,
+        _10_Full = 0x02,
+        _100_Half = 0x04,
+        _100_Full = 0x08,
+        _1000_Full = 0x10,
+*/
+static int media = -1;
+
+#if 0
+/* Maximum events (Rx packets, etc.) to handle at each interrupt. */
+static int max_interrupt_work = 20;
+#endif
+
+#if 0
+/* Maximum number of multicast addresses to filter (vs. Rx-all-multicast).
+   The RTL chips use a 64 element hash table based on the Ethernet CRC.  */
+static int multicast_filter_limit = 32;
+#endif
+
+/* MAC address length*/
+#define MAC_ADDR_LEN	6
+
+/* max supported gigabit ethernet frame size -- must be at least (dev->mtu+14+4).*/
+#define MAX_ETH_FRAME_SIZE	1536
+
+#define TX_FIFO_THRESH 256	/* In bytes */
+
+#define RX_FIFO_THRESH	7	/* 7 means NO threshold, Rx buffer level before first PCI xfer.  */
+#define RX_DMA_BURST	6	/* Maximum PCI burst, '6' is 1024 */
+#define TX_DMA_BURST	6	/* Maximum PCI burst, '6' is 1024 */
+#define EarlyTxThld 	0x3F	/* 0x3F means NO early transmit */
+#define RxPacketMaxSize	0x0800	/* Maximum size supported is 16K-1 */
+#define InterFrameGap	0x03	/* 3 means InterFrameGap = the shortest one */
+
+#define NUM_TX_DESC	1	/* Number of Tx descriptor registers */
+#define NUM_RX_DESC	4	/* Number of Rx descriptor registers */
+#define RX_BUF_SIZE	1536	/* Rx Buffer size */
+
+#define RTL_MIN_IO_SIZE 0x80
+#define TX_TIMEOUT  (6*HZ)
+
+/* write/read MMIO register */
+#define RTL_W8(reg, val8)	writeb ((val8), ioaddr + (reg))
+#define RTL_W16(reg, val16)	writew ((val16), ioaddr + (reg))
+#define RTL_W32(reg, val32)	writel ((val32), ioaddr + (reg))
+#define RTL_R8(reg)		readb (ioaddr + (reg))
+#define RTL_R16(reg)		readw (ioaddr + (reg))
+#define RTL_R32(reg)		((unsigned long) readl (ioaddr + (reg)))
+
+enum RTL8169_registers {
+	MAC0 = 0,		/* Ethernet hardware address. */
+	MAR0 = 8,		/* Multicast filter. */
+	TxDescStartAddr = 0x20,
+	TxHDescStartAddr = 0x28,
+	FLASH = 0x30,
+	ERSR = 0x36,
+	ChipCmd = 0x37,
+	TxPoll = 0x38,
+	IntrMask = 0x3C,
+	IntrStatus = 0x3E,
+	TxConfig = 0x40,
+	RxConfig = 0x44,
+	RxMissed = 0x4C,
+	Cfg9346 = 0x50,
+	Config0 = 0x51,
+	Config1 = 0x52,
+	Config2 = 0x53,
+	Config3 = 0x54,
+	Config4 = 0x55,
+	Config5 = 0x56,
+	MultiIntr = 0x5C,
+	PHYAR = 0x60,
+	TBICSR = 0x64,
+	TBI_ANAR = 0x68,
+	TBI_LPAR = 0x6A,
+	PHYstatus = 0x6C,
+	RxMaxSize = 0xDA,
+	CPlusCmd = 0xE0,
+	RxDescStartAddr = 0xE4,
+	EarlyTxThres = 0xEC,
+	FuncEvent = 0xF0,
+	FuncEventMask = 0xF4,
+	FuncPresetState = 0xF8,
+	FuncForceEvent = 0xFC,
+};
+
+enum RTL8169_register_content {
+	/*InterruptStatusBits */
+	SYSErr = 0x8000,
+	PCSTimeout = 0x4000,
+	SWInt = 0x0100,
+	TxDescUnavail = 0x80,
+	RxFIFOOver = 0x40,
+	RxUnderrun = 0x20,
+	RxOverflow = 0x10,
+	TxErr = 0x08,
+	TxOK = 0x04,
+	RxErr = 0x02,
+	RxOK = 0x01,
+
+	/*RxStatusDesc */
+	RxRES = 0x00200000,
+	RxCRC = 0x00080000,
+	RxRUNT = 0x00100000,
+	RxRWT = 0x00400000,
+
+	/*ChipCmdBits */
+	CmdReset = 0x10,
+	CmdRxEnb = 0x08,
+	CmdTxEnb = 0x04,
+	RxBufEmpty = 0x01,
+
+	/*Cfg9346Bits */
+	Cfg9346_Lock = 0x00,
+	Cfg9346_Unlock = 0xC0,
+
+	/*rx_mode_bits */
+	AcceptErr = 0x20,
+	AcceptRunt = 0x10,
+	AcceptBroadcast = 0x08,
+	AcceptMulticast = 0x04,
+	AcceptMyPhys = 0x02,
+	AcceptAllPhys = 0x01,
+
+	/*RxConfigBits */
+	RxCfgFIFOShift = 13,
+	RxCfgDMAShift = 8,
+
+	/*TxConfigBits */
+	TxInterFrameGapShift = 24,
+	TxDMAShift = 8,		/* DMA burst value (0-7) is shift this many bits */
+
+	/*rtl8169_PHYstatus */
+	TBI_Enable = 0x80,
+	TxFlowCtrl = 0x40,
+	RxFlowCtrl = 0x20,
+	_1000bpsF = 0x10,
+	_100bps = 0x08,
+	_10bps = 0x04,
+	LinkStatus = 0x02,
+	FullDup = 0x01,
+
+	/*GIGABIT_PHY_registers */
+	PHY_CTRL_REG = 0,
+	PHY_STAT_REG = 1,
+	PHY_AUTO_NEGO_REG = 4,
+	PHY_1000_CTRL_REG = 9,
+
+	/*GIGABIT_PHY_REG_BIT */
+	PHY_Restart_Auto_Nego = 0x0200,
+	PHY_Enable_Auto_Nego = 0x1000,
+
+	/* PHY_STAT_REG = 1; */
+	PHY_Auto_Neco_Comp = 0x0020,
+
+	/* PHY_AUTO_NEGO_REG = 4; */
+	PHY_Cap_10_Half = 0x0020,
+	PHY_Cap_10_Full = 0x0040,
+	PHY_Cap_100_Half = 0x0080,
+	PHY_Cap_100_Full = 0x0100,
+
+	/* PHY_1000_CTRL_REG = 9; */
+	PHY_Cap_1000_Full = 0x0200,
+
+	PHY_Cap_Null = 0x0,
+
+	/*_MediaType*/
+	_10_Half = 0x01,
+	_10_Full = 0x02,
+	_100_Half = 0x04,
+	_100_Full = 0x08,
+	_1000_Full = 0x10,
+
+	/*_TBICSRBit*/
+	TBILinkOK = 0x02000000,
+};
+
+static struct {
+	const char *name;
+	u8 version;		/* depend on RTL8169 docs */
+	u32 RxConfigMask;	/* should clear the bits supported by this chip */
+} rtl_chip_info[] = {
+	{
+"RTL-8169", 0x00, 0xff7e1880,},};
+
+enum _DescStatusBit {
+	OWNbit = 0x80000000,
+	EORbit = 0x40000000,
+	FSbit = 0x20000000,
+	LSbit = 0x10000000,
+};
+
+struct TxDesc {
+	u32 status;
+	u32 vlan_tag;
+	u32 buf_addr;
+	u32 buf_Haddr;
+};
+
+struct RxDesc {
+	u32 status;
+	u32 vlan_tag;
+	u32 buf_addr;
+	u32 buf_Haddr;
+};
+
+/* The descriptors for this card are required to be aligned on
+256 byte boundaries.  As the align attribute does not do more than
+16 bytes of alignment it requires some extra steps.  Add 256 to the 
+size of the array and the init_ring adjusts the alignment */
+
+/* Define the TX Descriptor */
+static u8 tx_ring[NUM_TX_DESC * sizeof(struct TxDesc) + 256];
+
+/* Create a static buffer of size RX_BUF_SZ for each
+TX Descriptor.  All descriptors point to a
+part of this buffer */
+static unsigned char txb[NUM_TX_DESC * RX_BUF_SIZE];
+
+/* Define the RX Descriptor */
+static u8 rx_ring[NUM_RX_DESC * sizeof(struct TxDesc) + 256];
+
+/* Create a static buffer of size RX_BUF_SZ for each
+RX Descriptor   All descriptors point to a
+part of this buffer */
+static unsigned char rxb[NUM_RX_DESC * RX_BUF_SIZE];
+
+struct rtl8169_private {
+	void *mmio_addr;	/* memory map physical address */
+	int chipset;
+	unsigned long cur_rx;	/* Index into the Rx descriptor buffer of next Rx pkt. */
+	unsigned long cur_tx;	/* Index into the Tx descriptor buffer of next Rx pkt. */
+	unsigned char *TxDescArrays;	/* Index of Tx Descriptor buffer */
+	unsigned char *RxDescArrays;	/* Index of Rx Descriptor buffer */
+	struct TxDesc *TxDescArray;	/* Index of 256-alignment Tx Descriptor buffer */
+	struct RxDesc *RxDescArray;	/* Index of 256-alignment Rx Descriptor buffer */
+	unsigned char *RxBufferRing[NUM_RX_DESC];	/* Index of Rx Buffer array */
+	unsigned char *Tx_skbuff[NUM_TX_DESC];
+} tpx;
+
+static struct rtl8169_private *tpc;
+
+static const u16 rtl8169_intr_mask =
+    SYSErr | PCSTimeout | RxUnderrun | RxOverflow | RxFIFOOver | TxErr |
+    TxOK | RxErr | RxOK;
+static const unsigned int rtl8169_rx_config =
+    (RX_FIFO_THRESH << RxCfgFIFOShift) | (RX_DMA_BURST << RxCfgDMAShift);
+
+void mdio_write(int RegAddr, int value)
+{
+	int i;
+
+	RTL_W32(PHYAR, 0x80000000 | (RegAddr & 0xFF) << 16 | value);
+	udelay(1000);
+
+	for (i = 2000; i > 0; i--) {
+		/* Check if the RTL8169 has completed writing to the specified MII register */
+		if (!(RTL_R32(PHYAR) & 0x80000000)) {
+			break;
+		} else {
+			udelay(100);
+		}
+	}
+}
+
+int mdio_read(int RegAddr)
+{
+	int i, value = -1;
+
+	RTL_W32(PHYAR, 0x0 | (RegAddr & 0xFF) << 16);
+	udelay(1000);
+
+	for (i = 2000; i > 0; i--) {
+		/* Check if the RTL8169 has completed retrieving data from the specified MII register */
+		if (RTL_R32(PHYAR) & 0x80000000) {
+			value = (int) (RTL_R32(PHYAR) & 0xFFFF);
+			break;
+		} else {
+			udelay(100);
+		}
+	}
+	return value;
+}
+
+static int rtl8169_init_board(struct pci_device *pdev)
+{
+	int i;
+	unsigned long rtreg_base, rtreg_len;
+	u32 tmp;
+
+	rtreg_base = pci_bar_start(pdev, PCI_BASE_ADDRESS_1);
+	rtreg_len = pci_bar_size(pdev, PCI_BASE_ADDRESS_1);
+
+	/* check for weird/broken PCI region reporting */
+	if (rtreg_len < RTL_MIN_IO_SIZE) {
+		printf("Invalid PCI region size(s), aborting\n");
+	}
+
+	adjust_pci_device(pdev);
+/*      pm_cap = pci_find_capability(pdev, PCI_CAP_ID_PM); */
+
+	/* ioremap MMIO region */
+	ioaddr = (unsigned long) ioremap(rtreg_base, rtreg_len);
+	if (ioaddr == 0)
+		return 0;
+
+	tpc->mmio_addr = &ioaddr;
+	/* Soft reset the chip. */
+	RTL_W8(ChipCmd, CmdReset);
+
+	/* Check that the chip has finished the reset. */
+	for (i = 1000; i > 0; i--)
+		if ((RTL_R8(ChipCmd) & CmdReset) == 0)
+			break;
+		else
+			udelay(10);
+
+	/* identify chip attached to board */
+	tmp = RTL_R32(TxConfig);
+	tmp = ((tmp & 0x7c000000) + ((tmp & 0x00800000) << 2)) >> 24;
+
+	for (i = ARRAY_SIZE(rtl_chip_info) - 1; i >= 0; i--)
+		if (tmp == rtl_chip_info[i].version) {
+			tpc->chipset = i;
+			goto match;
+		}
+	/* if unknown chip, assume array element #0, original RTL-8169 in this case */
+	dprintf(("PCI device: unknown chip version, assuming RTL-8169\n"));
+	dprintf(("PCI device: TxConfig = 0x%hX\n",
+		 (unsigned long) RTL_R32(TxConfig)));
+	tpc->chipset = 0;
+	return 1;
+      match:
+	return 0;
+
+}
+
+/**************************************************************************
+IRQ - Wait for a frame
+***************************************************************************/
+void r8169_irq ( struct nic *nic __unused, irq_action_t action ) {
+	int intr_status = 0;
+	int interested = RxUnderrun | RxOverflow | RxFIFOOver | RxErr | RxOK;
+ 
+	switch ( action ) {
+		case DISABLE:
+		case ENABLE:
+			intr_status = RTL_R16(IntrStatus);
+			/* h/w no longer present (hotplug?) or major error, 
+				bail */
+			if (intr_status == 0xFFFF)
+				break;
+
+			intr_status = intr_status & ~interested;
+			if ( action == ENABLE )
+				intr_status = intr_status | interested;
+			RTL_W16(IntrMask, intr_status);
+			break;
+		case FORCE :
+			RTL_W8(TxPoll, (RTL_R8(TxPoll) | 0x01));
+			break;
+	}
+}
+
+/**************************************************************************
+POLL - Wait for a frame
+***************************************************************************/
+static int r8169_poll(struct nic *nic, int retreive)
+{
+	/* return true if there's an ethernet packet ready to read */
+	/* nic->packet should contain data on return */
+	/* nic->packetlen should contain length of data */
+	int cur_rx;
+	unsigned int intr_status = 0;
+	cur_rx = tpc->cur_rx;
+	if ((tpc->RxDescArray[cur_rx].status & OWNbit) == 0) {
+	         /* There is a packet ready */
+  	         if(!retreive)
+  	                 return 1;
+		intr_status = RTL_R16(IntrStatus);
+		/* h/w no longer present (hotplug?) or major error,
+			bail */
+		if (intr_status == 0xFFFF)
+			return 0;
+		RTL_W16(IntrStatus, intr_status & 
+			~(RxFIFOOver | RxOverflow | RxOK));
+
+		if (!(tpc->RxDescArray[cur_rx].status & RxRES)) {
+			nic->packetlen = (int) (tpc->RxDescArray[cur_rx].
+						status & 0x00001FFF) - 4;
+			memcpy(nic->packet, tpc->RxBufferRing[cur_rx],
+			       nic->packetlen);
+			if (cur_rx == NUM_RX_DESC - 1)
+				tpc->RxDescArray[cur_rx].status =
+				    (OWNbit | EORbit) + RX_BUF_SIZE;
+			else
+				tpc->RxDescArray[cur_rx].status =
+				    OWNbit + RX_BUF_SIZE;
+			tpc->RxDescArray[cur_rx].buf_addr =
+			    virt_to_bus(tpc->RxBufferRing[cur_rx]);
+		} else
+			printf("Error Rx");
+		/* FIXME: shouldn't I reset the status on an error */
+		cur_rx = (cur_rx + 1) % NUM_RX_DESC;
+		tpc->cur_rx = cur_rx;
+		RTL_W16(IntrStatus, intr_status & 
+			(RxFIFOOver | RxOverflow | RxOK));
+
+		return 1;
+
+	}
+	tpc->cur_rx = cur_rx;
+	/* FIXME: There is no reason to do this as cur_rx did not change */
+
+	return (0);		/* initially as this is called to flush the input */
+
+}
+
+/**************************************************************************
+TRANSMIT - Transmit a frame
+***************************************************************************/
+static void r8169_transmit(struct nic *nic, const char *d,	/* Destination */
+			   unsigned int t,	/* Type */
+			   unsigned int s,	/* size */
+			   const char *p)
+{				/* Packet */
+	/* send the packet to destination */
+
+	u16 nstype;
+	u32 to;
+	u8 *ptxb;
+	int entry = tpc->cur_tx % NUM_TX_DESC;
+
+	/* point to the current txb incase multiple tx_rings are used */
+	ptxb = tpc->Tx_skbuff[entry * MAX_ETH_FRAME_SIZE];
+	memcpy(ptxb, d, ETH_ALEN);
+	memcpy(ptxb + ETH_ALEN, nic->node_addr, ETH_ALEN);
+	nstype = htons((u16) t);
+	memcpy(ptxb + 2 * ETH_ALEN, (u8 *) & nstype, 2);
+	memcpy(ptxb + ETH_HLEN, p, s);
+	s += ETH_HLEN;
+	s &= 0x0FFF;
+	while (s < ETH_ZLEN)
+		ptxb[s++] = '\0';
+
+	tpc->TxDescArray[entry].buf_addr = virt_to_bus(ptxb);
+	if (entry != (NUM_TX_DESC - 1))
+		tpc->TxDescArray[entry].status =
+		    (OWNbit | FSbit | LSbit) | ((s > ETH_ZLEN) ? s :
+						ETH_ZLEN);
+	else
+		tpc->TxDescArray[entry].status =
+		    (OWNbit | EORbit | FSbit | LSbit) | ((s > ETH_ZLEN) ? s
+							 : ETH_ZLEN);
+	RTL_W8(TxPoll, 0x40);	/* set polling bit */
+
+	tpc->cur_tx++;
+	to = currticks() + TX_TIMEOUT;
+	while ((tpc->TxDescArray[entry].status & OWNbit) && (currticks() < to));	/* wait */
+
+	if (currticks() >= to) {
+		printf("TX Time Out");
+	}
+}
+
+static void rtl8169_set_rx_mode(struct nic *nic __unused)
+{
+	u32 mc_filter[2];	/* Multicast hash filter */
+	int rx_mode;
+	u32 tmp = 0;
+
+	/* IFF_ALLMULTI */
+	/* Too many to filter perfectly -- accept all multicasts. */
+	rx_mode = AcceptBroadcast | AcceptMulticast | AcceptMyPhys;
+	mc_filter[1] = mc_filter[0] = 0xffffffff;
+
+	tmp =
+	    rtl8169_rx_config | rx_mode | (RTL_R32(RxConfig) &
+					   rtl_chip_info[tpc->chipset].
+					   RxConfigMask);
+
+	RTL_W32(RxConfig, tmp);
+	RTL_W32(MAR0 + 0, mc_filter[0]);
+	RTL_W32(MAR0 + 4, mc_filter[1]);
+}
+static void rtl8169_hw_start(struct nic *nic)
+{
+	u32 i;
+
+	/* Soft reset the chip. */
+	RTL_W8(ChipCmd, CmdReset);
+
+	/* Check that the chip has finished the reset. */
+	for (i = 1000; i > 0; i--) {
+		if ((RTL_R8(ChipCmd) & CmdReset) == 0)
+			break;
+		else
+			udelay(10);
+	}
+
+	RTL_W8(Cfg9346, Cfg9346_Unlock);
+	RTL_W8(ChipCmd, CmdTxEnb | CmdRxEnb);
+	RTL_W8(EarlyTxThres, EarlyTxThld);
+
+	/* For gigabit rtl8169 */
+	RTL_W16(RxMaxSize, RxPacketMaxSize);
+
+	/* Set Rx Config register */
+	i = rtl8169_rx_config | (RTL_R32(RxConfig) &
+				 rtl_chip_info[tpc->chipset].RxConfigMask);
+	RTL_W32(RxConfig, i);
+
+	/* Set DMA burst size and Interframe Gap Time */
+	RTL_W32(TxConfig,
+		(TX_DMA_BURST << TxDMAShift) | (InterFrameGap <<
+						TxInterFrameGapShift));
+
+
+	tpc->cur_rx = 0;
+
+	RTL_W32(TxDescStartAddr, virt_to_le32desc(tpc->TxDescArray));
+	RTL_W32(RxDescStartAddr, virt_to_le32desc(tpc->RxDescArray));
+	RTL_W8(Cfg9346, Cfg9346_Lock);
+	udelay(10);
+
+	RTL_W32(RxMissed, 0);
+
+	rtl8169_set_rx_mode(nic);
+
+	/* no early-rx interrupts */
+	RTL_W16(MultiIntr, RTL_R16(MultiIntr) & 0xF000);
+}
+
+static void rtl8169_init_ring(struct nic *nic __unused)
+{
+	int i;
+
+	tpc->cur_rx = 0;
+	tpc->cur_tx = 0;
+	memset(tpc->TxDescArray, 0x0, NUM_TX_DESC * sizeof(struct TxDesc));
+	memset(tpc->RxDescArray, 0x0, NUM_RX_DESC * sizeof(struct RxDesc));
+
+	for (i = 0; i < NUM_TX_DESC; i++) {
+		tpc->Tx_skbuff[i] = &txb[i];
+	}
+
+	for (i = 0; i < NUM_RX_DESC; i++) {
+		if (i == (NUM_RX_DESC - 1))
+			tpc->RxDescArray[i].status =
+			    (OWNbit | EORbit) + RX_BUF_SIZE;
+		else
+			tpc->RxDescArray[i].status = OWNbit + RX_BUF_SIZE;
+
+		tpc->RxBufferRing[i] = &rxb[i * RX_BUF_SIZE];
+		tpc->RxDescArray[i].buf_addr =
+		    virt_to_bus(tpc->RxBufferRing[i]);
+	}
+}
+
+/**************************************************************************
+RESET - Finish setting up the ethernet interface
+***************************************************************************/
+static void r8169_reset(struct nic *nic)
+{
+	int i;
+	u8 diff;
+	u32 TxPhyAddr, RxPhyAddr;
+
+	tpc->TxDescArrays = tx_ring;
+	if (tpc->TxDescArrays == 0)
+		printf("Allot Error");
+	/* Tx Desscriptor needs 256 bytes alignment; */
+	TxPhyAddr = virt_to_bus(tpc->TxDescArrays);
+	diff = 256 - (TxPhyAddr - ((TxPhyAddr >> 8) << 8));
+	TxPhyAddr += diff;
+	tpc->TxDescArray = (struct TxDesc *) (tpc->TxDescArrays + diff);
+
+	tpc->RxDescArrays = rx_ring;
+	/* Rx Desscriptor needs 256 bytes alignment; */
+	RxPhyAddr = virt_to_bus(tpc->RxDescArrays);
+	diff = 256 - (RxPhyAddr - ((RxPhyAddr >> 8) << 8));
+	RxPhyAddr += diff;
+	tpc->RxDescArray = (struct RxDesc *) (tpc->RxDescArrays + diff);
+
+	if (tpc->TxDescArrays == NULL || tpc->RxDescArrays == NULL) {
+		printf("Allocate RxDescArray or TxDescArray failed\n");
+		return;
+	}
+
+	rtl8169_init_ring(nic);
+	rtl8169_hw_start(nic);
+	/* Construct a perfect filter frame with the mac address as first match
+	 * and broadcast for all others */
+	for (i = 0; i < 192; i++)
+		txb[i] = 0xFF;
+
+	txb[0] = nic->node_addr[0];
+	txb[1] = nic->node_addr[1];
+	txb[2] = nic->node_addr[2];
+	txb[3] = nic->node_addr[3];
+	txb[4] = nic->node_addr[4];
+	txb[5] = nic->node_addr[5];
+}
+
+/**************************************************************************
+DISABLE - Turn off ethernet interface
+***************************************************************************/
+static void r8169_disable(struct dev *dev __unused)
+{
+	int i;
+	/* Stop the chip's Tx and Rx DMA processes. */
+	RTL_W8(ChipCmd, 0x00);
+
+	/* Disable interrupts by clearing the interrupt mask. */
+	RTL_W16(IntrMask, 0x0000);
+
+	RTL_W32(RxMissed, 0);
+
+	tpc->TxDescArrays = NULL;
+	tpc->RxDescArrays = NULL;
+	tpc->TxDescArray = NULL;
+	tpc->RxDescArray = NULL;
+	for (i = 0; i < NUM_RX_DESC; i++) {
+		tpc->RxBufferRing[i] = NULL;
+	}
+}
+
+/**************************************************************************
+PROBE - Look for an adapter, this routine's visible to the outside
+***************************************************************************/
+
+#define board_found 1
+#define valid_link 0
+static int r8169_probe(struct dev *dev, struct pci_device *pci)
+{
+	struct nic *nic = (struct nic *) dev;
+	static int board_idx = -1;
+	static int printed_version = 0;
+	int i, rc;
+	int option = -1, Cap10_100 = 0, Cap1000 = 0;
+
+	printf("r8169.c: Found %s, Vendor=%hX Device=%hX\n",
+	       pci->name, pci->vendor, pci->dev_id);
+
+	board_idx++;
+
+	printed_version = 1;
+
+	/* point to private storage */
+	tpc = &tpx;
+
+	rc = rtl8169_init_board(pci);	/* Return code is meaningless */
+
+	/* Get MAC address.  FIXME: read EEPROM */
+	for (i = 0; i < MAC_ADDR_LEN; i++)
+		nic->node_addr[i] = RTL_R8(MAC0 + i);
+
+	dprintf(("%s: Identified chip type is '%s'.\n", pci->name,
+		 rtl_chip_info[tpc->chipset].name));
+	/* Print out some hardware info */
+	printf("%s: %! at ioaddr %hX, ", pci->name, nic->node_addr,
+	       ioaddr);
+
+	/* if TBI is not endbled */
+	if (!(RTL_R8(PHYstatus) & TBI_Enable)) {
+		int val = mdio_read(PHY_AUTO_NEGO_REG);
+
+		option = media;
+		/* Force RTL8169 in 10/100/1000 Full/Half mode. */
+		if (option > 0) {
+			printf(" Force-mode Enabled.\n");
+			Cap10_100 = 0, Cap1000 = 0;
+			switch (option) {
+			case _10_Half:
+				Cap10_100 = PHY_Cap_10_Half;
+				Cap1000 = PHY_Cap_Null;
+				break;
+			case _10_Full:
+				Cap10_100 = PHY_Cap_10_Full;
+				Cap1000 = PHY_Cap_Null;
+				break;
+			case _100_Half:
+				Cap10_100 = PHY_Cap_100_Half;
+				Cap1000 = PHY_Cap_Null;
+				break;
+			case _100_Full:
+				Cap10_100 = PHY_Cap_100_Full;
+				Cap1000 = PHY_Cap_Null;
+				break;
+			case _1000_Full:
+				Cap10_100 = PHY_Cap_Null;
+				Cap1000 = PHY_Cap_1000_Full;
+				break;
+			default:
+				break;
+			}
+			/* leave PHY_AUTO_NEGO_REG bit4:0 unchanged */
+			mdio_write(PHY_AUTO_NEGO_REG,
+				   Cap10_100 | (val & 0x1F));
+			mdio_write(PHY_1000_CTRL_REG, Cap1000);
+		} else {
+			dprintf(("Auto-negotiation Enabled.\n",
+				 pci->name));
+
+			/* enable 10/100 Full/Half Mode, leave PHY_AUTO_NEGO_REG bit4:0 unchanged */
+			mdio_write(PHY_AUTO_NEGO_REG,
+				   PHY_Cap_10_Half | PHY_Cap_10_Full |
+				   PHY_Cap_100_Half | PHY_Cap_100_Full |
+				   (val & 0x1F));
+
+			/* enable 1000 Full Mode */
+			mdio_write(PHY_1000_CTRL_REG, PHY_Cap_1000_Full);
+
+		}
+
+		/* Enable auto-negotiation and restart auto-nigotiation */
+		mdio_write(PHY_CTRL_REG,
+			   PHY_Enable_Auto_Nego | PHY_Restart_Auto_Nego);
+		udelay(100);
+
+		/* wait for auto-negotiation process */
+		for (i = 10000; i > 0; i--) {
+			/* Check if auto-negotiation complete */
+			if (mdio_read(PHY_STAT_REG) & PHY_Auto_Neco_Comp) {
+				udelay(100);
+				option = RTL_R8(PHYstatus);
+				if (option & _1000bpsF) {
+					printf
+					    ("1000Mbps Full-duplex operation.\n");
+				} else {
+					printf
+					    ("%sMbps %s-duplex operation.\n",
+					     (option & _100bps) ? "100" :
+					     "10",
+					     (option & FullDup) ? "Full" :
+					     "Half");
+				}
+				break;
+			} else {
+				udelay(100);
+			}
+		}		/* end for-loop to wait for auto-negotiation process */
+
+	} else {
+		udelay(100);
+		printf
+		    ("%s: 1000Mbps Full-duplex operation, TBI Link %s!\n",
+		     pci->name,
+		     (RTL_R32(TBICSR) & TBILinkOK) ? "OK" : "Failed");
+
+	}
+
+	r8169_reset(nic);
+	/* point to NIC specific routines */
+	dev->disable = r8169_disable;
+	nic->poll = r8169_poll;
+	nic->transmit = r8169_transmit;
+	nic->irqno = pci->irq;
+	nic->irq = r8169_irq;
+	nic->ioaddr = ioaddr;
+	return 1;
+
+}
+
+static struct pci_id r8169_nics[] = {
+	PCI_ROM(0x10ec, 0x8169, "r8169", "RealTek RTL8169 Gigabit Ethernet"),
+};
+
+struct pci_driver r8169_driver = {
+	.type = NIC_DRIVER,
+	.name = "r8169/PCI",
+	.probe = r8169_probe,
+	.ids = r8169_nics,
+	.id_count = sizeof(r8169_nics) / sizeof(r8169_nics[0]),
+	.class = 0,
+};
diff -Naur grub-0.97.orig/netboot/rtl8139.c grub-0.97/netboot/rtl8139.c
--- grub-0.97.orig/netboot/rtl8139.c	2003-07-09 11:45:38.000000000 +0000
+++ grub-0.97/netboot/rtl8139.c	2005-08-31 19:03:35.000000000 +0000
@@ -17,6 +17,8 @@
 /*********************************************************************/
 
 /*
+  28 Dec 2002	ken_yap@users.sourceforge.net (Ken Yap)
+     Put in virt_to_bus calls to allow Etherboot relocation.
 
   06 Apr 2001	ken_yap@users.sourceforge.net (Ken Yap)
      Following email from Hyun-Joon Cha, added a disable routine, otherwise
@@ -63,7 +65,6 @@
 #include "etherboot.h"
 #include "nic.h"
 #include "pci.h"
-#include "cards.h"
 #include "timer.h"
 
 #define RTL_TIMEOUT (1*TICKS_PER_SEC)
@@ -112,9 +113,19 @@
 	 * definitions we will probably never need to know about.  */
 };
 
+enum RxEarlyStatusBits {
+	ERGood=0x08, ERBad=0x04, EROVW=0x02, EROK=0x01
+};
+
 enum ChipCmdBits {
 	CmdReset=0x10, CmdRxEnb=0x08, CmdTxEnb=0x04, RxBufEmpty=0x01, };
 
+enum IntrMaskBits {
+	SERR=0x8000, TimeOut=0x4000, LenChg=0x2000,
+	FOVW=0x40, PUN_LinkChg=0x20, RXOVW=0x10,
+	TER=0x08, TOK=0x04, RER=0x02, ROK=0x01
+};
+
 /* Interrupt register bits, using my own meaningful names. */
 enum IntrStatusBits {
 	PCIErr=0x8000, PCSTimeout=0x4000, CableLenChange= 0x2000,
@@ -155,74 +166,68 @@
 	AcceptMulticast=0x04, AcceptMyPhys=0x02, AcceptAllPhys=0x01,
 };
 
-static int ioaddr;
 static unsigned int cur_rx,cur_tx;
 
 /* The RTL8139 can only transmit from a contiguous, aligned memory block.  */
 static unsigned char tx_buffer[TX_BUF_SIZE] __attribute__((aligned(4)));
-
-/* I know that this is a MEGA HACK, but the tagged boot image specification
- * states that we can do whatever we want below 0x10000 - so we do!  */
-/* But we still give the user the choice of using an internal buffer
-   just in case - Ken */
-#ifdef	USE_LOWMEM_BUFFER
-#define rx_ring ((unsigned char *)(0x10000 - (RX_BUF_LEN + 16)))
-#else
 static unsigned char rx_ring[RX_BUF_LEN+16] __attribute__((aligned(4)));
-#endif
 
-struct nic *rtl8139_probe(struct nic *nic, unsigned short *probeaddrs,
-	struct pci_device *pci);
-static int read_eeprom(int location);
+static int rtl8139_probe(struct dev *dev, struct pci_device *pci);
+static int read_eeprom(struct nic *nic, int location, int addr_len);
 static void rtl_reset(struct nic *nic);
 static void rtl_transmit(struct nic *nic, const char *destaddr,
 	unsigned int type, unsigned int len, const char *data);
-static int rtl_poll(struct nic *nic);
-static void rtl_disable(struct nic*);
+static int rtl_poll(struct nic *nic, int retrieve);
+static void rtl_disable(struct dev *);
+static void rtl_irq(struct nic *nic, irq_action_t action);
 
 
-struct nic *rtl8139_probe(struct nic *nic, unsigned short *probeaddrs,
-	struct pci_device *pci)
+static int rtl8139_probe(struct dev *dev, struct pci_device *pci)
 {
+	struct nic *nic = (struct nic *)dev;
 	int i;
 	int speed10, fullduplex;
+	int addr_len;
+	unsigned short *ap = (unsigned short*)nic->node_addr;
 
 	/* There are enough "RTL8139" strings on the console already, so
 	 * be brief and concentrate on the interesting pieces of info... */
 	printf(" - ");
 
 	/* Mask the bit that says "this is an io addr" */
-	ioaddr = probeaddrs[0] & ~3;
+	nic->ioaddr = pci->ioaddr & ~3;
+
+	/* Copy IRQ from PCI information */
+	nic->irqno = pci->irq;
 
 	adjust_pci_device(pci);
 
 	/* Bring the chip out of low-power mode. */
-	outb(0x00, ioaddr + Config1);
-
-	if (read_eeprom(0) != 0xffff) {
-		unsigned short *ap = (unsigned short*)nic->node_addr;
-		for (i = 0; i < 3; i++)
-			*ap++ = read_eeprom(i + 7);
-	} else {
-		unsigned char *ap = (unsigned char*)nic->node_addr;
-		for (i = 0; i < ETH_ALEN; i++)
-			*ap++ = inb(ioaddr + MAC0 + i);
-	}
+	outb(0x00, nic->ioaddr + Config1);
 
-	speed10 = inb(ioaddr + MediaStatus) & MSRSpeed10;
-	fullduplex = inw(ioaddr + MII_BMCR) & BMCRDuplex;
-	printf("ioaddr %#hX, addr %! %sMbps %s-duplex\n", ioaddr,
-		nic->node_addr,  speed10 ? "10" : "100",
-		fullduplex ? "full" : "half");
+	addr_len = read_eeprom(nic,0,8) == 0x8129 ? 8 : 6;
+	for (i = 0; i < 3; i++)
+	  *ap++ = read_eeprom(nic,i + 7,addr_len);
+
+	speed10 = inb(nic->ioaddr + MediaStatus) & MSRSpeed10;
+	fullduplex = inw(nic->ioaddr + MII_BMCR) & BMCRDuplex;
+	printf("ioaddr %#hX, irq %d, addr %! %sMbps %s-duplex\n", nic->ioaddr,
+	       nic->irqno, nic->node_addr,  speed10 ? "10" : "100",
+	       fullduplex ? "full" : "half");
 
 	rtl_reset(nic);
 
-	nic->reset = rtl_reset;
-	nic->poll = rtl_poll;
+	if (inb(nic->ioaddr + MediaStatus) & MSRLinkFail) {
+		printf("Cable not connected or other link failure\n");
+		return(0);
+	}
+
+	dev->disable  = rtl_disable;
+	nic->poll     = rtl_poll;
 	nic->transmit = rtl_transmit;
-	nic->disable = rtl_disable;
+	nic->irq      = rtl_irq;
 
-	return nic;
+	return 1;
 }
 
 /* Serial EEPROM section. */
@@ -244,22 +249,23 @@
 #define eeprom_delay()  inl(ee_addr)
 
 /* The EEPROM commands include the alway-set leading bit. */
-#define EE_WRITE_CMD    (5 << 6)
-#define EE_READ_CMD     (6 << 6)
-#define EE_ERASE_CMD    (7 << 6)
+#define EE_WRITE_CMD    (5)
+#define EE_READ_CMD     (6)
+#define EE_ERASE_CMD    (7)
 
-static int read_eeprom(int location)
+static int read_eeprom(struct nic *nic, int location, int addr_len)
 {
 	int i;
 	unsigned int retval = 0;
-	long ee_addr = ioaddr + Cfg9346;
-	int read_cmd = location | EE_READ_CMD;
+	long ee_addr = nic->ioaddr + Cfg9346;
+	int read_cmd = location | (EE_READ_CMD << addr_len);
 
 	outb(EE_ENB & ~EE_CS, ee_addr);
 	outb(EE_ENB, ee_addr);
+	eeprom_delay();
 
 	/* Shift the read command bits out. */
-	for (i = 10; i >= 0; i--) {
+	for (i = 4 + addr_len; i >= 0; i--) {
 		int dataval = (read_cmd & (1 << i)) ? EE_DATA_WRITE : 0;
 		outb(EE_ENB | dataval, ee_addr);
 		eeprom_delay();
@@ -279,31 +285,51 @@
 
 	/* Terminate the EEPROM access. */
 	outb(~EE_CS, ee_addr);
+	eeprom_delay();
 	return retval;
 }
 
+static const unsigned int rtl8139_rx_config = 
+	(RX_BUF_LEN_IDX << 11) |
+	(RX_FIFO_THRESH << 13) |
+	(RX_DMA_BURST << 8);
+	
+static void set_rx_mode(struct nic *nic) {
+	unsigned int mc_filter[2];
+	int rx_mode;
+	/* !IFF_PROMISC */
+	rx_mode = AcceptBroadcast | AcceptMulticast | AcceptMyPhys;
+	mc_filter[1] = mc_filter[0] = 0xffffffff;
+
+	outl(rtl8139_rx_config | rx_mode, nic->ioaddr + RxConfig);
+
+	outl(mc_filter[0], nic->ioaddr + MAR0 + 0);
+	outl(mc_filter[1], nic->ioaddr + MAR0 + 4);
+}
+	
 static void rtl_reset(struct nic* nic)
 {
 	int i;
 
-	outb(CmdReset, ioaddr + ChipCmd);
+	outb(CmdReset, nic->ioaddr + ChipCmd);
 
 	cur_rx = 0;
 	cur_tx = 0;
 
 	/* Give the chip 10ms to finish the reset. */
 	load_timer2(10*TICKS_PER_MS);
-	while ((inb(ioaddr + ChipCmd) & CmdReset) != 0 && timer2_running())
+	while ((inb(nic->ioaddr + ChipCmd) & CmdReset) != 0 &&
+	       timer2_running())
 		/* wait */;
 
 	for (i = 0; i < ETH_ALEN; i++)
-		outb(nic->node_addr[i], ioaddr + MAC0 + i);
+		outb(nic->node_addr[i], nic->ioaddr + MAC0 + i);
 
 	/* Must enable Tx/Rx before setting transfer thresholds! */
-	outb(CmdRxEnb | CmdTxEnb, ioaddr + ChipCmd);
+	outb(CmdRxEnb | CmdTxEnb, nic->ioaddr + ChipCmd);
 	outl((RX_FIFO_THRESH<<13) | (RX_BUF_LEN_IDX<<11) | (RX_DMA_BURST<<8),
-		ioaddr + RxConfig);		/* accept no frames yet!  */
-	outl((TX_DMA_BURST<<8)|0x03000000, ioaddr + TxConfig);
+		nic->ioaddr + RxConfig);	  /* accept no frames yet!  */
+	outl((TX_DMA_BURST<<8)|0x03000000, nic->ioaddr + TxConfig);
 
 	/* The Linux driver changes Config1 here to use a different LED pattern
 	 * for half duplex or full/autodetect duplex (for full/autodetect, the
@@ -316,19 +342,26 @@
 #ifdef	DEBUG_RX
 	printf("rx ring address is %X\n",(unsigned long)rx_ring);
 #endif
-	outl((unsigned long)rx_ring, ioaddr + RxBuf);
+	outl((unsigned long)virt_to_bus(rx_ring), nic->ioaddr + RxBuf);
+
+
 
-	/* Start the chip's Tx and Rx process. */
-	outl(0, ioaddr + RxMissed);
-	/* set_rx_mode */
-	outb(AcceptBroadcast|AcceptMyPhys, ioaddr + RxConfig);
 	/* If we add multicast support, the MAR0 register would have to be
 	 * initialized to 0xffffffffffffffff (two 32 bit accesses).  Etherboot
 	 * only needs broadcast (for ARP/RARP/BOOTP/DHCP) and unicast.  */
-	outb(CmdRxEnb | CmdTxEnb, ioaddr + ChipCmd);
 
+	outb(CmdRxEnb | CmdTxEnb, nic->ioaddr + ChipCmd);
+	
+	outl(rtl8139_rx_config, nic->ioaddr + RxConfig);
+	
+	/* Start the chip's Tx and Rx process. */
+	outl(0, nic->ioaddr + RxMissed);
+
+	/* set_rx_mode */
+	set_rx_mode(nic);
+	
 	/* Disable all known interrupts by setting the interrupt mask. */
-	outw(0, ioaddr + IntrMask);
+	outw(0, nic->ioaddr + IntrMask);
 }
 
 static void rtl_transmit(struct nic *nic, const char *destaddr,
@@ -337,10 +370,11 @@
 	unsigned int status, to, nstype;
 	unsigned long txstatus;
 
+	/* nstype assignment moved up here to avoid gcc 3.0.3 compiler bug */
+	nstype = htons(type);
 	memcpy(tx_buffer, destaddr, ETH_ALEN);
 	memcpy(tx_buffer + ETH_ALEN, nic->node_addr, ETH_ALEN);
-	nstype = htons(type);
-	memcpy(tx_buffer + 2 * ETH_ALEN, (char*)&nstype, 2);
+	memcpy(tx_buffer + 2 * ETH_ALEN, &nstype, 2);
 	memcpy(tx_buffer + ETH_HLEN, data, len);
 
 	len += ETH_HLEN;
@@ -354,22 +388,22 @@
 		tx_buffer[len++] = '\0';
 	}
 
-	outl((unsigned long)tx_buffer, ioaddr + TxAddr0 + cur_tx*4);
+	outl((unsigned long)virt_to_bus(tx_buffer), nic->ioaddr + TxAddr0 + cur_tx*4);
 	outl(((TX_FIFO_THRESH<<11) & 0x003f0000) | len,
-		ioaddr + TxStatus0 + cur_tx*4);
+		nic->ioaddr + TxStatus0 + cur_tx*4);
 
 	to = currticks() + RTL_TIMEOUT;
 
 	do {
-		status = inw(ioaddr + IntrStatus);
+		status = inw(nic->ioaddr + IntrStatus);
 		/* Only acknlowledge interrupt sources we can properly handle
 		 * here - the RxOverflow/RxFIFOOver MUST be handled in the
 		 * rtl_poll() function.  */
-		outw(status & (TxOK | TxErr | PCIErr), ioaddr + IntrStatus);
+		outw(status & (TxOK | TxErr | PCIErr), nic->ioaddr + IntrStatus);
 		if ((status & (TxOK | TxErr | PCIErr)) != 0) break;
 	} while (currticks() < to);
 
-	txstatus = inl(ioaddr+ TxStatus0 + cur_tx*4);
+	txstatus = inl(nic->ioaddr+ TxStatus0 + cur_tx*4);
 
 	if (status & TxOK) {
 		cur_tx = (cur_tx + 1) % NUM_TX_DESC;
@@ -386,19 +420,22 @@
 	}
 }
 
-static int rtl_poll(struct nic *nic)
+static int rtl_poll(struct nic *nic, int retrieve)
 {
 	unsigned int status;
 	unsigned int ring_offs;
 	unsigned int rx_size, rx_status;
 
-	if (inb(ioaddr + ChipCmd) & RxBufEmpty) {
+	if (inb(nic->ioaddr + ChipCmd) & RxBufEmpty) {
 		return 0;
 	}
 
-	status = inw(ioaddr + IntrStatus);
+	/* There is a packet ready */
+	if ( ! retrieve ) return 1;
+
+	status = inw(nic->ioaddr + IntrStatus);
 	/* See below for the rest of the interrupt acknowledges.  */
-	outw(status & ~(RxFIFOOver | RxOverflow | RxOK), ioaddr + IntrStatus);
+	outw(status & ~(RxFIFOOver | RxOverflow | RxOK), nic->ioaddr + IntrStatus);
 
 #ifdef	DEBUG_RX
 	printf("rtl_poll: int %hX ", status);
@@ -438,21 +475,77 @@
 		nic->packet[12], nic->packet[13], rx_status);
 #endif
 	cur_rx = (cur_rx + rx_size + 4 + 3) & ~3;
-	outw(cur_rx - 16, ioaddr + RxBufPtr);
+	outw(cur_rx - 16, nic->ioaddr + RxBufPtr);
 	/* See RTL8139 Programming Guide V0.1 for the official handling of
 	 * Rx overflow situations.  The document itself contains basically no
 	 * usable information, except for a few exception handling rules.  */
-	outw(status & (RxFIFOOver | RxOverflow | RxOK), ioaddr + IntrStatus);
+	outw(status & (RxFIFOOver | RxOverflow | RxOK), nic->ioaddr + IntrStatus);
 	return 1;
 }
 
-static void rtl_disable(struct nic *nic)
+static void rtl_irq(struct nic *nic, irq_action_t action)
 {
+	unsigned int mask;
+	/* Bit of a guess as to which interrupts we should allow */
+	unsigned int interested = ROK | RER | RXOVW | FOVW | SERR;
+
+	switch ( action ) {
+	case DISABLE :
+	case ENABLE :
+		mask = inw(nic->ioaddr + IntrMask);
+		mask = mask & ~interested;
+		if ( action == ENABLE ) mask = mask | interested;
+		outw(mask, nic->ioaddr + IntrMask);
+		break;
+	case FORCE :
+		/* Apparently writing a 1 to this read-only bit of a
+		 * read-only and otherwise unrelated register will
+		 * force an interrupt.  If you ever want to see how
+		 * not to write a datasheet, read the one for the
+		 * RTL8139...
+		 */
+		outb(EROK, nic->ioaddr + RxEarlyStatus);
+		break;
+	}
+}
+
+static void rtl_disable(struct dev *dev)
+{
+	struct nic *nic = (struct nic *)dev;
+	/* merge reset and disable */
+	rtl_reset(nic);
+
 	/* reset the chip */
-	outb(CmdReset, ioaddr + ChipCmd);
+	outb(CmdReset, nic->ioaddr + ChipCmd);
 
 	/* 10 ms timeout */
 	load_timer2(10*TICKS_PER_MS);
-	while ((inb(ioaddr + ChipCmd) & CmdReset) != 0 && timer2_running())
+	while ((inb(nic->ioaddr + ChipCmd) & CmdReset) != 0 && timer2_running())
 		/* wait */;
 }
+
+static struct pci_id rtl8139_nics[] = {
+PCI_ROM(0x10ec, 0x8129, "rtl8129",       "Realtek 8129"),
+PCI_ROM(0x10ec, 0x8139, "rtl8139",       "Realtek 8139"),
+PCI_ROM(0x10ec, 0x8138, "rtl8139b",      "Realtek 8139B"),
+PCI_ROM(0x1186, 0x1300, "dfe538",        "DFE530TX+/DFE538TX"),
+PCI_ROM(0x1113, 0x1211, "smc1211-1",     "SMC EZ10/100"),
+PCI_ROM(0x1112, 0x1211, "smc1211",       "SMC EZ10/100"),
+PCI_ROM(0x1500, 0x1360, "delta8139",     "Delta Electronics 8139"),
+PCI_ROM(0x4033, 0x1360, "addtron8139",   "Addtron Technology 8139"),
+PCI_ROM(0x1186, 0x1340, "dfe690txd",     "D-Link DFE690TXD"),
+PCI_ROM(0x13d1, 0xab06, "fe2000vx",      "AboCom FE2000VX"),
+PCI_ROM(0x1259, 0xa117, "allied8139",    "Allied Telesyn 8139"),
+PCI_ROM(0x14ea, 0xab06, "fnw3603tx",     "Planex FNW-3603-TX"),
+PCI_ROM(0x14ea, 0xab07, "fnw3800tx",     "Planex FNW-3800-TX"),
+PCI_ROM(0xffff, 0x8139, "clone-rtl8139", "Cloned 8139"),
+};
+
+struct pci_driver rtl8139_driver = {
+	.type     = NIC_DRIVER,
+	.name     = "RTL8139",
+	.probe    = rtl8139_probe,
+	.ids      = rtl8139_nics,
+	.id_count = sizeof(rtl8139_nics)/sizeof(rtl8139_nics[0]),
+	.class    = 0,
+};
diff -Naur grub-0.97.orig/netboot/segoff.h grub-0.97/netboot/segoff.h
--- grub-0.97.orig/netboot/segoff.h	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/segoff.h	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,43 @@
+/*
+ * Segment:offset types and macros
+ *
+ * Initially written by Michael Brown (mcb30).
+ */
+
+#ifndef SEGOFF_H
+#define SEGOFF_H
+
+#include <stdint.h>
+#include <io.h>
+
+/* Segment:offset structure.  Note that the order within the structure
+ * is offset:segment.
+ */
+typedef struct {
+	uint16_t offset;
+	uint16_t segment;
+} segoff_t;
+
+/* For PXE stuff */
+typedef segoff_t SEGOFF16_t;
+
+/* Macros for converting from virtual to segment:offset addresses,
+ * when we don't actually care which of the many isomorphic results we
+ * get.
+ */
+#ifdef DEBUG_SEGMENT
+uint16_t SEGMENT ( const void * const ptr ) {
+	uint32_t phys = virt_to_phys ( ptr );
+	if ( phys > 0xfffff ) {
+		printf ( "FATAL ERROR: segment address out of range\n" );
+	}
+	return phys >> 4;
+}
+#else
+#define SEGMENT(x) ( virt_to_phys ( x ) >> 4 )
+#endif
+#define OFFSET(x) ( virt_to_phys ( x ) & 0xf )
+#define SEGOFF(x) { OFFSET(x), SEGMENT(x) }
+#define VIRTUAL(x,y) ( phys_to_virt ( ( ( x ) << 4 ) + ( y ) ) )
+
+#endif /* SEGOFF_H */
diff -Naur grub-0.97.orig/netboot/sis900.c grub-0.97/netboot/sis900.c
--- grub-0.97.orig/netboot/sis900.c	2003-07-09 11:45:38.000000000 +0000
+++ grub-0.97/netboot/sis900.c	2005-08-31 20:02:38.000000000 +0000
@@ -27,6 +27,11 @@
 /* Revision History */
 
 /*
+  07 Dec 2003  timlegge - Enabled Multicast Support
+  06 Dec 2003  timlegge - Fixed relocation issue in 5.2
+  04 Jan 2002  Chien-Yu Chen, Doug Ambrisko, Marty Connor  Patch to Etherboot 5.0.5
+     Added support for the SiS 630ET plus various bug fixes from linux kernel
+     source 2.4.17.
   01 March 2001  mdc     1.0
      Initial Release.  Tested with PCI based sis900 card and ThinkNIC
      computer.
@@ -35,13 +40,12 @@
      Testet with SIS730S chipset + ICS1893
 */
 
-
 /* Includes */
 
 #include "etherboot.h"
 #include "nic.h"
 #include "pci.h"
-#include "cards.h"
+#include "timer.h"
 
 #include "sis900.h"
 
@@ -51,6 +55,7 @@
 
 static unsigned short vendor, dev_id;
 static unsigned long ioaddr;
+static u8 pci_revision;
 
 static unsigned int cur_phy;
 
@@ -58,15 +63,10 @@
 
 static BufferDesc txd;
 static BufferDesc rxd[NUM_RX_DESC];
-
-#ifdef USE_LOWMEM_BUFFER
-#define txb ((char *)0x10000 - TX_BUF_SIZE)
-#define rxb ((char *)0x10000 - NUM_RX_DESC*RX_BUF_SIZE - TX_BUF_SIZE)
-#else
 static unsigned char txb[TX_BUF_SIZE];
 static unsigned char rxb[NUM_RX_DESC * RX_BUF_SIZE];
-#endif
 
+#if 0
 static struct mac_chip_info {
     const char *name;
     u16 vendor_id, device_id, flags;
@@ -78,11 +78,13 @@
       PCI_COMMAND_IO|PCI_COMMAND_MASTER, SIS900_TOTAL_SIZE},
     {0,0,0,0,0} /* 0 terminated list. */
 };
+#endif
 
 static void sis900_read_mode(struct nic *nic, int phy_addr, int *speed, int *duplex);
 static void amd79c901_read_mode(struct nic *nic, int phy_addr, int *speed, int *duplex);
 static void ics1893_read_mode(struct nic *nic, int phy_addr, int *speed, int *duplex);
 static void rtl8201_read_mode(struct nic *nic, int phy_addr, int *speed, int *duplex);
+static void vt6103_read_mode(struct nic *nic, int phy_addr, int *speed, int *duplex);
 
 static struct mii_chip_info {
     const char * name;
@@ -96,6 +98,7 @@
     {"AMD 79C901 HomePNA PHY",   0x0000, 0x35c8, amd79c901_read_mode},
     {"ICS 1893 Integrated PHYceiver"   , 0x0015, 0xf441,ics1893_read_mode},
     {"RTL 8201 10/100Mbps Phyceiver"   , 0x0000, 0x8201,rtl8201_read_mode},
+    {"VIA 6103 10/100Mbps Phyceiver", 0x0101, 0x8f20,vt6103_read_mode},
     {0,0,0,0}
 };
 
@@ -106,24 +109,32 @@
     u16 status;
 } mii;
 
-
 // PCI to ISA bridge for SIS640E access
-static struct pci_device   pci_isa_bridge_list[] = {
+static struct pci_id   pci_isa_bridge_list[] = {
 	{ 0x1039, 0x0008,
-		"SIS 85C503/5513 PCI to ISA bridge", 0, 0, 0, 0},
-	{0, 0, NULL, 0, 0, 0, 0}
+		"SIS 85C503/5513 PCI to ISA bridge"},
+};
+
+struct pci_driver sis_bridge_driver = {
+	.type     = BRIDGE_DRIVER,
+	.name     = "",
+	.probe    = 0,
+	.ids      = pci_isa_bridge_list,
+	.id_count = sizeof(pci_isa_bridge_list)/sizeof(pci_isa_bridge_list[0]),
+	.class    = 0,
 };
 
 /* Function Prototypes */
 
-struct nic *sis900_probe(struct nic *nic, unsigned short *io_addrs, struct pci_device *pci);
+static int sis900_probe(struct dev *dev, struct pci_device *pci);
 
 static u16  sis900_read_eeprom(int location);
 static void sis900_mdio_reset(long mdio_addr);
 static void sis900_mdio_idle(long mdio_addr);
 static u16  sis900_mdio_read(int phy_id, int location);
+#if 0
 static void sis900_mdio_write(int phy_id, int location, int val);
-
+#endif
 static void sis900_init(struct nic *nic);
 
 static void sis900_reset(struct nic *nic);
@@ -136,9 +147,11 @@
 
 static void sis900_transmit(struct nic *nic, const char *d, 
                             unsigned int t, unsigned int s, const char *p);
-static int  sis900_poll(struct nic *nic);
+static int  sis900_poll(struct nic *nic, int retrieve);
+
+static void sis900_disable(struct dev *dev);
 
-static void sis900_disable(struct nic *nic);
+static void sis900_irq(struct nic *nic, irq_action_t action);
 
 /**
  *	sis900_get_mac_addr: - Get MAC address for stand alone SiS900 model
@@ -149,7 +162,7 @@
  *	MAC address is read from read_eeprom() into @net_dev->dev_addr.
  */
 
-static int sis900_get_mac_addr(struct pci_device * pci_dev , struct nic *nic)
+static int sis900_get_mac_addr(struct pci_device * pci_dev __unused, struct nic *nic)
 {
 	u16 signature;
 	int i;
@@ -168,6 +181,50 @@
 }
 
 /**
+ *	sis96x_get_mac_addr: - Get MAC address for SiS962 or SiS963 model
+ *	@pci_dev: the sis900 pci device
+ *	@net_dev: the net device to get address for 
+ *
+ *	SiS962 or SiS963 model, use EEPROM to store MAC address. And EEPROM 
+ *	is shared by
+ *	LAN and 1394. When access EEPROM, send EEREQ signal to hardware first 
+ *	and wait for EEGNT. If EEGNT is ON, EEPROM is permitted to be access 
+ *	by LAN, otherwise is not. After MAC address is read from EEPROM, send
+ *	EEDONE signal to refuse EEPROM access by LAN. 
+ *	The EEPROM map of SiS962 or SiS963 is different to SiS900. 
+ *	The signature field in SiS962 or SiS963 spec is meaningless. 
+ *	MAC address is read into @net_dev->dev_addr.
+ */
+
+static int sis96x_get_mac_addr(struct pci_device * pci_dev __unused, struct nic *nic)
+{
+/* 	long ioaddr = net_dev->base_addr; */
+	long ee_addr = ioaddr + mear;
+	u32 waittime = 0;
+	int i;
+	
+	printf("Alternate function\n");
+
+	outl(EEREQ, ee_addr);
+	while(waittime < 2000) {
+		if(inl(ee_addr) & EEGNT) {
+
+			/* get MAC address from EEPROM */
+			for (i = 0; i < 3; i++)
+			        ((u16 *)(nic->node_addr))[i] = sis900_read_eeprom(i+EEPROMMACAddr);
+
+			outl(EEDONE, ee_addr);
+			return 1;
+		} else {
+			udelay(1);	
+			waittime ++;
+		}
+	}
+	outl(EEDONE, ee_addr);
+	return 0;
+}
+
+/**
  *	sis630e_get_mac_addr: - Get MAC address for SiS630E model
  *	@pci_dev: the sis900 pci device
  *	@net_dev: the net device to get address for
@@ -177,17 +234,21 @@
  *	MAC address is read into @net_dev->dev_addr.
  */
 
-static int sis630e_get_mac_addr(struct pci_device * pci_dev, struct nic *nic)
+static int sis630e_get_mac_addr(struct pci_device * pci_dev __unused, struct nic *nic)
 {
 	u8 reg;
 	int i;
-	struct pci_device	*p;
-
-	// find PCI to ISA bridge
-	eth_pci_init(pci_isa_bridge_list);
+	struct pci_device	p[1];
 
-    /* the firts entry in this list should contain bus/devfn */
-    p = pci_isa_bridge_list;
+	/* find PCI to ISA bridge */
+	memset(p, 0, sizeof(p));
+	do {
+		find_pci(BRIDGE_DRIVER, p);
+	} while(p->driver && p->driver != &sis_bridge_driver);
+
+	/* error on failure */
+	if (!p->driver)
+	    return 0;
 
 	pcibios_read_config_byte(p->bus,p->devfn, 0x48, &reg);
 	pcibios_write_config_byte(p->bus,p->devfn, 0x48, reg | 0x40);
@@ -201,7 +262,43 @@
 
 	return 1;
 }
-
+
+/**
+ *      sis630e_get_mac_addr: - Get MAC address for SiS630E model
+ *      @pci_dev: the sis900 pci device
+ *      @net_dev: the net device to get address for
+ *
+ *      SiS630E model, use APC CMOS RAM to store MAC address.
+ *      APC CMOS RAM is accessed through ISA bridge.
+ *      MAC address is read into @net_dev->dev_addr.
+ */
+
+static int sis635_get_mac_addr(struct pci_device * pci_dev __unused, struct nic *nic)
+{
+        u32 rfcrSave;
+        u32 i;
+	
+	
+        rfcrSave = inl(rfcr + ioaddr);
+
+        outl(rfcrSave | RELOAD, ioaddr + cr);
+        outl(0, ioaddr + cr);
+
+        /* disable packet filtering before setting filter */
+        outl(rfcrSave & ~RFEN, rfcr + ioaddr);
+
+        /* load MAC addr to filter data register */
+        for (i = 0 ; i < 3 ; i++) {
+                outl((i << RFADDR_shift), ioaddr + rfcr);
+                *( ((u16 *)nic->node_addr) + i) = inw(ioaddr + rfdr);
+        }
+
+        /* enable packet filitering */
+        outl(rfcrSave | RFEN, rfcr + ioaddr);
+
+        return 1;
+}
+
 /* 
  * Function: sis900_probe
  *
@@ -216,19 +313,21 @@
  * Returns:   struct nic *:          pointer to NIC data structure
  */
 
-struct nic *sis900_probe(struct nic *nic, unsigned short *io_addrs, struct pci_device *pci)
+static int sis900_probe(struct dev *dev, struct pci_device *pci)
 {
+    struct nic *nic = (struct nic *)dev;
     int i;
     int found=0;
     int phy_addr;
-    u16 signature;
     u8 revision;
     int ret;
 
-    if (io_addrs == 0 || *io_addrs == 0)
-        return NULL;
+    if (pci->ioaddr == 0)
+        return 0;
 
-    ioaddr  = *io_addrs & ~3;
+    nic->irqno  = 0;
+    nic->ioaddr = pci->ioaddr & ~3;
+    ioaddr  = pci->ioaddr & ~3;
     vendor  = pci->vendor;
     dev_id  = pci->dev_id;
 
@@ -240,19 +339,29 @@
     /* get MAC address */
     ret = 0;
     pcibios_read_config_byte(pci->bus,pci->devfn, PCI_REVISION, &revision);
-    if (revision == SIS630E_900_REV || revision == SIS630EA1_900_REV)
-       ret = sis630e_get_mac_addr(pci, nic);
-    else if (revision == SIS630S_900_REV)
+    
+    /* save for use later in sis900_reset() */
+    pci_revision = revision; 
+
+    if (revision == SIS630E_900_REV)
         ret = sis630e_get_mac_addr(pci, nic);
+    else if ((revision > 0x81) && (revision <= 0x90))
+        ret = sis635_get_mac_addr(pci, nic);
+    else if (revision == SIS96x_900_REV)
+	ret = sis96x_get_mac_addr(pci, nic);
     else
         ret = sis900_get_mac_addr(pci, nic);
 
     if (ret == 0)
     {
         printf ("sis900_probe: Error MAC address not found\n");
-        return NULL;
+        return 0;
     }
 
+    /* 630ET : set the mii access mode as software-mode */
+    if (revision == SIS630ET_900_REV)
+	outl(ACCESSMODE | inl(ioaddr + cr), ioaddr + cr);
+
     printf("\nsis900_probe: MAC addr %! at ioaddr %#hX\n",
            nic->node_addr, ioaddr);
     printf("sis900_probe: Vendor:%#hX Device:%#hX\n", vendor, dev_id);
@@ -264,7 +373,7 @@
     for (phy_addr = 0; phy_addr < 32; phy_addr++) {
         u16 mii_status;
         u16 phy_id0, phy_id1;
-                
+
         mii_status = sis900_mdio_read(phy_addr, MII_STATUS);
         if (mii_status == 0xffff || mii_status == 0x0000)
             /* the mii is not accessable, try next one */
@@ -272,7 +381,7 @@
                 
         phy_id0 = sis900_mdio_read(phy_addr, MII_PHY_ID0);
         phy_id1 = sis900_mdio_read(phy_addr, MII_PHY_ID1);
-                
+
         /* search our mii table for the current mii */ 
         for (i = 0; mii_chip_table[i].phy_id1; i++) {
 
@@ -294,7 +403,7 @@
         
     if (found == 0) {
         printf("sis900_probe: No MII transceivers found!\n");
-        return NULL;
+        return 0;
     }
 
     /* Arbitrarily select the last PHY found as current PHY */
@@ -304,15 +413,14 @@
     /* initialize device */
     sis900_init(nic);
 
-    nic->reset    = sis900_init;
+    dev->disable  = sis900_disable;
     nic->poll     = sis900_poll;
     nic->transmit = sis900_transmit;
-    nic->disable  = sis900_disable;
+    nic->irq      = sis900_irq;
 
-    return nic;
+    return 1;
 }
 
-
 /* 
  * EEPROM Routines:  These functions read and write to EEPROM for 
  *    retrieving the MAC address and other configuration information about 
@@ -322,7 +430,6 @@
 /* Delay between EEPROM clock transitions. */
 #define eeprom_delay()  inl(ee_addr)
 
-
 /* Function: sis900_read_eeprom
  *
  * Description: reads and returns a given location from EEPROM
@@ -378,7 +485,6 @@
 
 #define sis900_mdio_delay()    inl(mdio_addr)
 
-
 /* 
    Read and write the MII management registers using software-generated
    serial MDIO protocol. Note that the command bits and data bits are
@@ -432,9 +538,11 @@
         outl(MDC, mdio_addr);
         sis900_mdio_delay();
     }
+    outl(0x00, mdio_addr);
     return retval;
 }
 
+#if 0
 static void sis900_mdio_write(int phy_id, int location, int value)
 {
     long mdio_addr = ioaddr + mear;
@@ -471,10 +579,11 @@
         outb(MDC, mdio_addr);
         sis900_mdio_delay();
     }
+    outl(0x00, mdio_addr);
     return;
 }
+#endif
 
-
 /* Function: sis900_init
  *
  * Description: resets the ethernet controller chip and various
@@ -500,10 +609,9 @@
 
     sis900_check_mode(nic);
 
-    outl(RxENA, ioaddr + cr);
+    outl(RxENA| inl(ioaddr + cr), ioaddr + cr);
 }
 
-
 /* 
  * Function: sis900_reset
  *
@@ -515,7 +623,7 @@
  */
 
 static void 
-sis900_reset(struct nic *nic)
+sis900_reset(struct nic *nic __unused)
 {
     int i = 0;
     u32 status = TxRCMP | RxRCMP;
@@ -524,16 +632,19 @@
     outl(0, ioaddr + imr);
     outl(0, ioaddr + rfcr);
 
-    outl(RxRESET | TxRESET | RESET, ioaddr + cr);
-        
+    outl(RxRESET | TxRESET | RESET | inl(ioaddr + cr), ioaddr + cr);
+
     /* Check that the chip has finished the reset. */
     while (status && (i++ < 1000)) {
         status ^= (inl(isr + ioaddr) & status);
     }
-    outl(PESEL, ioaddr + cfg);
+
+    if( (pci_revision == SIS635A_900_REV) || (pci_revision == SIS900B_900_REV) )
+            outl(PESEL | RND_CNT, ioaddr + cfg);
+    else
+            outl(PESEL, ioaddr + cfg);
 }
 
-
 /* Function: sis_init_rxfilter
  *
  * Description: sets receive filter address to our MAC address
@@ -552,7 +663,7 @@
     rfcrSave = inl(rfcr + ioaddr);
 
     /* disable packet filtering before setting filter */
-    outl(rfcrSave & ~RFEN, rfcr);
+    outl(rfcrSave & ~RFEN, rfcr + ioaddr);
 
     /* load MAC addr to filter data register */
     for (i = 0 ; i < 3 ; i++) {
@@ -571,7 +682,6 @@
     outl(rfcrSave | RFEN, rfcr + ioaddr);
 }
 
-
 /* 
  * Function: sis_init_txd
  *
@@ -583,20 +693,19 @@
  */
 
 static void
-sis900_init_txd(struct nic *nic)
+sis900_init_txd(struct nic *nic __unused)
 {
     txd.link   = (u32) 0;
     txd.cmdsts = (u32) 0;
-    txd.bufptr = (u32) &txb[0];
+    txd.bufptr = virt_to_bus(&txb[0]);
 
     /* load Transmit Descriptor Register */
-    outl((u32) &txd, ioaddr + txdp); 
+    outl(virt_to_bus(&txd), ioaddr + txdp); 
     if (sis900_debug > 0)
         printf("sis900_init_txd: TX descriptor register loaded with: %X\n", 
                inl(ioaddr + txdp));
 }
 
-
 /* Function: sis_init_rxd
  *
  * Description: initializes the Rx descriptor ring
@@ -607,7 +716,7 @@
  */
 
 static void 
-sis900_init_rxd(struct nic *nic) 
+sis900_init_rxd(struct nic *nic __unused) 
 { 
     int i;
 
@@ -615,16 +724,16 @@
 
     /* init RX descriptor */
     for (i = 0; i < NUM_RX_DESC; i++) {
-        rxd[i].link   = (i+1 < NUM_RX_DESC) ? (u32) &rxd[i+1] : (u32) &rxd[0];
+        rxd[i].link   = virt_to_bus((i+1 < NUM_RX_DESC) ? &rxd[i+1] : &rxd[0]);
         rxd[i].cmdsts = (u32) RX_BUF_SIZE;
-        rxd[i].bufptr = (u32) &rxb[i*RX_BUF_SIZE];
+        rxd[i].bufptr = virt_to_bus(&rxb[i*RX_BUF_SIZE]);
         if (sis900_debug > 0)
             printf("sis900_init_rxd: rxd[%d]=%X link=%X cmdsts=%X bufptr=%X\n", 
                    i, &rxd[i], rxd[i].link, rxd[i].cmdsts, rxd[i].bufptr);
     }
 
     /* load Receive Descriptor Register */
-    outl((u32) &rxd[0], ioaddr + rxdp);
+    outl(virt_to_bus(&rxd[0]), ioaddr + rxdp);
 
     if (sis900_debug > 0)
         printf("sis900_init_rxd: RX descriptor register loaded with: %X\n", 
@@ -632,7 +741,6 @@
 
 }
 
-
 /* Function: sis_init_rxd
  *
  * Description: 
@@ -644,25 +752,36 @@
  * Returns:   void.
  */
 
-static void sis900_set_rx_mode(struct nic *nic)
+static void sis900_set_rx_mode(struct nic *nic __unused)
 {
-    int i;
+    int i, table_entries;
+    u32 rx_mode; 
+    u16 mc_filter[16] = {0};	/* 256/128 bits multicast hash table */
+    	
+    if((pci_revision == SIS635A_900_REV) || (pci_revision == SIS900B_900_REV))
+	table_entries = 16;
+    else
+	table_entries = 8;
 
-    /* Configure Multicast Hash Table in Receive Filter 
-       to reject all MCAST packets */
-    for (i = 0; i < 8; i++) {
+    /* accept all multicast packet */
+    rx_mode = RFAAB | RFAAM;
+    for (i = 0; i < table_entries; i++)
+		mc_filter[i] = 0xffff;
+					
+    /* update Multicast Hash Table in Receive Filter */
+    for (i = 0; i < table_entries; i++) {
         /* why plus 0x04? That makes the correct value for hash table. */
         outl((u32)(0x00000004+i) << RFADDR_shift, ioaddr + rfcr);
-        outl((u32)(0x0), ioaddr + rfdr);
+        outl(mc_filter[i], ioaddr + rfdr);
     }
-    /* Accept Broadcast packets, destination addresses that match 
+
+    /* Accept Broadcast and multicast packets, destination addresses that match 
        our MAC address */
-    outl(RFEN | RFAAB, ioaddr + rfcr);
+    outl(RFEN | rx_mode, ioaddr + rfcr);
 
     return;
 }
 
-
 /* Function: sis900_check_mode
  *
  * Description: checks the state of transmit and receive
@@ -674,15 +793,21 @@
  */
 
 static void
-sis900_check_mode (struct nic *nic)
+sis900_check_mode(struct nic *nic)
 {
     int speed, duplex;
     u32 tx_flags = 0, rx_flags = 0;
 
     mii.chip_info->read_mode(nic, cur_phy, &speed, &duplex);
 
-    tx_flags = TxATP | (TX_DMA_BURST << TxMXDMA_shift) | (TX_FILL_THRESH << TxFILLT_shift);
-    rx_flags = RX_DMA_BURST << RxMXDMA_shift;
+    if( inl(ioaddr + cfg) & EDB_MASTER_EN ) {
+        tx_flags = TxATP | (DMA_BURST_64 << TxMXDMA_shift) | (TX_FILL_THRESH << TxFILLT_shift);
+	rx_flags = DMA_BURST_64 << RxMXDMA_shift;
+    }
+    else {
+            tx_flags = TxATP | (DMA_BURST_512 << TxMXDMA_shift) | (TX_FILL_THRESH << TxFILLT_shift);
+            rx_flags = DMA_BURST_512 << RxMXDMA_shift;
+    }
 
     if (speed == HW_SPEED_HOME || speed == HW_SPEED_10_MBPS) {
         rx_flags |= (RxDRNT_10 << RxDRNT_shift);
@@ -702,7 +827,6 @@
     outl (rx_flags, ioaddr + rxcfg);
 }
 
-
 /* Function: sis900_read_mode
  *
  * Description: retrieves and displays speed and duplex
@@ -714,24 +838,33 @@
  */
 
 static void
-sis900_read_mode(struct nic *nic, int phy_addr, int *speed, int *duplex)
+sis900_read_mode(struct nic *nic __unused, int phy_addr, int *speed, int *duplex)
 {
     int i = 0;
     u32 status;
+    u16 phy_id0, phy_id1;
         
     /* STSOUT register is Latched on Transition, read operation updates it */
     while (i++ < 2)
         status = sis900_mdio_read(phy_addr, MII_STSOUT);
 
-    if (status & MII_STSOUT_SPD)
-        *speed = HW_SPEED_100_MBPS;
-    else
-        *speed = HW_SPEED_10_MBPS;
-
-    if (status & MII_STSOUT_DPLX)
-        *duplex = FDX_CAPABLE_FULL_SELECTED;
-    else
-        *duplex = FDX_CAPABLE_HALF_SELECTED;
+    *speed = HW_SPEED_10_MBPS;
+    *duplex = FDX_CAPABLE_HALF_SELECTED;
+    
+    if (status & (MII_NWAY_TX | MII_NWAY_TX_FDX))
+	*speed = HW_SPEED_100_MBPS;
+    if (status & ( MII_NWAY_TX_FDX | MII_NWAY_T_FDX))
+	*duplex = FDX_CAPABLE_FULL_SELECTED;
+	
+    /* Workaround for Realtek RTL8201 PHY issue */
+    phy_id0 = sis900_mdio_read(phy_addr, MII_PHY_ID0);
+    phy_id1 = sis900_mdio_read(phy_addr, MII_PHY_ID1);
+    if((phy_id0 == 0x0000) && ((phy_id1 & 0xFFF0) == 0x8200)){
+	if(sis900_mdio_read(phy_addr, MII_CONTROL) & MII_CNTL_FDX)
+	    *duplex = FDX_CAPABLE_FULL_SELECTED;
+	if(sis900_mdio_read(phy_addr, 0x0019) & 0x01)
+	    *speed = HW_SPEED_100_MBPS;
+    }
 
     if (status & MII_STSOUT_LINK_FAIL)
         printf("sis900_read_mode: Media Link Off\n");
@@ -743,7 +876,6 @@
                "full" : "half");
 }
 
-
 /* Function: amd79c901_read_mode
  *
  * Description: retrieves and displays speed and duplex
@@ -755,7 +887,7 @@
  */
 
 static void
-amd79c901_read_mode(struct nic *nic, int phy_addr, int *speed, int *duplex)
+amd79c901_read_mode(struct nic *nic __unused, int phy_addr, int *speed, int *duplex)
 {
     int i;
     u16 status;
@@ -796,7 +928,6 @@
     }
 }
 
-
 /**
  *	ics1893_read_mode: - read media mode for ICS1893 PHY
  *	@net_dev: the net device to read mode for
@@ -808,7 +939,7 @@
  *	to determine the speed and duplex mode for sis900
  */
 
-static void ics1893_read_mode(struct nic *nic, int phy_addr, int *speed, int *duplex)
+static void ics1893_read_mode(struct nic *nic __unused, int phy_addr, int *speed, int *duplex)
 {
 	int i = 0;
 	u32 status;
@@ -848,7 +979,7 @@
  *	to determine the speed and duplex mode for sis900
  */
 
-static void rtl8201_read_mode(struct nic *nic, int phy_addr, int *speed, int *duplex)
+static void rtl8201_read_mode(struct nic *nic __unused, int phy_addr, int *speed, int *duplex)
 {
 	u32 status;
 
@@ -878,7 +1009,51 @@
 		       *duplex == FDX_CAPABLE_FULL_SELECTED ?
 		       "full" : "half");
 	else
-		printf("rtl9201_read_config_mode: Media Link Off\n");
+		printf("rtl8201_read_config_mode: Media Link Off\n");
+}
+
+/**
+ *	vt6103_read_mode: - read media mode for vt6103 phy
+ *	@nic: the net device to read mode for
+ *	@phy_addr: mii phy address
+ *	@speed: the transmit speed to be determined
+ *	@duplex: the duplex mode to be determined
+ *
+ *	read MII_STATUS register from rtl8201 phy
+ *	to determine the speed and duplex mode for sis900
+ */
+
+static void vt6103_read_mode(struct nic *nic __unused, int phy_addr, int *speed, int *duplex)
+{
+	u32 status;
+
+	status = sis900_mdio_read(phy_addr, MII_STATUS);
+
+	if (status & MII_STAT_CAN_TX_FDX) {
+		*speed = HW_SPEED_100_MBPS;
+		*duplex = FDX_CAPABLE_FULL_SELECTED;
+	}
+	else if (status & MII_STAT_CAN_TX) {
+		*speed = HW_SPEED_100_MBPS;
+		*duplex = FDX_CAPABLE_HALF_SELECTED;
+	}
+	else if (status & MII_STAT_CAN_T_FDX) {
+		*speed = HW_SPEED_10_MBPS;
+		*duplex = FDX_CAPABLE_FULL_SELECTED;
+	}
+	else if (status & MII_STAT_CAN_T) {
+		*speed = HW_SPEED_10_MBPS;
+		*duplex = FDX_CAPABLE_HALF_SELECTED;
+	}
+
+	if (status & MII_STAT_LINK)
+		printf("vt6103_read_mode: Media Link On %s %s-duplex \n",
+		       *speed == HW_SPEED_100_MBPS ?
+		       "100mbps" : "10mbps",
+		       *duplex == FDX_CAPABLE_FULL_SELECTED ?
+		       "full" : "half");
+	else
+		printf("vt6103_read_config_mode: Media Link Off\n");
 }
 
 /* Function: sis900_transmit
@@ -900,14 +1075,14 @@
                 unsigned int s,     /* size */
                 const char  *p)     /* Packet */
 {
-    u32 status, to, nstype;
+    u32 to, nstype;
     u32 tx_status;
     
     /* Stop the transmitter */
-    outl(TxDIS, ioaddr + cr);
+    outl(TxDIS | inl(ioaddr + cr), ioaddr + cr);
 
     /* load Transmit Descriptor Register */
-    outl((u32) &txd, ioaddr + txdp); 
+    outl(virt_to_bus(&txd), ioaddr + txdp); 
     if (sis900_debug > 1)
         printf("sis900_transmit: TX descriptor register loaded with: %X\n", 
                inl(ioaddr + txdp));
@@ -929,18 +1104,18 @@
         txb[s++] = '\0';
 
     /* set the transmit buffer descriptor and enable Transmit State Machine */
-    txd.bufptr = (u32) &txb[0];
+    txd.bufptr = virt_to_bus(&txb[0]);
     txd.cmdsts = (u32) OWN | s;
 
     /* restart the transmitter */
-    outl(TxENA, ioaddr + cr);
+    outl(TxENA | inl(ioaddr + cr), ioaddr + cr);
 
     if (sis900_debug > 1)
         printf("sis900_transmit: Queued Tx packet size %d.\n", (int) s);
 
     to = currticks() + TX_TIMEOUT;
 
-    while ((((volatile u32) tx_status=txd.cmdsts) & OWN) && (currticks() < to))
+    while ((volatile u32) ( tx_status=txd.cmdsts & OWN) && (currticks() < to))
         /* wait */ ;
 
     if (currticks() >= to) {
@@ -955,7 +1130,6 @@
     outl(0, ioaddr + imr);
 }
 
-
 /* Function: sis900_poll
  *
  * Description: checks for a received packet and returns it if found.
@@ -971,7 +1145,7 @@
  */
 
 static int
-sis900_poll(struct nic *nic)
+sis900_poll(struct nic *nic, int retrieve)
 {
     u32 rx_status = rxd[cur_rx].cmdsts;
     int retstat = 0;
@@ -986,6 +1160,8 @@
         printf("sis900_poll: got a packet: cur_rx:%d, status:%X\n",
                cur_rx, rx_status);
 
+    if ( ! retrieve ) return 1;
+    
     nic->packetlen = (rx_status & DSIZE) - CRC_SIZE;
 
     if (rx_status & (ABORT|OVERRUN|TOOLONG|RUNT|RXISERR|CRCERR|FAERR)) {
@@ -1001,18 +1177,18 @@
 
     /* return the descriptor and buffer to receive ring */
     rxd[cur_rx].cmdsts = RX_BUF_SIZE;
-    rxd[cur_rx].bufptr = (u32) &rxb[cur_rx*RX_BUF_SIZE];
+    rxd[cur_rx].bufptr = virt_to_bus(&rxb[cur_rx*RX_BUF_SIZE]);
         
     if (++cur_rx == NUM_RX_DESC)
         cur_rx = 0;
 
     /* re-enable the potentially idle receive state machine */
-    outl(RxENA , ioaddr + cr);
+    outl(RxENA | inl(ioaddr + cr), ioaddr + cr);
 
     return retstat;
+
 }
 
-
 /* Function: sis900_disable
  *
  * Description: Turns off interrupts and stops Tx and Rx engines
@@ -1023,12 +1199,53 @@
  */
 
 static void
-sis900_disable(struct nic *nic)
+sis900_disable(struct dev *dev)
 {
+    struct nic *nic = (struct nic *)dev;
+    /* merge reset and disable */
+    sis900_init(nic);
+
     /* Disable interrupts by clearing the interrupt mask. */
     outl(0, ioaddr + imr);
     outl(0, ioaddr + ier);
     
     /* Stop the chip's Tx and Rx Status Machine */
-    outl(RxDIS | TxDIS, ioaddr + cr);
+    outl(RxDIS | TxDIS | inl(ioaddr + cr), ioaddr + cr);
+}
+
+/* Function: sis900_irq
+ *
+ * Description: Enable, Disable, or Force, interrupts
+ *    
+ * Arguments: struct nic *nic:          NIC data structure
+ *            irq_action_t action:      Requested action       
+ *
+ * Returns:   void.
+ */
+
+static void
+sis900_irq(struct nic *nic __unused, irq_action_t action __unused)
+{
+  switch ( action ) {
+  case DISABLE :
+    break;
+  case ENABLE :
+    break;
+  case FORCE :
+    break;
+  }
 }
+
+static struct pci_id sis900_nics[] = {
+PCI_ROM(0x1039, 0x0900, "sis900",  "SIS900"),
+PCI_ROM(0x1039, 0x7016, "sis7016", "SIS7016"),
+};
+
+struct pci_driver sis900_driver = {
+	.type     = NIC_DRIVER,
+	.name     = "SIS900",
+	.probe    = sis900_probe,
+	.ids      = sis900_nics,
+	.id_count = sizeof(sis900_nics)/sizeof(sis900_nics[0]),
+	.class    = 0,
+};
diff -Naur grub-0.97.orig/netboot/sis900.h grub-0.97/netboot/sis900.h
--- grub-0.97.orig/netboot/sis900.h	2003-07-09 11:45:38.000000000 +0000
+++ grub-0.97/netboot/sis900.h	2005-08-31 19:03:35.000000000 +0000
@@ -39,14 +39,16 @@
 
 /* Symbolic names for bits in various registers */
 enum sis900_command_register_bits {
-    RESET   = 0x00000100, 
-    SWI     = 0x00000080, 
-    RxRESET = 0x00000020,
-    TxRESET = 0x00000010, 
-    RxDIS   = 0x00000008, 
-    RxENA   = 0x00000004,
-    TxDIS   = 0x00000002, 
-    TxENA   = 0x00000001
+    RELOAD     = 0x00000400,
+    ACCESSMODE = 0x00000200,
+    RESET      = 0x00000100, 
+    SWI        = 0x00000080, 
+    RxRESET    = 0x00000020,
+    TxRESET    = 0x00000010, 
+    RxDIS      = 0x00000008, 
+    RxENA      = 0x00000004,
+    TxDIS      = 0x00000002, 
+    TxENA      = 0x00000001
 };
 
 enum sis900_configuration_register_bits {
@@ -57,7 +59,10 @@
     EXD      = 0x00000010, 
     PESEL    = 0x00000008, 
     LPM      = 0x00000004, 
-    BEM      = 0x00000001
+    BEM      = 0x00000001,
+    RND_CNT  = 0x00000400,
+    FAIR_BACKOFF = 0x00000200,
+    EDB_MASTER_EN = 0x00002000
 };
 
 enum sis900_eeprom_access_reigster_bits {
@@ -108,6 +113,10 @@
 #define TX_DMA_BURST    0
 #define RX_DMA_BURST    0
 
+enum sis900_tx_rx_dma{
+	        DMA_BURST_512 = 0,      DMA_BURST_64 = 5
+};
+
 /* transmit FIFO threshholds */
 #define TX_FILL_THRESH  16      /* 1/4 FIFO size */
 #define TxFILLT_shift   8
@@ -172,6 +181,11 @@
     EEeraseAll      = 0x0120,
     EEwriteAll      = 0x0110, 
     EEaddrMask      = 0x013F, 
+    EEcmdShift 	    = 16
+};
+/* For SiS962 or SiS963, request the eeprom software access */
+enum sis96x_eeprom_command {
+	EEREQ = 0x00000400, EEDONE = 0x00000200, EEGNT = 0x00000100
 };
 
 /* Manamgement Data I/O (mdio) frame */
@@ -236,7 +250,8 @@
     MII_CONFIG1 = 0x0010,
     MII_CONFIG2 = 0x0011,
     MII_STSOUT  = 0x0012,
-    MII_MASK    = 0x0013
+    MII_MASK    = 0x0013,
+    MII_RESV    = 0x0014
 };
 
 /* mii registers specific to AMD 79C901 */
@@ -320,7 +335,9 @@
 
 enum sis900_revision_id {
 	SIS630A_900_REV = 0x80,		SIS630E_900_REV = 0x81,
-	SIS630S_900_REV = 0x82,		SIS630EA1_900_REV = 0x83
+	SIS630S_900_REV = 0x82,		SIS630EA1_900_REV = 0x83,
+	SIS630ET_900_REV = 0x84,        SIS635A_900_REV = 0x90,
+	SIS96x_900_REV = 0X91,		SIS900B_900_REV = 0x03
 };
 
 enum sis630_revision_id {
diff -Naur grub-0.97.orig/netboot/sis900.txt grub-0.97/netboot/sis900.txt
--- grub-0.97.orig/netboot/sis900.txt	2003-07-09 11:45:38.000000000 +0000
+++ grub-0.97/netboot/sis900.txt	1970-01-01 00:00:00.000000000 +0000
@@ -1,91 +0,0 @@
-How I added the SIS900 card to Etherboot
-
-Author: Marty Connor (mdc@thinguin.org)
-
-Date:   25 Febrary 2001
-
-Description:
-
-This file is intended to help people who want to write an Etherboot
-driver or port another driver to Etherboot.  It is a starting point.
-Perhaps someday I may write a more detailed description of writing an
-Etherboot driver. This text should help get people started, and
-studying sis900.[ch] should help show the basic structure and
-techniques involved in writing and Etherboot driver.
-
-***********************************************************************
-
-0. Back up all the files I need to modify:
-
-cd etherboot-4.7.20/src
-cp Makefile Makefile.orig
-cp config.c config.c.orig
-cp pci.h pci.h.orig
-cp NIC NIC.orig
-cp cards.h cards.h.orig
-
-1. Edit src/Makefile to add SIS900FLAGS to defines
-
-SIS900FLAGS=	       	-DINCLUDE_SIS900
-
-2. edit src/pci.h to add PCI signatures for card
-
-#define PCI_VENDOR_ID_SIS         	0x1039
-#define PCI_DEVICE_ID_SIS900     	0x0900   
-#define PCI_DEVICE_ID_SIS7016    	0x7016  
-
-3. Edit src/config.c to add the card to the card probe list
-
-#if defined(INCLUDE_NS8390)  || defined(INCLUDE_EEPRO100)  || 
-    defined(INCLUDE_LANCE)   || defined(INCLUDE_EPIC100)   || 
-    defined(INCLUDE_TULIP)   || defined(INCLUDE_OTULIP)    ||
-    defined(INCLUDE_3C90X)   || defined(INCLUDE_3C595)     ||
-    defined(INCLUDE_RTL8139) || defined(INCLUDE_VIA_RHINE) || 
-    defined(INCLUDE_SIS900)  || defined(INCLUDE_W89C840)
-
-... and ...
-
-#ifdef INCLUDE_SIS900
-       { PCI_VENDOR_ID_SIS,     	PCI_DEVICE_ID_SIS900,
-         "SIS900", 0, 0, 0, 0},
-       { PCI_VENDOR_ID_SIS,     	PCI_DEVICE_ID_SIS7016,
-	 "SIS7016", 0, 0, 0, 0},
-#endif
-
-... and ...
-
-#ifdef INCLUDE_SIS900
-	{ "SIS900", sis900_probe, pci_ioaddrs },	
-#endif
-
-4. Edit NIC to add sis900 and sis7016 to NIC list
-
-# SIS 900 and SIS 7016
-sis900		sis900		0x1039,0x0900
-sis7016		sis900		0x1039,0x7016
-
-5. Edit cards.h to add sis900 probe routine declaration
-
-#ifdef	INCLUDE_SIS900
-extern struct nic	*sis900_probe(struct nic *, unsigned short *
-                        PCI_ARG(struct pci_device *));
-#endif
-
-***********************************************************************
-
-At this point, you can begin creating your driver source file.  See
-the "Writing and Etherboot Driver" section of the Etherboot
-documentation for some hints.  See the skel.c file for a starting
-point.  If there is a Linux driver for the card, you may be able to
-use that.  Copy and learn from existing Etherboot drivers (this is GPL
-/ Open Source software!).
-
-Join the etherboot-developers and etherboot-users mailing lists
-(information is on etherboot.sourceforge.net) for information and
-assistance. We invite more developers to help improve Etherboot.
-
-Visit the http://etherboot.sourceforge.net, http://thinguin.org, 
-http://rom-o-matic.net, and http://ltsp.org sites for information and
-assistance.
-
-Enjoy.
diff -Naur grub-0.97.orig/netboot/sk_g16.c grub-0.97/netboot/sk_g16.c
--- grub-0.97.orig/netboot/sk_g16.c	2003-07-09 11:45:38.000000000 +0000
+++ grub-0.97/netboot/sk_g16.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,1160 +0,0 @@
-/**************************************************************************
-Etherboot -  BOOTP/TFTP Bootstrap Program
-Schneider & Koch G16 NIC driver for Etherboot
-heavily based on SK G16 driver from Linux 2.0.36
-Changes to make it work with Etherboot by Georg Baum <Georg.Baum@gmx.de>
-***************************************************************************/
-
-/*-
- * Copyright (C) 1994 by PJD Weichmann & SWS Bern, Switzerland
- *
- * This software may be used and distributed according to the terms
- * of the GNU Public License, incorporated herein by reference.
- *
- * Module         : sk_g16.c
- *
- * Version        : $Revision: 1.4 $
- *
- * Author         : Patrick J.D. Weichmann
- *
- * Date Created   : 94/05/26
- * Last Updated   : $Date: 2002/01/02 21:56:40 $
- *
- * Description    : Schneider & Koch G16 Ethernet Device Driver for
- *                  Linux Kernel >= 1.1.22
- * Update History :
- *
--*/
-
-/*
- * The Schneider & Koch (SK) G16 Network device driver is based
- * on the 'ni6510' driver from Michael Hipp which can be found at
- * ftp://sunsite.unc.edu/pub/Linux/system/Network/drivers/nidrivers.tar.gz
- *
- * Sources: 1) ni6510.c by M. Hipp
- *          2) depca.c  by D.C. Davies
- *          3) skeleton.c by D. Becker
- *          4) Am7990 Local Area Network Controller for Ethernet (LANCE),
- *             AMD, Pub. #05698, June 1989
- *
- * Many Thanks for helping me to get things working to:
- *
- *                 A. Cox (A.Cox@swansea.ac.uk)
- *                 M. Hipp (mhipp@student.uni-tuebingen.de)
- *                 R. Bolz (Schneider & Koch, Germany)
- *
- * See README.sk_g16 for details about limitations and bugs for the
- * current version.
- *
- * To Do:
- *        - Support of SK_G8 and other SK Network Cards.
- *        - Autoset memory mapped RAM. Check for free memory and then
- *          configure RAM correctly.
- *        - SK_close should really set card in to initial state.
- *        - Test if IRQ 3 is not switched off. Use autoirq() functionality.
- *          (as in /drivers/net/skeleton.c)
- *        - Implement Multicast addressing. At minimum something like
- *          in depca.c.
- *        - Redo the statistics part.
- *        - Try to find out if the board is in 8 Bit or 16 Bit slot.
- *          If in 8 Bit mode don't use IRQ 11.
- *        - (Try to make it slightly faster.)
- */
-
-/* to get some global routines like printf */
-#include "etherboot.h"
-/* to get the interface to the body of the program */
-#include "nic.h"
-
-/* From linux/if_ether.h: */
-#define ETH_ZLEN	60		/* Min. octets in frame sans FCS */
-
-#include "sk_g16.h"
-
-/*
- * Schneider & Koch Card Definitions
- * =================================
- */
-
-#define SK_NAME   "SK_G16"
-
-/*
- * SK_G16 Configuration
- * --------------------
- */
-
-/*
- * Abbreviations
- * -------------
- *
- * RAM - used for the 16KB shared memory
- * Boot_ROM, ROM - are used for referencing the BootEPROM
- *
- * SK_ADDR is a symbolic constant used to configure
- * the behaviour of the driver and the SK_G16.
- *
- * SK_ADDR defines the address where the RAM will be mapped into the real
- *         host memory.
- *         valid addresses are from 0xa0000 to 0xfc000 in 16Kbyte steps.
- */
-
-#define SK_ADDR         0xcc000
-
-/*
- * In POS3 are bits A14-A19 of the address bus. These bits can be set
- * to choose the RAM address. That's why we only can choose the RAM address
- * in 16KB steps.
- */
-
-#define POS_ADDR       (rom_addr>>14)  /* Do not change this line */
-
-/*
- * SK_G16 I/O PORT's + IRQ's + Boot_ROM locations
- * ----------------------------------------------
- */
-
-/*
- * As nearly every card has also SK_G16 a specified I/O Port region and
- * only a few possible IRQ's.
- * In the Installation Guide from Schneider & Koch is listed a possible
- * Interrupt IRQ2. IRQ2 is always IRQ9 in boards with two cascaded interrupt
- * controllers. So we use in SK_IRQS IRQ9.
- */
-
-/* Don't touch any of the following #defines. */
-
-#define SK_IO_PORTS     { 0x100, 0x180, 0x208, 0x220, 0x288, 0x320, 0x328, 0x390, 0 }
-
-/*
- * SK_G16 POS REGISTERS
- * --------------------
- */
-
-/*
- * SK_G16 has a Programmable Option Select (POS) Register.
- * The POS is composed of 8 separate registers (POS0-7) which
- * are I/O mapped on an address set by the W1 switch.
- *
- */
-
-#define SK_POS_SIZE 8           /* 8 I/O Ports are used by SK_G16 */
-
-#define SK_POS0     ioaddr      /* Card-ID Low (R) */
-#define SK_POS1     ioaddr+1    /* Card-ID High (R) */
-#define SK_POS2     ioaddr+2    /* Card-Enable, Boot-ROM Disable (RW) */
-#define SK_POS3     ioaddr+3    /* Base address of RAM */
-#define SK_POS4     ioaddr+4    /* IRQ */
-
-/* POS5 - POS7 are unused */
-
-/*
- * SK_G16 MAC PREFIX
- * -----------------
- */
-
-/*
- * Scheider & Koch manufacturer code (00:00:a5).
- * This must be checked, that we are sure it is a SK card.
- */
-
-#define SK_MAC0         0x00
-#define SK_MAC1         0x00
-#define SK_MAC2         0x5a
-
-/*
- * SK_G16 ID
- * ---------
- */
-
-/*
- * If POS0,POS1 contain the following ID, then we know
- * at which I/O Port Address we are.
- */
-
-#define SK_IDLOW  0xfd
-#define SK_IDHIGH 0x6a
-
-
-/*
- * LANCE POS Bit definitions
- * -------------------------
- */
-
-#define SK_ROM_RAM_ON  (POS2_CARD)
-#define SK_ROM_RAM_OFF (POS2_EPROM)
-#define SK_ROM_ON      (inb(SK_POS2) & POS2_CARD)
-#define SK_ROM_OFF     (inb(SK_POS2) | POS2_EPROM)
-#define SK_RAM_ON      (inb(SK_POS2) | POS2_CARD)
-#define SK_RAM_OFF     (inb(SK_POS2) & POS2_EPROM)
-
-#define POS2_CARD  0x0001              /* 1 = SK_G16 on      0 = off */
-#define POS2_EPROM 0x0002              /* 1 = Boot EPROM off 0 = on */
-
-/*
- * SK_G16 Memory mapped Registers
- * ------------------------------
- *
- */
-
-#define SK_IOREG        (board->ioreg) /* LANCE data registers.     */
-#define SK_PORT         (board->port)  /* Control, Status register  */
-#define SK_IOCOM        (board->iocom) /* I/O Command               */
-
-/*
- * SK_G16 Status/Control Register bits
- * -----------------------------------
- *
- * (C) Controlreg (S) Statusreg
- */
-
-/*
- * Register transfer: 0 = no transfer
- *                    1 = transferring data between LANCE and I/O reg
- */
-#define SK_IORUN        0x20
-
-/*
- * LANCE interrupt: 0 = LANCE interrupt occurred
- *                  1 = no LANCE interrupt occurred
- */
-#define SK_IRQ          0x10
-
-#define SK_RESET        0x08   /* Reset SK_CARD: 0 = RESET 1 = normal */
-#define SK_RW           0x02   /* 0 = write to 1 = read from */
-#define SK_ADR          0x01   /* 0 = REG DataPort 1 = RAP Reg addr port */
-
-
-#define SK_RREG         SK_RW  /* Transferdirection to read from lance */
-#define SK_WREG         0      /* Transferdirection to write to lance */
-#define SK_RAP          SK_ADR /* Destination Register RAP */
-#define SK_RDATA        0      /* Destination Register REG DataPort */
-
-/*
- * SK_G16 I/O Command
- * ------------------
- */
-
-/*
- * Any bitcombination sets the internal I/O bit (transfer will start)
- * when written to I/O Command
- */
-
-#define SK_DOIO         0x80   /* Do Transfer */
-
-/*
- * LANCE RAP (Register Address Port).
- * ---------------------------------
- */
-
-/*
- * The LANCE internal registers are selected through the RAP.
- * The Registers are:
- *
- * CSR0 - Status and Control flags
- * CSR1 - Low order bits of initialize block (bits 15:00)
- * CSR2 - High order bits of initialize block (bits 07:00, 15:08 are reserved)
- * CSR3 - Allows redefinition of the Bus Master Interface.
- *        This register must be set to 0x0002, which means BSWAP = 0,
- *        ACON = 1, BCON = 0;
- *
- */
-
-#define CSR0            0x00
-#define CSR1            0x01
-#define CSR2            0x02
-#define CSR3            0x03
-
-/*
- * General Definitions
- * ===================
- */
-
-/*
- * Set the number of Tx and Rx buffers, using Log_2(# buffers).
- * We have 16KB RAM which can be accessed by the LANCE. In the
- * memory are not only the buffers but also the ring descriptors and
- * the initialize block.
- * Don't change anything unless you really know what you do.
- */
-
-#define LC_LOG_TX_BUFFERS 1               /* (2 == 2^^1) 2 Transmit buffers */
-#define LC_LOG_RX_BUFFERS 2               /* (8 == 2^^3) 8 Receive buffers */
-
-/* Descriptor ring sizes */
-
-#define TMDNUM (1 << (LC_LOG_TX_BUFFERS)) /* 2 Transmit descriptor rings */
-#define RMDNUM (1 << (LC_LOG_RX_BUFFERS)) /* 8 Receive Buffers */
-
-/* Define Mask for setting RMD, TMD length in the LANCE init_block */
-
-#define TMDNUMMASK (LC_LOG_TX_BUFFERS << 29)
-#define RMDNUMMASK (LC_LOG_RX_BUFFERS << 29)
-
-/*
- * Data Buffer size is set to maximum packet length.
- */
-
-#define PKT_BUF_SZ              1518
-
-/*
- * The number of low I/O ports used by the ethercard.
- */
-
-#define ETHERCARD_TOTAL_SIZE    SK_POS_SIZE
-
-/*
- * Portreserve is there to mark the Card I/O Port region as used.
- * Check_region is to check if the region at ioaddr with the size "size"
- * is free or not.
- * Snarf_region allocates the I/O Port region.
- */
-
-#ifndef	HAVE_PORTRESERVE
-
-#define check_region(ioaddr1, size)              0
-#define request_region(ioaddr1, size,name)       do ; while (0)
-
-#endif
-
-/*
- * SK_DEBUG
- *
- * Here you can choose what level of debugging wanted.
- *
- * If SK_DEBUG and SK_DEBUG2 are undefined, then only the
- *  necessary messages will be printed.
- *
- * If SK_DEBUG is defined, there will be many debugging prints
- *  which can help to find some mistakes in configuration or even
- *  in the driver code.
- *
- * If SK_DEBUG2 is defined, many many messages will be printed
- *  which normally you don't need. I used this to check the interrupt
- *  routine.
- *
- * (If you define only SK_DEBUG2 then only the messages for
- *  checking interrupts will be printed!)
- *
- * Normal way of live is:
- *
- * For the whole thing get going let both symbolic constants
- * undefined. If you face any problems and you know what's going
- * on (you know something about the card and you can interpret some
- * hex LANCE register output) then define SK_DEBUG
- *
- */
-
-#undef  SK_DEBUG	/* debugging */
-#undef  SK_DEBUG2	/* debugging with more verbose report */
-
-#ifdef	SK_DEBUG
-#define PRINTF(x) printf x
-#else
-#define PRINTF(x) /**/
-#endif
-
-#ifdef	SK_DEBUG2
-#define PRINTF2(x) printf x
-#else
-#define PRINTF2(x) /**/
-#endif
-
-/*
- * SK_G16 RAM
- *
- * The components are memory mapped and can be set in a region from
- * 0x00000 through 0xfc000 in 16KB steps.
- *
- * The Network components are: dual ported RAM, Prom, I/O Reg, Status-,
- * Controlregister and I/O Command.
- *
- * dual ported RAM: This is the only memory region which the LANCE chip
- *      has access to. From the Lance it is addressed from 0x0000 to
- *      0x3fbf. The host accesses it normally.
- *
- * PROM: The PROM obtains the ETHERNET-MAC-Address. It is realised as a
- *       8-Bit PROM, this means only the 16 even addresses are used of the
- *       32 Byte Address region. Access to a odd address results in invalid
- *       data.
- *
- * LANCE I/O Reg: The I/O Reg is build of 4 single Registers, Low-Byte Write,
- *       Hi-Byte Write, Low-Byte Read, Hi-Byte Read.
- *       Transfer from or to the LANCE is always in 16Bit so Low and High
- *       registers are always relevant.
- *
- *       The Data from the Readregister is not the data in the Writeregister!!
- *
- * Port: Status- and Controlregister.
- *       Two different registers which share the same address, Status is
- *       read-only, Control is write-only.
- *
- * I/O Command:
- *       Any bitcombination written in here starts the transmission between
- *       Host and LANCE.
- */
-
-typedef struct
-{
-	unsigned char  ram[0x3fc0];   /* 16KB dual ported ram */
-	unsigned char  rom[0x0020];   /* 32Byte PROM containing 6Byte MAC */
-	unsigned char  res1[0x0010];  /* reserved */
-	unsigned volatile short ioreg;/* LANCE I/O Register */
-	unsigned volatile char  port; /* Statusregister and Controlregister */
-	unsigned char  iocom;         /* I/O Command Register */
-} SK_RAM;
-
-/* struct  */
-
-/*
- * This is the structure for the dual ported ram. We
- * have exactly 16 320 Bytes. In here there must be:
- *
- *     - Initialize Block   (starting at a word boundary)
- *     - Receive and Transmit Descriptor Rings (quadword boundary)
- *     - Data Buffers (arbitrary boundary)
- *
- * This is because LANCE has on SK_G16 only access to the dual ported
- * RAM and nowhere else.
- */
-
-struct SK_ram
-{
-    struct init_block ib;
-    struct tmd tmde[TMDNUM];
-    struct rmd rmde[RMDNUM];
-    char tmdbuf[TMDNUM][PKT_BUF_SZ];
-    char rmdbuf[RMDNUM][PKT_BUF_SZ];
-};
-
-/*
- * Structure where all necessary information is for ring buffer
- * management and statistics.
- */
-
-struct priv
-{
-    struct SK_ram *ram;  /* dual ported ram structure */
-    struct rmd *rmdhead; /* start of receive ring descriptors */
-    struct tmd *tmdhead; /* start of transmit ring descriptors */
-    int        rmdnum;   /* actual used ring descriptor */
-    int        tmdnum;   /* actual transmit descriptor for transmitting data */
-    int        tmdlast;  /* last sent descriptor used for error handling, etc */
-    void       *rmdbufs[RMDNUM]; /* pointer to the receive buffers */
-    void       *tmdbufs[TMDNUM]; /* pointer to the transmit buffers */
-};
-
-/* global variable declaration */
-
-/* static variables */
-
-static SK_RAM *board;  /* pointer to our memory mapped board components */
-static unsigned short	ioaddr; /* base io address */
-static struct priv	p_data;
-
-/* Macros */
-
-
-/* Function Prototypes */
-
-/*
- * Device Driver functions
- * -----------------------
- * See for short explanation of each function its definitions header.
- */
-
-static int   SK_probe1(struct nic *nic, short ioaddr1);
-
-static void SK_reset(struct nic *nic);
-static int SK_poll(struct nic *nic);
-static void SK_transmit(
-struct nic *nic,
-const char *d,			/* Destination */
-unsigned int t,			/* Type */
-unsigned int s,			/* size */
-const char *p);			/* Packet */
-static void SK_disable(struct nic *nic);
-struct nic *SK_probe(struct nic *nic, unsigned short *probe_addrs);
-
-/*
- * LANCE Functions
- * ---------------
- */
-
-static int SK_lance_init(struct nic *nic, unsigned short mode);
-static void SK_reset_board(void);
-static void SK_set_RAP(int reg_number);
-static int SK_read_reg(int reg_number);
-static int SK_rread_reg(void);
-static void SK_write_reg(int reg_number, int value);
-
-/*
- * Debugging functions
- * -------------------
- */
-
-static void SK_print_pos(struct nic *nic, char *text);
-static void SK_print_ram(struct nic *nic);
-
-
-/**************************************************************************
-RESET - Reset adapter
-***************************************************************************/
-static void SK_reset(struct nic *nic)
-{
-	/* put the card in its initial state */
-	SK_lance_init(nic, MODE_NORMAL);
-}
-
-/**************************************************************************
-POLL - Wait for a frame
-***************************************************************************/
-static int SK_poll(struct nic *nic)
-{
-	/* return true if there's an ethernet packet ready to read */
-	struct priv *p;         /* SK_G16 private structure */
-	struct rmd *rmdp;
-	int csr0, rmdstat, packet_there;
-    PRINTF2(("## %s: At beginning of SK_poll(). CSR0: %#hX\n",
-           SK_NAME, SK_read_reg(CSR0)));
-
-	p = nic->priv_data;
-    csr0 = SK_read_reg(CSR0);      /* store register for checking */
-
-    /*
-     * Acknowledge all of the current interrupt sources, disable
-     * Interrupts (INEA = 0)
-     */
-
-    SK_write_reg(CSR0, csr0 & CSR0_CLRALL);
-
-    if (csr0 & CSR0_ERR) /* LANCE Error */
-    {
-	printf("%s: error: %#hX", SK_NAME, csr0);
-
-        if (csr0 & CSR0_MISS)      /* No place to store packet ? */
-        {
-		printf(", Packet dropped.");
-        }
-	putchar('\n');
-    }
-
-    rmdp = p->rmdhead + p->rmdnum;
-    packet_there = 0;
-    /* As long as we own the next entry, check status and send
-     * it up to higher layer
-     */
-
-    while (!( (rmdstat = rmdp->u.s.status) & RX_OWN))
-    {
-	/*
-         * Start and end of packet must be set, because we use
-	 * the ethernet maximum packet length (1518) as buffer size.
-	 *
-	 * Because our buffers are at maximum OFLO and BUFF errors are
-	 * not to be concerned (see Data sheet)
-	 */
-
-	if ((rmdstat & (RX_STP | RX_ENP)) != (RX_STP | RX_ENP))
-	{
-	    /* Start of a frame > 1518 Bytes ? */
-
-	    if (rmdstat & RX_STP)
-	    {
-		printf("%s: packet too long\n", SK_NAME);
-	    }
-
-	    /*
-             * All other packets will be ignored until a new frame with
-	     * start (RX_STP) set follows.
-	     *
-	     * What we do is just give descriptor free for new incoming
-	     * packets.
-	     */
-
-	    rmdp->u.s.status = RX_OWN;      /* Relinquish ownership to LANCE */
-
-	}
-	else if (rmdstat & RX_ERR)          /* Receive Error ? */
-	{
-	    printf("%s: RX error: %#hX\n", SK_NAME, (int) rmdstat);
-	    rmdp->u.s.status = RX_OWN;      /* Relinquish ownership to LANCE */
-	}
-	else /* We have a packet which can be queued for the upper layers */
-	{
-
-	    int len = (rmdp->mlen & 0x0fff);  /* extract message length from receive buffer */
-
-	    /*
-             * Copy data out of our receive descriptor into nic->packet.
-	     *
-	     * (rmdp->u.buffer & 0x00ffffff) -> get address of buffer and
-	     * ignore status fields)
-	     */
-
-	    memcpy(nic->packet, (unsigned char *) (rmdp->u.buffer & 0x00ffffff), nic->packetlen = len);
-	    packet_there = 1;
-
-
-	    /*
-             * Packet is queued and marked for processing so we
-	     * free our descriptor
-	     */
-
-	    rmdp->u.s.status = RX_OWN;
-
-	    p->rmdnum++;
-	    p->rmdnum %= RMDNUM;
-
-	    rmdp = p->rmdhead + p->rmdnum;
-	}
-    }
-    SK_write_reg(CSR0, CSR0_INEA); /* Enable Interrupts */
-	return (packet_there);
-}
-
-/**************************************************************************
-TRANSMIT - Transmit a frame
-***************************************************************************/
-static void SK_transmit(
-struct nic *nic,
-const char *d,			/* Destination */
-unsigned int t,			/* Type */
-unsigned int s,			/* size */
-const char *pack)		/* Packet */
-{
-	/* send the packet to destination */
-    struct priv *p;         /* SK_G16 private structure */
-    struct tmd *tmdp;
-    short len;
-    int csr0, i, tmdstat;
-
-    PRINTF2(("## %s: At beginning of SK_transmit(). CSR0: %#hX\n",
-           SK_NAME, SK_read_reg(CSR0)));
-	p = nic->priv_data;
-	tmdp = p->tmdhead + p->tmdnum; /* Which descriptor for transmitting */
-
-	/* Copy data into dual ported ram */
-
-	memcpy(&p->ram->tmdbuf[p->tmdnum][0], d, ETH_ALEN);	/* dst */
-	memcpy(&p->ram->tmdbuf[p->tmdnum][ETH_ALEN], nic->node_addr, ETH_ALEN); /* src */
-	p->ram->tmdbuf[p->tmdnum][ETH_ALEN + ETH_ALEN] = t >> 8;	/* type */
-	p->ram->tmdbuf[p->tmdnum][ETH_ALEN + ETH_ALEN + 1] = t;	/* type */
-	memcpy(&p->ram->tmdbuf[p->tmdnum][ETH_HLEN], pack, s);
-	s += ETH_HLEN;
-	while (s < ETH_ZLEN)	/* pad to min length */
-		p->ram->tmdbuf[p->tmdnum][s++] = 0;
-	p->ram->tmde[p->tmdnum].status2 = 0x0;
-
-	/* Evaluate Packet length */
-	len = ETH_ZLEN < s ? s : ETH_ZLEN;
-
-	/* Fill in Transmit Message Descriptor */
-
-	tmdp->blen = -len;            /* set length to transmit */
-
-	/*
-	 * Packet start and end is always set because we use the maximum
-	 * packet length as buffer length.
-	 * Relinquish ownership to LANCE
-	 */
-
-	tmdp->u.s.status = TX_OWN | TX_STP | TX_ENP;
-
-	/* Start Demand Transmission */
-	SK_write_reg(CSR0, CSR0_TDMD | CSR0_INEA);
-
-    csr0 = SK_read_reg(CSR0);      /* store register for checking */
-
-    /*
-     * Acknowledge all of the current interrupt sources, disable
-     * Interrupts (INEA = 0)
-     */
-
-    SK_write_reg(CSR0, csr0 & CSR0_CLRALL);
-
-    if (csr0 & CSR0_ERR) /* LANCE Error */
-    {
-	printf("%s: error: %#hX", SK_NAME, csr0);
-
-        if (csr0 & CSR0_MISS)      /* No place to store packet ? */
-        {
-		printf(", Packet dropped.");
-        }
-	putchar('\n');
-    }
-
-
-    /* Set next buffer */
-    p->tmdlast++;
-    p->tmdlast &= TMDNUM-1;
-
-    tmdstat = tmdp->u.s.status & 0xff00; /* filter out status bits 15:08 */
-
-    /*
-     * We check status of transmitted packet.
-     * see LANCE data-sheet for error explanation
-     */
-    if (tmdstat & TX_ERR) /* Error occurred */
-    {
-	printf("%s: TX error: %#hX %#hX\n", SK_NAME, (int) tmdstat,
-		(int) tmdp->status2);
-
-	if (tmdp->status2 & TX_TDR)    /* TDR problems? */
-	{
-	    printf("%s: tdr-problems \n", SK_NAME);
-	}
-
-        if (tmdp->status2 & TX_UFLO)   /* Underflow error ? */
-        {
-            /*
-             * If UFLO error occurs it will turn transmitter of.
-             * So we must reinit LANCE
-             */
-
-            SK_lance_init(nic, MODE_NORMAL);
-        }
-
-	tmdp->status2 = 0;             /* Clear error flags */
-    }
-
-    SK_write_reg(CSR0, CSR0_INEA); /* Enable Interrupts */
-
-	/* Set pointer to next transmit buffer */
-	p->tmdnum++;
-	p->tmdnum &= TMDNUM-1;
-
-}
-
-/**************************************************************************
-DISABLE - Turn off ethernet interface
-***************************************************************************/
-static void SK_disable(struct nic *nic)
-{
-    PRINTF(("## %s: At beginning of SK_disable(). CSR0: %#hX\n",
-           SK_NAME, SK_read_reg(CSR0)));
-    PRINTF(("%s: Shutting %s down CSR0 %#hX\n", SK_NAME, SK_NAME,
-           (int) SK_read_reg(CSR0)));
-
-    SK_write_reg(CSR0, CSR0_STOP); /* STOP the LANCE */
-}
-
-/**************************************************************************
-PROBE - Look for an adapter, this routine's visible to the outside
-***************************************************************************/
-struct nic *SK_probe(struct nic *nic, unsigned short *probe_addrs)
-{
-	unsigned short		*p;
-	static unsigned short	io_addrs[] = SK_IO_PORTS;
-	/* if probe_addrs is 0, then routine can use a hardwired default */
-	putchar('\n');
-	nic->priv_data = &p_data;
-	if (probe_addrs == 0)
-		probe_addrs = io_addrs;
-	for (p = probe_addrs; (ioaddr = *p) != 0; ++p)
-	{
-		long		offset1, offset0 = inb(ioaddr);
-		if ((offset0 == SK_IDLOW) &&
-		 ((offset1 = inb(ioaddr + 1)) == SK_IDHIGH))
-			if (SK_probe1(nic, ioaddr) >= 0)
-				break;
-	}
-	/* if board found */
-	if (ioaddr != 0)
-	{
-		/* point to NIC specific routines */
-		nic->reset = SK_reset;
-		nic->poll = SK_poll;
-		nic->transmit = SK_transmit;
-		nic->disable = SK_disable;
-		return nic;
-	}
-	/* else */
-	{
-		return 0;
-	}
-}
-
-int SK_probe1(struct nic *nic, short ioaddr1)
-{
-    int i,j;                /* Counters */
-    int sk_addr_flag = 0;   /* SK ADDR correct? 1 - no, 0 - yes */
-    unsigned int rom_addr;  /* used to store RAM address used for POS_ADDR */
-
-    struct priv *p;         /* SK_G16 private structure */
-
-    if (SK_ADDR & 0x3fff || SK_ADDR < 0xa0000)
-    {
-       /*
-        * Now here we could use a routine which searches for a free
-        * place in the ram and set SK_ADDR if found. TODO.
-        */
-            printf("%s: SK_ADDR %#hX is not valid. Check configuration.\n",
-                    SK_NAME, SK_ADDR);
-            return -1;
-    }
-
-    rom_addr = SK_ADDR;
-
-    outb(SK_ROM_RAM_OFF, SK_POS2); /* Boot_ROM + RAM off */
-    outb(POS_ADDR, SK_POS3);       /* Set RAM address */
-    outb(SK_ROM_RAM_ON, SK_POS2);  /* RAM on, BOOT_ROM on */
-#ifdef	SK_DEBUG
-    SK_print_pos(nic, "POS registers after ROM, RAM config");
-#endif
-
-    board = (SK_RAM *) rom_addr;
-	PRINTF(("adr[0]: %hX, adr[1]: %hX, adr[2]: %hX\n",
-	board->rom[0], board->rom[2], board->rom[4]));
-
-    /* Read in station address */
-    for (i = 0, j = 0; i < ETH_ALEN; i++, j+=2)
-    {
-	*(nic->node_addr+i) = board->rom[j];
-    }
-
-    /* Check for manufacturer code */
-#ifdef	SK_DEBUG
-    if (!(*(nic->node_addr+0) == SK_MAC0 &&
-	  *(nic->node_addr+1) == SK_MAC1 &&
-	  *(nic->node_addr+2) == SK_MAC2) )
-    {
-        PRINTF(("## %s: We did not find SK_G16 at RAM location.\n",
-                SK_NAME));
-	return -1;                     /* NO SK_G16 found */
-    }
-#endif
-
-    p = nic->priv_data;
-
-    /* Initialize private structure */
-
-    p->ram = (struct SK_ram *) rom_addr; /* Set dual ported RAM addr */
-    p->tmdhead = &(p->ram)->tmde[0];     /* Set TMD head */
-    p->rmdhead = &(p->ram)->rmde[0];     /* Set RMD head */
-
-    printf("Schneider & Koch G16 at %#hX, mem at %#hX, HW addr: %!\n",
-	    (unsigned int) ioaddr, (unsigned int) p->ram, nic->node_addr);
-
-    /* Initialize buffer pointers */
-
-    for (i = 0; i < TMDNUM; i++)
-    {
-	p->tmdbufs[i] = p->ram->tmdbuf[i];
-    }
-
-    for (i = 0; i < RMDNUM; i++)
-    {
-	p->rmdbufs[i] = p->ram->rmdbuf[i];
-    }
-    i = 0;
-
-    if (!(i = SK_lance_init(nic, MODE_NORMAL)))  /* LANCE init OK? */
-    {
-
-#ifdef	SK_DEBUG
-        /*
-         * This debug block tries to stop LANCE,
-         * reinit LANCE with transmitter and receiver disabled,
-         * then stop again and reinit with NORMAL_MODE
-         */
-
-        printf("## %s: After lance init. CSR0: %#hX\n",
-               SK_NAME, SK_read_reg(CSR0));
-        SK_write_reg(CSR0, CSR0_STOP);
-        printf("## %s: LANCE stopped. CSR0: %#hX\n",
-               SK_NAME, SK_read_reg(CSR0));
-        SK_lance_init(nic, MODE_DTX | MODE_DRX);
-        printf("## %s: Reinit with DTX + DRX off. CSR0: %#hX\n",
-               SK_NAME, SK_read_reg(CSR0));
-        SK_write_reg(CSR0, CSR0_STOP);
-        printf("## %s: LANCE stopped. CSR0: %#hX\n",
-               SK_NAME, SK_read_reg(CSR0));
-        SK_lance_init(nic, MODE_NORMAL);
-        printf("## %s: LANCE back to normal mode. CSR0: %#hX\n",
-               SK_NAME, SK_read_reg(CSR0));
-        SK_print_pos(nic, "POS regs before returning OK");
-
-#endif	/* SK_DEBUG */
-
-    }
-    else /* LANCE init failed */
-    {
-
-	PRINTF(("## %s: LANCE init failed: CSR0: %#hX\n",
-               SK_NAME, SK_read_reg(CSR0)));
-	return -1;
-    }
-
-#ifdef	SK_DEBUG
-    SK_print_pos(nic, "End of SK_probe1");
-    SK_print_ram(nic);
-#endif
-
-    return 0;                            /* Initialization done */
-
-} /* End of SK_probe1() */
-
-static int SK_lance_init(struct nic *nic, unsigned short mode)
-{
-    int i;
-    struct priv *p = (struct priv *) nic->priv_data;
-    struct tmd  *tmdp;
-    struct rmd  *rmdp;
-
-    PRINTF(("## %s: At beginning of LANCE init. CSR0: %#hX\n",
-           SK_NAME, SK_read_reg(CSR0)));
-
-    /* Reset LANCE */
-    SK_reset_board();
-
-    /* Initialize TMD's with start values */
-    p->tmdnum = 0;                   /* First descriptor for transmitting */
-    p->tmdlast = 0;                  /* First descriptor for reading stats */
-
-    for (i = 0; i < TMDNUM; i++)     /* Init all TMD's */
-    {
-	tmdp = p->tmdhead + i;
-
-	tmdp->u.buffer = (unsigned long) p->tmdbufs[i]; /* assign buffer */
-
-	/* Mark TMD as start and end of packet */
-	tmdp->u.s.status = TX_STP | TX_ENP;
-    }
-
-
-    /* Initialize RMD's with start values */
-
-    p->rmdnum = 0;                   /* First RMD which will be used */
-
-    for (i = 0; i < RMDNUM; i++)     /* Init all RMD's */
-    {
-	rmdp = p->rmdhead + i;
-
-
-	rmdp->u.buffer = (unsigned long) p->rmdbufs[i]; /* assign buffer */
-
-	/*
-         * LANCE must be owner at beginning so that he can fill in
-	 * receiving packets, set status and release RMD
-	 */
-
-	rmdp->u.s.status = RX_OWN;
-
-	rmdp->blen = -PKT_BUF_SZ;    /* Buffer Size in a two's complement */
-
-	rmdp->mlen = 0;              /* init message length */
-
-    }
-
-    /* Fill LANCE Initialize Block */
-
-    (p->ram)->ib.mode = mode;        /* Set operation mode */
-
-    for (i = 0; i < ETH_ALEN; i++)   /* Set physical address */
-    {
-	(p->ram)->ib.paddr[i] = *(nic->node_addr+i);
-    }
-
-    for (i = 0; i < 8; i++)          /* Set multicast, logical address */
-    {
-	(p->ram)->ib.laddr[i] = 0;   /* We do not use logical addressing */
-    }
-
-    /* Set ring descriptor pointers and set number of descriptors */
-
-    (p->ram)->ib.rdrp = (int)  p->rmdhead | RMDNUMMASK;
-    (p->ram)->ib.tdrp = (int)  p->tmdhead | TMDNUMMASK;
-
-    /* Prepare LANCE Control and Status Registers */
-
-    SK_write_reg(CSR3, CSR3_ACON);   /* Ale Control !!!THIS MUST BE SET!!!! */
-
-    /*
-     * LANCE addresses the RAM from 0x0000 to 0x3fbf and has no access to
-     * PC Memory locations.
-     *
-     * In structure SK_ram is defined that the first thing in ram
-     * is the initialization block. So his address is for LANCE always
-     * 0x0000
-     *
-     * CSR1 contains low order bits 15:0 of initialization block address
-     * CSR2 is built of:
-     *    7:0  High order bits 23:16 of initialization block address
-     *   15:8  reserved, must be 0
-     */
-
-    /* Set initialization block address (must be on word boundary) */
-    SK_write_reg(CSR1, 0);          /* Set low order bits 15:0 */
-    SK_write_reg(CSR2, 0);          /* Set high order bits 23:16 */
-
-
-    PRINTF(("## %s: After setting CSR1-3. CSR0: %#hX\n",
-           SK_NAME, SK_read_reg(CSR0)));
-
-    /* Initialize LANCE */
-
-    /*
-     * INIT = Initialize, when set, causes the LANCE to begin the
-     * initialization procedure and access the Init Block.
-     */
-
-    SK_write_reg(CSR0, CSR0_INIT);
-
-    /* Wait until LANCE finished initialization */
-
-    SK_set_RAP(CSR0);              /* Register Address Pointer to CSR0 */
-
-    for (i = 0; (i < 100) && !(SK_rread_reg() & CSR0_IDON); i++)
-	; /* Wait until init done or go ahead if problems (i>=100) */
-
-    if (i >= 100) /* Something is wrong ! */
-    {
-	printf("%s: can't init am7990, status: %#hX "
-	       "init_block: %#hX\n",
-		SK_NAME, (int) SK_read_reg(CSR0),
-		(unsigned int) &(p->ram)->ib);
-
-#ifdef	SK_DEBUG
-	SK_print_pos(nic, "LANCE INIT failed");
-#endif
-
-	return -1;                 /* LANCE init failed */
-    }
-
-    PRINTF(("## %s: init done after %d ticks\n", SK_NAME, i));
-
-    /* Clear Initialize done, enable Interrupts, start LANCE */
-
-    SK_write_reg(CSR0, CSR0_IDON | CSR0_INEA | CSR0_STRT);
-
-    PRINTF(("## %s: LANCE started. CSR0: %#hX\n", SK_NAME,
-            SK_read_reg(CSR0)));
-
-    return 0;                      /* LANCE is up and running */
-
-} /* End of SK_lance_init() */
-
-/* LANCE access functions
- *
- * ! CSR1-3 can only be accessed when in CSR0 the STOP bit is set !
- */
-
-static void SK_reset_board(void)
-{
-    int i;
-
-	PRINTF(("## %s: At beginning of SK_reset_board.\n", SK_NAME));
-    SK_PORT = 0x00;           /* Reset active */
-    for (i = 0; i < 10 ; i++) /* Delay min 5ms */
-	;
-    SK_PORT = SK_RESET;       /* Set back to normal operation */
-
-} /* End of SK_reset_board() */
-
-static void SK_set_RAP(int reg_number)
-{
-    SK_IOREG = reg_number;
-    SK_PORT  = SK_RESET | SK_RAP | SK_WREG;
-    SK_IOCOM = SK_DOIO;
-
-    while (SK_PORT & SK_IORUN)
-	;
-} /* End of SK_set_RAP() */
-
-static int SK_read_reg(int reg_number)
-{
-    SK_set_RAP(reg_number);
-
-    SK_PORT  = SK_RESET | SK_RDATA | SK_RREG;
-    SK_IOCOM = SK_DOIO;
-
-    while (SK_PORT & SK_IORUN)
-	;
-    return (SK_IOREG);
-
-} /* End of SK_read_reg() */
-
-static int SK_rread_reg(void)
-{
-    SK_PORT  = SK_RESET | SK_RDATA | SK_RREG;
-
-    SK_IOCOM = SK_DOIO;
-
-    while (SK_PORT & SK_IORUN)
-	;
-    return (SK_IOREG);
-
-} /* End of SK_rread_reg() */
-
-static void SK_write_reg(int reg_number, int value)
-{
-    SK_set_RAP(reg_number);
-
-    SK_IOREG = value;
-    SK_PORT  = SK_RESET | SK_RDATA | SK_WREG;
-    SK_IOCOM = SK_DOIO;
-
-    while (SK_PORT & SK_IORUN)
-	;
-} /* End of SK_write_reg */
-
-/*
- * Debugging functions
- * -------------------
- */
-
-#ifdef	SK_DEBUG
-static void SK_print_pos(struct nic *nic, char *text)
-{
-
-    unsigned char pos0 = inb(SK_POS0),
-		  pos1 = inb(SK_POS1),
-		  pos2 = inb(SK_POS2),
-		  pos3 = inb(SK_POS3),
-		  pos4 = inb(SK_POS4);
-
-
-    printf("## %s: %s.\n"
-           "##   pos0=%#hX pos1=%#hX pos2=%#hX pos3=%#hX pos4=%#hX\n",
-           SK_NAME, text, pos0, pos1, pos2, (pos3<<14), pos4);
-
-} /* End of SK_print_pos() */
-
-static void SK_print_ram(struct nic *nic)
-{
-
-    int i;
-    struct priv *p = (struct priv *) nic->priv_data;
-
-    printf("## %s: RAM Details.\n"
-           "##   RAM at %#hX tmdhead: %#hX rmdhead: %#hX initblock: %#hX\n",
-           SK_NAME,
-           (unsigned int) p->ram,
-           (unsigned int) p->tmdhead,
-           (unsigned int) p->rmdhead,
-           (unsigned int) &(p->ram)->ib);
-
-    printf("##   ");
-
-    for(i = 0; i < TMDNUM; i++)
-    {
-           if (!(i % 3)) /* Every third line do a newline */
-           {
-               printf("\n##   ");
-           }
-        printf("tmdbufs%d: %#hX ", (i+1), (int) p->tmdbufs[i]);
-    }
-    printf("##   ");
-
-    for(i = 0; i < RMDNUM; i++)
-    {
-         if (!(i % 3)) /* Every third line do a newline */
-           {
-               printf("\n##   ");
-           }
-        printf("rmdbufs%d: %#hX ", (i+1), (int) p->rmdbufs[i]);
-    }
-    putchar('\n');
-
-} /* End of SK_print_ram() */
-#endif
diff -Naur grub-0.97.orig/netboot/sk_g16.h grub-0.97/netboot/sk_g16.h
--- grub-0.97.orig/netboot/sk_g16.h	2003-07-09 11:45:38.000000000 +0000
+++ grub-0.97/netboot/sk_g16.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,168 +0,0 @@
-/*-
- *
- * This software may be used and distributed according to the terms
- * of the GNU Public License, incorporated herein by reference.
- *
- * Module         : sk_g16.h
- * Version        : $Revision: 1.3 $
- *
- * Author         : M.Hipp (mhipp@student.uni-tuebingen.de)
- * changes by     : Patrick J.D. Weichmann
- *
- * Date Created   : 94/05/25
- *
- * Description    : In here are all necessary definitions of
- *                  the am7990 (LANCE) chip used for writing a
- *                  network device driver which uses this chip
- *
- * $Log: sk_g16.h,v $
- * Revision 1.3  2000/07/29 19:22:54  okuji
- * update the network support to etherboot-4.6.4.
- *
--*/
-
-#ifndef	SK_G16_H
-
-#define SK_G16_H
-
-
-/*
- *	Control and Status Register 0 (CSR0) bit definitions
- *
- * (R=Readable) (W=Writeable) (S=Set on write) (C-Clear on write)
- *
- */
-
-#define CSR0_ERR	0x8000	/* Error summary (R) */
-#define CSR0_BABL	0x4000	/* Babble transmitter timeout error (RC) */
-#define CSR0_CERR	0x2000	/* Collision Error (RC) */
-#define CSR0_MISS	0x1000	/* Missed packet (RC) */
-#define CSR0_MERR	0x0800	/* Memory Error  (RC) */
-#define CSR0_RINT	0x0400	/* Receiver Interrupt (RC) */
-#define CSR0_TINT       0x0200	/* Transmit Interrupt (RC) */
-#define CSR0_IDON	0x0100	/* Initialization Done (RC) */
-#define CSR0_INTR	0x0080	/* Interrupt Flag (R) */
-#define CSR0_INEA	0x0040	/* Interrupt Enable (RW) */
-#define CSR0_RXON	0x0020	/* Receiver on (R) */
-#define CSR0_TXON	0x0010  /* Transmitter on (R) */
-#define CSR0_TDMD	0x0008	/* Transmit Demand (RS) */
-#define CSR0_STOP	0x0004	/* Stop (RS) */
-#define CSR0_STRT	0x0002	/* Start (RS) */
-#define CSR0_INIT	0x0001	/* Initialize (RS) */
-
-#define CSR0_CLRALL     0x7f00  /* mask for all clearable bits */
-
-/*
- *    Control and Status Register 3 (CSR3) bit definitions
- *
- */
-
-#define CSR3_BSWAP	0x0004	/* Byte Swap (RW) */
-#define CSR3_ACON	0x0002  /* ALE Control (RW) */
-#define CSR3_BCON	0x0001	/* Byte Control (RW) */
-
-/*
- *	Initialization Block Mode operation Bit Definitions.
- */
-
-#define MODE_PROM	0x8000	/* Promiscuous Mode */
-#define MODE_INTL	0x0040  /* Internal Loopback */
-#define MODE_DRTY	0x0020  /* Disable Retry */
-#define MODE_COLL	0x0010	/* Force Collision */
-#define MODE_DTCR	0x0008	/* Disable Transmit CRC) */
-#define MODE_LOOP	0x0004	/* Loopback */
-#define MODE_DTX	0x0002	/* Disable the Transmitter */
-#define MODE_DRX	0x0001  /* Disable the Receiver */
-
-#define MODE_NORMAL	0x0000  /* Normal operation mode */
-
-/*
- *	Receive message descriptor status bit definitions.
- */
-
-#define RX_OWN		0x80	/* Owner bit 0 = host, 1 = lance */
-#define RX_ERR		0x40	/* Error Summary */
-#define RX_FRAM		0x20	/* Framing Error */
-#define RX_OFLO		0x10	/* Overflow Error */
-#define RX_CRC		0x08	/* CRC Error */
-#define RX_BUFF		0x04	/* Buffer Error */
-#define RX_STP		0x02	/* Start of Packet */
-#define RX_ENP		0x01	/* End of Packet */
-
-
-/*
- *	Transmit message descriptor status bit definitions.
- */
-
-#define TX_OWN		0x80	/* Owner bit 0 = host, 1 = lance */
-#define TX_ERR		0x40    /* Error Summary */
-#define TX_MORE		0x10	/* More the 1 retry needed to Xmit */
-#define TX_ONE		0x08	/* One retry needed to Xmit */
-#define TX_DEF		0x04	/* Deferred */
-#define TX_STP		0x02	/* Start of Packet */
-#define TX_ENP		0x01	/* End of Packet */
-
-/*
- *      Transmit status (2) (valid if TX_ERR == 1)
- */
-
-#define TX_BUFF		0x8000  /* Buffering error (no ENP) */
-#define TX_UFLO		0x4000  /* Underflow (late memory) */
-#define TX_LCOL		0x1000  /* Late collision */
-#define TX_LCAR		0x0400  /* Loss of Carrier */
-#define TX_RTRY		0x0200  /* Failed after 16 retransmissions  */
-#define TX_TDR          0x003f  /* Time-domain-reflectometer-value */
-
-
-/*
- * Structures used for Communication with the LANCE
- */
-
-/* LANCE Initialize Block */
-
-struct init_block
-{
-  unsigned short mode;     /* Mode Register */
-  unsigned char  paddr[6]; /* Physical Address (MAC) */
-  unsigned char  laddr[8]; /* Logical Filter Address (not used) */
-  unsigned int   rdrp;     /* Receive Descriptor Ring pointer */
-  unsigned int   tdrp;     /* Transmit Descriptor Ring pointer */
-};
-
-
-/* Receive Message Descriptor Entry */
-
-struct rmd
-{
-  union rmd_u
-  {
-    unsigned long buffer;     /* Address of buffer */
-    struct rmd_s
-    {
-      unsigned char unused[3];
-      unsigned volatile char status;   /* Status Bits */
-    } s;
-  } u;
-  volatile short blen;        /* Buffer Length (two's complement) */
-  unsigned short mlen;        /* Message Byte Count */
-};
-
-
-/* Transmit Message Descriptor Entry */
-
-struct tmd
-{
-  union tmd_u
-  {
-    unsigned long  buffer;    /* Address of buffer */
-    struct tmd_s
-    {
-      unsigned char unused[3];
-      unsigned volatile char status;   /* Status Bits */
-    } s;
-  } u;
-  unsigned short blen;             /* Buffer Length (two's complement) */
-  unsigned volatile short status2; /* Error Status Bits */
-};
-
-#endif	/* End of SK_G16_H */
diff -Naur grub-0.97.orig/netboot/smc9000.c grub-0.97/netboot/smc9000.c
--- grub-0.97.orig/netboot/smc9000.c	2003-07-09 11:45:38.000000000 +0000
+++ grub-0.97/netboot/smc9000.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,522 +0,0 @@
- /*------------------------------------------------------------------------
- * smc9000.c
- * This is a Etherboot driver for SMC's 9000 series of Ethernet cards.
- *
- * Copyright (C) 1998 Daniel Engstrm <daniel.engstrom@riksnett.no>
- * Based on the Linux SMC9000 driver, smc9194.c by Eric Stahlman
- * Copyright (C) 1996 by Erik Stahlman <eric@vt.edu>
- *
- * This software may be used and distributed according to the terms
- * of the GNU Public License, incorporated herein by reference.
- *
- * "Features" of the SMC chip:
- *   4608 byte packet memory. ( for the 91C92/4.  Others have more )
- *   EEPROM for configuration
- *   AUI/TP selection
- *
- * Authors
- *	Erik Stahlman				<erik@vt.edu>
- *      Daniel Engstrm                         <daniel.engstrom@riksnett.no>
- *
- * History
- * 98-09-25              Daniel Engstrm Etherboot driver crated from Eric's
- *                                       Linux driver.
- *
- *---------------------------------------------------------------------------*/
-#define LINUX_OUT_MACROS 1
-#define SMC9000_VERBOSE  1
-#define SMC9000_DEBUG    0
-
-#include "etherboot.h"
-#include "nic.h"
-#include "cards.h"
-#include "smc9000.h"
-
-# define _outb outb
-# define _outw outw
-
-static const char       smc9000_version[] = "Version 0.99 98-09-30";
-static unsigned int	smc9000_base=0;
-static const char       *interfaces[ 2 ] = { "TP", "AUI" };
-static const char       *chip_ids[ 15 ] =  {
-   NULL, NULL, NULL,
-   /* 3 */ "SMC91C90/91C92",
-   /* 4 */ "SMC91C94",
-   /* 5 */ "SMC91C95",
-   NULL,
-   /* 7 */ "SMC91C100",
-   /* 8 */ "SMC91C100FD",
-   NULL, NULL, NULL,
-   NULL, NULL, NULL
-};
-static const char      smc91c96_id[] = "SMC91C96";
-
-/*
- * Function: smc_reset( int ioaddr )
- * Purpose:
- *	This sets the SMC91xx chip to its normal state, hopefully from whatever
- *	mess that any other DOS driver has put it in.
- *
- * Maybe I should reset more registers to defaults in here?  SOFTRESET  should
- * do that for me.
- *
- * Method:
- *	1.  send a SOFT RESET
- *	2.  wait for it to finish
- *	3.  reset the memory management unit
- *      4.  clear all interrupts
- *
-*/
-static void smc_reset(int ioaddr)
-{
-   /* This resets the registers mostly to defaults, but doesn't
-    * affect EEPROM.  That seems unnecessary */
-   SMC_SELECT_BANK(ioaddr, 0);
-   _outw( RCR_SOFTRESET, ioaddr + RCR );
-
-   /* this should pause enough for the chip to be happy */
-   SMC_DELAY(ioaddr);
-
-   /* Set the transmit and receive configuration registers to
-    * default values */
-   _outw(RCR_CLEAR, ioaddr + RCR);
-   _outw(TCR_CLEAR, ioaddr + TCR);
-
-   /* Reset the MMU */
-   SMC_SELECT_BANK(ioaddr, 2);
-   _outw( MC_RESET, ioaddr + MMU_CMD );
-
-   /* Note:  It doesn't seem that waiting for the MMU busy is needed here,
-    * but this is a place where future chipsets _COULD_ break.  Be wary
-    * of issuing another MMU command right after this */
-   _outb(0, ioaddr + INT_MASK);
-}
-
-
-/*----------------------------------------------------------------------
- * Function: smc_probe( int ioaddr )
- *
- * Purpose:
- *	Tests to see if a given ioaddr points to an SMC9xxx chip.
- *	Returns a 0 on success
- *
- * Algorithm:
- *	(1) see if the high byte of BANK_SELECT is 0x33
- *	(2) compare the ioaddr with the base register's address
- *	(3) see if I recognize the chip ID in the appropriate register
- *
- * ---------------------------------------------------------------------
- */
-static int smc_probe( int ioaddr )
-{
-   word bank;
-   word	revision_register;
-   word base_address_register;
-
-   /* First, see if the high byte is 0x33 */
-   bank = inw(ioaddr + BANK_SELECT);
-   if ((bank & 0xFF00) != 0x3300) {
-      return -1;
-   }
-   /* The above MIGHT indicate a device, but I need to write to further
-    *	test this.  */
-   _outw(0x0, ioaddr + BANK_SELECT);
-   bank = inw(ioaddr + BANK_SELECT);
-   if ((bank & 0xFF00) != 0x3300) {
-      return -1;
-   }
-
-   /* well, we've already written once, so hopefully another time won't
-    *  hurt.  This time, I need to switch the bank register to bank 1,
-    *  so I can access the base address register */
-   SMC_SELECT_BANK(ioaddr, 1);
-   base_address_register = inw(ioaddr + BASE);
-
-   if (ioaddr != (base_address_register >> 3 & 0x3E0))  {
-#ifdef	SMC9000_VERBOSE
-      printf("SMC9000: IOADDR %hX doesn't match configuration (%hX)."
-	     "Probably not a SMC chip\n",
-	     ioaddr, base_address_register >> 3 & 0x3E0);
-#endif
-      /* well, the base address register didn't match.  Must not have
-       * been a SMC chip after all. */
-      return -1;
-   }
-
-
-   /* check if the revision register is something that I recognize.
-    * These might need to be added to later, as future revisions
-    * could be added.  */
-   SMC_SELECT_BANK(ioaddr, 3);
-   revision_register  = inw(ioaddr + REVISION);
-   if (!chip_ids[(revision_register >> 4) & 0xF]) {
-      /* I don't recognize this chip, so... */
-#ifdef	SMC9000_VERBOSE
-      printf("SMC9000: IO %hX: Unrecognized revision register:"
-	     " %hX, Contact author.\n", ioaddr, revision_register);
-#endif
-      return -1;
-   }
-
-   /* at this point I'll assume that the chip is an SMC9xxx.
-    * It might be prudent to check a listing of MAC addresses
-    * against the hardware address, or do some other tests. */
-   return 0;
-}
-
-
-/**************************************************************************
- * ETH_RESET - Reset adapter
- ***************************************************************************/
-
-static void smc9000_reset(struct nic *nic)
-{
-   smc_reset(smc9000_base);
-}
-
-/**************************************************************************
- * ETH_TRANSMIT - Transmit a frame
- ***************************************************************************/
-static void smc9000_transmit(
-	struct nic *nic,
-	const char *d,			/* Destination */
-	unsigned int t,			/* Type */
-	unsigned int s,			/* size */
-	const char *p)			/* Packet */
-{
-   word length; /* real, length incl. header */
-   word numPages;
-   unsigned long time_out;
-   byte	packet_no;
-   word status;
-   int i;
-
-   /* We dont pad here since we can have the hardware doing it for us */
-   length = (s + ETH_HLEN + 1)&~1;
-
-   /* convert to MMU pages */
-   numPages = length / 256;
-
-   if (numPages > 7 ) {
-#ifdef	SMC9000_VERBOSE
-      printf("SMC9000: Far too big packet error. \n");
-#endif
-      return;
-   }
-
-   /* dont try more than, say 30 times */
-   for (i=0;i<30;i++) {
-      /* now, try to allocate the memory */
-      SMC_SELECT_BANK(smc9000_base, 2);
-      _outw(MC_ALLOC | numPages, smc9000_base + MMU_CMD);
-
-      status = 0;
-      /* wait for the memory allocation to finnish */
-      for (time_out = currticks() + 5*TICKS_PER_SEC; currticks() < time_out; ) {
-	 status = inb(smc9000_base + INTERRUPT);
-	 if ( status & IM_ALLOC_INT ) {
-	    /* acknowledge the interrupt */
-	    _outb(IM_ALLOC_INT, smc9000_base + INTERRUPT);
-	    break;
-	 }
-      }
-
-      if ((status & IM_ALLOC_INT) != 0 ) {
-	 /* We've got the memory */
-	 break;
-      } else {
-	 printf("SMC9000: Memory allocation timed out, resetting MMU.\n");
-	 _outw(MC_RESET, smc9000_base + MMU_CMD);
-      }
-   }
-
-   /* If I get here, I _know_ there is a packet slot waiting for me */
-   packet_no = inb(smc9000_base + PNR_ARR + 1);
-   if (packet_no & 0x80) {
-      /* or isn't there?  BAD CHIP! */
-      printf("SMC9000: Memory allocation failed. \n");
-      return;
-   }
-
-   /* we have a packet address, so tell the card to use it */
-   _outb(packet_no, smc9000_base + PNR_ARR);
-
-   /* point to the beginning of the packet */
-   _outw(PTR_AUTOINC, smc9000_base + POINTER);
-
-#if	SMC9000_DEBUG > 2
-   printf("Trying to xmit packet of length %hX\n", length );
-#endif
-
-   /* send the packet length ( +6 for status, length and ctl byte )
-    * and the status word ( set to zeros ) */
-   _outw(0, smc9000_base + DATA_1 );
-
-   /* send the packet length ( +6 for status words, length, and ctl) */
-   _outb((length+6) & 0xFF,  smc9000_base + DATA_1);
-   _outb((length+6) >> 8 ,   smc9000_base + DATA_1);
-
-   /* Write the contents of the packet */
-
-   /* The ethernet header first... */
-   outsw(smc9000_base + DATA_1, d, ETH_ALEN >> 1);
-   outsw(smc9000_base + DATA_1, nic->node_addr, ETH_ALEN >> 1);
-   _outw(htons(t), smc9000_base + DATA_1);
-
-   /* ... the data ... */
-   outsw(smc9000_base + DATA_1 , p, s >> 1);
-
-   /* ... and the last byte, if there is one.   */
-   if ((s & 1) == 0) {
-      _outw(0, smc9000_base + DATA_1);
-   } else {
-      _outb(p[s-1], smc9000_base + DATA_1);
-      _outb(0x20, smc9000_base + DATA_1);
-   }
-
-   /* and let the chipset deal with it */
-   _outw(MC_ENQUEUE , smc9000_base + MMU_CMD);
-
-   status = 0; time_out = currticks() + 5*TICKS_PER_SEC;
-   do {
-      status = inb(smc9000_base + INTERRUPT);
-
-      if ((status & IM_TX_INT ) != 0) {
-	 word tx_status;
-
-	 /* ack interrupt */
-	 _outb(IM_TX_INT, smc9000_base + INTERRUPT);
-
-	 packet_no = inw(smc9000_base + FIFO_PORTS);
-	 packet_no &= 0x7F;
-
-	 /* select this as the packet to read from */
-	 _outb( packet_no, smc9000_base + PNR_ARR );
-
-	 /* read the first word from this packet */
-	 _outw( PTR_AUTOINC | PTR_READ, smc9000_base + POINTER );
-
-	 tx_status = inw( smc9000_base + DATA_1 );
-
-	 if (0 == (tx_status & TS_SUCCESS)) {
-#ifdef	SMC9000_VERBOSE
-	    printf("SMC9000: TX FAIL STATUS: %hX \n", tx_status);
-#endif
-	    /* re-enable transmit */
-	    SMC_SELECT_BANK(smc9000_base, 0);
-	    _outw(inw(smc9000_base + TCR ) | TCR_ENABLE, smc9000_base + TCR );
-	 }
-
-	 /* kill the packet */
-	 SMC_SELECT_BANK(smc9000_base, 2);
-	 _outw(MC_FREEPKT, smc9000_base + MMU_CMD);
-
-	 return;
-      }
-   }while(currticks() < time_out);
-
-   printf("SMC9000: Waring TX timed out, resetting board\n");
-   smc_reset(smc9000_base);
-   return;
-}
-
-/**************************************************************************
- * ETH_POLL - Wait for a frame
- ***************************************************************************/
-static int smc9000_poll(struct nic *nic)
-{
-   if(!smc9000_base)
-     return 0;
-
-   SMC_SELECT_BANK(smc9000_base, 2);
-   if (inw(smc9000_base + FIFO_PORTS) & FP_RXEMPTY)
-     return 0;
-
-   /*  start reading from the start of the packet */
-   _outw(PTR_READ | PTR_RCV | PTR_AUTOINC, smc9000_base + POINTER);
-
-   /* First read the status and check that we're ok */
-   if (!(inw(smc9000_base + DATA_1) & RS_ERRORS)) {
-      /* Next: read the packet length and mask off the top bits */
-      nic->packetlen = (inw(smc9000_base + DATA_1) & 0x07ff);
-
-      /* the packet length includes the 3 extra words */
-      nic->packetlen -= 6;
-#if	SMC9000_DEBUG > 2
-      printf(" Reading %d words (and %d byte(s))\n",
-	       (nic->packetlen >> 1), nic->packetlen & 1);
-#endif
-      /* read the packet (and the last "extra" word) */
-      insw(smc9000_base + DATA_1, nic->packet, (nic->packetlen+2) >> 1);
-      /* is there an odd last byte ? */
-      if (nic->packet[nic->packetlen+1] & 0x20)
-	 nic->packetlen++;
-
-      /*  error or good, tell the card to get rid of this packet */
-      _outw(MC_RELEASE, smc9000_base + MMU_CMD);
-      return 1;
-   }
-
-   printf("SMC9000: RX error\n");
-   /*  error or good, tell the card to get rid of this packet */
-   _outw(MC_RELEASE, smc9000_base + MMU_CMD);
-   return 0;
-}
-
-static void smc9000_disable(struct nic *nic)
-{
-   if(!smc9000_base)
-     return;
-
-   /* no more interrupts for me */
-   SMC_SELECT_BANK(smc9000_base, 2);
-   _outb( 0, smc9000_base + INT_MASK);
-
-   /* and tell the card to stay away from that nasty outside world */
-   SMC_SELECT_BANK(smc9000_base, 0);
-   _outb( RCR_CLEAR, smc9000_base + RCR );
-   _outb( TCR_CLEAR, smc9000_base + TCR );
-}
-
-/**************************************************************************
- * ETH_PROBE - Look for an adapter
- ***************************************************************************/
-
-struct nic *smc9000_probe(struct nic *nic, unsigned short *probe_addrs)
-{
-   unsigned short   revision;
-   int	            memory;
-   int              media;
-   const char *	    version_string;
-   const char *	    if_string;
-   int              i;
-
-   /*
-    * the SMC9000 can be at any of the following port addresses.  To change,
-    * for a slightly different card, you can add it to the array.  Keep in
-    * mind that the array must end in zero.
-    */
-   static unsigned short portlist[] = {
-#ifdef	SMC9000_SCAN
-      SMC9000_SCAN,
-#else
-      0x200, 0x220, 0x240, 0x260, 0x280, 0x2A0, 0x2C0, 0x2E0,
-      0x300, 0x320, 0x340, 0x360, 0x380, 0x3A0, 0x3C0, 0x3E0,
-#endif
-      0 };
-
-   printf("\nSMC9000 %s\n", smc9000_version);
-#ifdef	SMC9000_VERBOSE
-   printf("Copyright (C) 1998 Daniel Engstr\x94m\n");
-   printf("Copyright (C) 1996 Eric Stahlman\n");
-#endif
-   /* if no addresses supplied, fall back on defaults */
-   if (probe_addrs == 0 || probe_addrs[0] == 0)
-     probe_addrs = portlist;
-
-   /* check every ethernet address */
-   for (i = 0; probe_addrs[i]; i++) {
-      /* check this specific address */
-      if (smc_probe(probe_addrs[i]) == 0)
-	smc9000_base = probe_addrs[i];
-   }
-
-   /* couldn't find anything */
-   if(0 == smc9000_base)
-     goto out;
-
-   /*
-    * Get the MAC address ( bank 1, regs 4 - 9 )
-    */
-   SMC_SELECT_BANK(smc9000_base, 1);
-   for ( i = 0; i < 6; i += 2 ) {
-      word address;
-
-      address = inw(smc9000_base + ADDR0 + i);
-      nic->node_addr[i+1] = address >> 8;
-      nic->node_addr[i] = address & 0xFF;
-   }
-
-
-   /* get the memory information */
-   SMC_SELECT_BANK(smc9000_base, 0);
-   memory = ( inw(smc9000_base + MCR) >> 9 )  & 0x7;  /* multiplier */
-   memory *= 256 * (inw(smc9000_base + MIR) & 0xFF);
-
-   /*
-    * Now, I want to find out more about the chip.  This is sort of
-    * redundant, but it's cleaner to have it in both, rather than having
-    * one VERY long probe procedure.
-    */
-   SMC_SELECT_BANK(smc9000_base, 3);
-   revision  = inw(smc9000_base + REVISION);
-   version_string = chip_ids[(revision >> 4) & 0xF];
-
-   if (((revision & 0xF0) >> 4 == CHIP_9196) &&
-       ((revision & 0x0F) >= REV_9196)) {
-      /* This is a 91c96. 'c96 has the same chip id as 'c94 (4) but
-       * a revision starting at 6 */
-      version_string = smc91c96_id;
-   }
-
-   if ( !version_string ) {
-      /* I shouldn't get here because this call was done before.... */
-      goto out;
-   }
-
-   /* is it using AUI or 10BaseT ? */
-   SMC_SELECT_BANK(smc9000_base, 1);
-   if (inw(smc9000_base + CONFIG) & CFG_AUI_SELECT)
-     media = 2;
-   else
-     media = 1;
-
-   if_string = interfaces[media - 1];
-
-   /* now, reset the chip, and put it into a known state */
-   smc_reset(smc9000_base);
-
-   printf("%s rev:%d I/O port:%hX Interface:%s RAM:%d bytes \n",
-	  version_string, revision & 0xF,
-	  smc9000_base, if_string, memory );
-   /*
-    * Print the Ethernet address
-    */
-   printf("Ethernet MAC address: %!\n", nic->node_addr);
-
-   SMC_SELECT_BANK(smc9000_base, 0);
-
-   /* see the header file for options in TCR/RCR NORMAL*/
-   _outw(TCR_NORMAL, smc9000_base + TCR);
-   _outw(RCR_NORMAL, smc9000_base + RCR);
-
-   /* Select which interface to use */
-   SMC_SELECT_BANK(smc9000_base, 1);
-   if ( media == 1 ) {
-      _outw( inw( smc9000_base + CONFIG ) & ~CFG_AUI_SELECT,
-	   smc9000_base + CONFIG );
-   }
-   else if ( media == 2 ) {
-      _outw( inw( smc9000_base + CONFIG ) | CFG_AUI_SELECT,
-	   smc9000_base + CONFIG );
-   }
-
-   nic->reset = smc9000_reset;
-   nic->poll = smc9000_poll;
-   nic->transmit = smc9000_transmit;
-   nic->disable = smc9000_disable;
-
-
-   return nic;
-
-out:
-#ifdef	SMC9000_VERBOSE
-   printf("No SMC9000 adapters found\n");
-#endif
-   smc9000_base = 0;
-
-   return (0);
-}
-
-
-
diff -Naur grub-0.97.orig/netboot/smc9000.h grub-0.97/netboot/smc9000.h
--- grub-0.97.orig/netboot/smc9000.h	2003-07-09 11:45:38.000000000 +0000
+++ grub-0.97/netboot/smc9000.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,205 +0,0 @@
-/*------------------------------------------------------------------------
- * smc9000.h
- *
- * Copyright (C) 1998 by Daniel Engstrm
- * Copyright (C) 1996 by Erik Stahlman
- *
- * This software may be used and distributed according to the terms
- * of the GNU Public License, incorporated herein by reference.
- *
- * This file contains register information and access macros for
- * the SMC91xxx chipset.
- *
- * Information contained in this file was obtained from the SMC91C94
- * manual from SMC.  To get a copy, if you really want one, you can find
- * information under www.smsc.com in the components division.
- * ( this thanks to advice from Donald Becker ).
- *
- * Authors
- *      Daniel Engstrm                         <daniel.engstrom@riksnett.no>
- *	Erik Stahlman				<erik@vt.edu>
- *
- * History
- * 96-01-06		 Erik Stahlman   moved definitions here from main .c
- *                                       file
- * 96-01-19		 Erik Stahlman	 polished this up some, and added
- *                                       better error handling
- * 98-09-25              Daniel Engstrm adjusted for Etherboot
- * 98-09-27              Daniel Engstrm moved some static strings back to the
- *                                       main .c file
- * --------------------------------------------------------------------------*/
-#ifndef	_SMC9000_H_
-# define _SMC9000_H_
-
-/* I want some simple types */
-typedef unsigned char			byte;
-typedef unsigned short			word;
-typedef unsigned long int		dword;
-
-/*---------------------------------------------------------------
- *
- * A description of the SMC registers is probably in order here,
- * although for details, the SMC datasheet is invaluable.
- *
- * Basically, the chip has 4 banks of registers ( 0 to 3 ), which
- * are accessed by writing a number into the BANK_SELECT register
- * ( I also use a SMC_SELECT_BANK macro for this ).
- *
- * The banks are configured so that for most purposes, bank 2 is all
- * that is needed for simple run time tasks.
- * ----------------------------------------------------------------------*/
-
-/*
- * Bank Select Register:
- *
- *		yyyy yyyy 0000 00xx
- *		xx		= bank number
- *		yyyy yyyy	= 0x33, for identification purposes.
- */
-#define	BANK_SELECT		14
-
-/* BANK 0  */
-
-#define	TCR		0	/* transmit control register */
-#define TCR_ENABLE	0x0001	/* if this is 1, we can transmit */
-#define TCR_FDUPLX	0x0800	/* receive packets sent out */
-#define TCR_STP_SQET	0x1000	/* stop transmitting if Signal quality error */
-#define	TCR_MON_CNS	0x0400	/* monitors the carrier status */
-#define	TCR_PAD_ENABLE	0x0080	/* pads short packets to 64 bytes */
-
-#define	TCR_CLEAR	0	/* do NOTHING */
-/* the normal settings for the TCR register : */
-#define	TCR_NORMAL	(TCR_ENABLE | TCR_PAD_ENABLE)
-
-
-#define EPH_STATUS	2
-#define ES_LINK_OK	0x4000	/* is the link integrity ok ? */
-
-#define	RCR		4
-#define RCR_SOFTRESET	0x8000	/* resets the chip */
-#define	RCR_STRIP_CRC	0x200	/* strips CRC */
-#define RCR_ENABLE	0x100	/* IFF this is set, we can receive packets */
-#define RCR_ALMUL	0x4	/* receive all multicast packets */
-#define	RCR_PROMISC	0x2	/* enable promiscuous mode */
-
-/* the normal settings for the RCR register : */
-#define	RCR_NORMAL	(RCR_STRIP_CRC | RCR_ENABLE)
-#define RCR_CLEAR	0x0		/* set it to a base state */
-
-#define	COUNTER		6
-#define	MIR		8
-#define	MCR		10
-/* 12 is reserved */
-
-/* BANK 1 */
-#define CONFIG			0
-#define CFG_AUI_SELECT		0x100
-#define	BASE			2
-#define	ADDR0			4
-#define	ADDR1			6
-#define	ADDR2			8
-#define	GENERAL			10
-#define	CONTROL			12
-#define	CTL_POWERDOWN		0x2000
-#define	CTL_LE_ENABLE		0x80
-#define	CTL_CR_ENABLE		0x40
-#define	CTL_TE_ENABLE		0x0020
-#define CTL_AUTO_RELEASE	0x0800
-#define	CTL_EPROM_ACCESS	0x0003 /* high if Eprom is being read */
-
-/* BANK 2 */
-#define MMU_CMD		0
-#define MC_BUSY		1	/* only readable bit in the register */
-#define MC_NOP		0
-#define	MC_ALLOC	0x20	/* or with number of 256 byte packets */
-#define	MC_RESET	0x40
-#define	MC_REMOVE	0x60	/* remove the current rx packet */
-#define MC_RELEASE	0x80	/* remove and release the current rx packet */
-#define MC_FREEPKT	0xA0	/* Release packet in PNR register */
-#define MC_ENQUEUE	0xC0	/* Enqueue the packet for transmit */
-
-#define	PNR_ARR		2
-#define FIFO_PORTS	4
-
-#define FP_RXEMPTY	0x8000
-#define FP_TXEMPTY	0x80
-
-#define	POINTER		6
-#define PTR_READ	0x2000
-#define	PTR_RCV		0x8000
-#define	PTR_AUTOINC	0x4000
-#define PTR_AUTO_INC	0x0040
-
-#define	DATA_1		8
-#define	DATA_2		10
-#define	INTERRUPT	12
-
-#define INT_MASK	13
-#define IM_RCV_INT	0x1
-#define	IM_TX_INT	0x2
-#define	IM_TX_EMPTY_INT	0x4
-#define	IM_ALLOC_INT	0x8
-#define	IM_RX_OVRN_INT	0x10
-#define	IM_EPH_INT	0x20
-#define	IM_ERCV_INT	0x40 /* not on SMC9192 */
-
-/* BANK 3 */
-#define	MULTICAST1	0
-#define	MULTICAST2	2
-#define	MULTICAST3	4
-#define	MULTICAST4	6
-#define	MGMT		8
-#define	REVISION	10 /* ( hi: chip id   low: rev # ) */
-
-
-/* this is NOT on SMC9192 */
-#define	ERCV		12
-
-/* Note that 9194 and 9196 have the smame chip id,
- * the 9196 will have revisions starting at 6 */
-#define CHIP_9190	3
-#define CHIP_9194	4
-#define CHIP_9195	5
-#define CHIP_9196	4
-#define CHIP_91100	7
-#define CHIP_91100FD	8
-
-#define REV_9196	6
-
-/*
- * Transmit status bits
- */
-#define TS_SUCCESS	0x0001
-#define TS_LOSTCAR	0x0400
-#define TS_LATCOL	0x0200
-#define TS_16COL	0x0010
-
-/*
- * Receive status bits
- */
-#define RS_ALGNERR	0x8000
-#define RS_BADCRC	0x2000
-#define RS_ODDFRAME	0x1000
-#define RS_TOOLONG	0x0800
-#define RS_TOOSHORT	0x0400
-#define RS_MULTICAST	0x0001
-#define RS_ERRORS	(RS_ALGNERR | RS_BADCRC | RS_TOOLONG | RS_TOOSHORT)
-
-
-/*-------------------------------------------------------------------------
- *  I define some macros to make it easier to do somewhat common
- * or slightly complicated, repeated tasks.
- --------------------------------------------------------------------------*/
-
-/* select a register bank, 0 to 3  */
-
-#define SMC_SELECT_BANK(x, y) { _outw( y, x + BANK_SELECT ); }
-
-/* define a small delay for the reset */
-#define SMC_DELAY(x) { inw( x + RCR );\
-			inw( x + RCR );\
-			inw( x + RCR ); }
-
-
-#endif	/* _SMC_9000_H_ */
-
diff -Naur grub-0.97.orig/netboot/stdint.h grub-0.97/netboot/stdint.h
--- grub-0.97.orig/netboot/stdint.h	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/stdint.h	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,18 @@
+#ifndef STDINT_H
+#define STDINT_H
+/* 
+ * I'm architecture depended. Check me before port GRUB
+ */
+typedef unsigned           size_t;
+
+typedef unsigned char      uint8_t;
+typedef unsigned short     uint16_t;
+typedef unsigned long      uint32_t;
+typedef unsigned long long uint64_t;
+
+typedef signed char        int8_t;
+typedef signed short       int16_t;
+typedef signed long        int32_t;
+typedef signed long long   int64_t;
+
+#endif /* STDINT_H */
diff -Naur grub-0.97.orig/netboot/tftp.h grub-0.97/netboot/tftp.h
--- grub-0.97.orig/netboot/tftp.h	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/tftp.h	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,82 @@
+#ifndef	_TFTP_H
+#define	_TFTP_H
+
+#include "if_ether.h"
+#include "ip.h"
+#include "udp.h"
+
+#ifndef	MAX_TFTP_RETRIES
+#define MAX_TFTP_RETRIES	20
+#endif
+
+/* These settings have sense only if compiled with -DCONGESTED */
+/* total retransmission timeout in ticks */
+#define TFTP_TIMEOUT		(30*TICKS_PER_SEC)
+/* packet retransmission timeout in ticks */
+#define TFTP_REXMT		(3*TICKS_PER_SEC)
+
+#define TFTP_PORT	69
+#define	TFTP_DEFAULTSIZE_PACKET	512
+#define	TFTP_MAX_PACKET		1432 /* 512 */
+
+#define TFTP_RRQ	1
+#define TFTP_WRQ	2
+#define TFTP_DATA	3
+#define TFTP_ACK	4
+#define TFTP_ERROR	5
+#define TFTP_OACK	6
+
+#define TFTP_CODE_EOF	1
+#define TFTP_CODE_MORE	2
+#define TFTP_CODE_ERROR	3
+#define TFTP_CODE_BOOT	4
+#define TFTP_CODE_CFG	5
+
+struct tftp_t {
+	struct iphdr ip;
+	struct udphdr udp;
+	uint16_t opcode;
+	union {
+		uint8_t rrq[TFTP_DEFAULTSIZE_PACKET];
+		struct {
+			uint16_t block;
+			uint8_t  download[TFTP_MAX_PACKET];
+		} data;
+		struct {
+			uint16_t block;
+		} ack;
+		struct {
+			uint16_t errcode;
+			uint8_t  errmsg[TFTP_DEFAULTSIZE_PACKET];
+		} err;
+		struct {
+			uint8_t  data[TFTP_DEFAULTSIZE_PACKET+2];
+		} oack;
+	} u;
+};
+
+/* define a smaller tftp packet solely for making requests to conserve stack
+   512 bytes should be enough */
+struct tftpreq_t {
+	struct iphdr ip;
+	struct udphdr udp;
+	uint16_t opcode;
+	union {
+		uint8_t rrq[512];
+		struct {
+			uint16_t block;
+		} ack;
+		struct {
+			uint16_t errcode;
+			uint8_t  errmsg[512-2];
+		} err;
+	} u;
+};
+
+#define TFTP_MIN_PACKET	(sizeof(struct iphdr) + sizeof(struct udphdr) + 4)
+
+typedef int (*read_actor_t)(unsigned char *, unsigned int, unsigned int, int);
+
+int tftp_file_read(const char *name, read_actor_t);
+
+#endif	/* _TFTP_H */
diff -Naur grub-0.97.orig/netboot/tg3.c grub-0.97/netboot/tg3.c
--- grub-0.97.orig/netboot/tg3.c	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/tg3.c	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,3322 @@
+/* $Id: grub-0.95-diskless-patch-2.patch,v 1.1.1.1 2005/06/14 08:18:50 wesolows Exp $
+ * tg3.c: Broadcom Tigon3 ethernet driver.
+ *
+ * Copyright (C) 2001, 2002 David S. Miller (davem@redhat.com)
+ * Copyright (C) 2001, 2002 Jeff Garzik (jgarzik@mandrakesoft.com)
+ * Copyright (C) 2003 Eric Biederman (ebiederman@lnxi.com)  [etherboot port]
+ */
+
+/* 11-13-2003	timlegge	Fix Issue with NetGear GA302T 
+ * 11-18-2003   ebiederm        Generalize NetGear Fix to what the code was supposed to be.
+ */
+
+#include "etherboot.h"
+#include "nic.h"
+#include "pci.h"
+#include "timer.h"
+/*#include "string.h"*/
+#include "tg3.h"
+
+#define SUPPORT_COPPER_PHY  1
+#define SUPPORT_FIBER_PHY   1
+#define SUPPORT_LINK_REPORT 1
+#define SUPPORT_PARTNO_STR  1
+#define SUPPORT_PHY_STR     1
+
+struct tg3 tg3;
+
+/* Dummy defines for error handling */
+#define EBUSY  1
+#define ENODEV 2
+#define EINVAL 3
+#define ENOMEM 4
+
+
+/* These numbers seem to be hard coded in the NIC firmware somehow.
+ * You can't change the ring sizes, but you can change where you place
+ * them in the NIC onboard memory.
+ */
+#define TG3_RX_RING_SIZE		512
+#define TG3_DEF_RX_RING_PENDING		20	/* RX_RING_PENDING seems to be o.k. at 20 and 200 */
+#define TG3_RX_RCB_RING_SIZE	1024
+
+/*	(GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705 ? \
+	 512 : 1024) */
+ #define TG3_TX_RING_SIZE		512
+#define TG3_DEF_TX_RING_PENDING		(TG3_TX_RING_SIZE - 1)
+
+#define TG3_RX_RING_BYTES	(sizeof(struct tg3_rx_buffer_desc) * TG3_RX_RING_SIZE)
+#define TG3_RX_RCB_RING_BYTES	(sizeof(struct tg3_rx_buffer_desc) * TG3_RX_RCB_RING_SIZE)
+
+#define TG3_TX_RING_BYTES	(sizeof(struct tg3_tx_buffer_desc) * TG3_TX_RING_SIZE)
+#define NEXT_TX(N)		(((N) + 1) & (TG3_TX_RING_SIZE - 1))
+#define PREV_TX(N)		(((N) - 1) & (TG3_TX_RING_SIZE - 1))
+
+#define RX_PKT_BUF_SZ		(1536 + 2 + 64)
+
+
+static struct bss {
+	struct tg3_rx_buffer_desc rx_std[TG3_RX_RING_SIZE];
+	struct tg3_rx_buffer_desc rx_rcb[TG3_RX_RCB_RING_SIZE];
+	struct tg3_tx_buffer_desc tx_ring[TG3_TX_RING_SIZE];
+	struct tg3_hw_status      hw_status;
+	struct tg3_hw_stats       hw_stats;
+	unsigned char             rx_bufs[TG3_DEF_RX_RING_PENDING][RX_PKT_BUF_SZ];
+} tg3_bss;
+
+/**
+ * pci_save_state - save the PCI configuration space of a device before suspending
+ * @dev: - PCI device that we're dealing with
+ * @buffer: - buffer to hold config space context
+ *
+ * @buffer must be large enough to hold the entire PCI 2.2 config space 
+ * (>= 64 bytes).
+ */
+static int pci_save_state(struct pci_device *dev, uint32_t *buffer)
+{
+	int i;
+	for (i = 0; i < 16; i++)
+		pci_read_config_dword(dev, i * 4,&buffer[i]);
+	return 0;
+}
+
+/** 
+ * pci_restore_state - Restore the saved state of a PCI device
+ * @dev: - PCI device that we're dealing with
+ * @buffer: - saved PCI config space
+ *
+ */
+static int pci_restore_state(struct pci_device *dev, uint32_t *buffer)
+{
+	int i;
+
+	for (i = 0; i < 16; i++)
+		pci_write_config_dword(dev,i * 4, buffer[i]);
+	return 0;
+}
+
+static void tg3_write_indirect_reg32(uint32_t off, uint32_t val)
+{
+	pci_write_config_dword(tg3.pdev, TG3PCI_REG_BASE_ADDR, off);
+	pci_write_config_dword(tg3.pdev, TG3PCI_REG_DATA, val);
+}
+
+#define tw32(reg,val)		tg3_write_indirect_reg32((reg),(val))
+#define tw32_mailbox(reg, val)	writel(((val) & 0xffffffff), tg3.regs + (reg))
+#define tw16(reg,val)		writew(((val) & 0xffff), tg3.regs + (reg))
+#define tw8(reg,val)		writeb(((val) & 0xff), tg3.regs + (reg))
+#define tr32(reg)		readl(tg3.regs + (reg))
+#define tr16(reg)		readw(tg3.regs + (reg))
+#define tr8(reg)		readb(tg3.regs + (reg))
+
+static void tw32_carefully(uint32_t reg, uint32_t val)
+{
+	tw32(reg, val);
+	tr32(reg);
+	udelay(100);
+}
+
+static void tw32_mailbox2(uint32_t reg, uint32_t val)
+{
+	tw32_mailbox(reg, val);
+	tr32(reg);
+}
+
+static void tg3_write_mem(uint32_t off, uint32_t val)
+{
+	pci_write_config_dword(tg3.pdev, TG3PCI_MEM_WIN_BASE_ADDR, off);
+	pci_write_config_dword(tg3.pdev, TG3PCI_MEM_WIN_DATA, val);
+
+	/* Always leave this as zero. */
+	pci_write_config_dword(tg3.pdev, TG3PCI_MEM_WIN_BASE_ADDR, 0);
+}
+
+static void tg3_read_mem(uint32_t off, uint32_t *val)
+{
+	pci_write_config_dword(tg3.pdev, TG3PCI_MEM_WIN_BASE_ADDR, off);
+	pci_read_config_dword(tg3.pdev, TG3PCI_MEM_WIN_DATA, val);
+
+	/* Always leave this as zero. */
+	pci_write_config_dword(tg3.pdev, TG3PCI_MEM_WIN_BASE_ADDR, 0);
+}
+
+static void tg3_disable_ints(struct tg3 *tp)
+{
+	tw32(TG3PCI_MISC_HOST_CTRL,
+	     (tp->misc_host_ctrl | MISC_HOST_CTRL_MASK_PCI_INT));
+	tw32_mailbox2(MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW, 0x00000001);
+}
+
+static void tg3_switch_clocks(struct tg3 *tp)
+{
+	uint32_t orig_clock_ctrl, clock_ctrl;
+
+	clock_ctrl = tr32(TG3PCI_CLOCK_CTRL);
+
+	orig_clock_ctrl = clock_ctrl;
+	clock_ctrl &= (CLOCK_CTRL_FORCE_CLKRUN | CLOCK_CTRL_CLKRUN_OENABLE | 0x1f);
+	tp->pci_clock_ctrl = clock_ctrl;
+	
+	if ((GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5705) &&
+		(orig_clock_ctrl & CLOCK_CTRL_44MHZ_CORE)!=0) {
+		tw32_carefully(TG3PCI_CLOCK_CTRL, 
+			clock_ctrl | (CLOCK_CTRL_44MHZ_CORE | CLOCK_CTRL_ALTCLK));
+		tw32_carefully(TG3PCI_CLOCK_CTRL, 
+			clock_ctrl | (CLOCK_CTRL_ALTCLK));
+	}
+	tw32_carefully(TG3PCI_CLOCK_CTRL, clock_ctrl);
+}
+
+#define PHY_BUSY_LOOPS	5000
+
+static int tg3_readphy(struct tg3 *tp, int reg, uint32_t *val)
+{
+	uint32_t frame_val;
+	int loops, ret;
+
+	tw32_carefully(MAC_MI_MODE, tp->mi_mode & ~MAC_MI_MODE_AUTO_POLL);
+
+	*val = 0xffffffff;
+
+	frame_val  = ((PHY_ADDR << MI_COM_PHY_ADDR_SHIFT) &
+		      MI_COM_PHY_ADDR_MASK);
+	frame_val |= ((reg << MI_COM_REG_ADDR_SHIFT) &
+		      MI_COM_REG_ADDR_MASK);
+	frame_val |= (MI_COM_CMD_READ | MI_COM_START);
+	
+	tw32_carefully(MAC_MI_COM, frame_val);
+
+	loops = PHY_BUSY_LOOPS;
+	while (loops-- > 0) {
+		udelay(10);
+		frame_val = tr32(MAC_MI_COM);
+
+		if ((frame_val & MI_COM_BUSY) == 0) {
+			udelay(5);
+			frame_val = tr32(MAC_MI_COM);
+			break;
+		}
+	}
+
+	ret = -EBUSY;
+	if (loops > 0) {
+		*val = frame_val & MI_COM_DATA_MASK;
+		ret = 0;
+	}
+
+	tw32_carefully(MAC_MI_MODE, tp->mi_mode);
+
+	return ret;
+}
+
+static int tg3_writephy(struct tg3 *tp, int reg, uint32_t val)
+{
+	uint32_t frame_val;
+	int loops, ret;
+
+	tw32_carefully(MAC_MI_MODE, tp->mi_mode & ~MAC_MI_MODE_AUTO_POLL);
+
+	frame_val  = ((PHY_ADDR << MI_COM_PHY_ADDR_SHIFT) &
+		      MI_COM_PHY_ADDR_MASK);
+	frame_val |= ((reg << MI_COM_REG_ADDR_SHIFT) &
+		      MI_COM_REG_ADDR_MASK);
+	frame_val |= (val & MI_COM_DATA_MASK);
+	frame_val |= (MI_COM_CMD_WRITE | MI_COM_START);
+	
+	tw32_carefully(MAC_MI_COM, frame_val);
+
+	loops = PHY_BUSY_LOOPS;
+	while (loops-- > 0) {
+		udelay(10);
+		frame_val = tr32(MAC_MI_COM);
+		if ((frame_val & MI_COM_BUSY) == 0) {
+			udelay(5);
+			frame_val = tr32(MAC_MI_COM);
+			break;
+		}
+	}
+
+	ret = -EBUSY;
+	if (loops > 0)
+		ret = 0;
+
+	tw32_carefully(MAC_MI_MODE, tp->mi_mode);
+
+	return ret;
+}
+
+static int tg3_writedsp(struct tg3 *tp, uint16_t addr, uint16_t val)
+{
+	int err;
+	err  = tg3_writephy(tp, MII_TG3_DSP_ADDRESS, addr);
+	err |= tg3_writephy(tp, MII_TG3_DSP_RW_PORT, val);
+	return err;
+}
+
+
+static void tg3_phy_set_wirespeed(struct tg3 *tp)
+{
+	uint32_t val;
+
+	if (tp->tg3_flags2 & TG3_FLG2_NO_ETH_WIRE_SPEED)
+		return;
+
+	tg3_writephy(tp, MII_TG3_AUX_CTRL, 0x7007);
+	tg3_readphy(tp, MII_TG3_AUX_CTRL, &val);
+	tg3_writephy(tp, MII_TG3_AUX_CTRL, (val | (1 << 15) | (1 << 4)));
+}
+
+static int tg3_bmcr_reset(struct tg3 *tp)
+{
+	uint32_t phy_control;
+	int limit, err;
+
+	/* OK, reset it, and poll the BMCR_RESET bit until it
+	 * clears or we time out.
+	 */
+	phy_control = BMCR_RESET;
+	err = tg3_writephy(tp, MII_BMCR, phy_control);
+	if (err != 0)
+		return -EBUSY;
+
+	limit = 5000;
+	while (limit--) {
+		err = tg3_readphy(tp, MII_BMCR, &phy_control);
+		if (err != 0)
+			return -EBUSY;
+
+		if ((phy_control & BMCR_RESET) == 0) {
+			udelay(40);
+			break;
+		}
+		udelay(10);
+	}
+	if (limit <= 0)
+		return -EBUSY;
+
+	return 0;
+}
+
+static int tg3_wait_macro_done(struct tg3 *tp)
+{
+	int limit = 100;
+
+	while (limit--) {
+		uint32_t tmp32;
+
+		tg3_readphy(tp, 0x16, &tmp32);
+		if ((tmp32 & 0x1000) == 0)
+			break;
+	}
+	if (limit <= 0)
+		return -EBUSY;
+
+	return 0;
+}
+
+static int tg3_phy_write_and_check_testpat(struct tg3 *tp, int *resetp)
+{
+	static const uint32_t test_pat[4][6] = {
+	{ 0x00005555, 0x00000005, 0x00002aaa, 0x0000000a, 0x00003456, 0x00000003 },
+	{ 0x00002aaa, 0x0000000a, 0x00003333, 0x00000003, 0x0000789a, 0x00000005 },
+	{ 0x00005a5a, 0x00000005, 0x00002a6a, 0x0000000a, 0x00001bcd, 0x00000003 },
+	{ 0x00002a5a, 0x0000000a, 0x000033c3, 0x00000003, 0x00002ef1, 0x00000005 }
+	};
+	int chan;
+
+	for (chan = 0; chan < 4; chan++) {
+		int i;
+
+		tg3_writephy(tp, MII_TG3_DSP_ADDRESS,
+			(chan * 0x2000) | 0x0200);
+		tg3_writephy(tp, 0x16, 0x0002);
+
+		for (i = 0; i < 6; i++)
+			tg3_writephy(tp, MII_TG3_DSP_RW_PORT,
+				test_pat[chan][i]);
+
+		tg3_writephy(tp, 0x16, 0x0202);
+		if (tg3_wait_macro_done(tp)) {
+			*resetp = 1;
+			return -EBUSY;
+		}
+
+		tg3_writephy(tp, MII_TG3_DSP_ADDRESS,
+			     (chan * 0x2000) | 0x0200);
+		tg3_writephy(tp, 0x16, 0x0082);
+		if (tg3_wait_macro_done(tp)) {
+			*resetp = 1;
+			return -EBUSY;
+		}
+
+		tg3_writephy(tp, 0x16, 0x0802);
+		if (tg3_wait_macro_done(tp)) {
+			*resetp = 1;
+			return -EBUSY;
+		}
+
+		for (i = 0; i < 6; i += 2) {
+			uint32_t low, high;
+
+			tg3_readphy(tp, MII_TG3_DSP_RW_PORT, &low);
+			tg3_readphy(tp, MII_TG3_DSP_RW_PORT, &high);
+			if (tg3_wait_macro_done(tp)) {
+				*resetp = 1;
+				return -EBUSY;
+			}
+			low &= 0x7fff;
+			high &= 0x000f;
+			if (low != test_pat[chan][i] ||
+			    high != test_pat[chan][i+1]) {
+				tg3_writephy(tp, MII_TG3_DSP_ADDRESS, 0x000b);
+				tg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x4001);
+				tg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x4005);
+
+				return -EBUSY;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int tg3_phy_reset_chanpat(struct tg3 *tp)
+{
+	int chan;
+
+	for (chan = 0; chan < 4; chan++) {
+		int i;
+
+		tg3_writephy(tp, MII_TG3_DSP_ADDRESS,
+			     (chan * 0x2000) | 0x0200);
+		tg3_writephy(tp, 0x16, 0x0002);
+		for (i = 0; i < 6; i++)
+			tg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x000);
+		tg3_writephy(tp, 0x16, 0x0202);
+		if (tg3_wait_macro_done(tp))
+			return -EBUSY;
+	}
+
+	return 0;
+}
+
+static int tg3_phy_reset_5703_4_5(struct tg3 *tp)
+{
+	uint32_t reg32, phy9_orig;
+	int retries, do_phy_reset, err;
+
+	retries = 10;
+	do_phy_reset = 1;
+	do {
+		if (do_phy_reset) {
+			err = tg3_bmcr_reset(tp);
+			if (err)
+				return err;
+			do_phy_reset = 0;
+		}
+		
+		/* Disable transmitter and interrupt.  */
+		tg3_readphy(tp, MII_TG3_EXT_CTRL, &reg32);
+		reg32 |= 0x3000;
+		tg3_writephy(tp, MII_TG3_EXT_CTRL, reg32);
+
+		/* Set full-duplex, 1000 mbps.  */
+		tg3_writephy(tp, MII_BMCR,
+			BMCR_FULLDPLX | TG3_BMCR_SPEED1000);
+
+		/* Set to master mode.  */
+		tg3_readphy(tp, MII_TG3_CTRL, &phy9_orig);
+		tg3_writephy(tp, MII_TG3_CTRL,
+			(MII_TG3_CTRL_AS_MASTER |
+				MII_TG3_CTRL_ENABLE_AS_MASTER));
+
+		/* Enable SM_DSP_CLOCK and 6dB.  */
+		tg3_writephy(tp, MII_TG3_AUX_CTRL, 0x0c00);
+
+		/* Block the PHY control access.  */
+		tg3_writephy(tp, MII_TG3_DSP_ADDRESS, 0x8005);
+		tg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x0800);
+
+		err = tg3_phy_write_and_check_testpat(tp, &do_phy_reset);
+		if (!err)
+			break;
+	} while (--retries);
+
+	err = tg3_phy_reset_chanpat(tp);
+	if (err)
+		return err;
+
+	tg3_writephy(tp, MII_TG3_DSP_ADDRESS, 0x8005);
+	tg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x0000);
+
+	tg3_writephy(tp, MII_TG3_DSP_ADDRESS, 0x8200);
+	tg3_writephy(tp, 0x16, 0x0000);
+
+	tg3_writephy(tp, MII_TG3_AUX_CTRL, 0x0400);
+
+	tg3_writephy(tp, MII_TG3_CTRL, phy9_orig);
+
+	tg3_readphy(tp, MII_TG3_EXT_CTRL, &reg32);
+	reg32 &= ~0x3000;
+	tg3_writephy(tp, MII_TG3_EXT_CTRL, reg32);
+
+	return err;
+}
+
+/* This will reset the tigon3 PHY if there is no valid
+ * link.
+ */
+static int tg3_phy_reset(struct tg3 *tp)
+{
+	uint32_t phy_status;
+	int err;
+
+	err  = tg3_readphy(tp, MII_BMSR, &phy_status);
+	err |= tg3_readphy(tp, MII_BMSR, &phy_status);
+	if (err != 0)
+		return -EBUSY;
+
+	if ((GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5703) ||
+		(GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5704) ||
+		(GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705)) {
+		err = tg3_phy_reset_5703_4_5(tp);
+		if (err)
+			return err;
+		goto out;
+	}
+	err = tg3_bmcr_reset(tp);
+	if (err)
+		return err;
+ out:
+	tg3_phy_set_wirespeed(tp);
+	return 0;
+}
+
+static void tg3_set_power_state_0(struct tg3 *tp)
+{
+	uint16_t power_control;
+	int pm = tp->pm_cap;
+
+	/* Make sure register accesses (indirect or otherwise)
+	 * will function correctly.
+	 */
+	pci_write_config_dword(tp->pdev,  TG3PCI_MISC_HOST_CTRL, tp->misc_host_ctrl);
+
+	pci_read_config_word(tp->pdev, pm + PCI_PM_CTRL, &power_control);
+
+	power_control |= PCI_PM_CTRL_PME_STATUS;
+	power_control &= ~(PCI_PM_CTRL_STATE_MASK);
+	power_control |= 0;
+	pci_write_config_word(tp->pdev, pm + PCI_PM_CTRL, power_control);
+
+	tw32_carefully(GRC_LOCAL_CTRL, tp->grc_local_ctrl);
+
+	return;
+}
+
+
+#if SUPPORT_LINK_REPORT
+static void tg3_link_report(struct tg3 *tp)
+{
+	if (!tp->carrier_ok) {
+		printf("Link is down.\n");
+	} else {
+		printf("Link is up at %d Mbps, %s duplex. %s %s %s\n",
+			(tp->link_config.active_speed == SPEED_1000 ?
+			       1000 :
+			(tp->link_config.active_speed == SPEED_100 ?
+				100 : 10)),
+			(tp->link_config.active_duplex == DUPLEX_FULL ?  
+				"full" : "half"),
+			(tp->tg3_flags & TG3_FLAG_TX_PAUSE) ? "TX" : "",
+			(tp->tg3_flags & TG3_FLAG_RX_PAUSE) ? "RX" : "",
+			(tp->tg3_flags & (TG3_FLAG_TX_PAUSE |TG3_FLAG_RX_PAUSE)) ? "flow control" : "");
+	}
+}
+#else
+#define tg3_link_report(tp)
+#endif
+
+static void tg3_setup_flow_control(struct tg3 *tp, uint32_t local_adv, uint32_t remote_adv)
+{
+	uint32_t new_tg3_flags = 0;
+
+	if (local_adv & ADVERTISE_PAUSE_CAP) {
+		if (local_adv & ADVERTISE_PAUSE_ASYM) {
+			if (remote_adv & LPA_PAUSE_CAP)
+				new_tg3_flags |=
+					(TG3_FLAG_RX_PAUSE |
+					 TG3_FLAG_TX_PAUSE);
+			else if (remote_adv & LPA_PAUSE_ASYM)
+				new_tg3_flags |=
+					(TG3_FLAG_RX_PAUSE);
+		} else {
+			if (remote_adv & LPA_PAUSE_CAP)
+				new_tg3_flags |=
+					(TG3_FLAG_RX_PAUSE |
+					 TG3_FLAG_TX_PAUSE);
+		}
+	} else if (local_adv & ADVERTISE_PAUSE_ASYM) {
+		if ((remote_adv & LPA_PAUSE_CAP) &&
+		    (remote_adv & LPA_PAUSE_ASYM))
+			new_tg3_flags |= TG3_FLAG_TX_PAUSE;
+	}
+
+	tp->tg3_flags &= ~(TG3_FLAG_RX_PAUSE | TG3_FLAG_TX_PAUSE);
+	tp->tg3_flags |= new_tg3_flags;
+
+	if (new_tg3_flags & TG3_FLAG_RX_PAUSE)
+		tp->rx_mode |= RX_MODE_FLOW_CTRL_ENABLE;
+	else
+		tp->rx_mode &= ~RX_MODE_FLOW_CTRL_ENABLE;
+
+	if (new_tg3_flags & TG3_FLAG_TX_PAUSE)
+		tp->tx_mode |= TX_MODE_FLOW_CTRL_ENABLE;
+	else
+		tp->tx_mode &= ~TX_MODE_FLOW_CTRL_ENABLE;
+}
+
+#if SUPPORT_COPPER_PHY
+static void tg3_aux_stat_to_speed_duplex(
+	struct tg3 *tp __unused, uint32_t val, uint8_t *speed, uint8_t *duplex)
+{
+	static const uint8_t map[] = {
+		[0] = (SPEED_INVALID << 2) | DUPLEX_INVALID,
+		[MII_TG3_AUX_STAT_10HALF >> 8]   = (SPEED_10 << 2) | DUPLEX_HALF,
+		[MII_TG3_AUX_STAT_10FULL >> 8]   = (SPEED_10 << 2) | DUPLEX_FULL,
+		[MII_TG3_AUX_STAT_100HALF >> 8]  = (SPEED_100 << 2) | DUPLEX_HALF,
+		[MII_TG3_AUX_STAT_100_4 >> 8] = (SPEED_INVALID << 2) | DUPLEX_INVALID,
+		[MII_TG3_AUX_STAT_100FULL >> 8]  = (SPEED_100 << 2) | DUPLEX_FULL,
+		[MII_TG3_AUX_STAT_1000HALF >> 8] = (SPEED_1000 << 2) | DUPLEX_HALF,
+		[MII_TG3_AUX_STAT_1000FULL >> 8] = (SPEED_1000 << 2) | DUPLEX_FULL,
+	};
+	uint8_t result;
+	result = map[(val & MII_TG3_AUX_STAT_SPDMASK) >> 8];
+	*speed = result >> 2;
+	*duplex = result & 3;
+}
+
+static int tg3_phy_copper_begin(struct tg3 *tp)
+{
+	uint32_t new_adv;
+
+	tp->link_config.advertising =
+		(ADVERTISED_10baseT_Half | ADVERTISED_10baseT_Full |
+			ADVERTISED_100baseT_Half | ADVERTISED_100baseT_Full |
+			ADVERTISED_1000baseT_Half | ADVERTISED_1000baseT_Full |
+			ADVERTISED_Autoneg | ADVERTISED_MII);
+	
+	if (tp->tg3_flags & TG3_FLAG_10_100_ONLY) {
+		tp->link_config.advertising &=
+			~(ADVERTISED_1000baseT_Half | ADVERTISED_1000baseT_Full);
+	}
+	
+	new_adv = (ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP);
+	if (tp->link_config.advertising & ADVERTISED_10baseT_Half) {
+		new_adv |= ADVERTISE_10HALF;
+	}
+	if (tp->link_config.advertising & ADVERTISED_10baseT_Full) {
+		new_adv |= ADVERTISE_10FULL;
+	}
+	if (tp->link_config.advertising & ADVERTISED_100baseT_Half) {
+		new_adv |= ADVERTISE_100HALF;
+	}
+	if (tp->link_config.advertising & ADVERTISED_100baseT_Full) {
+		new_adv |= ADVERTISE_100FULL;
+	}
+	tg3_writephy(tp, MII_ADVERTISE, new_adv);
+	
+	if (tp->link_config.advertising &
+		(ADVERTISED_1000baseT_Half | ADVERTISED_1000baseT_Full)) {
+		new_adv = 0;
+		if (tp->link_config.advertising & ADVERTISED_1000baseT_Half) {
+			new_adv |= MII_TG3_CTRL_ADV_1000_HALF;
+		}
+		if (tp->link_config.advertising & ADVERTISED_1000baseT_Full) {
+			new_adv |= MII_TG3_CTRL_ADV_1000_FULL;
+		}
+		if (!(tp->tg3_flags & TG3_FLAG_10_100_ONLY) &&
+			(tp->pci_chip_rev_id == CHIPREV_ID_5701_A0 ||
+				tp->pci_chip_rev_id == CHIPREV_ID_5701_B0)) {
+			new_adv |= (MII_TG3_CTRL_AS_MASTER |
+				MII_TG3_CTRL_ENABLE_AS_MASTER);
+		}
+		tg3_writephy(tp, MII_TG3_CTRL, new_adv);
+	} else {
+		tg3_writephy(tp, MII_TG3_CTRL, 0);
+	}
+
+	tg3_writephy(tp, MII_BMCR, BMCR_ANENABLE | BMCR_ANRESTART);
+
+	return 0;
+}
+
+static int tg3_init_5401phy_dsp(struct tg3 *tp)
+{
+	int err;
+
+	/* Turn off tap power management. */
+	err  = tg3_writephy(tp, MII_TG3_AUX_CTRL, 0x0c20);
+	
+	err |= tg3_writedsp(tp, 0x0012, 0x1804);
+	err |= tg3_writedsp(tp, 0x0013, 0x1204);
+	err |= tg3_writedsp(tp, 0x8006, 0x0132);
+	err |= tg3_writedsp(tp, 0x8006, 0x0232);
+	err |= tg3_writedsp(tp, 0x201f, 0x0a20);
+
+	udelay(40);
+
+	return err;
+}
+
+static int tg3_setup_copper_phy(struct tg3 *tp)
+{
+	int current_link_up;
+	uint32_t bmsr, dummy;
+	int i, err;
+
+	tw32_carefully(MAC_STATUS,
+		(MAC_STATUS_SYNC_CHANGED | MAC_STATUS_CFG_CHANGED));
+
+	tp->mi_mode = MAC_MI_MODE_BASE;
+	tw32_carefully(MAC_MI_MODE, tp->mi_mode);
+
+	tg3_writephy(tp, MII_TG3_AUX_CTRL, 0x02);
+
+	/* Some third-party PHYs need to be reset on link going
+	 * down.
+	 */
+	if (	(	(GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5703) ||
+			(GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5704) ||
+			(tp->pci_chip_rev_id == CHIPREV_ID_5705_A0)) &&
+		(tp->carrier_ok)) {
+		tg3_readphy(tp, MII_BMSR, &bmsr);
+		tg3_readphy(tp, MII_BMSR, &bmsr);
+		if (!(bmsr & BMSR_LSTATUS))
+			tg3_phy_reset(tp);
+	}
+
+	if ((tp->phy_id & PHY_ID_MASK) == PHY_ID_BCM5401) {
+		tg3_readphy(tp, MII_BMSR, &bmsr);
+		tg3_readphy(tp, MII_BMSR, &bmsr);
+
+		if (!(tp->tg3_flags & TG3_FLAG_INIT_COMPLETE))
+			bmsr = 0;
+
+		if (!(bmsr & BMSR_LSTATUS)) {
+			err = tg3_init_5401phy_dsp(tp);
+			if (err)
+				return err;
+
+			tg3_readphy(tp, MII_BMSR, &bmsr);
+			for (i = 0; i < 1000; i++) {
+				udelay(10);
+				tg3_readphy(tp, MII_BMSR, &bmsr);
+				if (bmsr & BMSR_LSTATUS) {
+					udelay(40);
+					break;
+				}
+			}
+
+			if ((tp->phy_id & PHY_ID_REV_MASK) == PHY_REV_BCM5401_B0 &&
+			    !(bmsr & BMSR_LSTATUS) &&
+			    tp->link_config.active_speed == SPEED_1000) {
+				err = tg3_phy_reset(tp);
+				if (!err)
+					err = tg3_init_5401phy_dsp(tp);
+				if (err)
+					return err;
+			}
+		}
+	} else if (tp->pci_chip_rev_id == CHIPREV_ID_5701_A0 ||
+		   tp->pci_chip_rev_id == CHIPREV_ID_5701_B0) {
+		/* 5701 {A0,B0} CRC bug workaround */
+		tg3_writephy(tp, 0x15, 0x0a75);
+		tg3_writephy(tp, 0x1c, 0x8c68);
+		tg3_writephy(tp, 0x1c, 0x8d68);
+		tg3_writephy(tp, 0x1c, 0x8c68);
+	}
+
+	/* Clear pending interrupts... */
+	tg3_readphy(tp, MII_TG3_ISTAT, &dummy);
+	tg3_readphy(tp, MII_TG3_ISTAT, &dummy);
+
+	tg3_writephy(tp, MII_TG3_IMASK, ~0);
+
+	if (tp->led_mode == led_mode_three_link)
+		tg3_writephy(tp, MII_TG3_EXT_CTRL,
+			     MII_TG3_EXT_CTRL_LNK3_LED_MODE);
+	else
+		tg3_writephy(tp, MII_TG3_EXT_CTRL, 0);
+
+	current_link_up = 0;
+
+	tg3_readphy(tp, MII_BMSR, &bmsr);
+	tg3_readphy(tp, MII_BMSR, &bmsr);
+
+	if (bmsr & BMSR_LSTATUS) {
+		uint32_t aux_stat, bmcr;
+
+		tg3_readphy(tp, MII_TG3_AUX_STAT, &aux_stat);
+		for (i = 0; i < 2000; i++) {
+			udelay(10);
+			tg3_readphy(tp, MII_TG3_AUX_STAT, &aux_stat);
+			if (aux_stat)
+				break;
+		}
+
+		tg3_aux_stat_to_speed_duplex(tp, aux_stat,
+			&tp->link_config.active_speed,
+			&tp->link_config.active_duplex);
+		tg3_readphy(tp, MII_BMCR, &bmcr);
+		tg3_readphy(tp, MII_BMCR, &bmcr);
+		if (bmcr & BMCR_ANENABLE) {
+			uint32_t gig_ctrl;
+			
+			current_link_up = 1;
+			
+			/* Force autoneg restart if we are exiting
+			 * low power mode.
+			 */
+			tg3_readphy(tp, MII_TG3_CTRL, &gig_ctrl);
+			if (!(gig_ctrl & (MII_TG3_CTRL_ADV_1000_HALF |
+				      MII_TG3_CTRL_ADV_1000_FULL))) {
+				current_link_up = 0;
+			}
+		} else {
+			current_link_up = 0;
+		}
+	}
+
+	if (current_link_up == 1 &&
+		(tp->link_config.active_duplex == DUPLEX_FULL)) {
+		uint32_t local_adv, remote_adv;
+
+		tg3_readphy(tp, MII_ADVERTISE, &local_adv);
+		local_adv &= (ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM);
+
+		tg3_readphy(tp, MII_LPA, &remote_adv);
+		remote_adv &= (LPA_PAUSE_CAP | LPA_PAUSE_ASYM);
+
+		/* If we are not advertising full pause capability,
+		 * something is wrong.  Bring the link down and reconfigure.
+		 */
+		if (local_adv != ADVERTISE_PAUSE_CAP) {
+			current_link_up = 0;
+		} else {
+			tg3_setup_flow_control(tp, local_adv, remote_adv);
+		}
+	}
+
+	if (current_link_up == 0) {
+		uint32_t tmp;
+
+		tg3_phy_copper_begin(tp);
+
+		tg3_readphy(tp, MII_BMSR, &tmp);
+		tg3_readphy(tp, MII_BMSR, &tmp);
+		if (tmp & BMSR_LSTATUS)
+			current_link_up = 1;
+	}
+
+	tp->mac_mode &= ~MAC_MODE_PORT_MODE_MASK;
+	if (current_link_up == 1) {
+		if (tp->link_config.active_speed == SPEED_100 ||
+		    tp->link_config.active_speed == SPEED_10)
+			tp->mac_mode |= MAC_MODE_PORT_MODE_MII;
+		else
+			tp->mac_mode |= MAC_MODE_PORT_MODE_GMII;
+	} else
+		tp->mac_mode |= MAC_MODE_PORT_MODE_GMII;
+
+	tp->mac_mode &= ~MAC_MODE_HALF_DUPLEX;
+	if (tp->link_config.active_duplex == DUPLEX_HALF)
+		tp->mac_mode |= MAC_MODE_HALF_DUPLEX;
+
+	tp->mac_mode &= ~MAC_MODE_LINK_POLARITY;
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5700) {
+		if ((tp->led_mode == led_mode_link10) ||
+		    (current_link_up == 1 &&
+		     tp->link_config.active_speed == SPEED_10))
+			tp->mac_mode |= MAC_MODE_LINK_POLARITY;
+	} else {
+		if (current_link_up == 1)
+			tp->mac_mode |= MAC_MODE_LINK_POLARITY;
+		tw32(MAC_LED_CTRL, LED_CTRL_PHY_MODE_1);
+	}
+
+	/* ??? Without this setting Netgear GA302T PHY does not
+	 * ??? send/receive packets...
+	 * With this other PHYs cannot bring up the link
+	 */
+	if ((tp->phy_id & PHY_ID_MASK) == PHY_ID_BCM5411 &&
+		tp->pci_chip_rev_id == CHIPREV_ID_5700_ALTIMA) {
+		tp->mi_mode |= MAC_MI_MODE_AUTO_POLL;
+		tw32_carefully(MAC_MI_MODE, tp->mi_mode);
+	}
+
+	tw32_carefully(MAC_MODE, tp->mac_mode);
+
+	/* Link change polled. */
+	tw32_carefully(MAC_EVENT, 0);
+
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5700 &&
+	    current_link_up == 1 &&
+	    tp->link_config.active_speed == SPEED_1000 &&
+	    ((tp->tg3_flags & TG3_FLAG_PCIX_MODE) ||
+	     (tp->tg3_flags & TG3_FLAG_PCI_HIGH_SPEED))) {
+		udelay(120);
+		tw32_carefully(MAC_STATUS,
+			(MAC_STATUS_SYNC_CHANGED | MAC_STATUS_CFG_CHANGED));
+		tg3_write_mem(
+			      NIC_SRAM_FIRMWARE_MBOX,
+			      NIC_SRAM_FIRMWARE_MBOX_MAGIC2);
+	}
+
+	if (current_link_up != tp->carrier_ok) {
+		tp->carrier_ok = current_link_up;
+		tg3_link_report(tp);
+	}
+
+	return 0;
+}
+#else
+#define tg3_setup_copper_phy(TP) (-EINVAL)
+#endif /* SUPPORT_COPPER_PHY */
+
+#if SUPPORT_FIBER_PHY
+struct tg3_fiber_aneginfo {
+	int state;
+#define ANEG_STATE_UNKNOWN		0
+#define ANEG_STATE_AN_ENABLE		1
+#define ANEG_STATE_RESTART_INIT		2
+#define ANEG_STATE_RESTART		3
+#define ANEG_STATE_DISABLE_LINK_OK	4
+#define ANEG_STATE_ABILITY_DETECT_INIT	5
+#define ANEG_STATE_ABILITY_DETECT	6
+#define ANEG_STATE_ACK_DETECT_INIT	7
+#define ANEG_STATE_ACK_DETECT		8
+#define ANEG_STATE_COMPLETE_ACK_INIT	9
+#define ANEG_STATE_COMPLETE_ACK		10
+#define ANEG_STATE_IDLE_DETECT_INIT	11
+#define ANEG_STATE_IDLE_DETECT		12
+#define ANEG_STATE_LINK_OK		13
+#define ANEG_STATE_NEXT_PAGE_WAIT_INIT	14
+#define ANEG_STATE_NEXT_PAGE_WAIT	15
+
+	uint32_t flags;
+#define MR_AN_ENABLE		0x00000001
+#define MR_RESTART_AN		0x00000002
+#define MR_AN_COMPLETE		0x00000004
+#define MR_PAGE_RX		0x00000008
+#define MR_NP_LOADED		0x00000010
+#define MR_TOGGLE_TX		0x00000020
+#define MR_LP_ADV_FULL_DUPLEX	0x00000040
+#define MR_LP_ADV_HALF_DUPLEX	0x00000080
+#define MR_LP_ADV_SYM_PAUSE	0x00000100
+#define MR_LP_ADV_ASYM_PAUSE	0x00000200
+#define MR_LP_ADV_REMOTE_FAULT1	0x00000400
+#define MR_LP_ADV_REMOTE_FAULT2	0x00000800
+#define MR_LP_ADV_NEXT_PAGE	0x00001000
+#define MR_TOGGLE_RX		0x00002000
+#define MR_NP_RX		0x00004000
+
+#define MR_LINK_OK		0x80000000
+
+	unsigned long link_time, cur_time;
+
+	uint32_t ability_match_cfg;
+	int ability_match_count;
+
+	char ability_match, idle_match, ack_match;
+
+	uint32_t txconfig, rxconfig;
+#define ANEG_CFG_NP		0x00000080
+#define ANEG_CFG_ACK		0x00000040
+#define ANEG_CFG_RF2		0x00000020
+#define ANEG_CFG_RF1		0x00000010
+#define ANEG_CFG_PS2		0x00000001
+#define ANEG_CFG_PS1		0x00008000
+#define ANEG_CFG_HD		0x00004000
+#define ANEG_CFG_FD		0x00002000
+#define ANEG_CFG_INVAL		0x00001f06
+
+};
+#define ANEG_OK		0
+#define ANEG_DONE	1
+#define ANEG_TIMER_ENAB	2
+#define ANEG_FAILED	-1
+
+#define ANEG_STATE_SETTLE_TIME	10000
+
+static int tg3_fiber_aneg_smachine(struct tg3 *tp,
+				   struct tg3_fiber_aneginfo *ap)
+{
+	unsigned long delta;
+	uint32_t rx_cfg_reg;
+	int ret;
+
+	if (ap->state == ANEG_STATE_UNKNOWN) {
+		ap->rxconfig = 0;
+		ap->link_time = 0;
+		ap->cur_time = 0;
+		ap->ability_match_cfg = 0;
+		ap->ability_match_count = 0;
+		ap->ability_match = 0;
+		ap->idle_match = 0;
+		ap->ack_match = 0;
+	}
+	ap->cur_time++;
+
+	if (tr32(MAC_STATUS) & MAC_STATUS_RCVD_CFG) {
+		rx_cfg_reg = tr32(MAC_RX_AUTO_NEG);
+
+		if (rx_cfg_reg != ap->ability_match_cfg) {
+			ap->ability_match_cfg = rx_cfg_reg;
+			ap->ability_match = 0;
+			ap->ability_match_count = 0;
+		} else {
+			if (++ap->ability_match_count > 1) {
+				ap->ability_match = 1;
+				ap->ability_match_cfg = rx_cfg_reg;
+			}
+		}
+		if (rx_cfg_reg & ANEG_CFG_ACK)
+			ap->ack_match = 1;
+		else
+			ap->ack_match = 0;
+
+		ap->idle_match = 0;
+	} else {
+		ap->idle_match = 1;
+		ap->ability_match_cfg = 0;
+		ap->ability_match_count = 0;
+		ap->ability_match = 0;
+		ap->ack_match = 0;
+
+		rx_cfg_reg = 0;
+	}
+
+	ap->rxconfig = rx_cfg_reg;
+	ret = ANEG_OK;
+
+	switch(ap->state) {
+	case ANEG_STATE_UNKNOWN:
+		if (ap->flags & (MR_AN_ENABLE | MR_RESTART_AN))
+			ap->state = ANEG_STATE_AN_ENABLE;
+
+		/* fallthru */
+	case ANEG_STATE_AN_ENABLE:
+		ap->flags &= ~(MR_AN_COMPLETE | MR_PAGE_RX);
+		if (ap->flags & MR_AN_ENABLE) {
+			ap->link_time = 0;
+			ap->cur_time = 0;
+			ap->ability_match_cfg = 0;
+			ap->ability_match_count = 0;
+			ap->ability_match = 0;
+			ap->idle_match = 0;
+			ap->ack_match = 0;
+
+			ap->state = ANEG_STATE_RESTART_INIT;
+		} else {
+			ap->state = ANEG_STATE_DISABLE_LINK_OK;
+		}
+		break;
+
+	case ANEG_STATE_RESTART_INIT:
+		ap->link_time = ap->cur_time;
+		ap->flags &= ~(MR_NP_LOADED);
+		ap->txconfig = 0;
+		tw32(MAC_TX_AUTO_NEG, 0);
+		tp->mac_mode |= MAC_MODE_SEND_CONFIGS;
+		tw32_carefully(MAC_MODE, tp->mac_mode);
+
+		ret = ANEG_TIMER_ENAB;
+		ap->state = ANEG_STATE_RESTART;
+
+		/* fallthru */
+	case ANEG_STATE_RESTART:
+		delta = ap->cur_time - ap->link_time;
+		if (delta > ANEG_STATE_SETTLE_TIME) {
+			ap->state = ANEG_STATE_ABILITY_DETECT_INIT;
+		} else {
+			ret = ANEG_TIMER_ENAB;
+		}
+		break;
+
+	case ANEG_STATE_DISABLE_LINK_OK:
+		ret = ANEG_DONE;
+		break;
+
+	case ANEG_STATE_ABILITY_DETECT_INIT:
+		ap->flags &= ~(MR_TOGGLE_TX);
+		ap->txconfig = (ANEG_CFG_FD | ANEG_CFG_PS1);
+		tw32(MAC_TX_AUTO_NEG, ap->txconfig);
+		tp->mac_mode |= MAC_MODE_SEND_CONFIGS;
+		tw32_carefully(MAC_MODE, tp->mac_mode);
+
+		ap->state = ANEG_STATE_ABILITY_DETECT;
+		break;
+
+	case ANEG_STATE_ABILITY_DETECT:
+		if (ap->ability_match != 0 && ap->rxconfig != 0) {
+			ap->state = ANEG_STATE_ACK_DETECT_INIT;
+		}
+		break;
+
+	case ANEG_STATE_ACK_DETECT_INIT:
+		ap->txconfig |= ANEG_CFG_ACK;
+		tw32(MAC_TX_AUTO_NEG, ap->txconfig);
+		tp->mac_mode |= MAC_MODE_SEND_CONFIGS;
+		tw32_carefully(MAC_MODE, tp->mac_mode);
+
+		ap->state = ANEG_STATE_ACK_DETECT;
+
+		/* fallthru */
+	case ANEG_STATE_ACK_DETECT:
+		if (ap->ack_match != 0) {
+			if ((ap->rxconfig & ~ANEG_CFG_ACK) ==
+			    (ap->ability_match_cfg & ~ANEG_CFG_ACK)) {
+				ap->state = ANEG_STATE_COMPLETE_ACK_INIT;
+			} else {
+				ap->state = ANEG_STATE_AN_ENABLE;
+			}
+		} else if (ap->ability_match != 0 &&
+			   ap->rxconfig == 0) {
+			ap->state = ANEG_STATE_AN_ENABLE;
+		}
+		break;
+
+	case ANEG_STATE_COMPLETE_ACK_INIT:
+		if (ap->rxconfig & ANEG_CFG_INVAL) {
+			ret = ANEG_FAILED;
+			break;
+		}
+		ap->flags &= ~(MR_LP_ADV_FULL_DUPLEX |
+			       MR_LP_ADV_HALF_DUPLEX |
+			       MR_LP_ADV_SYM_PAUSE |
+			       MR_LP_ADV_ASYM_PAUSE |
+			       MR_LP_ADV_REMOTE_FAULT1 |
+			       MR_LP_ADV_REMOTE_FAULT2 |
+			       MR_LP_ADV_NEXT_PAGE |
+			       MR_TOGGLE_RX |
+			       MR_NP_RX);
+		if (ap->rxconfig & ANEG_CFG_FD)
+			ap->flags |= MR_LP_ADV_FULL_DUPLEX;
+		if (ap->rxconfig & ANEG_CFG_HD)
+			ap->flags |= MR_LP_ADV_HALF_DUPLEX;
+		if (ap->rxconfig & ANEG_CFG_PS1)
+			ap->flags |= MR_LP_ADV_SYM_PAUSE;
+		if (ap->rxconfig & ANEG_CFG_PS2)
+			ap->flags |= MR_LP_ADV_ASYM_PAUSE;
+		if (ap->rxconfig & ANEG_CFG_RF1)
+			ap->flags |= MR_LP_ADV_REMOTE_FAULT1;
+		if (ap->rxconfig & ANEG_CFG_RF2)
+			ap->flags |= MR_LP_ADV_REMOTE_FAULT2;
+		if (ap->rxconfig & ANEG_CFG_NP)
+			ap->flags |= MR_LP_ADV_NEXT_PAGE;
+
+		ap->link_time = ap->cur_time;
+
+		ap->flags ^= (MR_TOGGLE_TX);
+		if (ap->rxconfig & 0x0008)
+			ap->flags |= MR_TOGGLE_RX;
+		if (ap->rxconfig & ANEG_CFG_NP)
+			ap->flags |= MR_NP_RX;
+		ap->flags |= MR_PAGE_RX;
+
+		ap->state = ANEG_STATE_COMPLETE_ACK;
+		ret = ANEG_TIMER_ENAB;
+		break;
+
+	case ANEG_STATE_COMPLETE_ACK:
+		if (ap->ability_match != 0 &&
+		    ap->rxconfig == 0) {
+			ap->state = ANEG_STATE_AN_ENABLE;
+			break;
+		}
+		delta = ap->cur_time - ap->link_time;
+		if (delta > ANEG_STATE_SETTLE_TIME) {
+			if (!(ap->flags & (MR_LP_ADV_NEXT_PAGE))) {
+				ap->state = ANEG_STATE_IDLE_DETECT_INIT;
+			} else {
+				if ((ap->txconfig & ANEG_CFG_NP) == 0 &&
+				    !(ap->flags & MR_NP_RX)) {
+					ap->state = ANEG_STATE_IDLE_DETECT_INIT;
+				} else {
+					ret = ANEG_FAILED;
+				}
+			}
+		}
+		break;
+
+	case ANEG_STATE_IDLE_DETECT_INIT:
+		ap->link_time = ap->cur_time;
+		tp->mac_mode &= ~MAC_MODE_SEND_CONFIGS;
+		tw32_carefully(MAC_MODE, tp->mac_mode);
+
+		ap->state = ANEG_STATE_IDLE_DETECT;
+		ret = ANEG_TIMER_ENAB;
+		break;
+
+	case ANEG_STATE_IDLE_DETECT:
+		if (ap->ability_match != 0 &&
+		    ap->rxconfig == 0) {
+			ap->state = ANEG_STATE_AN_ENABLE;
+			break;
+		}
+		delta = ap->cur_time - ap->link_time;
+		if (delta > ANEG_STATE_SETTLE_TIME) {
+			/* XXX another gem from the Broadcom driver :( */
+			ap->state = ANEG_STATE_LINK_OK;
+		}
+		break;
+
+	case ANEG_STATE_LINK_OK:
+		ap->flags |= (MR_AN_COMPLETE | MR_LINK_OK);
+		ret = ANEG_DONE;
+		break;
+
+	case ANEG_STATE_NEXT_PAGE_WAIT_INIT:
+		/* ??? unimplemented */
+		break;
+
+	case ANEG_STATE_NEXT_PAGE_WAIT:
+		/* ??? unimplemented */
+		break;
+
+	default:
+		ret = ANEG_FAILED;
+		break;
+	};
+
+	return ret;
+}
+
+static int tg3_setup_fiber_phy(struct tg3 *tp)
+{
+	uint32_t orig_pause_cfg;
+	uint16_t orig_active_speed;
+	uint8_t orig_active_duplex;
+	int current_link_up;
+	int i;
+
+	orig_pause_cfg =
+		(tp->tg3_flags & (TG3_FLAG_RX_PAUSE |
+				  TG3_FLAG_TX_PAUSE));
+	orig_active_speed = tp->link_config.active_speed;
+	orig_active_duplex = tp->link_config.active_duplex;
+
+	tp->mac_mode &= ~(MAC_MODE_PORT_MODE_MASK | MAC_MODE_HALF_DUPLEX);
+	tp->mac_mode |= MAC_MODE_PORT_MODE_TBI;
+	tw32_carefully(MAC_MODE, tp->mac_mode);
+
+	/* Reset when initting first time or we have a link. */
+	if (!(tp->tg3_flags & TG3_FLAG_INIT_COMPLETE) ||
+	    (tr32(MAC_STATUS) & MAC_STATUS_PCS_SYNCED)) {
+		/* Set PLL lock range. */
+		tg3_writephy(tp, 0x16, 0x8007);
+
+		/* SW reset */
+		tg3_writephy(tp, MII_BMCR, BMCR_RESET);
+
+		/* Wait for reset to complete. */
+		mdelay(5);
+
+		/* Config mode; select PMA/Ch 1 regs. */
+		tg3_writephy(tp, 0x10, 0x8411);
+
+		/* Enable auto-lock and comdet, select txclk for tx. */
+		tg3_writephy(tp, 0x11, 0x0a10);
+
+		tg3_writephy(tp, 0x18, 0x00a0);
+		tg3_writephy(tp, 0x16, 0x41ff);
+
+		/* Assert and deassert POR. */
+		tg3_writephy(tp, 0x13, 0x0400);
+		udelay(40);
+		tg3_writephy(tp, 0x13, 0x0000);
+
+		tg3_writephy(tp, 0x11, 0x0a50);
+		udelay(40);
+		tg3_writephy(tp, 0x11, 0x0a10);
+
+		/* Wait for signal to stabilize */
+		mdelay(150);
+
+		/* Deselect the channel register so we can read the PHYID
+		 * later.
+		 */
+		tg3_writephy(tp, 0x10, 0x8011);
+	}
+
+	/* Disable link change interrupt.  */
+	tw32_carefully(MAC_EVENT, 0);
+
+	current_link_up = 0;
+	if (tr32(MAC_STATUS) & MAC_STATUS_PCS_SYNCED) {
+		if (!(tp->tg3_flags & TG3_FLAG_GOT_SERDES_FLOWCTL)) {
+			struct tg3_fiber_aneginfo aninfo;
+			int status = ANEG_FAILED;
+			unsigned int tick;
+			uint32_t tmp;
+
+			memset(&aninfo, 0, sizeof(aninfo));
+			aninfo.flags |= (MR_AN_ENABLE);
+
+			tw32(MAC_TX_AUTO_NEG, 0);
+
+			tmp = tp->mac_mode & ~MAC_MODE_PORT_MODE_MASK;
+			tw32_carefully(MAC_MODE, tmp | MAC_MODE_PORT_MODE_GMII);
+
+			tw32_carefully(MAC_MODE, tp->mac_mode | MAC_MODE_SEND_CONFIGS);
+
+			aninfo.state = ANEG_STATE_UNKNOWN;
+			aninfo.cur_time = 0;
+			tick = 0;
+			while (++tick < 195000) {
+				status = tg3_fiber_aneg_smachine(tp, &aninfo);
+				if (status == ANEG_DONE ||
+				    status == ANEG_FAILED)
+					break;
+
+				udelay(1);
+			}
+
+			tp->mac_mode &= ~MAC_MODE_SEND_CONFIGS;
+			tw32_carefully(MAC_MODE, tp->mac_mode);
+
+			if (status == ANEG_DONE &&
+			    (aninfo.flags &
+			     (MR_AN_COMPLETE | MR_LINK_OK |
+			      MR_LP_ADV_FULL_DUPLEX))) {
+				uint32_t local_adv, remote_adv;
+
+				local_adv = ADVERTISE_PAUSE_CAP;
+				remote_adv = 0;
+				if (aninfo.flags & MR_LP_ADV_SYM_PAUSE)
+					remote_adv |= LPA_PAUSE_CAP;
+				if (aninfo.flags & MR_LP_ADV_ASYM_PAUSE)
+					remote_adv |= LPA_PAUSE_ASYM;
+
+				tg3_setup_flow_control(tp, local_adv, remote_adv);
+
+				tp->tg3_flags |=
+					TG3_FLAG_GOT_SERDES_FLOWCTL;
+				current_link_up = 1;
+			}
+			for (i = 0; i < 60; i++) {
+				udelay(20);
+				tw32_carefully(MAC_STATUS,
+					(MAC_STATUS_SYNC_CHANGED | MAC_STATUS_CFG_CHANGED));
+				if ((tr32(MAC_STATUS) &
+				     (MAC_STATUS_SYNC_CHANGED |
+				      MAC_STATUS_CFG_CHANGED)) == 0)
+					break;
+			}
+			if (current_link_up == 0 &&
+			    (tr32(MAC_STATUS) & MAC_STATUS_PCS_SYNCED)) {
+				current_link_up = 1;
+			}
+		} else {
+			/* Forcing 1000FD link up. */
+			current_link_up = 1;
+		}
+	}
+
+	tp->mac_mode &= ~MAC_MODE_LINK_POLARITY;
+	tw32_carefully(MAC_MODE, tp->mac_mode);
+
+	tp->hw_status->status =
+		(SD_STATUS_UPDATED |
+		 (tp->hw_status->status & ~SD_STATUS_LINK_CHG));
+
+	for (i = 0; i < 100; i++) {
+		udelay(20);
+		tw32_carefully(MAC_STATUS,
+			(MAC_STATUS_SYNC_CHANGED | MAC_STATUS_CFG_CHANGED));
+		if ((tr32(MAC_STATUS) &
+		     (MAC_STATUS_SYNC_CHANGED |
+		      MAC_STATUS_CFG_CHANGED)) == 0)
+			break;
+	}
+
+	if ((tr32(MAC_STATUS) & MAC_STATUS_PCS_SYNCED) == 0)
+		current_link_up = 0;
+
+	if (current_link_up == 1) {
+		tp->link_config.active_speed = SPEED_1000;
+		tp->link_config.active_duplex = DUPLEX_FULL;
+	} else {
+		tp->link_config.active_speed = SPEED_INVALID;
+		tp->link_config.active_duplex = DUPLEX_INVALID;
+	}
+
+	if (current_link_up != tp->carrier_ok) {
+		tp->carrier_ok = current_link_up;
+		tg3_link_report(tp);
+	} else {
+		uint32_t now_pause_cfg =
+			tp->tg3_flags & (TG3_FLAG_RX_PAUSE |
+					 TG3_FLAG_TX_PAUSE);
+		if (orig_pause_cfg != now_pause_cfg ||
+		    orig_active_speed != tp->link_config.active_speed ||
+		    orig_active_duplex != tp->link_config.active_duplex)
+			tg3_link_report(tp);
+	}
+
+	if ((tr32(MAC_STATUS) & MAC_STATUS_PCS_SYNCED) == 0) {
+		tw32_carefully(MAC_MODE, tp->mac_mode | MAC_MODE_LINK_POLARITY);
+		if (tp->tg3_flags & TG3_FLAG_INIT_COMPLETE) {
+			tw32_carefully(MAC_MODE, tp->mac_mode);
+		}
+	}
+
+	return 0;
+}
+#else
+#define tg3_setup_fiber_phy(TP) (-EINVAL)
+#endif /* SUPPORT_FIBER_PHY */
+
+static int tg3_setup_phy(struct tg3 *tp)
+{
+	int err;
+
+	if (tp->phy_id == PHY_ID_SERDES) {
+		err = tg3_setup_fiber_phy(tp);
+	} else {
+		err = tg3_setup_copper_phy(tp);
+	}
+
+	if (tp->link_config.active_speed == SPEED_1000 &&
+	    tp->link_config.active_duplex == DUPLEX_HALF)
+		tw32(MAC_TX_LENGTHS,
+		     ((2 << TX_LENGTHS_IPG_CRS_SHIFT) |
+		      (6 << TX_LENGTHS_IPG_SHIFT) |
+		      (0xff << TX_LENGTHS_SLOT_TIME_SHIFT)));
+	else
+		tw32(MAC_TX_LENGTHS,
+		     ((2 << TX_LENGTHS_IPG_CRS_SHIFT) |
+		      (6 << TX_LENGTHS_IPG_SHIFT) |
+		      (32 << TX_LENGTHS_SLOT_TIME_SHIFT)));
+
+	return err;
+}
+
+
+#define MAX_WAIT_CNT 1000
+
+/* To stop a block, clear the enable bit and poll till it
+ * clears.  
+ */
+static int tg3_stop_block(struct tg3 *tp, unsigned long ofs, uint32_t enable_bit)
+{
+	unsigned int i;
+	uint32_t val;
+
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705) {
+		switch(ofs) {
+		case RCVLSC_MODE:
+		case DMAC_MODE:
+		case MBFREE_MODE:
+		case BUFMGR_MODE:
+		case MEMARB_MODE:
+			/* We can't enable/disable these bits of the
+			 * 5705, just say success.
+			 */
+			return 0;
+		default:
+			break;
+		}
+	}
+	val = tr32(ofs);
+	val &= ~enable_bit;
+	tw32(ofs, val);
+	tr32(ofs);
+
+	for (i = 0; i < MAX_WAIT_CNT; i++) {
+		udelay(100);
+		val = tr32(ofs);
+		if ((val & enable_bit) == 0)
+			break;
+	}
+
+	if (i == MAX_WAIT_CNT) {
+		printf("tg3_stop_block timed out, ofs=%lx enable_bit=%x\n",
+		       ofs, enable_bit);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int tg3_abort_hw(struct tg3 *tp)
+{
+	int i, err;
+
+	tg3_disable_ints(tp);
+
+	tp->rx_mode &= ~RX_MODE_ENABLE;
+	tw32_carefully(MAC_RX_MODE, tp->rx_mode);
+
+	err  = tg3_stop_block(tp, RCVBDI_MODE,   RCVBDI_MODE_ENABLE);
+	err |= tg3_stop_block(tp, RCVLPC_MODE,   RCVLPC_MODE_ENABLE);
+	err |= tg3_stop_block(tp, RCVLSC_MODE,   RCVLSC_MODE_ENABLE);
+	err |= tg3_stop_block(tp, RCVDBDI_MODE,  RCVDBDI_MODE_ENABLE);
+	err |= tg3_stop_block(tp, RCVDCC_MODE,   RCVDCC_MODE_ENABLE);
+	err |= tg3_stop_block(tp, RCVCC_MODE,    RCVCC_MODE_ENABLE);
+
+	err |= tg3_stop_block(tp, SNDBDS_MODE,   SNDBDS_MODE_ENABLE);
+	err |= tg3_stop_block(tp, SNDBDI_MODE,   SNDBDI_MODE_ENABLE);
+	err |= tg3_stop_block(tp, SNDDATAI_MODE, SNDDATAI_MODE_ENABLE);
+	err |= tg3_stop_block(tp, RDMAC_MODE,    RDMAC_MODE_ENABLE);
+	err |= tg3_stop_block(tp, SNDDATAC_MODE, SNDDATAC_MODE_ENABLE);
+	err |= tg3_stop_block(tp, SNDBDC_MODE,   SNDBDC_MODE_ENABLE);
+	if (err)
+		goto out;
+
+	tp->mac_mode &= ~MAC_MODE_TDE_ENABLE;
+	tw32_carefully(MAC_MODE, tp->mac_mode);
+
+	tp->tx_mode &= ~TX_MODE_ENABLE;
+	tw32_carefully(MAC_TX_MODE, tp->tx_mode);
+
+	for (i = 0; i < MAX_WAIT_CNT; i++) {
+		udelay(100);
+		if (!(tr32(MAC_TX_MODE) & TX_MODE_ENABLE))
+			break;
+	}
+	if (i >= MAX_WAIT_CNT) {
+		printf("tg3_abort_hw timed out TX_MODE_ENABLE will not clear MAC_TX_MODE=%x\n",
+			tr32(MAC_TX_MODE));
+		return -ENODEV;
+	}
+
+	err  = tg3_stop_block(tp, HOSTCC_MODE, HOSTCC_MODE_ENABLE);
+	err |= tg3_stop_block(tp, WDMAC_MODE,  WDMAC_MODE_ENABLE);
+	err |= tg3_stop_block(tp, MBFREE_MODE, MBFREE_MODE_ENABLE);
+
+	tw32(FTQ_RESET, 0xffffffff);
+	tw32(FTQ_RESET, 0x00000000);
+
+	err |= tg3_stop_block(tp, BUFMGR_MODE, BUFMGR_MODE_ENABLE);
+	err |= tg3_stop_block(tp, MEMARB_MODE, MEMARB_MODE_ENABLE);
+	if (err)
+		goto out;
+
+	memset(tp->hw_status, 0, TG3_HW_STATUS_SIZE);
+
+out:
+	return err;
+}
+
+static void tg3_chip_reset(struct tg3 *tp)
+{
+	uint32_t val;
+
+	if (!(tp->tg3_flags2 & TG3_FLG2_SUN_5704)) {
+		/* Force NVRAM to settle.
+		 * This deals with a chip bug which can result in EEPROM
+		 * corruption.
+		 */
+		if (tp->tg3_flags & TG3_FLAG_NVRAM) {
+			int i;
+	
+			tw32(NVRAM_SWARB, SWARB_REQ_SET1);
+			for (i = 0; i < 100000; i++) {
+				if (tr32(NVRAM_SWARB) & SWARB_GNT1)
+					break;
+				udelay(10);
+			}
+		}
+	}
+	/* In Etherboot we don't need to worry about the 5701
+	 * REG_WRITE_BUG because we do all register writes indirectly.
+	 */
+
+	/* do the reset */
+	val = GRC_MISC_CFG_CORECLK_RESET;
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705)
+		val |= GRC_MISC_CFG_KEEP_GPHY_POWER;
+	tw32(GRC_MISC_CFG, val);
+
+	/* Flush PCI posted writes.  The normal MMIO registers
+	 * are inaccessible at this time so this is the only
+	 * way to make this reliably.  I tried to use indirect
+	 * register read/write but this upset some 5701 variants.
+	 */
+	pci_read_config_dword(tp->pdev, PCI_COMMAND, &val);
+
+	udelay(120);
+
+	/* Re-enable indirect register accesses. */
+	pci_write_config_dword(tp->pdev, TG3PCI_MISC_HOST_CTRL,
+			       tp->misc_host_ctrl);
+
+	/* Set MAX PCI retry to zero. */
+	val = (PCISTATE_ROM_ENABLE | PCISTATE_ROM_RETRY_ENABLE);
+	if (tp->pci_chip_rev_id == CHIPREV_ID_5704_A0 &&
+	    (tp->tg3_flags & TG3_FLAG_PCIX_MODE))
+		val |= PCISTATE_RETRY_SAME_DMA;
+	pci_write_config_dword(tp->pdev, TG3PCI_PCISTATE, val);
+
+	pci_restore_state(tp->pdev, tp->pci_cfg_state);
+
+	/* Make sure PCI-X relaxed ordering bit is clear. */
+	pci_read_config_dword(tp->pdev, TG3PCI_X_CAPS, &val);
+	val &= ~PCIX_CAPS_RELAXED_ORDERING;
+	pci_write_config_dword(tp->pdev, TG3PCI_X_CAPS, val);
+
+	tw32(MEMARB_MODE, MEMARB_MODE_ENABLE);
+
+	if (((tp->nic_sram_data_cfg & NIC_SRAM_DATA_CFG_MINI_PCI) != 0) &&
+		(GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705)) {
+		tp->pci_clock_ctrl |=
+			(CLOCK_CTRL_FORCE_CLKRUN | CLOCK_CTRL_CLKRUN_OENABLE);
+		tw32(TG3PCI_CLOCK_CTRL, tp->pci_clock_ctrl);
+	}
+
+	tw32(TG3PCI_MISC_HOST_CTRL, tp->misc_host_ctrl);
+}
+
+static void tg3_stop_fw(struct tg3 *tp)
+{
+	if (tp->tg3_flags & TG3_FLAG_ENABLE_ASF) {
+		uint32_t val;
+		int i;
+
+		tg3_write_mem(NIC_SRAM_FW_CMD_MBOX, FWCMD_NICDRV_PAUSE_FW);
+		val = tr32(GRC_RX_CPU_EVENT);
+		val |= (1 << 14);
+		tw32(GRC_RX_CPU_EVENT, val);
+
+		/* Wait for RX cpu to ACK the event.  */
+		for (i = 0; i < 100; i++) {
+			if (!(tr32(GRC_RX_CPU_EVENT) & (1 << 14)))
+				break;
+			udelay(1);
+		}
+	}
+}
+
+static int tg3_restart_fw(struct tg3 *tp, uint32_t state)
+{
+	uint32_t val;
+	int i;
+	
+	tg3_write_mem(NIC_SRAM_FIRMWARE_MBOX, 
+		NIC_SRAM_FIRMWARE_MBOX_MAGIC1);
+	/* Wait for firmware initialization to complete. */
+	for (i = 0; i < 100000; i++) {
+		tg3_read_mem(NIC_SRAM_FIRMWARE_MBOX, &val);
+		if (val == (uint32_t) ~NIC_SRAM_FIRMWARE_MBOX_MAGIC1)
+			break;
+		udelay(10);
+	}
+	if (i >= 100000 &&
+		    !(tp->tg3_flags2 & TG3_FLG2_SUN_5704)) {
+		printf("Firmware will not restart magic=%x\n",
+			val);
+		return -ENODEV;
+	}
+	if (!(tp->tg3_flags & TG3_FLAG_ENABLE_ASF)) {
+		state = DRV_STATE_SUSPEND;
+	}
+	tg3_write_mem(NIC_SRAM_FW_DRV_STATE_MBOX, state);
+	return 0;
+}
+
+static int tg3_halt(struct tg3 *tp)
+{
+	tg3_stop_fw(tp);
+	tg3_abort_hw(tp);
+	tg3_chip_reset(tp);
+	return tg3_restart_fw(tp, DRV_STATE_UNLOAD);
+}
+
+static void __tg3_set_mac_addr(struct tg3 *tp)
+{
+	uint32_t addr_high, addr_low;
+	int i;
+
+	addr_high = ((tp->nic->node_addr[0] << 8) |
+		     tp->nic->node_addr[1]);
+	addr_low = ((tp->nic->node_addr[2] << 24) |
+		    (tp->nic->node_addr[3] << 16) |
+		    (tp->nic->node_addr[4] <<  8) |
+		    (tp->nic->node_addr[5] <<  0));
+	for (i = 0; i < 4; i++) {
+		tw32(MAC_ADDR_0_HIGH + (i * 8), addr_high);
+		tw32(MAC_ADDR_0_LOW + (i * 8), addr_low);
+	}
+
+	if ((GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5700) &&
+		(GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5701) &&
+		(GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5705)) {
+		for(i = 0; i < 12; i++) {
+			tw32(MAC_EXTADDR_0_HIGH + (i * 8), addr_high);
+			tw32(MAC_EXTADDR_0_LOW + (i * 8), addr_low);
+		}
+	}
+	addr_high = (tp->nic->node_addr[0] +
+		     tp->nic->node_addr[1] +
+		     tp->nic->node_addr[2] +
+		     tp->nic->node_addr[3] +
+		     tp->nic->node_addr[4] +
+		     tp->nic->node_addr[5]) &
+		TX_BACKOFF_SEED_MASK;
+	tw32(MAC_TX_BACKOFF_SEED, addr_high);
+}
+
+static void tg3_set_bdinfo(struct tg3 *tp, uint32_t bdinfo_addr,
+			   dma_addr_t mapping, uint32_t maxlen_flags,
+			   uint32_t nic_addr)
+{
+	tg3_write_mem((bdinfo_addr +
+		       TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_HIGH),
+		      ((uint64_t) mapping >> 32));
+	tg3_write_mem((bdinfo_addr +
+		       TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_LOW),
+		      ((uint64_t) mapping & 0xffffffff));
+	tg3_write_mem((bdinfo_addr +
+		       TG3_BDINFO_MAXLEN_FLAGS),
+		       maxlen_flags);
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5705) {
+		tg3_write_mem((bdinfo_addr + TG3_BDINFO_NIC_ADDR), nic_addr);
+	}
+}
+
+
+static void tg3_init_rings(struct tg3 *tp)
+{
+	unsigned i;
+
+	/* Zero out the tg3 variables */
+	memset(&tg3_bss, 0, sizeof(tg3_bss));
+	tp->rx_std    = &tg3_bss.rx_std[0];
+	tp->rx_rcb    = &tg3_bss.rx_rcb[0];
+	tp->tx_ring   = &tg3_bss.tx_ring[0];
+	tp->hw_status = &tg3_bss.hw_status;
+	tp->hw_stats  = &tg3_bss.hw_stats;
+	tp->mac_mode  = 0;
+
+
+	/* Initialize tx/rx rings for packet processing.
+	 *
+	 * The chip has been shut down and the driver detached from
+	 * the networking, so no interrupts or new tx packets will
+	 * end up in the driver.
+	 */
+
+	/* Initialize invariants of the rings, we only set this
+	 * stuff once.  This works because the card does not
+	 * write into the rx buffer posting rings.
+	 */
+	for (i = 0; i < TG3_RX_RING_SIZE; i++) {
+		struct tg3_rx_buffer_desc *rxd;
+
+		rxd = &tp->rx_std[i];
+		rxd->idx_len = (RX_PKT_BUF_SZ - 2 - 64)	<< RXD_LEN_SHIFT;
+		rxd->type_flags = (RXD_FLAG_END << RXD_FLAGS_SHIFT);
+		rxd->opaque = (RXD_OPAQUE_RING_STD | (i << RXD_OPAQUE_INDEX_SHIFT));
+
+		/* Note where the receive buffer for the ring is placed */
+		rxd->addr_hi = 0;
+		rxd->addr_lo = virt_to_bus(
+			&tg3_bss.rx_bufs[i%TG3_DEF_RX_RING_PENDING][2]);
+	}
+}
+
+#define TG3_WRITE_SETTINGS(TABLE) \
+do { \
+	const uint32_t *_table, *_end; \
+	_table = TABLE; \
+	_end = _table + sizeof(TABLE)/sizeof(TABLE[0]);  \
+	for(; _table < _end; _table += 2) { \
+		tw32(_table[0], _table[1]); \
+	} \
+} while(0)
+
+
+/* initialize/reset the tg3 */
+static int tg3_setup_hw(struct tg3 *tp)
+{
+	uint32_t val, rdmac_mode;
+	int i, err, limit;
+
+	/* Simply don't support setups with extremly buggy firmware in etherboot */
+	if (tp->pci_chip_rev_id == CHIPREV_ID_5701_A0) {
+		printf("Error 5701_A0 firmware bug detected\n");
+		return -EINVAL;
+	}
+
+	tg3_disable_ints(tp);
+
+	/* Originally this was all in tg3_init_hw */
+
+	/* Force the chip into D0. */
+	tg3_set_power_state_0(tp);
+
+	tg3_switch_clocks(tp);
+
+	tw32(TG3PCI_MEM_WIN_BASE_ADDR, 0);
+
+
+	/* Originally this was all in tg3_reset_hw */
+
+	tg3_stop_fw(tp);
+
+	/* No need to call tg3_abort_hw here, it is called before tg3_setup_hw. */
+
+	tg3_chip_reset(tp);
+
+	tw32(GRC_MODE, tp->grc_mode);  /* Redundant? */
+
+	err = tg3_restart_fw(tp, DRV_STATE_START);
+	if (err)
+		return err;
+
+	if (tp->phy_id == PHY_ID_SERDES) {
+		tp->mac_mode = MAC_MODE_PORT_MODE_TBI;
+	}
+	tw32_carefully(MAC_MODE, tp->mac_mode);
+
+
+	/* This works around an issue with Athlon chipsets on
+	 * B3 tigon3 silicon.  This bit has no effect on any
+	 * other revision.
+	 */
+	tp->pci_clock_ctrl |= CLOCK_CTRL_DELAY_PCI_GRANT;
+	tw32_carefully(TG3PCI_CLOCK_CTRL, tp->pci_clock_ctrl);
+
+	if (tp->pci_chip_rev_id == CHIPREV_ID_5704_A0 &&
+	    (tp->tg3_flags & TG3_FLAG_PCIX_MODE)) {
+		val = tr32(TG3PCI_PCISTATE);
+		val |= PCISTATE_RETRY_SAME_DMA;
+		tw32(TG3PCI_PCISTATE, val);
+	}
+
+	/* Descriptor ring init may make accesses to the
+	 * NIC SRAM area to setup the TX descriptors, so we
+	 * can only do this after the hardware has been
+	 * successfully reset.
+	 */
+	tg3_init_rings(tp);
+
+	/* Clear statistics/status block in chip */
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5705) {
+		for (i = NIC_SRAM_STATS_BLK;
+		     i < NIC_SRAM_STATUS_BLK + TG3_HW_STATUS_SIZE;
+		     i += sizeof(uint32_t)) {
+			tg3_write_mem(i, 0);
+			udelay(40);
+		}
+	}
+
+	/* This value is determined during the probe time DMA
+	 * engine test, tg3_setup_dma.
+	 */
+	tw32(TG3PCI_DMA_RW_CTRL, tp->dma_rwctrl);
+
+	tp->grc_mode &= ~(GRC_MODE_HOST_SENDBDS |
+			  GRC_MODE_4X_NIC_SEND_RINGS |
+			  GRC_MODE_NO_TX_PHDR_CSUM |
+			  GRC_MODE_NO_RX_PHDR_CSUM);
+	tp->grc_mode |= GRC_MODE_HOST_SENDBDS;
+	tp->grc_mode |= GRC_MODE_NO_TX_PHDR_CSUM;
+	tp->grc_mode |= GRC_MODE_NO_RX_PHDR_CSUM;
+
+	tw32(GRC_MODE,
+		tp->grc_mode | 
+		(GRC_MODE_IRQ_ON_MAC_ATTN | GRC_MODE_HOST_STACKUP));
+
+	/* Setup the timer prescalar register.  Clock is always 66Mhz. */
+	tw32(GRC_MISC_CFG,
+	     (65 << GRC_MISC_CFG_PRESCALAR_SHIFT));
+
+	/* Initialize MBUF/DESC pool. */
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5705) {
+		tw32(BUFMGR_MB_POOL_ADDR, NIC_SRAM_MBUF_POOL_BASE);
+		if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5704)
+			tw32(BUFMGR_MB_POOL_SIZE, NIC_SRAM_MBUF_POOL_SIZE64);
+		else
+			tw32(BUFMGR_MB_POOL_SIZE, NIC_SRAM_MBUF_POOL_SIZE96);
+		tw32(BUFMGR_DMA_DESC_POOL_ADDR, NIC_SRAM_DMA_DESC_POOL_BASE);
+		tw32(BUFMGR_DMA_DESC_POOL_SIZE, NIC_SRAM_DMA_DESC_POOL_SIZE);
+	}
+	if (!(tp->tg3_flags & TG3_FLAG_JUMBO_ENABLE)) {
+		tw32(BUFMGR_MB_RDMA_LOW_WATER,
+		     tp->bufmgr_config.mbuf_read_dma_low_water);
+		tw32(BUFMGR_MB_MACRX_LOW_WATER,
+		     tp->bufmgr_config.mbuf_mac_rx_low_water);
+		tw32(BUFMGR_MB_HIGH_WATER,
+		     tp->bufmgr_config.mbuf_high_water);
+	} else {
+		tw32(BUFMGR_MB_RDMA_LOW_WATER,
+		     tp->bufmgr_config.mbuf_read_dma_low_water_jumbo);
+		tw32(BUFMGR_MB_MACRX_LOW_WATER,
+		     tp->bufmgr_config.mbuf_mac_rx_low_water_jumbo);
+		tw32(BUFMGR_MB_HIGH_WATER,
+		     tp->bufmgr_config.mbuf_high_water_jumbo);
+	}
+	tw32(BUFMGR_DMA_LOW_WATER,
+	     tp->bufmgr_config.dma_low_water);
+	tw32(BUFMGR_DMA_HIGH_WATER,
+	     tp->bufmgr_config.dma_high_water);
+
+	tw32(BUFMGR_MODE, BUFMGR_MODE_ENABLE | BUFMGR_MODE_ATTN_ENABLE);
+	for (i = 0; i < 2000; i++) {
+		if (tr32(BUFMGR_MODE) & BUFMGR_MODE_ENABLE)
+			break;
+		udelay(10);
+	}
+	if (i >= 2000) {
+		printf("tg3_setup_hw cannot enable BUFMGR\n");
+		return -ENODEV;
+	}
+
+	tw32(FTQ_RESET, 0xffffffff);
+	tw32(FTQ_RESET, 0x00000000);
+	for (i = 0; i < 2000; i++) {
+		if (tr32(FTQ_RESET) == 0x00000000)
+			break;
+		udelay(10);
+	}
+	if (i >= 2000) {
+		printf("tg3_setup_hw cannot reset FTQ\n");
+		return -ENODEV;
+	}
+
+	/* Initialize TG3_BDINFO's at:
+	 *  RCVDBDI_STD_BD:	standard eth size rx ring
+	 *  RCVDBDI_JUMBO_BD:	jumbo frame rx ring
+	 *  RCVDBDI_MINI_BD:	small frame rx ring (??? does not work)
+	 *
+	 * like so:
+	 *  TG3_BDINFO_HOST_ADDR:	high/low parts of DMA address of ring
+	 *  TG3_BDINFO_MAXLEN_FLAGS:	(rx max buffer size << 16) |
+	 *                              ring attribute flags
+	 *  TG3_BDINFO_NIC_ADDR:	location of descriptors in nic SRAM
+	 *
+	 * Standard receive ring @ NIC_SRAM_RX_BUFFER_DESC, 512 entries.
+	 * Jumbo receive ring @ NIC_SRAM_RX_JUMBO_BUFFER_DESC, 256 entries.
+	 *
+	 * ??? No space allocated for mini receive ring? :(
+	 *
+	 * The size of each ring is fixed in the firmware, but the location is
+	 * configurable.
+	 */
+	{
+		static const uint32_t table_all[] = {
+			/* Setup replenish thresholds. */
+			RCVBDI_STD_THRESH, TG3_DEF_RX_RING_PENDING / 8,
+
+			/* Etherboot lives below 4GB */
+			RCVDBDI_STD_BD + TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_HIGH, 0,
+			RCVDBDI_STD_BD + TG3_BDINFO_NIC_ADDR, NIC_SRAM_RX_BUFFER_DESC,
+		};
+		static const uint32_t table_not_5705[] = {
+			/* Buffer maximum length */
+			RCVDBDI_STD_BD + TG3_BDINFO_MAXLEN_FLAGS, RX_STD_MAX_SIZE << BDINFO_FLAGS_MAXLEN_SHIFT,
+			
+			/* Disable the mini frame rx ring */
+			RCVDBDI_MINI_BD + TG3_BDINFO_MAXLEN_FLAGS,	BDINFO_FLAGS_DISABLED,
+			
+			/* Disable the jumbo frame rx ring */
+			RCVBDI_JUMBO_THRESH, 0,
+			RCVDBDI_JUMBO_BD + TG3_BDINFO_MAXLEN_FLAGS, BDINFO_FLAGS_DISABLED,
+			
+			
+		};
+		TG3_WRITE_SETTINGS(table_all);
+		tw32(RCVDBDI_STD_BD + TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_LOW, 
+			virt_to_bus(tp->rx_std));
+		if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705) {
+			tw32(RCVDBDI_STD_BD + TG3_BDINFO_MAXLEN_FLAGS,
+				RX_STD_MAX_SIZE_5705 << BDINFO_FLAGS_MAXLEN_SHIFT);
+		} else {
+			TG3_WRITE_SETTINGS(table_not_5705);
+		}
+	}
+
+	
+	/* There is only one send ring on 5705, no need to explicitly
+	 * disable the others.
+	 */
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5705) {
+		/* Clear out send RCB ring in SRAM. */
+		for (i = NIC_SRAM_SEND_RCB; i < NIC_SRAM_RCV_RET_RCB; i += TG3_BDINFO_SIZE)
+			tg3_write_mem(i + TG3_BDINFO_MAXLEN_FLAGS, BDINFO_FLAGS_DISABLED);
+	}
+
+	tp->tx_prod = 0;
+	tw32_mailbox(MAILBOX_SNDHOST_PROD_IDX_0 + TG3_64BIT_REG_LOW, 0);
+	tw32_mailbox2(MAILBOX_SNDNIC_PROD_IDX_0 + TG3_64BIT_REG_LOW, 0);
+
+	tg3_set_bdinfo(tp,
+		NIC_SRAM_SEND_RCB,
+		virt_to_bus(tp->tx_ring),
+		(TG3_TX_RING_SIZE << BDINFO_FLAGS_MAXLEN_SHIFT),
+		NIC_SRAM_TX_BUFFER_DESC);
+
+	/* There is only one receive return ring on 5705, no need to explicitly
+	 * disable the others.
+	 */
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5705) {
+		for (i = NIC_SRAM_RCV_RET_RCB; i < NIC_SRAM_STATS_BLK; i += TG3_BDINFO_SIZE) {
+			tg3_write_mem(i + TG3_BDINFO_MAXLEN_FLAGS,
+				BDINFO_FLAGS_DISABLED);
+		}
+	}
+
+	tp->rx_rcb_ptr = 0;
+	tw32_mailbox2(MAILBOX_RCVRET_CON_IDX_0 + TG3_64BIT_REG_LOW, 0);
+
+	tg3_set_bdinfo(tp,
+		NIC_SRAM_RCV_RET_RCB,
+		virt_to_bus(tp->rx_rcb),
+		(TG3_RX_RCB_RING_SIZE << BDINFO_FLAGS_MAXLEN_SHIFT),
+		0);
+
+	tp->rx_std_ptr = TG3_DEF_RX_RING_PENDING;
+	tw32_mailbox2(MAILBOX_RCV_STD_PROD_IDX + TG3_64BIT_REG_LOW,
+		     tp->rx_std_ptr);
+
+	tw32_mailbox2(MAILBOX_RCV_JUMBO_PROD_IDX + TG3_64BIT_REG_LOW, 0);
+
+	/* Initialize MAC address and backoff seed. */
+	__tg3_set_mac_addr(tp);
+
+	/* Calculate RDMAC_MODE setting early, we need it to determine
+	 * the RCVLPC_STATE_ENABLE mask.
+	 */
+	rdmac_mode = (RDMAC_MODE_ENABLE | RDMAC_MODE_TGTABORT_ENAB |
+		RDMAC_MODE_MSTABORT_ENAB | RDMAC_MODE_PARITYERR_ENAB |
+		RDMAC_MODE_ADDROFLOW_ENAB | RDMAC_MODE_FIFOOFLOW_ENAB |
+		RDMAC_MODE_FIFOURUN_ENAB | RDMAC_MODE_FIFOOREAD_ENAB |
+		RDMAC_MODE_LNGREAD_ENAB);
+	if (tp->tg3_flags & TG3_FLAG_SPLIT_MODE)
+		rdmac_mode |= RDMAC_MODE_SPLIT_ENABLE;
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705) {
+		if (tp->pci_chip_rev_id != CHIPREV_ID_5705_A0) {
+			if (!(tr32(TG3PCI_PCISTATE) & PCISTATE_BUS_SPEED_HIGH) &&
+				!(tp->tg3_flags2 & TG3_FLG2_IS_5788)) {
+				rdmac_mode |= RDMAC_MODE_FIFO_LONG_BURST;
+			}
+		}
+	}
+
+	/* Setup host coalescing engine. */
+	tw32(HOSTCC_MODE, 0);
+	for (i = 0; i < 2000; i++) {
+		if (!(tr32(HOSTCC_MODE) & HOSTCC_MODE_ENABLE))
+			break;
+		udelay(10);
+	}
+
+	tp->mac_mode = MAC_MODE_TXSTAT_ENABLE | MAC_MODE_RXSTAT_ENABLE |
+		MAC_MODE_TDE_ENABLE | MAC_MODE_RDE_ENABLE | MAC_MODE_FHDE_ENABLE;
+	tw32_carefully(MAC_MODE, tp->mac_mode | MAC_MODE_RXSTAT_CLEAR | MAC_MODE_TXSTAT_CLEAR);
+
+	tp->grc_local_ctrl = GRC_LCLCTRL_INT_ON_ATTN | GRC_LCLCTRL_AUTO_SEEPROM;
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5700)
+		tp->grc_local_ctrl |= (GRC_LCLCTRL_GPIO_OE1 |
+				       GRC_LCLCTRL_GPIO_OUTPUT1);
+	tw32_carefully(GRC_LOCAL_CTRL, tp->grc_local_ctrl);
+
+	tw32_mailbox(MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW, 0);
+	tr32(MAILBOX_INTERRUPT_0);
+
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5705) {
+		tw32_carefully(DMAC_MODE, DMAC_MODE_ENABLE);
+	}
+
+	val = (	WDMAC_MODE_ENABLE | WDMAC_MODE_TGTABORT_ENAB |
+		WDMAC_MODE_MSTABORT_ENAB | WDMAC_MODE_PARITYERR_ENAB |
+		WDMAC_MODE_ADDROFLOW_ENAB | WDMAC_MODE_FIFOOFLOW_ENAB |
+		WDMAC_MODE_FIFOURUN_ENAB | WDMAC_MODE_FIFOOREAD_ENAB |
+		WDMAC_MODE_LNGREAD_ENAB);
+	if ((GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5705) &&
+		((tr32(TG3PCI_PCISTATE) & PCISTATE_BUS_SPEED_HIGH) != 0) &&
+		!(tp->tg3_flags2 & TG3_FLG2_IS_5788)) {
+		val |= WDMAC_MODE_RX_ACCEL;
+	}
+	tw32_carefully(WDMAC_MODE, val);
+
+	if ((tp->tg3_flags & TG3_FLAG_PCIX_MODE) != 0) {
+		val = tr32(TG3PCI_X_CAPS);
+		if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5703) {
+			val &= PCIX_CAPS_BURST_MASK;
+			val |= (PCIX_CAPS_MAX_BURST_CPIOB << PCIX_CAPS_BURST_SHIFT);
+		} else if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5704) {
+			val &= ~(PCIX_CAPS_SPLIT_MASK | PCIX_CAPS_BURST_MASK);
+			val |= (PCIX_CAPS_MAX_BURST_CPIOB << PCIX_CAPS_BURST_SHIFT);
+			if (tp->tg3_flags & TG3_FLAG_SPLIT_MODE)
+				val |= (tp->split_mode_max_reqs <<
+					PCIX_CAPS_SPLIT_SHIFT);
+		}
+		tw32(TG3PCI_X_CAPS, val);
+	}
+
+	tw32_carefully(RDMAC_MODE, rdmac_mode);
+	{
+		static const uint32_t table_all[] = {
+			/* MTU + ethernet header + FCS + optional VLAN tag */
+			MAC_RX_MTU_SIZE, ETH_MAX_MTU + ETH_HLEN + 8,
+			
+			/* The slot time is changed by tg3_setup_phy if we
+			 * run at gigabit with half duplex.
+			 */
+			MAC_TX_LENGTHS,	
+			(2 << TX_LENGTHS_IPG_CRS_SHIFT) |
+			(6 << TX_LENGTHS_IPG_SHIFT) |
+			(32 << TX_LENGTHS_SLOT_TIME_SHIFT),
+			
+			/* Receive rules. */
+			MAC_RCV_RULE_CFG, RCV_RULE_CFG_DEFAULT_CLASS,
+			RCVLPC_CONFIG, 0x0181,
+			
+			/* Receive/send statistics. */
+			RCVLPC_STATS_ENABLE, 0xffffff,
+			RCVLPC_STATSCTRL, RCVLPC_STATSCTRL_ENABLE,
+			SNDDATAI_STATSENAB, 0xffffff,
+			SNDDATAI_STATSCTRL, (SNDDATAI_SCTRL_ENABLE |SNDDATAI_SCTRL_FASTUPD),
+			
+			/* Host coalescing engine */
+			HOSTCC_RXCOL_TICKS, 0,
+			HOSTCC_TXCOL_TICKS, LOW_TXCOL_TICKS,
+			HOSTCC_RXMAX_FRAMES, 1,
+			HOSTCC_TXMAX_FRAMES, LOW_RXMAX_FRAMES,
+			HOSTCC_RXCOAL_MAXF_INT, 1,
+			HOSTCC_TXCOAL_MAXF_INT, 0,
+			
+			/* Status/statistics block address. */
+			/* Etherboot lives below 4GB, so HIGH == 0 */
+			HOSTCC_STATUS_BLK_HOST_ADDR + TG3_64BIT_REG_HIGH, 0,
+
+			/* No need to enable 32byte coalesce mode. */
+			HOSTCC_MODE, HOSTCC_MODE_ENABLE | 0,
+			
+			RCVCC_MODE, RCVCC_MODE_ENABLE | RCVCC_MODE_ATTN_ENABLE,
+			RCVLPC_MODE, RCVLPC_MODE_ENABLE,
+			
+			RCVDCC_MODE, RCVDCC_MODE_ENABLE | RCVDCC_MODE_ATTN_ENABLE,
+
+			SNDDATAC_MODE, SNDDATAC_MODE_ENABLE,
+			SNDBDC_MODE, SNDBDC_MODE_ENABLE | SNDBDC_MODE_ATTN_ENABLE,
+			RCVBDI_MODE, RCVBDI_MODE_ENABLE | RCVBDI_MODE_RCB_ATTN_ENAB,
+			RCVDBDI_MODE, RCVDBDI_MODE_ENABLE | RCVDBDI_MODE_INV_RING_SZ,
+			SNDDATAI_MODE, SNDDATAI_MODE_ENABLE,
+			SNDBDI_MODE, SNDBDI_MODE_ENABLE | SNDBDI_MODE_ATTN_ENABLE,
+			SNDBDS_MODE, SNDBDS_MODE_ENABLE | SNDBDS_MODE_ATTN_ENABLE,
+			
+			/* Accept all multicast frames. */
+			MAC_HASH_REG_0, 0xffffffff,
+			MAC_HASH_REG_1, 0xffffffff,
+			MAC_HASH_REG_2, 0xffffffff,
+			MAC_HASH_REG_3, 0xffffffff,
+		};
+		static const uint32_t table_not_5705[] = {
+			/* Host coalescing engine */
+			HOSTCC_RXCOAL_TICK_INT, 0,
+			HOSTCC_TXCOAL_TICK_INT, 0,
+
+			/* Status/statistics block address. */
+			/* Etherboot lives below 4GB, so HIGH == 0 */
+			HOSTCC_STAT_COAL_TICKS, DEFAULT_STAT_COAL_TICKS,
+			HOSTCC_STATS_BLK_HOST_ADDR + TG3_64BIT_REG_HIGH, 0,
+			HOSTCC_STATS_BLK_NIC_ADDR, NIC_SRAM_STATS_BLK,
+			HOSTCC_STATUS_BLK_NIC_ADDR, NIC_SRAM_STATUS_BLK,
+
+			RCVLSC_MODE, RCVLSC_MODE_ENABLE | RCVLSC_MODE_ATTN_ENABLE,
+
+			MBFREE_MODE, MBFREE_MODE_ENABLE,
+		};
+		TG3_WRITE_SETTINGS(table_all);
+		tw32(HOSTCC_STATS_BLK_HOST_ADDR + TG3_64BIT_REG_LOW,
+			virt_to_bus(tp->hw_stats));
+		tw32(HOSTCC_STATUS_BLK_HOST_ADDR + TG3_64BIT_REG_LOW,
+			virt_to_bus(tp->hw_status));
+		if (GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5705) {
+			TG3_WRITE_SETTINGS(table_not_5705);
+		}
+	}
+
+	tp->tx_mode = TX_MODE_ENABLE;
+	tw32_carefully(MAC_TX_MODE, tp->tx_mode);
+
+	tp->rx_mode = RX_MODE_ENABLE;
+	tw32_carefully(MAC_RX_MODE, tp->rx_mode);
+
+	tp->mi_mode = MAC_MI_MODE_BASE;
+	tw32_carefully(MAC_MI_MODE, tp->mi_mode);
+
+	tw32(MAC_LED_CTRL, 0);
+	tw32(MAC_MI_STAT, MAC_MI_STAT_LNKSTAT_ATTN_ENAB);
+	if (tp->phy_id == PHY_ID_SERDES) {
+		tw32_carefully(MAC_RX_MODE, RX_MODE_RESET);
+	}
+	tp->rx_mode |= RX_MODE_KEEP_VLAN_TAG; /* drop tagged vlan packets */
+	tw32_carefully(MAC_RX_MODE, tp->rx_mode);
+
+	if (tp->pci_chip_rev_id == CHIPREV_ID_5703_A1)
+		tw32(MAC_SERDES_CFG, 0x616000);
+
+	/* Prevent chip from dropping frames when flow control
+	 * is enabled.
+	 */
+	tw32(MAC_LOW_WMARK_MAX_RX_FRAME, 2);
+	tr32(MAC_LOW_WMARK_MAX_RX_FRAME);
+
+	err = tg3_setup_phy(tp);
+
+	/* Ignore CRC stats */
+
+	/* Initialize receive rules. */
+	tw32(MAC_RCV_RULE_0,  0xc2000000 & RCV_RULE_DISABLE_MASK);
+	tw32(MAC_RCV_VALUE_0, 0xffffffff & RCV_RULE_DISABLE_MASK);
+	tw32(MAC_RCV_RULE_1,  0x86000004 & RCV_RULE_DISABLE_MASK);
+	tw32(MAC_RCV_VALUE_1, 0xffffffff & RCV_RULE_DISABLE_MASK);
+
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705)
+		limit = 8;
+	else
+		limit = 16;
+	if (tp->tg3_flags & TG3_FLAG_ENABLE_ASF)
+		limit -= 4;
+	switch (limit) {
+	case 16:	tw32(MAC_RCV_RULE_15,  0); tw32(MAC_RCV_VALUE_15,  0);
+	case 15:	tw32(MAC_RCV_RULE_14,  0); tw32(MAC_RCV_VALUE_14,  0);
+	case 14:	tw32(MAC_RCV_RULE_13,  0); tw32(MAC_RCV_VALUE_13,  0);
+	case 13:	tw32(MAC_RCV_RULE_12,  0); tw32(MAC_RCV_VALUE_12,  0);
+	case 12:	tw32(MAC_RCV_RULE_11,  0); tw32(MAC_RCV_VALUE_11,  0);
+	case 11:	tw32(MAC_RCV_RULE_10,  0); tw32(MAC_RCV_VALUE_10,  0);
+	case 10:	tw32(MAC_RCV_RULE_9,  0);  tw32(MAC_RCV_VALUE_9,  0);
+	case 9:		tw32(MAC_RCV_RULE_8,  0);  tw32(MAC_RCV_VALUE_8,  0);
+	case 8:		tw32(MAC_RCV_RULE_7,  0);  tw32(MAC_RCV_VALUE_7,  0);
+	case 7:		tw32(MAC_RCV_RULE_6,  0);  tw32(MAC_RCV_VALUE_6,  0);
+	case 6:		tw32(MAC_RCV_RULE_5,  0);  tw32(MAC_RCV_VALUE_5,  0);
+	case 5:		tw32(MAC_RCV_RULE_4,  0);  tw32(MAC_RCV_VALUE_4,  0);
+	case 4:		/* tw32(MAC_RCV_RULE_3,  0); tw32(MAC_RCV_VALUE_3,  0); */
+	case 3:		/* tw32(MAC_RCV_RULE_2,  0); tw32(MAC_RCV_VALUE_2,  0); */
+	case 2:
+	case 1:
+	default:
+		break;
+	};
+
+	return err;
+}
+
+
+
+/* Chips other than 5700/5701 use the NVRAM for fetching info. */
+static void tg3_nvram_init(struct tg3 *tp)
+{
+	tw32(GRC_EEPROM_ADDR,
+	     (EEPROM_ADDR_FSM_RESET |
+	      (EEPROM_DEFAULT_CLOCK_PERIOD <<
+	       EEPROM_ADDR_CLKPERD_SHIFT)));
+
+	mdelay(1);
+
+	/* Enable seeprom accesses. */
+	tw32_carefully(GRC_LOCAL_CTRL,
+		tr32(GRC_LOCAL_CTRL) | GRC_LCLCTRL_AUTO_SEEPROM);
+
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5700 &&
+	    GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5701) {
+		uint32_t nvcfg1 = tr32(NVRAM_CFG1);
+
+		tp->tg3_flags |= TG3_FLAG_NVRAM;
+		if (nvcfg1 & NVRAM_CFG1_FLASHIF_ENAB) {
+			if (nvcfg1 & NVRAM_CFG1_BUFFERED_MODE)
+				tp->tg3_flags |= TG3_FLAG_NVRAM_BUFFERED;
+		} else {
+			nvcfg1 &= ~NVRAM_CFG1_COMPAT_BYPASS;
+			tw32(NVRAM_CFG1, nvcfg1);
+		}
+
+	} else {
+		tp->tg3_flags &= ~(TG3_FLAG_NVRAM | TG3_FLAG_NVRAM_BUFFERED);
+	}
+}
+
+
+static int tg3_nvram_read_using_eeprom(
+	struct tg3 *tp __unused, uint32_t offset, uint32_t *val)
+{
+	uint32_t tmp;
+	int i;
+
+	if (offset > EEPROM_ADDR_ADDR_MASK ||
+		(offset % 4) != 0) {
+		return -EINVAL;
+	}
+
+	tmp = tr32(GRC_EEPROM_ADDR) & ~(EEPROM_ADDR_ADDR_MASK |
+					EEPROM_ADDR_DEVID_MASK |
+					EEPROM_ADDR_READ);
+	tw32(GRC_EEPROM_ADDR,
+	     tmp |
+	     (0 << EEPROM_ADDR_DEVID_SHIFT) |
+	     ((offset << EEPROM_ADDR_ADDR_SHIFT) &
+	      EEPROM_ADDR_ADDR_MASK) |
+	     EEPROM_ADDR_READ | EEPROM_ADDR_START);
+
+	for (i = 0; i < 10000; i++) {
+		tmp = tr32(GRC_EEPROM_ADDR);
+
+		if (tmp & EEPROM_ADDR_COMPLETE)
+			break;
+		udelay(100);
+	}
+	if (!(tmp & EEPROM_ADDR_COMPLETE)) {
+		return -EBUSY;
+	}
+
+	*val = tr32(GRC_EEPROM_DATA);
+	return 0;
+}
+
+static int tg3_nvram_read(struct tg3 *tp, uint32_t offset, uint32_t *val)
+{
+	int i, saw_done_clear;
+
+	if (!(tp->tg3_flags & TG3_FLAG_NVRAM))
+		return tg3_nvram_read_using_eeprom(tp, offset, val);
+
+	if (tp->tg3_flags & TG3_FLAG_NVRAM_BUFFERED)
+		offset = ((offset / NVRAM_BUFFERED_PAGE_SIZE) <<
+			  NVRAM_BUFFERED_PAGE_POS) +
+			(offset % NVRAM_BUFFERED_PAGE_SIZE);
+
+	if (offset > NVRAM_ADDR_MSK)
+		return -EINVAL;
+
+	tw32(NVRAM_SWARB, SWARB_REQ_SET1);
+	for (i = 0; i < 1000; i++) {
+		if (tr32(NVRAM_SWARB) & SWARB_GNT1)
+			break;
+		udelay(20);
+	}
+
+	tw32(NVRAM_ADDR, offset);
+	tw32(NVRAM_CMD,
+	     NVRAM_CMD_RD | NVRAM_CMD_GO |
+	     NVRAM_CMD_FIRST | NVRAM_CMD_LAST | NVRAM_CMD_DONE);
+
+	/* Wait for done bit to clear then set again. */
+	saw_done_clear = 0;
+	for (i = 0; i < 1000; i++) {
+		udelay(10);
+		if (!saw_done_clear &&
+		    !(tr32(NVRAM_CMD) & NVRAM_CMD_DONE))
+			saw_done_clear = 1;
+		else if (saw_done_clear &&
+			 (tr32(NVRAM_CMD) & NVRAM_CMD_DONE))
+			break;
+	}
+	if (i >= 1000) {
+		tw32(NVRAM_SWARB, SWARB_REQ_CLR1);
+		return -EBUSY;
+	}
+
+	*val = bswap_32(tr32(NVRAM_RDDATA));
+	tw32(NVRAM_SWARB, 0x20);
+
+	return 0;
+}
+
+struct subsys_tbl_ent {
+	uint16_t subsys_vendor, subsys_devid;
+	uint32_t phy_id;
+};
+
+static struct subsys_tbl_ent subsys_id_to_phy_id[] = {
+	/* Broadcom boards. */
+	{ 0x14e4, 0x1644, PHY_ID_BCM5401 }, /* BCM95700A6 */
+	{ 0x14e4, 0x0001, PHY_ID_BCM5701 }, /* BCM95701A5 */
+	{ 0x14e4, 0x0002, PHY_ID_BCM8002 }, /* BCM95700T6 */
+	{ 0x14e4, 0x0003, PHY_ID_SERDES  }, /* BCM95700A9 */
+	{ 0x14e4, 0x0005, PHY_ID_BCM5701 }, /* BCM95701T1 */
+	{ 0x14e4, 0x0006, PHY_ID_BCM5701 }, /* BCM95701T8 */
+	{ 0x14e4, 0x0007, PHY_ID_SERDES  }, /* BCM95701A7 */
+	{ 0x14e4, 0x0008, PHY_ID_BCM5701 }, /* BCM95701A10 */
+	{ 0x14e4, 0x8008, PHY_ID_BCM5701 }, /* BCM95701A12 */
+	{ 0x14e4, 0x0009, PHY_ID_BCM5701 }, /* BCM95703Ax1 */
+	{ 0x14e4, 0x8009, PHY_ID_BCM5701 }, /* BCM95703Ax2 */
+
+	/* 3com boards. */
+	{ PCI_VENDOR_ID_3COM, 0x1000, PHY_ID_BCM5401 }, /* 3C996T */
+	{ PCI_VENDOR_ID_3COM, 0x1006, PHY_ID_BCM5701 }, /* 3C996BT */
+	/* { PCI_VENDOR_ID_3COM, 0x1002, PHY_ID_XXX },     3C996CT */
+	/* { PCI_VENDOR_ID_3COM, 0x1003, PHY_ID_XXX },     3C997T */
+	{ PCI_VENDOR_ID_3COM, 0x1004, PHY_ID_SERDES  }, /* 3C996SX */
+	/* { PCI_VENDOR_ID_3COM, 0x1005, PHY_ID_XXX },     3C997SZ */
+	{ PCI_VENDOR_ID_3COM, 0x1007, PHY_ID_BCM5701 }, /* 3C1000T */
+	{ PCI_VENDOR_ID_3COM, 0x1008, PHY_ID_BCM5701 }, /* 3C940BR01 */
+
+	/* DELL boards. */
+	{ PCI_VENDOR_ID_DELL, 0x00d1, PHY_ID_BCM5401 }, /* VIPER */
+	{ PCI_VENDOR_ID_DELL, 0x0106, PHY_ID_BCM5401 }, /* JAGUAR */
+	{ PCI_VENDOR_ID_DELL, 0x0109, PHY_ID_BCM5411 }, /* MERLOT */
+	{ PCI_VENDOR_ID_DELL, 0x010a, PHY_ID_BCM5411 }, /* SLIM_MERLOT */
+
+	/* Compaq boards. */
+	{ PCI_VENDOR_ID_COMPAQ, 0x007c, PHY_ID_BCM5701 }, /* BANSHEE */
+	{ PCI_VENDOR_ID_COMPAQ, 0x009a, PHY_ID_BCM5701 }, /* BANSHEE_2 */
+	{ PCI_VENDOR_ID_COMPAQ, 0x007d, PHY_ID_SERDES  }, /* CHANGELING */
+	{ PCI_VENDOR_ID_COMPAQ, 0x0085, PHY_ID_BCM5701 }, /* NC7780 */
+	{ PCI_VENDOR_ID_COMPAQ, 0x0099, PHY_ID_BCM5701 }  /* NC7780_2 */
+};
+
+static int tg3_phy_probe(struct tg3 *tp)
+{
+	uint32_t eeprom_phy_id, hw_phy_id_1, hw_phy_id_2;
+	uint32_t hw_phy_id, hw_phy_id_masked;
+	enum phy_led_mode eeprom_led_mode;
+	uint32_t val;
+	unsigned i;
+	int eeprom_signature_found, err;
+
+	tp->phy_id = PHY_ID_INVALID;
+
+	for (i = 0; i < sizeof(subsys_id_to_phy_id)/sizeof(subsys_id_to_phy_id[0]); i++) {
+		if ((subsys_id_to_phy_id[i].subsys_vendor == tp->subsystem_vendor) &&
+			(subsys_id_to_phy_id[i].subsys_devid == tp->subsystem_device)) {
+			tp->phy_id = subsys_id_to_phy_id[i].phy_id;
+			break;
+		}
+	}
+
+	eeprom_phy_id = PHY_ID_INVALID;
+	eeprom_led_mode = led_mode_auto;
+	eeprom_signature_found = 0;
+	tg3_read_mem(NIC_SRAM_DATA_SIG, &val);
+	if (val == NIC_SRAM_DATA_SIG_MAGIC) {
+		uint32_t nic_cfg;
+
+		tg3_read_mem(NIC_SRAM_DATA_CFG, &nic_cfg);
+		tp->nic_sram_data_cfg = nic_cfg;
+
+		eeprom_signature_found = 1;
+
+		if ((nic_cfg & NIC_SRAM_DATA_CFG_PHY_TYPE_MASK) ==
+		    NIC_SRAM_DATA_CFG_PHY_TYPE_FIBER) {
+			eeprom_phy_id = PHY_ID_SERDES;
+		} else {
+			uint32_t nic_phy_id;
+
+			tg3_read_mem(NIC_SRAM_DATA_PHY_ID, &nic_phy_id);
+			if (nic_phy_id != 0) {
+				uint32_t id1 = nic_phy_id & NIC_SRAM_DATA_PHY_ID1_MASK;
+				uint32_t id2 = nic_phy_id & NIC_SRAM_DATA_PHY_ID2_MASK;
+
+				eeprom_phy_id  = (id1 >> 16) << 10;
+				eeprom_phy_id |= (id2 & 0xfc00) << 16;
+				eeprom_phy_id |= (id2 & 0x03ff) <<  0;
+			}
+		}
+
+		switch (nic_cfg & NIC_SRAM_DATA_CFG_LED_MODE_MASK) {
+		case NIC_SRAM_DATA_CFG_LED_TRIPLE_SPD:
+			eeprom_led_mode = led_mode_three_link;
+			break;
+
+		case NIC_SRAM_DATA_CFG_LED_LINK_SPD:
+			eeprom_led_mode = led_mode_link10;
+			break;
+
+		default:
+			eeprom_led_mode = led_mode_auto;
+			break;
+		};
+		if (((GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5703) ||
+			(GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5704) ||
+			(GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705)) &&
+			(nic_cfg & NIC_SRAM_DATA_CFG_EEPROM_WP)) {
+			tp->tg3_flags |= TG3_FLAG_EEPROM_WRITE_PROT;
+		}
+
+		if (nic_cfg & NIC_SRAM_DATA_CFG_ASF_ENABLE)
+			tp->tg3_flags |= TG3_FLAG_ENABLE_ASF;
+		if (nic_cfg & NIC_SRAM_DATA_CFG_FIBER_WOL)
+			tp->tg3_flags |= TG3_FLAG_SERDES_WOL_CAP;
+	}
+
+	/* Now read the physical PHY_ID from the chip and verify
+	 * that it is sane.  If it doesn't look good, we fall back
+	 * to either the hard-coded table based PHY_ID and failing
+	 * that the value found in the eeprom area.
+	 */
+	err  = tg3_readphy(tp, MII_PHYSID1, &hw_phy_id_1);
+	err |= tg3_readphy(tp, MII_PHYSID2, &hw_phy_id_2);
+
+	hw_phy_id  = (hw_phy_id_1 & 0xffff) << 10;
+	hw_phy_id |= (hw_phy_id_2 & 0xfc00) << 16;
+	hw_phy_id |= (hw_phy_id_2 & 0x03ff) <<  0;
+
+	hw_phy_id_masked = hw_phy_id & PHY_ID_MASK;
+
+	if (!err && KNOWN_PHY_ID(hw_phy_id_masked)) {
+		tp->phy_id = hw_phy_id;
+	} else {
+		/* phy_id currently holds the value found in the
+		 * subsys_id_to_phy_id[] table or PHY_ID_INVALID
+		 * if a match was not found there.
+		 */
+		if (tp->phy_id == PHY_ID_INVALID) {
+			if (!eeprom_signature_found ||
+			    !KNOWN_PHY_ID(eeprom_phy_id & PHY_ID_MASK))
+				return -ENODEV;
+			tp->phy_id = eeprom_phy_id;
+		}
+	}
+
+	err = tg3_phy_reset(tp);
+	if (err)
+		return err;
+
+	if (tp->pci_chip_rev_id == CHIPREV_ID_5701_A0 ||
+	    tp->pci_chip_rev_id == CHIPREV_ID_5701_B0) {
+		uint32_t mii_tg3_ctrl;
+		
+		/* These chips, when reset, only advertise 10Mb
+		 * capabilities.  Fix that.
+		 */
+		err  = tg3_writephy(tp, MII_ADVERTISE,
+				    (ADVERTISE_CSMA |
+				     ADVERTISE_PAUSE_CAP |
+				     ADVERTISE_10HALF |
+				     ADVERTISE_10FULL |
+				     ADVERTISE_100HALF |
+				     ADVERTISE_100FULL));
+		mii_tg3_ctrl = (MII_TG3_CTRL_ADV_1000_HALF |
+				MII_TG3_CTRL_ADV_1000_FULL |
+				MII_TG3_CTRL_AS_MASTER |
+				MII_TG3_CTRL_ENABLE_AS_MASTER);
+		if (tp->tg3_flags & TG3_FLAG_10_100_ONLY)
+			mii_tg3_ctrl = 0;
+
+		err |= tg3_writephy(tp, MII_TG3_CTRL, mii_tg3_ctrl);
+		err |= tg3_writephy(tp, MII_BMCR,
+				    (BMCR_ANRESTART | BMCR_ANENABLE));
+	}
+
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5703) {
+		tg3_writephy(tp, MII_TG3_AUX_CTRL, 0x0c00);
+		tg3_writephy(tp, MII_TG3_DSP_ADDRESS, 0x201f);
+		tg3_writedsp(tp, MII_TG3_DSP_RW_PORT, 0x2aaa);
+	}
+
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5704) {
+		tg3_writephy(tp, 0x1c, 0x8d68);
+		tg3_writephy(tp, 0x1c, 0x8d68);
+	}
+
+	/* Enable Ethernet@WireSpeed */
+	tg3_phy_set_wirespeed(tp);
+
+	if (!err && ((tp->phy_id & PHY_ID_MASK) == PHY_ID_BCM5401)) {
+		err = tg3_init_5401phy_dsp(tp);
+	}
+
+	/* Determine the PHY led mode. 
+	 * Be careful if this gets set wrong it can result in an inability to 
+	 * establish a link.
+	 */
+	if (tp->phy_id == PHY_ID_SERDES) {
+		tp->led_mode = led_mode_three_link;
+	}
+	else if (tp->subsystem_vendor == PCI_VENDOR_ID_DELL) {
+		tp->led_mode = led_mode_link10;
+	} else {
+		tp->led_mode = led_mode_three_link;
+		if (eeprom_signature_found &&
+		    eeprom_led_mode != led_mode_auto)
+			tp->led_mode = eeprom_led_mode;
+	}
+
+	if (tp->phy_id == PHY_ID_SERDES)
+		tp->link_config.advertising =
+			(ADVERTISED_1000baseT_Half |
+			 ADVERTISED_1000baseT_Full |
+			 ADVERTISED_Autoneg |
+			 ADVERTISED_FIBRE);
+	if (tp->tg3_flags & TG3_FLAG_10_100_ONLY)
+		tp->link_config.advertising &=
+			~(ADVERTISED_1000baseT_Half |
+			  ADVERTISED_1000baseT_Full);
+
+	return err;
+}
+
+#if SUPPORT_PARTNO_STR
+static void tg3_read_partno(struct tg3 *tp)
+{
+	unsigned char vpd_data[256];
+	int i;
+
+	for (i = 0; i < 256; i += 4) {
+		uint32_t tmp;
+
+		if (tg3_nvram_read(tp, 0x100 + i, &tmp))
+			goto out_not_found;
+
+		vpd_data[i + 0] = ((tmp >>  0) & 0xff);
+		vpd_data[i + 1] = ((tmp >>  8) & 0xff);
+		vpd_data[i + 2] = ((tmp >> 16) & 0xff);
+		vpd_data[i + 3] = ((tmp >> 24) & 0xff);
+	}
+
+	/* Now parse and find the part number. */
+	for (i = 0; i < 256; ) {
+		unsigned char val = vpd_data[i];
+		int block_end;
+
+		if (val == 0x82 || val == 0x91) {
+			i = (i + 3 +
+			     (vpd_data[i + 1] +
+			      (vpd_data[i + 2] << 8)));
+			continue;
+		}
+
+		if (val != 0x90)
+			goto out_not_found;
+
+		block_end = (i + 3 +
+			     (vpd_data[i + 1] +
+			      (vpd_data[i + 2] << 8)));
+		i += 3;
+		while (i < block_end) {
+			if (vpd_data[i + 0] == 'P' &&
+			    vpd_data[i + 1] == 'N') {
+				int partno_len = vpd_data[i + 2];
+
+				if (partno_len > 24)
+					goto out_not_found;
+
+				memcpy(tp->board_part_number,
+				       &vpd_data[i + 3],
+				       partno_len);
+
+				/* Success. */
+				return;
+			}
+		}
+
+		/* Part number not found. */
+		goto out_not_found;
+	}
+
+out_not_found:
+	memcpy(tp->board_part_number, "none", sizeof("none"));
+}
+#else
+#define tg3_read_partno(TP) ((TP)->board_part_number[0] = '\0')
+#endif
+
+static int tg3_get_invariants(struct tg3 *tp)
+{
+	uint32_t misc_ctrl_reg;
+	uint32_t pci_state_reg, grc_misc_cfg;
+	uint16_t pci_cmd;
+	uint8_t  pci_latency;
+	int err;
+
+	/* Read the subsystem vendor and device ids */
+	pci_read_config_word(tp->pdev, PCI_SUBSYSTEM_VENDOR_ID, &tp->subsystem_vendor);
+	pci_read_config_word(tp->pdev, PCI_SUBSYSTEM_ID, &tp->subsystem_device);
+
+	/* The sun_5704 code needs infrastructure etherboot does have
+	 * ignore it for now.
+	 */
+
+	/* If we have an AMD 762 or Intel ICH/ICH0 chipset, write
+	 * reordering to the mailbox registers done by the host
+	 * controller can cause major troubles.  We read back from
+	 * every mailbox register write to force the writes to be
+	 * posted to the chip in order.
+	 *
+	 * TG3_FLAG_MBOX_WRITE_REORDER has been forced on.
+	 */
+
+	/* Force memory write invalidate off.  If we leave it on,
+	 * then on 5700_BX chips we have to enable a workaround.
+	 * The workaround is to set the TG3PCI_DMA_RW_CTRL boundry
+	 * to match the cacheline size.  The Broadcom driver have this
+	 * workaround but turns MWI off all the times so never uses
+	 * it.  This seems to suggest that the workaround is insufficient.
+	 */
+	pci_read_config_word(tp->pdev, PCI_COMMAND, &pci_cmd);
+	pci_cmd &= ~PCI_COMMAND_INVALIDATE;
+	/* Also, force SERR#/PERR# in PCI command. */
+	pci_cmd |= PCI_COMMAND_PARITY | PCI_COMMAND_SERR;
+	pci_write_config_word(tp->pdev, PCI_COMMAND, pci_cmd);
+
+	/* It is absolutely critical that TG3PCI_MISC_HOST_CTRL
+	 * has the register indirect write enable bit set before
+	 * we try to access any of the MMIO registers.  It is also
+	 * critical that the PCI-X hw workaround situation is decided
+	 * before that as well.
+	 */
+	pci_read_config_dword(tp->pdev, TG3PCI_MISC_HOST_CTRL, &misc_ctrl_reg);
+
+	tp->pci_chip_rev_id = (misc_ctrl_reg >> MISC_HOST_CTRL_CHIPREV_SHIFT);
+
+	/* Initialize misc host control in PCI block. */
+	tp->misc_host_ctrl |= (misc_ctrl_reg &
+			       MISC_HOST_CTRL_CHIPREV);
+	pci_write_config_dword(tp->pdev, TG3PCI_MISC_HOST_CTRL,
+			       tp->misc_host_ctrl);
+
+	pci_read_config_byte(tp->pdev, PCI_LATENCY_TIMER, &pci_latency);
+	if (pci_latency < 64) {
+		pci_write_config_byte(tp->pdev, PCI_LATENCY_TIMER, 64);
+	}
+
+	pci_read_config_dword(tp->pdev, TG3PCI_PCISTATE, &pci_state_reg);
+
+	/* If this is a 5700 BX chipset, and we are in PCI-X
+	 * mode, enable register write workaround.
+	 *
+	 * The workaround is to use indirect register accesses
+	 * for all chip writes not to mailbox registers.
+	 *
+	 * In etherboot to simplify things we just always use this work around.
+	 */
+	if ((pci_state_reg & PCISTATE_CONV_PCI_MODE) == 0) {
+		tp->tg3_flags |= TG3_FLAG_PCIX_MODE;
+	}
+	/* Back to back register writes can cause problems on the 5701,
+	 * the workaround is to read back all reg writes except those to
+	 * mailbox regs.
+	 * In etherboot we always use indirect register accesses so
+	 * we don't see this.
+	 */
+
+	if ((pci_state_reg & PCISTATE_BUS_SPEED_HIGH) != 0)
+		tp->tg3_flags |= TG3_FLAG_PCI_HIGH_SPEED;
+	if ((pci_state_reg & PCISTATE_BUS_32BIT) != 0)
+		tp->tg3_flags |= TG3_FLAG_PCI_32BIT;
+
+	/* Chip-specific fixup from Broadcom driver */
+	if ((tp->pci_chip_rev_id == CHIPREV_ID_5704_A0) &&
+	    (!(pci_state_reg & PCISTATE_RETRY_SAME_DMA))) {
+		pci_state_reg |= PCISTATE_RETRY_SAME_DMA;
+		pci_write_config_dword(tp->pdev, TG3PCI_PCISTATE, pci_state_reg);
+	}
+
+	/* Force the chip into D0. */
+	tg3_set_power_state_0(tp);
+
+	/* Etherboot does not ask the tg3 to do checksums */
+	/* Etherboot does not ask the tg3 to do jumbo frames */
+	/* Ehterboot does not ask the tg3 to use WakeOnLan. */
+
+	/* A few boards don't want Ethernet@WireSpeed phy feature */
+	if ((GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5700) ||
+		((GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705) &&
+			(tp->pci_chip_rev_id != CHIPREV_ID_5705_A0) &&
+			(tp->pci_chip_rev_id != CHIPREV_ID_5705_A1))) {
+		tp->tg3_flags2 |= TG3_FLG2_NO_ETH_WIRE_SPEED;
+	}
+
+	/* Avoid tagged irq status etherboot does not use irqs */
+
+	/* Only 5701 and later support tagged irq status mode.
+	 * Also, 5788 chips cannot use tagged irq status.
+	 *
+	 * However, since etherboot does not use irqs avoid tagged irqs
+	 * status  because the interrupt condition is more difficult to
+	 * fully clear in that mode.
+	 */
+	
+	/* Since some 5700_AX && 5700_BX have problems with 32BYTE
+	 * coalesce_mode, and the rest work fine anything set.
+	 * Don't enable HOST_CC_MODE_32BYTE in etherboot.
+	 */
+
+	/* Initialize MAC MI mode, polling disabled. */
+	tw32_carefully(MAC_MI_MODE, tp->mi_mode);
+
+	/* Initialize data/descriptor byte/word swapping. */
+	tw32(GRC_MODE, tp->grc_mode);
+
+	tg3_switch_clocks(tp);
+
+	/* Clear this out for sanity. */
+	tw32(TG3PCI_MEM_WIN_BASE_ADDR, 0);
+
+	/* Etherboot does not need to check if the PCIX_TARGET_HWBUG
+	 * is needed.  It always uses it.
+	 */
+	
+	udelay(50);
+	tg3_nvram_init(tp);
+
+	/* The TX descriptors will reside in main memory.
+	 */
+
+	/* See which board we are using.
+	 */
+	grc_misc_cfg = tr32(GRC_MISC_CFG);
+	grc_misc_cfg &= GRC_MISC_CFG_BOARD_ID_MASK;
+
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5704 &&
+	    grc_misc_cfg == GRC_MISC_CFG_BOARD_ID_5704CIOBE) {
+		tp->tg3_flags |= TG3_FLAG_SPLIT_MODE;
+		tp->split_mode_max_reqs = SPLIT_MODE_5704_MAX_REQ;
+	}
+
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705 &&
+	    (grc_misc_cfg == GRC_MISC_CFG_BOARD_ID_5788 ||
+	     grc_misc_cfg == GRC_MISC_CFG_BOARD_ID_5788M))
+		tp->tg3_flags2 |= TG3_FLG2_IS_5788;
+
+	/* these are limited to 10/100 only */
+	if (((GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5703) &&
+		    ((grc_misc_cfg == 0x8000) || (grc_misc_cfg == 0x4000))) ||
+		((GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705) &&
+			(tp->pdev->vendor == PCI_VENDOR_ID_BROADCOM) &&
+			((tp->pdev->dev_id == PCI_DEVICE_ID_TIGON3_5901) ||
+				(tp->pdev->dev_id == PCI_DEVICE_ID_TIGON3_5901_2)))) {
+		tp->tg3_flags |= TG3_FLAG_10_100_ONLY;
+	}
+
+	err = tg3_phy_probe(tp);
+	if (err) {
+		printf("phy probe failed, err %d\n", err);
+	}
+
+	tg3_read_partno(tp);
+
+
+	/* 5700 BX chips need to have their TX producer index mailboxes
+	 * written twice to workaround a bug.
+	 * In etherboot we do this unconditionally to simplify things.
+	 */
+
+	/* 5700 chips can get confused if TX buffers straddle the
+	 * 4GB address boundary in some cases.
+	 * 
+	 * In etherboot we can ignore the problem as etherboot lives below 4GB.
+	 */
+
+	/* In etherboot wake-on-lan is unconditionally disabled */
+	return err;
+}
+
+static int  tg3_get_device_address(struct tg3 *tp)
+{
+	struct nic *nic = tp->nic;
+	uint32_t hi, lo, mac_offset;
+
+	if (PCI_FUNC(tp->pdev->devfn) == 0)
+		mac_offset = 0x7c;
+	else
+		mac_offset = 0xcc;
+
+	/* First try to get it from MAC address mailbox. */
+	tg3_read_mem(NIC_SRAM_MAC_ADDR_HIGH_MBOX, &hi);
+	if ((hi >> 16) == 0x484b) {
+		nic->node_addr[0] = (hi >>  8) & 0xff;
+		nic->node_addr[1] = (hi >>  0) & 0xff;
+
+		tg3_read_mem(NIC_SRAM_MAC_ADDR_LOW_MBOX, &lo);
+		nic->node_addr[2] = (lo >> 24) & 0xff;
+		nic->node_addr[3] = (lo >> 16) & 0xff;
+		nic->node_addr[4] = (lo >>  8) & 0xff;
+		nic->node_addr[5] = (lo >>  0) & 0xff;
+	}
+	/* Next, try NVRAM. */
+	else if (!tg3_nvram_read(tp, mac_offset + 0, &hi) &&
+		 !tg3_nvram_read(tp, mac_offset + 4, &lo)) {
+		nic->node_addr[0] = ((hi >> 16) & 0xff);
+		nic->node_addr[1] = ((hi >> 24) & 0xff);
+		nic->node_addr[2] = ((lo >>  0) & 0xff);
+		nic->node_addr[3] = ((lo >>  8) & 0xff);
+		nic->node_addr[4] = ((lo >> 16) & 0xff);
+		nic->node_addr[5] = ((lo >> 24) & 0xff);
+	}
+	/* Finally just fetch it out of the MAC control regs. */
+	else {
+		hi = tr32(MAC_ADDR_0_HIGH);
+		lo = tr32(MAC_ADDR_0_LOW);
+
+		nic->node_addr[5] = lo & 0xff;
+		nic->node_addr[4] = (lo >> 8) & 0xff;
+		nic->node_addr[3] = (lo >> 16) & 0xff;
+		nic->node_addr[2] = (lo >> 24) & 0xff;
+		nic->node_addr[1] = hi & 0xff;
+		nic->node_addr[0] = (hi >> 8) & 0xff;
+	}
+
+	return 0;
+}
+
+
+static int tg3_setup_dma(struct tg3 *tp)
+{
+	tw32(TG3PCI_CLOCK_CTRL, 0);
+
+	if ((tp->tg3_flags & TG3_FLAG_PCIX_MODE) == 0) {
+		tp->dma_rwctrl =
+			(0x7 << DMA_RWCTRL_PCI_WRITE_CMD_SHIFT) |
+			(0x6 << DMA_RWCTRL_PCI_READ_CMD_SHIFT) |
+			(0x7 << DMA_RWCTRL_WRITE_WATER_SHIFT) |
+			(0x7 << DMA_RWCTRL_READ_WATER_SHIFT) |
+			(0x0f << DMA_RWCTRL_MIN_DMA_SHIFT);
+		if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705) {
+			tp->dma_rwctrl &= ~(DMA_RWCTRL_MIN_DMA << DMA_RWCTRL_MIN_DMA_SHIFT);
+		}
+	} else {
+		if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5704)
+			tp->dma_rwctrl =
+				(0x7 << DMA_RWCTRL_PCI_WRITE_CMD_SHIFT) |
+				(0x6 << DMA_RWCTRL_PCI_READ_CMD_SHIFT) |
+				(0x3 << DMA_RWCTRL_WRITE_WATER_SHIFT) |
+				(0x7 << DMA_RWCTRL_READ_WATER_SHIFT) |
+				(0x00 << DMA_RWCTRL_MIN_DMA_SHIFT);
+		else
+			tp->dma_rwctrl =
+				(0x7 << DMA_RWCTRL_PCI_WRITE_CMD_SHIFT) |
+				(0x6 << DMA_RWCTRL_PCI_READ_CMD_SHIFT) |
+				(0x3 << DMA_RWCTRL_WRITE_WATER_SHIFT) |
+				(0x3 << DMA_RWCTRL_READ_WATER_SHIFT) |
+				(0x0f << DMA_RWCTRL_MIN_DMA_SHIFT);
+
+		/* Wheee, some more chip bugs... */
+		if ((GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5703) ||
+			(GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5704)) {
+			uint32_t ccval = tr32(TG3PCI_CLOCK_CTRL) & 0x1f;
+
+			if ((ccval == 0x6) || (ccval == 0x7)) {
+				tp->dma_rwctrl |= DMA_RWCTRL_ONE_DMA;
+			}
+		}
+	}
+
+	if ((GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5703) ||
+		(GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5704)) {
+		tp->dma_rwctrl &= ~(DMA_RWCTRL_MIN_DMA << DMA_RWCTRL_MIN_DMA_SHIFT);
+	}
+
+	tp->dma_rwctrl |= DMA_RWCTRL_ASSERT_ALL_BE;
+
+	tw32(TG3PCI_DMA_RW_CTRL, tp->dma_rwctrl);
+
+	return 0;
+}
+
+static void tg3_init_link_config(struct tg3 *tp)
+{
+	tp->link_config.advertising =
+		(ADVERTISED_10baseT_Half | ADVERTISED_10baseT_Full |
+		 ADVERTISED_100baseT_Half | ADVERTISED_100baseT_Full |
+		 ADVERTISED_1000baseT_Half | ADVERTISED_1000baseT_Full |
+		 ADVERTISED_Autoneg | ADVERTISED_MII);
+	tp->carrier_ok = 0;
+	tp->link_config.active_speed = SPEED_INVALID;
+	tp->link_config.active_duplex = DUPLEX_INVALID;
+}
+
+
+#if SUPPORT_PHY_STR
+static const char * tg3_phy_string(struct tg3 *tp)
+{
+	switch (tp->phy_id & PHY_ID_MASK) {
+	case PHY_ID_BCM5400:	return "5400";
+	case PHY_ID_BCM5401:	return "5401";
+	case PHY_ID_BCM5411:	return "5411";
+	case PHY_ID_BCM5701:	return "5701";
+	case PHY_ID_BCM5703:	return "5703";
+	case PHY_ID_BCM5704:	return "5704";
+	case PHY_ID_BCM8002:	return "8002";
+	case PHY_ID_SERDES:	return "serdes";
+	default:		return "unknown";
+	};
+}
+#else
+#define tg3_phy_string(TP) "?"
+#endif
+
+
+static void tg3_poll_link(struct tg3 *tp)
+{
+	uint32_t mac_stat;
+
+	mac_stat = tr32(MAC_STATUS);
+	if (tp->phy_id == PHY_ID_SERDES) {
+		if (tp->carrier_ok?
+			(mac_stat & MAC_STATUS_LNKSTATE_CHANGED):
+			(mac_stat & MAC_STATUS_PCS_SYNCED)) {
+			tw32_carefully(MAC_MODE, tp->mac_mode & ~MAC_MODE_PORT_MODE_MASK);
+			tw32_carefully(MAC_MODE, tp->mac_mode);
+
+			tg3_setup_phy(tp);
+		}
+	}
+	else {
+		if (mac_stat & MAC_STATUS_LNKSTATE_CHANGED) {
+			tg3_setup_phy(tp);
+		}
+	}
+}
+
+/**************************************************************************
+POLL - Wait for a frame
+***************************************************************************/
+static void tg3_ack_irqs(struct tg3 *tp)
+{
+	if (tp->hw_status->status & SD_STATUS_UPDATED) {
+		/*
+		 * writing any value to intr-mbox-0 clears PCI INTA# and
+		 * chip-internal interrupt pending events.
+		 * writing non-zero to intr-mbox-0 additional tells the
+		 * NIC to stop sending us irqs, engaging "in-intr-handler"
+		 * event coalescing.
+		 */
+		tw32_mailbox(MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW, 
+			0x00000001);
+		/*
+		 * Flush PCI write.  This also guarantees that our
+		 * status block has been flushed to host memory.
+		 */
+		tr32(MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW);
+		tp->hw_status->status &= ~SD_STATUS_UPDATED;
+	}
+}
+
+static int tg3_poll(struct nic *nic, int retrieve)
+{
+	/* return true if there's an ethernet packet ready to read */
+	/* nic->packet should contain data on return */
+	/* nic->packetlen should contain length of data */
+
+	struct tg3 *tp = &tg3;
+	int result;
+
+	result = 0;
+
+	if ( (tp->hw_status->idx[0].rx_producer != tp->rx_rcb_ptr) && !retrieve ) 
+	  return 1;
+
+	tg3_ack_irqs(tp);
+
+	if (tp->hw_status->idx[0].rx_producer != tp->rx_rcb_ptr) {
+		struct tg3_rx_buffer_desc *desc;
+		unsigned int len;
+		desc = &tp->rx_rcb[tp->rx_rcb_ptr];
+		if ((desc->opaque & RXD_OPAQUE_RING_MASK) == RXD_OPAQUE_RING_STD) {
+			len = ((desc->idx_len & RXD_LEN_MASK) >> RXD_LEN_SHIFT) - 4; /* omit crc */
+			
+			nic->packetlen = len;
+			memcpy(nic->packet, bus_to_virt(desc->addr_lo), len);
+			result = 1;
+		}
+		tp->rx_rcb_ptr = (tp->rx_rcb_ptr + 1) % TG3_RX_RCB_RING_SIZE;
+		
+		/* ACK the status ring */
+		tw32_mailbox2(MAILBOX_RCVRET_CON_IDX_0 + TG3_64BIT_REG_LOW, tp->rx_rcb_ptr);
+
+		/* Refill RX ring. */
+		if (result) {
+			tp->rx_std_ptr = (tp->rx_std_ptr + 1) % TG3_RX_RING_SIZE;
+			tw32_mailbox2(MAILBOX_RCV_STD_PROD_IDX + TG3_64BIT_REG_LOW, tp->rx_std_ptr);
+		}
+	}
+	tg3_poll_link(tp);
+	return result;
+}
+
+/**************************************************************************
+TRANSMIT - Transmit a frame
+***************************************************************************/
+#if 0
+static void tg3_set_txd(struct tg3 *tp, int entry,
+	dma_addr_t mapping, int len, uint32_t flags,
+	uint32_t mss_and_is_end)
+{
+	struct tg3_tx_buffer_desc *txd =  &tp->tx_ring[entry];
+	int is_end = (mss_and_is_end & 0x1);
+	if (is_end) {
+		flags |= TXD_FLAG_END;
+	}
+
+	txd->addr_hi   = 0;
+	txd->addr_lo   = mapping & 0xffffffff;
+	txd->len_flags = (len << TXD_LEN_SHIFT) | flags;
+	txd->vlan_tag  = 0 << TXD_VLAN_TAG_SHIFT;
+}
+#endif
+
+static void tg3_transmit(struct nic *nic, const char *dst_addr,
+	unsigned int type, unsigned int size, const char *packet)
+{
+	static struct eth_frame {
+		uint8_t  dst_addr[ETH_ALEN];
+		uint8_t  src_addr[ETH_ALEN];
+		uint16_t type;
+		uint8_t  data [ETH_FRAME_LEN - ETH_HLEN];
+	} frame[2];
+	static int frame_idx;
+	
+	/* send the packet to destination */
+	struct tg3_tx_buffer_desc *txd;
+	struct tg3 *tp;
+	uint32_t entry;
+	int i;
+
+	/* Wait until there is a free packet frame */
+	tp = &tg3;
+	i = 0;
+	entry = tp->tx_prod;
+	while((tp->hw_status->idx[0].tx_consumer != entry) &&
+		(tp->hw_status->idx[0].tx_consumer != PREV_TX(entry))) {
+		mdelay(10);	/* give the nick a chance */
+		poll_interruptions();
+		if (++i > 500) { /* timeout 5s for transmit */
+			printf("transmit timed out\n");
+			tg3_halt(tp);
+			tg3_setup_hw(tp);
+			return;
+		}
+	}
+	if (i != 0) {
+		printf("#");
+	}
+	
+	/* Copy the packet to the our local buffer */
+	memcpy(&frame[frame_idx].dst_addr, dst_addr, ETH_ALEN);
+	memcpy(&frame[frame_idx].src_addr, nic->node_addr, ETH_ALEN);
+	frame[frame_idx].type = htons(type);
+	memset(&frame[frame_idx].data, 0, sizeof(frame[frame_idx].data));
+	memcpy(&frame[frame_idx].data, packet, size);
+
+	/* Setup the ring buffer entry to transmit */
+	txd            = &tp->tx_ring[entry];
+	txd->addr_hi   = 0; /* Etherboot runs under 4GB */
+	txd->addr_lo   = virt_to_bus(&frame[frame_idx]);
+	txd->len_flags = ((size + ETH_HLEN) << TXD_LEN_SHIFT) | TXD_FLAG_END;
+	txd->vlan_tag  = 0 << TXD_VLAN_TAG_SHIFT;
+
+	/* Advance to the next entry */
+	entry = NEXT_TX(entry);
+	frame_idx ^= 1;
+
+	/* Packets are ready, update Tx producer idx local and on card */
+	tw32_mailbox((MAILBOX_SNDHOST_PROD_IDX_0 + TG3_64BIT_REG_LOW), entry);
+	tw32_mailbox2((MAILBOX_SNDHOST_PROD_IDX_0 + TG3_64BIT_REG_LOW), entry);
+	tp->tx_prod = entry;
+}
+
+/**************************************************************************
+DISABLE - Turn off ethernet interface
+***************************************************************************/
+static void tg3_disable(struct dev *dev __unused)
+{
+	struct tg3 *tp = &tg3;
+	/* put the card in its initial state */
+	/* This function serves 3 purposes.
+	 * This disables DMA and interrupts so we don't receive
+	 *  unexpected packets or interrupts from the card after
+	 *  etherboot has finished. 
+	 * This frees resources so etherboot may use
+	 *  this driver on another interface
+	 * This allows etherboot to reinitialize the interface
+	 *  if something is something goes wrong.
+	 */
+	tg3_halt(tp);
+	tp->tg3_flags &= ~(TG3_FLAG_INIT_COMPLETE|TG3_FLAG_GOT_SERDES_FLOWCTL);
+	tp->carrier_ok = 0;
+	iounmap((void *)tp->regs);
+}
+
+/**************************************************************************
+IRQ - Enable, Disable, or Force interrupts
+***************************************************************************/
+static void tg3_irq(struct nic *nic __unused, irq_action_t action __unused)
+{
+  switch ( action ) {
+  case DISABLE :
+    break;
+  case ENABLE :
+    break;
+  case FORCE :
+    break;
+  }
+}
+
+/**************************************************************************
+PROBE - Look for an adapter, this routine's visible to the outside
+You should omit the last argument struct pci_device * for a non-PCI NIC
+***************************************************************************/
+static int tg3_probe(struct dev *dev, struct pci_device *pdev)
+{
+	struct nic *nic = (struct nic *)dev;
+	struct tg3 *tp = &tg3;
+	unsigned long tg3reg_base, tg3reg_len;
+	int i, err, pm_cap;
+
+	if (pdev == 0)
+		return 0;
+
+	memset(tp, 0, sizeof(*tp));
+
+	adjust_pci_device(pdev);
+
+	nic->irqno  = 0;
+	nic->ioaddr = pdev->ioaddr & ~3;
+
+	/* Find power-management capability. */
+	pm_cap = pci_find_capability(pdev, PCI_CAP_ID_PM);
+	if (pm_cap == 0) {
+		printf("Cannot find PowerManagement capability, aborting.\n");
+		return 0;
+	}
+	tg3reg_base = pci_bar_start(pdev, PCI_BASE_ADDRESS_0);
+	if (tg3reg_base == -1UL) {
+		printf("Unuseable bar\n");
+		return 0;
+	}
+	tg3reg_len  = pci_bar_size(pdev,  PCI_BASE_ADDRESS_0);
+
+	tp->pdev       = pdev;
+	tp->nic        = nic;
+	tp->pm_cap     = pm_cap;
+	tp->rx_mode    = 0;
+	tp->tx_mode    = 0;
+	tp->mi_mode    = MAC_MI_MODE_BASE;
+	tp->tg3_flags  = 0 & ~TG3_FLAG_INIT_COMPLETE; 
+	
+	/* The word/byte swap controls here control register access byte
+	 * swapping.  DMA data byte swapping is controlled in the GRC_MODE
+	 * setting below.
+	 */
+	tp->misc_host_ctrl =
+		MISC_HOST_CTRL_MASK_PCI_INT |
+		MISC_HOST_CTRL_WORD_SWAP |
+		MISC_HOST_CTRL_INDIR_ACCESS |
+		MISC_HOST_CTRL_PCISTATE_RW;
+
+	/* The NONFRM (non-frame) byte/word swap controls take effect
+	 * on descriptor entries, anything which isn't packet data.
+	 *
+	 * The StrongARM chips on the board (one for tx, one for rx)
+	 * are running in big-endian mode.
+	 */
+	tp->grc_mode = (GRC_MODE_WSWAP_DATA | GRC_MODE_BSWAP_DATA |
+			GRC_MODE_WSWAP_NONFRM_DATA);
+#if __BYTE_ORDER == __BIG_ENDIAN
+	tp->grc_mode |= GRC_MODE_BSWAP_NONFRM_DATA;
+#endif
+	tp->regs = (unsigned long) ioremap(tg3reg_base, tg3reg_len);
+	if (tp->regs == 0UL) {
+		printf("Cannot map device registers, aborting\n");
+		return 0;
+	}
+
+	tg3_init_link_config(tp);
+
+	err = tg3_get_invariants(tp);
+	if (err) {
+		printf("Problem fetching invariants of chip, aborting.\n");
+		goto err_out_iounmap;
+	}
+
+	err = tg3_get_device_address(tp);
+	if (err) {
+		printf("Could not obtain valid ethernet address, aborting.\n");
+		goto err_out_iounmap;
+	}
+	printf("Ethernet addr: %!\n", nic->node_addr);
+
+	tg3_setup_dma(tp);
+
+	/* Now that we have fully setup the chip, save away a snapshot
+	 * of the PCI config space.  We need to restore this after
+	 * GRC_MISC_CFG core clock resets and some resume events.
+	 */
+	pci_save_state(tp->pdev, tp->pci_cfg_state);
+
+	printf("Tigon3 [partno(%s) rev %hx PHY(%s)] (PCI%s:%s:%s)\n",
+		tp->board_part_number,
+		tp->pci_chip_rev_id,
+		tg3_phy_string(tp),
+		((tp->tg3_flags & TG3_FLAG_PCIX_MODE) ? "X" : ""),
+		((tp->tg3_flags & TG3_FLAG_PCI_HIGH_SPEED) ?
+			((tp->tg3_flags & TG3_FLAG_PCIX_MODE) ? "133MHz" : "66MHz") :
+			((tp->tg3_flags & TG3_FLAG_PCIX_MODE) ? "100MHz" : "33MHz")),
+		((tp->tg3_flags & TG3_FLAG_PCI_32BIT) ? "32-bit" : "64-bit"));
+
+
+	err = tg3_setup_hw(tp); 
+	if (err) {
+		goto err_out_disable;
+	} 
+	tp->tg3_flags |= TG3_FLAG_INIT_COMPLETE;
+
+	/* Wait for a reasonable time for the link to come up */
+	tg3_poll_link(tp);
+	for(i = 0; !tp->carrier_ok && (i < VALID_LINK_TIMEOUT*100); i++) {
+		mdelay(1);
+		tg3_poll_link(tp);
+	}
+	if (!tp->carrier_ok){
+		printf("Valid link not established\n");
+		goto err_out_disable;
+	}
+
+	dev->disable  = tg3_disable;
+	nic->poll     = tg3_poll;
+	nic->transmit = tg3_transmit;
+	nic->irq      = tg3_irq;
+
+	return 1;
+
+ err_out_iounmap:
+	iounmap((void *)tp->regs);
+	return 0;
+ err_out_disable:
+	tg3_disable(dev);
+	return 0;
+}
+
+static struct pci_id tg3_nics[] = {
+PCI_ROM(0x14e4, 0x1644, "tg3-5700",        "Broadcom Tigon 3 5700"),
+PCI_ROM(0x14e4, 0x1645, "tg3-5701",        "Broadcom Tigon 3 5701"),
+PCI_ROM(0x14e4, 0x1646, "tg3-5702",        "Broadcom Tigon 3 5702"),
+PCI_ROM(0x14e4, 0x1647, "tg3-5703",        "Broadcom Tigon 3 5703"),
+PCI_ROM(0x14e4, 0x1648, "tg3-5704",        "Broadcom Tigon 3 5704"),
+PCI_ROM(0x14e4, 0x164d, "tg3-5702FE",      "Broadcom Tigon 3 5702FE"),
+PCI_ROM(0x14e4, 0x1653, "tg3-5705",        "Broadcom Tigon 3 5705"),
+PCI_ROM(0x14e4, 0x1654, "tg3-5705_2",      "Broadcom Tigon 3 5705_2"),
+PCI_ROM(0x14e4, 0x165d, "tg3-5705M",       "Broadcom Tigon 3 5705M"),
+PCI_ROM(0x14e4, 0x165e, "tg3-5705M_2",     "Broadcom Tigon 3 5705M_2"),
+PCI_ROM(0x14e4, 0x1696, "tg3-5782",        "Broadcom Tigon 3 5782"),
+PCI_ROM(0x14e4, 0x169c, "tg3-5788",        "Broadcom Tigon 3 5788"),
+PCI_ROM(0x14e4, 0x16a6, "tg3-5702X",       "Broadcom Tigon 3 5702X"),
+PCI_ROM(0x14e4, 0x16a7, "tg3-5703X",       "Broadcom Tigon 3 5703X"),
+PCI_ROM(0x14e4, 0x16a8, "tg3-5704S",       "Broadcom Tigon 3 5704S"),
+PCI_ROM(0x14e4, 0x16c6, "tg3-5702A3",      "Broadcom Tigon 3 5702A3"),
+PCI_ROM(0x14e4, 0x16c7, "tg3-5703A3",      "Broadcom Tigon 3 5703A3"),
+PCI_ROM(0x14e4, 0x170d, "tg3-5901",        "Broadcom Tigon 3 5901"),
+PCI_ROM(0x14e4, 0x170e, "tg3-5901_2",      "Broadcom Tigon 3 5901_2"),
+PCI_ROM(0x1148, 0x4400, "tg3-9DXX",        "Syskonnect 9DXX"),
+PCI_ROM(0x1148, 0x4500, "tg3-9MXX",        "Syskonnect 9MXX"),
+PCI_ROM(0x173b, 0x03e8, "tg3-ac1000",      "Altima AC1000"),
+PCI_ROM(0x173b, 0x03e9, "tg3-ac1001",      "Altima AC1001"),
+PCI_ROM(0x173b, 0x03ea, "tg3-ac9100",      "Altima AC9100"),
+PCI_ROM(0x173b, 0x03eb, "tg3-ac1003",      "Altima AC1003"),
+};
+
+struct pci_driver tg3_driver = {
+	.type	  = NIC_DRIVER,
+	.name	  = "TG3",
+	.probe	  = tg3_probe,
+	.ids	  = tg3_nics,
+	.id_count = sizeof(tg3_nics)/sizeof(tg3_nics[0]),
+	.class    = 0,
+};
diff -Naur grub-0.97.orig/netboot/tg3.h grub-0.97/netboot/tg3.h
--- grub-0.97.orig/netboot/tg3.h	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/tg3.h	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,2203 @@
+/* $Id: grub-0.95-diskless-patch-2.patch,v 1.1.1.1 2005/06/14 08:18:50 wesolows Exp $
+ * tg3.h: Definitions for Broadcom Tigon3 ethernet driver.
+ *
+ * Copyright (C) 2001, 2002 David S. Miller (davem@redhat.com)
+ * Copyright (C) 2001 Jeff Garzik (jgarzik@mandrakesoft.com)
+ */
+
+#ifndef _T3_H
+#define _T3_H
+
+#include "stdint.h"
+
+typedef unsigned long dma_addr_t;
+
+/* From mii.h */
+
+/* Indicates what features are advertised by the interface. */
+#define ADVERTISED_10baseT_Half		(1 << 0)
+#define ADVERTISED_10baseT_Full		(1 << 1)
+#define ADVERTISED_100baseT_Half	(1 << 2)
+#define ADVERTISED_100baseT_Full	(1 << 3)
+#define ADVERTISED_1000baseT_Half	(1 << 4)
+#define ADVERTISED_1000baseT_Full	(1 << 5)
+#define ADVERTISED_Autoneg		(1 << 6)
+#define ADVERTISED_TP			(1 << 7)
+#define ADVERTISED_AUI			(1 << 8)
+#define ADVERTISED_MII			(1 << 9)
+#define ADVERTISED_FIBRE		(1 << 10)
+#define ADVERTISED_BNC			(1 << 11)
+
+/* The following are all involved in forcing a particular link
+ * mode for the device for setting things.  When getting the
+ * devices settings, these indicate the current mode and whether
+ * it was foced up into this mode or autonegotiated.
+ */
+
+/* The forced speed, 10Mb, 100Mb, gigabit. */
+#define SPEED_10		0
+#define SPEED_100		1
+#define SPEED_1000		2
+#define SPEED_INVALID           3
+
+
+/* Duplex, half or full. */
+#define DUPLEX_HALF		0x00
+#define DUPLEX_FULL		0x01
+#define DUPLEX_INVALID          0x02
+
+/* Which connector port. */
+#define PORT_TP			0x00
+#define PORT_AUI		0x01
+#define PORT_MII		0x02
+#define PORT_FIBRE		0x03
+#define PORT_BNC		0x04
+
+/* Which tranceiver to use. */
+#define XCVR_INTERNAL		0x00
+#define XCVR_EXTERNAL		0x01
+#define XCVR_DUMMY1		0x02
+#define XCVR_DUMMY2		0x03
+#define XCVR_DUMMY3		0x04
+
+/* Enable or disable autonegotiation.  If this is set to enable,
+ * the forced link modes above are completely ignored.
+ */
+#define AUTONEG_DISABLE		0x00
+#define AUTONEG_ENABLE		0x01
+
+/* Wake-On-Lan options. */
+#define WAKE_PHY		(1 << 0)
+#define WAKE_UCAST		(1 << 1)
+#define WAKE_MCAST		(1 << 2)
+#define WAKE_BCAST		(1 << 3)
+#define WAKE_ARP		(1 << 4)
+#define WAKE_MAGIC		(1 << 5)
+#define WAKE_MAGICSECURE	(1 << 6) /* only meaningful if WAKE_MAGIC */
+
+/* Generic MII registers. */
+
+#define MII_BMCR            0x00        /* Basic mode control register */
+#define MII_BMSR            0x01        /* Basic mode status register  */
+#define MII_PHYSID1         0x02        /* PHYS ID 1                   */
+#define MII_PHYSID2         0x03        /* PHYS ID 2                   */
+#define MII_ADVERTISE       0x04        /* Advertisement control reg   */
+#define MII_LPA             0x05        /* Link partner ability reg    */
+#define MII_EXPANSION       0x06        /* Expansion register          */
+#define MII_DCOUNTER        0x12        /* Disconnect counter          */
+#define MII_FCSCOUNTER      0x13        /* False carrier counter       */
+#define MII_NWAYTEST        0x14        /* N-way auto-neg test reg     */
+#define MII_RERRCOUNTER     0x15        /* Receive error counter       */
+#define MII_SREVISION       0x16        /* Silicon revision            */
+#define MII_RESV1           0x17        /* Reserved...                 */
+#define MII_LBRERROR        0x18        /* Lpback, rx, bypass error    */
+#define MII_PHYADDR         0x19        /* PHY address                 */
+#define MII_RESV2           0x1a        /* Reserved...                 */
+#define MII_TPISTATUS       0x1b        /* TPI status for 10mbps       */
+#define MII_NCONFIG         0x1c        /* Network interface config    */
+
+/* Basic mode control register. */
+#define BMCR_RESV               0x007f  /* Unused...                   */
+#define BMCR_CTST               0x0080  /* Collision test              */
+#define BMCR_FULLDPLX           0x0100  /* Full duplex                 */
+#define BMCR_ANRESTART          0x0200  /* Auto negotiation restart    */
+#define BMCR_ISOLATE            0x0400  /* Disconnect DP83840 from MII */
+#define BMCR_PDOWN              0x0800  /* Powerdown the DP83840       */
+#define BMCR_ANENABLE           0x1000  /* Enable auto negotiation     */
+#define BMCR_SPEED100           0x2000  /* Select 100Mbps              */
+#define BMCR_LOOPBACK           0x4000  /* TXD loopback bits           */
+#define BMCR_RESET              0x8000  /* Reset the DP83840           */
+
+/* Basic mode status register. */
+#define BMSR_ERCAP              0x0001  /* Ext-reg capability          */
+#define BMSR_JCD                0x0002  /* Jabber detected             */
+#define BMSR_LSTATUS            0x0004  /* Link status                 */
+#define BMSR_ANEGCAPABLE        0x0008  /* Able to do auto-negotiation */
+#define BMSR_RFAULT             0x0010  /* Remote fault detected       */
+#define BMSR_ANEGCOMPLETE       0x0020  /* Auto-negotiation complete   */
+#define BMSR_RESV               0x07c0  /* Unused...                   */
+#define BMSR_10HALF             0x0800  /* Can do 10mbps, half-duplex  */
+#define BMSR_10FULL             0x1000  /* Can do 10mbps, full-duplex  */
+#define BMSR_100HALF            0x2000  /* Can do 100mbps, half-duplex */
+#define BMSR_100FULL            0x4000  /* Can do 100mbps, full-duplex */
+#define BMSR_100BASE4           0x8000  /* Can do 100mbps, 4k packets  */
+
+/* Advertisement control register. */
+#define ADVERTISE_SLCT          0x001f  /* Selector bits               */
+#define ADVERTISE_CSMA          0x0001  /* Only selector supported     */
+#define ADVERTISE_10HALF        0x0020  /* Try for 10mbps half-duplex  */
+#define ADVERTISE_10FULL        0x0040  /* Try for 10mbps full-duplex  */
+#define ADVERTISE_100HALF       0x0080  /* Try for 100mbps half-duplex */
+#define ADVERTISE_100FULL       0x0100  /* Try for 100mbps full-duplex */
+#define ADVERTISE_100BASE4      0x0200  /* Try for 100mbps 4k packets  */
+#define ADVERTISE_RESV          0x1c00  /* Unused...                   */
+#define ADVERTISE_RFAULT        0x2000  /* Say we can detect faults    */
+#define ADVERTISE_LPACK         0x4000  /* Ack link partners response  */
+#define ADVERTISE_NPAGE         0x8000  /* Next page bit               */
+
+#define ADVERTISE_FULL (ADVERTISE_100FULL | ADVERTISE_10FULL | \
+			ADVERTISE_CSMA)
+#define ADVERTISE_ALL (ADVERTISE_10HALF | ADVERTISE_10FULL | \
+                       ADVERTISE_100HALF | ADVERTISE_100FULL)
+
+/* Link partner ability register. */
+#define LPA_SLCT                0x001f  /* Same as advertise selector  */
+#define LPA_10HALF              0x0020  /* Can do 10mbps half-duplex   */
+#define LPA_10FULL              0x0040  /* Can do 10mbps full-duplex   */
+#define LPA_100HALF             0x0080  /* Can do 100mbps half-duplex  */
+#define LPA_100FULL             0x0100  /* Can do 100mbps full-duplex  */
+#define LPA_100BASE4            0x0200  /* Can do 100mbps 4k packets   */
+#define LPA_RESV                0x1c00  /* Unused...                   */
+#define LPA_RFAULT              0x2000  /* Link partner faulted        */
+#define LPA_LPACK               0x4000  /* Link partner acked us       */
+#define LPA_NPAGE               0x8000  /* Next page bit               */
+
+#define LPA_DUPLEX		(LPA_10FULL | LPA_100FULL)
+#define LPA_100			(LPA_100FULL | LPA_100HALF | LPA_100BASE4)
+
+/* Expansion register for auto-negotiation. */
+#define EXPANSION_NWAY          0x0001  /* Can do N-way auto-nego      */
+#define EXPANSION_LCWP          0x0002  /* Got new RX page code word   */
+#define EXPANSION_ENABLENPAGE   0x0004  /* This enables npage words    */
+#define EXPANSION_NPCAPABLE     0x0008  /* Link partner supports npage */
+#define EXPANSION_MFAULTS       0x0010  /* Multiple faults detected    */
+#define EXPANSION_RESV          0xffe0  /* Unused...                   */
+
+/* N-way test register. */
+#define NWAYTEST_RESV1          0x00ff  /* Unused...                   */
+#define NWAYTEST_LOOPBACK       0x0100  /* Enable loopback for N-way   */
+#define NWAYTEST_RESV2          0xfe00  /* Unused...                   */
+
+
+/* From tg3.h */
+
+#define TG3_64BIT_REG_HIGH		0x00UL
+#define TG3_64BIT_REG_LOW		0x04UL
+
+/* Descriptor block info. */
+#define TG3_BDINFO_HOST_ADDR		0x0UL /* 64-bit */
+#define TG3_BDINFO_MAXLEN_FLAGS		0x8UL /* 32-bit */
+#define  BDINFO_FLAGS_USE_EXT_RECV	 0x00000001 /* ext rx_buffer_desc */
+#define  BDINFO_FLAGS_DISABLED		 0x00000002
+#define  BDINFO_FLAGS_MAXLEN_MASK	 0xffff0000
+#define  BDINFO_FLAGS_MAXLEN_SHIFT	 16
+#define TG3_BDINFO_NIC_ADDR		0xcUL /* 32-bit */
+#define TG3_BDINFO_SIZE			0x10UL
+
+#define RX_COPY_THRESHOLD  		256
+
+#define RX_STD_MAX_SIZE			1536
+#define RX_STD_MAX_SIZE_5705		512
+#define RX_JUMBO_MAX_SIZE		0xdeadbeef /* XXX */
+
+/* First 256 bytes are a mirror of PCI config space. */
+#define TG3PCI_VENDOR			0x00000000
+#define  TG3PCI_VENDOR_BROADCOM		 0x14e4
+#define TG3PCI_DEVICE			0x00000002
+#define  TG3PCI_DEVICE_TIGON3_1		 0x1644 /* BCM5700 */
+#define  TG3PCI_DEVICE_TIGON3_2		 0x1645 /* BCM5701 */
+#define  TG3PCI_DEVICE_TIGON3_3		 0x1646 /* BCM5702 */
+#define  TG3PCI_DEVICE_TIGON3_4		 0x1647 /* BCM5703 */
+#define TG3PCI_COMMAND			0x00000004
+#define TG3PCI_STATUS			0x00000006
+#define TG3PCI_CCREVID			0x00000008
+#define TG3PCI_CACHELINESZ		0x0000000c
+#define TG3PCI_LATTIMER			0x0000000d
+#define TG3PCI_HEADERTYPE		0x0000000e
+#define TG3PCI_BIST			0x0000000f
+#define TG3PCI_BASE0_LOW		0x00000010
+#define TG3PCI_BASE0_HIGH		0x00000014
+/* 0x18 --> 0x2c unused */
+#define TG3PCI_SUBSYSVENID		0x0000002c
+#define TG3PCI_SUBSYSID			0x0000002e
+#define TG3PCI_ROMADDR			0x00000030
+#define TG3PCI_CAPLIST			0x00000034
+/* 0x35 --> 0x3c unused */
+#define TG3PCI_IRQ_LINE			0x0000003c
+#define TG3PCI_IRQ_PIN			0x0000003d
+#define TG3PCI_MIN_GNT			0x0000003e
+#define TG3PCI_MAX_LAT			0x0000003f
+#define TG3PCI_X_CAPS			0x00000040
+#define  PCIX_CAPS_RELAXED_ORDERING	 0x00020000
+#define  PCIX_CAPS_SPLIT_MASK		 0x00700000
+#define  PCIX_CAPS_SPLIT_SHIFT		 20
+#define  PCIX_CAPS_BURST_MASK		 0x000c0000
+#define  PCIX_CAPS_BURST_SHIFT		 18
+#define  PCIX_CAPS_MAX_BURST_CPIOB	 2
+#define TG3PCI_PM_CAP_PTR		0x00000041
+#define TG3PCI_X_COMMAND		0x00000042
+#define TG3PCI_X_STATUS			0x00000044
+#define TG3PCI_PM_CAP_ID		0x00000048
+#define TG3PCI_VPD_CAP_PTR		0x00000049
+#define TG3PCI_PM_CAPS			0x0000004a
+#define TG3PCI_PM_CTRL_STAT		0x0000004c
+#define TG3PCI_BR_SUPP_EXT		0x0000004e
+#define TG3PCI_PM_DATA			0x0000004f
+#define TG3PCI_VPD_CAP_ID		0x00000050
+#define TG3PCI_MSI_CAP_PTR		0x00000051
+#define TG3PCI_VPD_ADDR_FLAG		0x00000052
+#define  VPD_ADDR_FLAG_WRITE		0x00008000
+#define TG3PCI_VPD_DATA			0x00000054
+#define TG3PCI_MSI_CAP_ID		0x00000058
+#define TG3PCI_NXT_CAP_PTR		0x00000059
+#define TG3PCI_MSI_CTRL			0x0000005a
+#define TG3PCI_MSI_ADDR_LOW		0x0000005c
+#define TG3PCI_MSI_ADDR_HIGH		0x00000060
+#define TG3PCI_MSI_DATA			0x00000064
+/* 0x66 --> 0x68 unused */
+#define TG3PCI_MISC_HOST_CTRL		0x00000068
+#define  MISC_HOST_CTRL_CLEAR_INT	 0x00000001
+#define  MISC_HOST_CTRL_MASK_PCI_INT	 0x00000002
+#define  MISC_HOST_CTRL_BYTE_SWAP	 0x00000004
+#define  MISC_HOST_CTRL_WORD_SWAP	 0x00000008
+#define  MISC_HOST_CTRL_PCISTATE_RW	 0x00000010
+#define  MISC_HOST_CTRL_CLKREG_RW	 0x00000020
+#define  MISC_HOST_CTRL_REGWORD_SWAP	 0x00000040
+#define  MISC_HOST_CTRL_INDIR_ACCESS	 0x00000080
+#define  MISC_HOST_CTRL_IRQ_MASK_MODE	 0x00000100
+#define  MISC_HOST_CTRL_TAGGED_STATUS	 0x00000200
+#define  MISC_HOST_CTRL_CHIPREV		 0xffff0000
+#define  MISC_HOST_CTRL_CHIPREV_SHIFT	 16
+#define  GET_CHIP_REV_ID(MISC_HOST_CTRL) \
+	 (((MISC_HOST_CTRL) & MISC_HOST_CTRL_CHIPREV) >> \
+	  MISC_HOST_CTRL_CHIPREV_SHIFT)
+#define  CHIPREV_ID_5700_A0		 0x7000
+#define  CHIPREV_ID_5700_A1		 0x7001
+#define  CHIPREV_ID_5700_B0		 0x7100
+#define  CHIPREV_ID_5700_B1		 0x7101
+#define  CHIPREV_ID_5700_B3		 0x7102
+#define  CHIPREV_ID_5700_ALTIMA		 0x7104
+#define  CHIPREV_ID_5700_C0		 0x7200
+#define  CHIPREV_ID_5701_A0		 0x0000
+#define  CHIPREV_ID_5701_B0		 0x0100
+#define  CHIPREV_ID_5701_B2		 0x0102
+#define  CHIPREV_ID_5701_B5		 0x0105
+#define  CHIPREV_ID_5703_A0		 0x1000
+#define  CHIPREV_ID_5703_A1		 0x1001
+#define  CHIPREV_ID_5703_A2		 0x1002
+#define  CHIPREV_ID_5703_A3		 0x1003
+#define  CHIPREV_ID_5704_A0		 0x2000
+#define  CHIPREV_ID_5704_A1		 0x2001
+#define  CHIPREV_ID_5704_A2		 0x2002
+#define  CHIPREV_ID_5705_A0		 0x3000
+#define  CHIPREV_ID_5705_A1		 0x3001
+#define	 CHIPREV_ID_5705_A2              0x3002
+#define  CHIPREV_ID_5705_A3              0x3003
+#define  GET_ASIC_REV(CHIP_REV_ID)	((CHIP_REV_ID) >> 12)
+#define   ASIC_REV_5700			 0x07
+#define   ASIC_REV_5701			 0x00
+#define   ASIC_REV_5703			 0x01
+#define   ASIC_REV_5704			 0x02
+#define   ASIC_REV_5705			 0x03
+#define  GET_CHIP_REV(CHIP_REV_ID)	((CHIP_REV_ID) >> 8)
+#define   CHIPREV_5700_AX		 0x70
+#define   CHIPREV_5700_BX		 0x71
+#define   CHIPREV_5700_CX		 0x72
+#define   CHIPREV_5701_AX		 0x00
+#define  GET_METAL_REV(CHIP_REV_ID)	((CHIP_REV_ID) & 0xff)
+#define   METAL_REV_A0			 0x00
+#define   METAL_REV_A1			 0x01
+#define   METAL_REV_B0			 0x00
+#define   METAL_REV_B1			 0x01
+#define   METAL_REV_B2			 0x02
+#define TG3PCI_DMA_RW_CTRL		0x0000006c
+#define  DMA_RWCTRL_MIN_DMA		 0x000000ff
+#define  DMA_RWCTRL_MIN_DMA_SHIFT	 0
+#define  DMA_RWCTRL_READ_BNDRY_MASK	 0x00000700
+#define  DMA_RWCTRL_READ_BNDRY_DISAB	 0x00000000
+#define  DMA_RWCTRL_READ_BNDRY_16	 0x00000100
+#define  DMA_RWCTRL_READ_BNDRY_32	 0x00000200
+#define  DMA_RWCTRL_READ_BNDRY_64	 0x00000300
+#define  DMA_RWCTRL_READ_BNDRY_128	 0x00000400
+#define  DMA_RWCTRL_READ_BNDRY_256	 0x00000500
+#define  DMA_RWCTRL_READ_BNDRY_512	 0x00000600
+#define  DMA_RWCTRL_READ_BNDRY_1024	 0x00000700
+#define  DMA_RWCTRL_WRITE_BNDRY_MASK	 0x00003800
+#define  DMA_RWCTRL_WRITE_BNDRY_DISAB	 0x00000000
+#define  DMA_RWCTRL_WRITE_BNDRY_16	 0x00000800
+#define  DMA_RWCTRL_WRITE_BNDRY_32	 0x00001000
+#define  DMA_RWCTRL_WRITE_BNDRY_64	 0x00001800
+#define  DMA_RWCTRL_WRITE_BNDRY_128	 0x00002000
+#define  DMA_RWCTRL_WRITE_BNDRY_256	 0x00002800
+#define  DMA_RWCTRL_WRITE_BNDRY_512	 0x00003000
+#define  DMA_RWCTRL_WRITE_BNDRY_1024	 0x00003800
+#define  DMA_RWCTRL_ONE_DMA		 0x00004000
+#define  DMA_RWCTRL_READ_WATER		 0x00070000
+#define  DMA_RWCTRL_READ_WATER_SHIFT	 16
+#define  DMA_RWCTRL_WRITE_WATER		 0x00380000
+#define  DMA_RWCTRL_WRITE_WATER_SHIFT	 19
+#define  DMA_RWCTRL_USE_MEM_READ_MULT	 0x00400000
+#define  DMA_RWCTRL_ASSERT_ALL_BE	 0x00800000
+#define  DMA_RWCTRL_PCI_READ_CMD	 0x0f000000
+#define  DMA_RWCTRL_PCI_READ_CMD_SHIFT	 24
+#define  DMA_RWCTRL_PCI_WRITE_CMD	 0xf0000000
+#define  DMA_RWCTRL_PCI_WRITE_CMD_SHIFT	 28
+#define TG3PCI_PCISTATE			0x00000070
+#define  PCISTATE_FORCE_RESET		 0x00000001
+#define  PCISTATE_INT_NOT_ACTIVE	 0x00000002
+#define  PCISTATE_CONV_PCI_MODE		 0x00000004
+#define  PCISTATE_BUS_SPEED_HIGH	 0x00000008
+#define  PCISTATE_BUS_32BIT		 0x00000010
+#define  PCISTATE_ROM_ENABLE		 0x00000020
+#define  PCISTATE_ROM_RETRY_ENABLE	 0x00000040
+#define  PCISTATE_FLAT_VIEW		 0x00000100
+#define  PCISTATE_RETRY_SAME_DMA	 0x00002000
+#define TG3PCI_CLOCK_CTRL		0x00000074
+#define  CLOCK_CTRL_CORECLK_DISABLE	 0x00000200
+#define  CLOCK_CTRL_RXCLK_DISABLE	 0x00000400
+#define  CLOCK_CTRL_TXCLK_DISABLE	 0x00000800
+#define  CLOCK_CTRL_ALTCLK		 0x00001000
+#define  CLOCK_CTRL_PWRDOWN_PLL133	 0x00008000
+#define  CLOCK_CTRL_44MHZ_CORE		 0x00040000
+#define  CLOCK_CTRL_625_CORE		 0x00100000
+#define  CLOCK_CTRL_FORCE_CLKRUN	 0x00200000
+#define  CLOCK_CTRL_CLKRUN_OENABLE	 0x00400000
+#define  CLOCK_CTRL_DELAY_PCI_GRANT	 0x80000000
+#define TG3PCI_REG_BASE_ADDR		0x00000078
+#define TG3PCI_MEM_WIN_BASE_ADDR	0x0000007c
+#define TG3PCI_REG_DATA			0x00000080
+#define TG3PCI_MEM_WIN_DATA		0x00000084
+#define TG3PCI_MODE_CTRL		0x00000088
+#define TG3PCI_MISC_CFG			0x0000008c
+#define TG3PCI_MISC_LOCAL_CTRL		0x00000090
+/* 0x94 --> 0x98 unused */
+#define TG3PCI_STD_RING_PROD_IDX	0x00000098 /* 64-bit */
+#define TG3PCI_RCV_RET_RING_CON_IDX	0x000000a0 /* 64-bit */
+#define TG3PCI_SND_PROD_IDX		0x000000a8 /* 64-bit */
+/* 0xb0 --> 0x100 unused */
+
+/* 0x100 --> 0x200 unused */
+
+/* Mailbox registers */
+#define MAILBOX_INTERRUPT_0		0x00000200 /* 64-bit */
+#define MAILBOX_INTERRUPT_1		0x00000208 /* 64-bit */
+#define MAILBOX_INTERRUPT_2		0x00000210 /* 64-bit */
+#define MAILBOX_INTERRUPT_3		0x00000218 /* 64-bit */
+#define MAILBOX_GENERAL_0		0x00000220 /* 64-bit */
+#define MAILBOX_GENERAL_1		0x00000228 /* 64-bit */
+#define MAILBOX_GENERAL_2		0x00000230 /* 64-bit */
+#define MAILBOX_GENERAL_3		0x00000238 /* 64-bit */
+#define MAILBOX_GENERAL_4		0x00000240 /* 64-bit */
+#define MAILBOX_GENERAL_5		0x00000248 /* 64-bit */
+#define MAILBOX_GENERAL_6		0x00000250 /* 64-bit */
+#define MAILBOX_GENERAL_7		0x00000258 /* 64-bit */
+#define MAILBOX_RELOAD_STAT		0x00000260 /* 64-bit */
+#define MAILBOX_RCV_STD_PROD_IDX	0x00000268 /* 64-bit */
+#define MAILBOX_RCV_JUMBO_PROD_IDX	0x00000270 /* 64-bit */
+#define MAILBOX_RCV_MINI_PROD_IDX	0x00000278 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_0	0x00000280 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_1	0x00000288 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_2	0x00000290 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_3	0x00000298 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_4	0x000002a0 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_5	0x000002a8 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_6	0x000002b0 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_7	0x000002b8 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_8	0x000002c0 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_9	0x000002c8 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_10	0x000002d0 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_11	0x000002d8 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_12	0x000002e0 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_13	0x000002e8 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_14	0x000002f0 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_15	0x000002f8 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_0	0x00000300 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_1	0x00000308 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_2	0x00000310 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_3	0x00000318 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_4	0x00000320 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_5	0x00000328 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_6	0x00000330 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_7	0x00000338 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_8	0x00000340 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_9	0x00000348 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_10	0x00000350 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_11	0x00000358 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_12	0x00000360 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_13	0x00000368 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_14	0x00000370 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_15	0x00000378 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_0	0x00000380 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_1	0x00000388 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_2	0x00000390 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_3	0x00000398 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_4	0x000003a0 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_5	0x000003a8 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_6	0x000003b0 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_7	0x000003b8 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_8	0x000003c0 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_9	0x000003c8 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_10	0x000003d0 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_11	0x000003d8 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_12	0x000003e0 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_13	0x000003e8 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_14	0x000003f0 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_15	0x000003f8 /* 64-bit */
+
+/* MAC control registers */
+#define MAC_MODE			0x00000400
+#define  MAC_MODE_RESET			 0x00000001
+#define  MAC_MODE_HALF_DUPLEX		 0x00000002
+#define  MAC_MODE_PORT_MODE_MASK	 0x0000000c
+#define  MAC_MODE_PORT_MODE_TBI		 0x0000000c
+#define  MAC_MODE_PORT_MODE_GMII	 0x00000008
+#define  MAC_MODE_PORT_MODE_MII		 0x00000004
+#define  MAC_MODE_PORT_MODE_NONE	 0x00000000
+#define  MAC_MODE_PORT_INT_LPBACK	 0x00000010
+#define  MAC_MODE_TAGGED_MAC_CTRL	 0x00000080
+#define  MAC_MODE_TX_BURSTING		 0x00000100
+#define  MAC_MODE_MAX_DEFER		 0x00000200
+#define  MAC_MODE_LINK_POLARITY		 0x00000400
+#define  MAC_MODE_RXSTAT_ENABLE		 0x00000800
+#define  MAC_MODE_RXSTAT_CLEAR		 0x00001000
+#define  MAC_MODE_RXSTAT_FLUSH		 0x00002000
+#define  MAC_MODE_TXSTAT_ENABLE		 0x00004000
+#define  MAC_MODE_TXSTAT_CLEAR		 0x00008000
+#define  MAC_MODE_TXSTAT_FLUSH		 0x00010000
+#define  MAC_MODE_SEND_CONFIGS		 0x00020000
+#define  MAC_MODE_MAGIC_PKT_ENABLE	 0x00040000
+#define  MAC_MODE_ACPI_ENABLE		 0x00080000
+#define  MAC_MODE_MIP_ENABLE		 0x00100000
+#define  MAC_MODE_TDE_ENABLE		 0x00200000
+#define  MAC_MODE_RDE_ENABLE		 0x00400000
+#define  MAC_MODE_FHDE_ENABLE		 0x00800000
+#define MAC_STATUS			0x00000404
+#define  MAC_STATUS_PCS_SYNCED		 0x00000001
+#define  MAC_STATUS_SIGNAL_DET		 0x00000002
+#define  MAC_STATUS_RCVD_CFG		 0x00000004
+#define  MAC_STATUS_CFG_CHANGED		 0x00000008
+#define  MAC_STATUS_SYNC_CHANGED	 0x00000010
+#define  MAC_STATUS_PORT_DEC_ERR	 0x00000400
+#define  MAC_STATUS_LNKSTATE_CHANGED	 0x00001000
+#define  MAC_STATUS_MI_COMPLETION	 0x00400000
+#define  MAC_STATUS_MI_INTERRUPT	 0x00800000
+#define  MAC_STATUS_AP_ERROR		 0x01000000
+#define  MAC_STATUS_ODI_ERROR		 0x02000000
+#define  MAC_STATUS_RXSTAT_OVERRUN	 0x04000000
+#define  MAC_STATUS_TXSTAT_OVERRUN	 0x08000000
+#define MAC_EVENT			0x00000408
+#define  MAC_EVENT_PORT_DECODE_ERR	 0x00000400
+#define  MAC_EVENT_LNKSTATE_CHANGED	 0x00001000
+#define  MAC_EVENT_MI_COMPLETION	 0x00400000
+#define  MAC_EVENT_MI_INTERRUPT		 0x00800000
+#define  MAC_EVENT_AP_ERROR		 0x01000000
+#define  MAC_EVENT_ODI_ERROR		 0x02000000
+#define  MAC_EVENT_RXSTAT_OVERRUN	 0x04000000
+#define  MAC_EVENT_TXSTAT_OVERRUN	 0x08000000
+#define MAC_LED_CTRL			0x0000040c
+#define  LED_CTRL_LNKLED_OVERRIDE	 0x00000001
+#define  LED_CTRL_1000MBPS_ON		 0x00000002
+#define  LED_CTRL_100MBPS_ON		 0x00000004
+#define  LED_CTRL_10MBPS_ON		 0x00000008
+#define  LED_CTRL_TRAFFIC_OVERRIDE	 0x00000010
+#define  LED_CTRL_TRAFFIC_BLINK		 0x00000020
+#define  LED_CTRL_TRAFFIC_LED		 0x00000040
+#define  LED_CTRL_1000MBPS_STATUS	 0x00000080
+#define  LED_CTRL_100MBPS_STATUS	 0x00000100
+#define  LED_CTRL_10MBPS_STATUS		 0x00000200
+#define  LED_CTRL_TRAFFIC_STATUS	 0x00000400
+#define  LED_CTRL_MAC_MODE		 0x00000000
+#define  LED_CTRL_PHY_MODE_1		 0x00000800
+#define  LED_CTRL_PHY_MODE_2		 0x00001000
+#define  LED_CTRL_BLINK_RATE_MASK	 0x7ff80000
+#define  LED_CTRL_BLINK_RATE_SHIFT	 19
+#define  LED_CTRL_BLINK_PER_OVERRIDE	 0x00080000
+#define  LED_CTRL_BLINK_RATE_OVERRIDE	 0x80000000
+#define MAC_ADDR_0_HIGH			0x00000410 /* upper 2 bytes */
+#define MAC_ADDR_0_LOW			0x00000414 /* lower 4 bytes */
+#define MAC_ADDR_1_HIGH			0x00000418 /* upper 2 bytes */
+#define MAC_ADDR_1_LOW			0x0000041c /* lower 4 bytes */
+#define MAC_ADDR_2_HIGH			0x00000420 /* upper 2 bytes */
+#define MAC_ADDR_2_LOW			0x00000424 /* lower 4 bytes */
+#define MAC_ADDR_3_HIGH			0x00000428 /* upper 2 bytes */
+#define MAC_ADDR_3_LOW			0x0000042c /* lower 4 bytes */
+#define MAC_ACPI_MBUF_PTR		0x00000430
+#define MAC_ACPI_LEN_OFFSET		0x00000434
+#define  ACPI_LENOFF_LEN_MASK		 0x0000ffff
+#define  ACPI_LENOFF_LEN_SHIFT		 0
+#define  ACPI_LENOFF_OFF_MASK		 0x0fff0000
+#define  ACPI_LENOFF_OFF_SHIFT		 16
+#define MAC_TX_BACKOFF_SEED		0x00000438
+#define  TX_BACKOFF_SEED_MASK		 0x000003ff
+#define MAC_RX_MTU_SIZE			0x0000043c
+#define  RX_MTU_SIZE_MASK		 0x0000ffff
+#define MAC_PCS_TEST			0x00000440
+#define  PCS_TEST_PATTERN_MASK		 0x000fffff
+#define  PCS_TEST_PATTERN_SHIFT		 0
+#define  PCS_TEST_ENABLE		 0x00100000
+#define MAC_TX_AUTO_NEG			0x00000444
+#define  TX_AUTO_NEG_MASK		 0x0000ffff
+#define  TX_AUTO_NEG_SHIFT		 0
+#define MAC_RX_AUTO_NEG			0x00000448
+#define  RX_AUTO_NEG_MASK		 0x0000ffff
+#define  RX_AUTO_NEG_SHIFT		 0
+#define MAC_MI_COM			0x0000044c
+#define  MI_COM_CMD_MASK		 0x0c000000
+#define  MI_COM_CMD_WRITE		 0x04000000
+#define  MI_COM_CMD_READ		 0x08000000
+#define  MI_COM_READ_FAILED		 0x10000000
+#define  MI_COM_START			 0x20000000
+#define  MI_COM_BUSY			 0x20000000
+#define  MI_COM_PHY_ADDR_MASK		 0x03e00000
+#define  MI_COM_PHY_ADDR_SHIFT		 21
+#define  MI_COM_REG_ADDR_MASK		 0x001f0000
+#define  MI_COM_REG_ADDR_SHIFT		 16
+#define  MI_COM_DATA_MASK		 0x0000ffff
+#define MAC_MI_STAT			0x00000450
+#define  MAC_MI_STAT_LNKSTAT_ATTN_ENAB	 0x00000001
+#define MAC_MI_MODE			0x00000454
+#define  MAC_MI_MODE_CLK_10MHZ		 0x00000001
+#define  MAC_MI_MODE_SHORT_PREAMBLE	 0x00000002
+#define  MAC_MI_MODE_AUTO_POLL		 0x00000010
+#define  MAC_MI_MODE_CORE_CLK_62MHZ	 0x00008000
+#define  MAC_MI_MODE_BASE		 0x000c0000 /* XXX magic values XXX */
+#define MAC_AUTO_POLL_STATUS		0x00000458
+#define  MAC_AUTO_POLL_ERROR		 0x00000001
+#define MAC_TX_MODE			0x0000045c
+#define  TX_MODE_RESET			 0x00000001
+#define  TX_MODE_ENABLE			 0x00000002
+#define  TX_MODE_FLOW_CTRL_ENABLE	 0x00000010
+#define  TX_MODE_BIG_BCKOFF_ENABLE	 0x00000020
+#define  TX_MODE_LONG_PAUSE_ENABLE	 0x00000040
+#define MAC_TX_STATUS			0x00000460
+#define  TX_STATUS_XOFFED		 0x00000001
+#define  TX_STATUS_SENT_XOFF		 0x00000002
+#define  TX_STATUS_SENT_XON		 0x00000004
+#define  TX_STATUS_LINK_UP		 0x00000008
+#define  TX_STATUS_ODI_UNDERRUN		 0x00000010
+#define  TX_STATUS_ODI_OVERRUN		 0x00000020
+#define MAC_TX_LENGTHS			0x00000464
+#define  TX_LENGTHS_SLOT_TIME_MASK	 0x000000ff
+#define  TX_LENGTHS_SLOT_TIME_SHIFT	 0
+#define  TX_LENGTHS_IPG_MASK		 0x00000f00
+#define  TX_LENGTHS_IPG_SHIFT		 8
+#define  TX_LENGTHS_IPG_CRS_MASK	 0x00003000
+#define  TX_LENGTHS_IPG_CRS_SHIFT	 12
+#define MAC_RX_MODE			0x00000468
+#define  RX_MODE_RESET			 0x00000001
+#define  RX_MODE_ENABLE			 0x00000002
+#define  RX_MODE_FLOW_CTRL_ENABLE	 0x00000004
+#define  RX_MODE_KEEP_MAC_CTRL		 0x00000008
+#define  RX_MODE_KEEP_PAUSE		 0x00000010
+#define  RX_MODE_ACCEPT_OVERSIZED	 0x00000020
+#define  RX_MODE_ACCEPT_RUNTS		 0x00000040
+#define  RX_MODE_LEN_CHECK		 0x00000080
+#define  RX_MODE_PROMISC		 0x00000100
+#define  RX_MODE_NO_CRC_CHECK		 0x00000200
+#define  RX_MODE_KEEP_VLAN_TAG		 0x00000400
+#define MAC_RX_STATUS			0x0000046c
+#define  RX_STATUS_REMOTE_TX_XOFFED	 0x00000001
+#define  RX_STATUS_XOFF_RCVD		 0x00000002
+#define  RX_STATUS_XON_RCVD		 0x00000004
+#define MAC_HASH_REG_0			0x00000470
+#define MAC_HASH_REG_1			0x00000474
+#define MAC_HASH_REG_2			0x00000478
+#define MAC_HASH_REG_3			0x0000047c
+#define MAC_RCV_RULE_0			0x00000480
+#define MAC_RCV_VALUE_0			0x00000484
+#define MAC_RCV_RULE_1			0x00000488
+#define MAC_RCV_VALUE_1			0x0000048c
+#define MAC_RCV_RULE_2			0x00000490
+#define MAC_RCV_VALUE_2			0x00000494
+#define MAC_RCV_RULE_3			0x00000498
+#define MAC_RCV_VALUE_3			0x0000049c
+#define MAC_RCV_RULE_4			0x000004a0
+#define MAC_RCV_VALUE_4			0x000004a4
+#define MAC_RCV_RULE_5			0x000004a8
+#define MAC_RCV_VALUE_5			0x000004ac
+#define MAC_RCV_RULE_6			0x000004b0
+#define MAC_RCV_VALUE_6			0x000004b4
+#define MAC_RCV_RULE_7			0x000004b8
+#define MAC_RCV_VALUE_7			0x000004bc
+#define MAC_RCV_RULE_8			0x000004c0
+#define MAC_RCV_VALUE_8			0x000004c4
+#define MAC_RCV_RULE_9			0x000004c8
+#define MAC_RCV_VALUE_9			0x000004cc
+#define MAC_RCV_RULE_10			0x000004d0
+#define MAC_RCV_VALUE_10		0x000004d4
+#define MAC_RCV_RULE_11			0x000004d8
+#define MAC_RCV_VALUE_11		0x000004dc
+#define MAC_RCV_RULE_12			0x000004e0
+#define MAC_RCV_VALUE_12		0x000004e4
+#define MAC_RCV_RULE_13			0x000004e8
+#define MAC_RCV_VALUE_13		0x000004ec
+#define MAC_RCV_RULE_14			0x000004f0
+#define MAC_RCV_VALUE_14		0x000004f4
+#define MAC_RCV_RULE_15			0x000004f8
+#define MAC_RCV_VALUE_15		0x000004fc
+#define  RCV_RULE_DISABLE_MASK		 0x7fffffff
+#define MAC_RCV_RULE_CFG		0x00000500
+#define  RCV_RULE_CFG_DEFAULT_CLASS	0x00000008
+#define MAC_LOW_WMARK_MAX_RX_FRAME	0x00000504
+/* 0x508 --> 0x520 unused */
+#define MAC_HASHREGU_0			0x00000520
+#define MAC_HASHREGU_1			0x00000524
+#define MAC_HASHREGU_2			0x00000528
+#define MAC_HASHREGU_3			0x0000052c
+#define MAC_EXTADDR_0_HIGH		0x00000530
+#define MAC_EXTADDR_0_LOW		0x00000534
+#define MAC_EXTADDR_1_HIGH		0x00000538
+#define MAC_EXTADDR_1_LOW		0x0000053c
+#define MAC_EXTADDR_2_HIGH		0x00000540
+#define MAC_EXTADDR_2_LOW		0x00000544
+#define MAC_EXTADDR_3_HIGH		0x00000548
+#define MAC_EXTADDR_3_LOW		0x0000054c
+#define MAC_EXTADDR_4_HIGH		0x00000550
+#define MAC_EXTADDR_4_LOW		0x00000554
+#define MAC_EXTADDR_5_HIGH		0x00000558
+#define MAC_EXTADDR_5_LOW		0x0000055c
+#define MAC_EXTADDR_6_HIGH		0x00000560
+#define MAC_EXTADDR_6_LOW		0x00000564
+#define MAC_EXTADDR_7_HIGH		0x00000568
+#define MAC_EXTADDR_7_LOW		0x0000056c
+#define MAC_EXTADDR_8_HIGH		0x00000570
+#define MAC_EXTADDR_8_LOW		0x00000574
+#define MAC_EXTADDR_9_HIGH		0x00000578
+#define MAC_EXTADDR_9_LOW		0x0000057c
+#define MAC_EXTADDR_10_HIGH		0x00000580
+#define MAC_EXTADDR_10_LOW		0x00000584
+#define MAC_EXTADDR_11_HIGH		0x00000588
+#define MAC_EXTADDR_11_LOW		0x0000058c
+#define MAC_SERDES_CFG			0x00000590
+#define MAC_SERDES_STAT			0x00000594
+/* 0x598 --> 0x600 unused */
+#define MAC_TX_MAC_STATE_BASE		0x00000600 /* 16 bytes */
+#define MAC_RX_MAC_STATE_BASE		0x00000610 /* 20 bytes */
+/* 0x624 --> 0x800 unused */
+#define MAC_TX_STATS_OCTETS		0x00000800
+#define MAC_TX_STATS_RESV1		0x00000804
+#define MAC_TX_STATS_COLLISIONS		0x00000808
+#define MAC_TX_STATS_XON_SENT		0x0000080c
+#define MAC_TX_STATS_XOFF_SENT		0x00000810
+#define MAC_TX_STATS_RESV2		0x00000814
+#define MAC_TX_STATS_MAC_ERRORS		0x00000818
+#define MAC_TX_STATS_SINGLE_COLLISIONS	0x0000081c
+#define MAC_TX_STATS_MULT_COLLISIONS	0x00000820
+#define MAC_TX_STATS_DEFERRED		0x00000824
+#define MAC_TX_STATS_RESV3		0x00000828
+#define MAC_TX_STATS_EXCESSIVE_COL	0x0000082c
+#define MAC_TX_STATS_LATE_COL		0x00000830
+#define MAC_TX_STATS_RESV4_1		0x00000834
+#define MAC_TX_STATS_RESV4_2		0x00000838
+#define MAC_TX_STATS_RESV4_3		0x0000083c
+#define MAC_TX_STATS_RESV4_4		0x00000840
+#define MAC_TX_STATS_RESV4_5		0x00000844
+#define MAC_TX_STATS_RESV4_6		0x00000848
+#define MAC_TX_STATS_RESV4_7		0x0000084c
+#define MAC_TX_STATS_RESV4_8		0x00000850
+#define MAC_TX_STATS_RESV4_9		0x00000854
+#define MAC_TX_STATS_RESV4_10		0x00000858
+#define MAC_TX_STATS_RESV4_11		0x0000085c
+#define MAC_TX_STATS_RESV4_12		0x00000860
+#define MAC_TX_STATS_RESV4_13		0x00000864
+#define MAC_TX_STATS_RESV4_14		0x00000868
+#define MAC_TX_STATS_UCAST		0x0000086c
+#define MAC_TX_STATS_MCAST		0x00000870
+#define MAC_TX_STATS_BCAST		0x00000874
+#define MAC_TX_STATS_RESV5_1		0x00000878
+#define MAC_TX_STATS_RESV5_2		0x0000087c
+#define MAC_RX_STATS_OCTETS		0x00000880
+#define MAC_RX_STATS_RESV1		0x00000884
+#define MAC_RX_STATS_FRAGMENTS		0x00000888
+#define MAC_RX_STATS_UCAST		0x0000088c
+#define MAC_RX_STATS_MCAST		0x00000890
+#define MAC_RX_STATS_BCAST		0x00000894
+#define MAC_RX_STATS_FCS_ERRORS		0x00000898
+#define MAC_RX_STATS_ALIGN_ERRORS	0x0000089c
+#define MAC_RX_STATS_XON_PAUSE_RECVD	0x000008a0
+#define MAC_RX_STATS_XOFF_PAUSE_RECVD	0x000008a4
+#define MAC_RX_STATS_MAC_CTRL_RECVD	0x000008a8
+#define MAC_RX_STATS_XOFF_ENTERED	0x000008ac
+#define MAC_RX_STATS_FRAME_TOO_LONG	0x000008b0
+#define MAC_RX_STATS_JABBERS		0x000008b4
+#define MAC_RX_STATS_UNDERSIZE		0x000008b8
+/* 0x8bc --> 0xc00 unused */
+
+/* Send data initiator control registers */
+#define SNDDATAI_MODE			0x00000c00
+#define  SNDDATAI_MODE_RESET		 0x00000001
+#define  SNDDATAI_MODE_ENABLE		 0x00000002
+#define  SNDDATAI_MODE_STAT_OFLOW_ENAB	 0x00000004
+#define SNDDATAI_STATUS			0x00000c04
+#define  SNDDATAI_STATUS_STAT_OFLOW	 0x00000004
+#define SNDDATAI_STATSCTRL		0x00000c08
+#define  SNDDATAI_SCTRL_ENABLE		 0x00000001
+#define  SNDDATAI_SCTRL_FASTUPD		 0x00000002
+#define  SNDDATAI_SCTRL_CLEAR		 0x00000004
+#define  SNDDATAI_SCTRL_FLUSH		 0x00000008
+#define  SNDDATAI_SCTRL_FORCE_ZERO	 0x00000010
+#define SNDDATAI_STATSENAB		0x00000c0c
+#define SNDDATAI_STATSINCMASK		0x00000c10
+/* 0xc14 --> 0xc80 unused */
+#define SNDDATAI_COS_CNT_0		0x00000c80
+#define SNDDATAI_COS_CNT_1		0x00000c84
+#define SNDDATAI_COS_CNT_2		0x00000c88
+#define SNDDATAI_COS_CNT_3		0x00000c8c
+#define SNDDATAI_COS_CNT_4		0x00000c90
+#define SNDDATAI_COS_CNT_5		0x00000c94
+#define SNDDATAI_COS_CNT_6		0x00000c98
+#define SNDDATAI_COS_CNT_7		0x00000c9c
+#define SNDDATAI_COS_CNT_8		0x00000ca0
+#define SNDDATAI_COS_CNT_9		0x00000ca4
+#define SNDDATAI_COS_CNT_10		0x00000ca8
+#define SNDDATAI_COS_CNT_11		0x00000cac
+#define SNDDATAI_COS_CNT_12		0x00000cb0
+#define SNDDATAI_COS_CNT_13		0x00000cb4
+#define SNDDATAI_COS_CNT_14		0x00000cb8
+#define SNDDATAI_COS_CNT_15		0x00000cbc
+#define SNDDATAI_DMA_RDQ_FULL_CNT	0x00000cc0
+#define SNDDATAI_DMA_PRIO_RDQ_FULL_CNT	0x00000cc4
+#define SNDDATAI_SDCQ_FULL_CNT		0x00000cc8
+#define SNDDATAI_NICRNG_SSND_PIDX_CNT	0x00000ccc
+#define SNDDATAI_STATS_UPDATED_CNT	0x00000cd0
+#define SNDDATAI_INTERRUPTS_CNT		0x00000cd4
+#define SNDDATAI_AVOID_INTERRUPTS_CNT	0x00000cd8
+#define SNDDATAI_SND_THRESH_HIT_CNT	0x00000cdc
+/* 0xce0 --> 0x1000 unused */
+
+/* Send data completion control registers */
+#define SNDDATAC_MODE			0x00001000
+#define  SNDDATAC_MODE_RESET		 0x00000001
+#define  SNDDATAC_MODE_ENABLE		 0x00000002
+/* 0x1004 --> 0x1400 unused */
+
+/* Send BD ring selector */
+#define SNDBDS_MODE			0x00001400
+#define  SNDBDS_MODE_RESET		 0x00000001
+#define  SNDBDS_MODE_ENABLE		 0x00000002
+#define  SNDBDS_MODE_ATTN_ENABLE	 0x00000004
+#define SNDBDS_STATUS			0x00001404
+#define  SNDBDS_STATUS_ERROR_ATTN	 0x00000004
+#define SNDBDS_HWDIAG			0x00001408
+/* 0x140c --> 0x1440 */
+#define SNDBDS_SEL_CON_IDX_0		0x00001440
+#define SNDBDS_SEL_CON_IDX_1		0x00001444
+#define SNDBDS_SEL_CON_IDX_2		0x00001448
+#define SNDBDS_SEL_CON_IDX_3		0x0000144c
+#define SNDBDS_SEL_CON_IDX_4		0x00001450
+#define SNDBDS_SEL_CON_IDX_5		0x00001454
+#define SNDBDS_SEL_CON_IDX_6		0x00001458
+#define SNDBDS_SEL_CON_IDX_7		0x0000145c
+#define SNDBDS_SEL_CON_IDX_8		0x00001460
+#define SNDBDS_SEL_CON_IDX_9		0x00001464
+#define SNDBDS_SEL_CON_IDX_10		0x00001468
+#define SNDBDS_SEL_CON_IDX_11		0x0000146c
+#define SNDBDS_SEL_CON_IDX_12		0x00001470
+#define SNDBDS_SEL_CON_IDX_13		0x00001474
+#define SNDBDS_SEL_CON_IDX_14		0x00001478
+#define SNDBDS_SEL_CON_IDX_15		0x0000147c
+/* 0x1480 --> 0x1800 unused */
+
+/* Send BD initiator control registers */
+#define SNDBDI_MODE			0x00001800
+#define  SNDBDI_MODE_RESET		 0x00000001
+#define  SNDBDI_MODE_ENABLE		 0x00000002
+#define  SNDBDI_MODE_ATTN_ENABLE	 0x00000004
+#define SNDBDI_STATUS			0x00001804
+#define  SNDBDI_STATUS_ERROR_ATTN	 0x00000004
+#define SNDBDI_IN_PROD_IDX_0		0x00001808
+#define SNDBDI_IN_PROD_IDX_1		0x0000180c
+#define SNDBDI_IN_PROD_IDX_2		0x00001810
+#define SNDBDI_IN_PROD_IDX_3		0x00001814
+#define SNDBDI_IN_PROD_IDX_4		0x00001818
+#define SNDBDI_IN_PROD_IDX_5		0x0000181c
+#define SNDBDI_IN_PROD_IDX_6		0x00001820
+#define SNDBDI_IN_PROD_IDX_7		0x00001824
+#define SNDBDI_IN_PROD_IDX_8		0x00001828
+#define SNDBDI_IN_PROD_IDX_9		0x0000182c
+#define SNDBDI_IN_PROD_IDX_10		0x00001830
+#define SNDBDI_IN_PROD_IDX_11		0x00001834
+#define SNDBDI_IN_PROD_IDX_12		0x00001838
+#define SNDBDI_IN_PROD_IDX_13		0x0000183c
+#define SNDBDI_IN_PROD_IDX_14		0x00001840
+#define SNDBDI_IN_PROD_IDX_15		0x00001844
+/* 0x1848 --> 0x1c00 unused */
+
+/* Send BD completion control registers */
+#define SNDBDC_MODE			0x00001c00
+#define SNDBDC_MODE_RESET		 0x00000001
+#define SNDBDC_MODE_ENABLE		 0x00000002
+#define SNDBDC_MODE_ATTN_ENABLE		 0x00000004
+/* 0x1c04 --> 0x2000 unused */
+
+/* Receive list placement control registers */
+#define RCVLPC_MODE			0x00002000
+#define  RCVLPC_MODE_RESET		 0x00000001
+#define  RCVLPC_MODE_ENABLE		 0x00000002
+#define  RCVLPC_MODE_CLASS0_ATTN_ENAB	 0x00000004
+#define  RCVLPC_MODE_MAPOOR_AATTN_ENAB	 0x00000008
+#define  RCVLPC_MODE_STAT_OFLOW_ENAB	 0x00000010
+#define RCVLPC_STATUS			0x00002004
+#define  RCVLPC_STATUS_CLASS0		 0x00000004
+#define  RCVLPC_STATUS_MAPOOR		 0x00000008
+#define  RCVLPC_STATUS_STAT_OFLOW	 0x00000010
+#define RCVLPC_LOCK			0x00002008
+#define  RCVLPC_LOCK_REQ_MASK		 0x0000ffff
+#define  RCVLPC_LOCK_REQ_SHIFT		 0
+#define  RCVLPC_LOCK_GRANT_MASK		 0xffff0000
+#define  RCVLPC_LOCK_GRANT_SHIFT	 16
+#define RCVLPC_NON_EMPTY_BITS		0x0000200c
+#define  RCVLPC_NON_EMPTY_BITS_MASK	 0x0000ffff
+#define RCVLPC_CONFIG			0x00002010
+#define RCVLPC_STATSCTRL		0x00002014
+#define  RCVLPC_STATSCTRL_ENABLE	 0x00000001
+#define  RCVLPC_STATSCTRL_FASTUPD	 0x00000002
+#define RCVLPC_STATS_ENABLE		0x00002018
+#define  RCVLPC_STATSENAB_LNGBRST_RFIX	 0x00400000
+#define RCVLPC_STATS_INCMASK		0x0000201c
+/* 0x2020 --> 0x2100 unused */
+#define RCVLPC_SELLST_BASE		0x00002100 /* 16 16-byte entries */
+#define  SELLST_TAIL			0x00000004
+#define  SELLST_CONT			0x00000008
+#define  SELLST_UNUSED			0x0000000c
+#define RCVLPC_COS_CNTL_BASE		0x00002200 /* 16 4-byte entries */
+#define RCVLPC_DROP_FILTER_CNT		0x00002240
+#define RCVLPC_DMA_WQ_FULL_CNT		0x00002244
+#define RCVLPC_DMA_HIPRIO_WQ_FULL_CNT	0x00002248
+#define RCVLPC_NO_RCV_BD_CNT		0x0000224c
+#define RCVLPC_IN_DISCARDS_CNT		0x00002250
+#define RCVLPC_IN_ERRORS_CNT		0x00002254
+#define RCVLPC_RCV_THRESH_HIT_CNT	0x00002258
+/* 0x225c --> 0x2400 unused */
+
+/* Receive Data and Receive BD Initiator Control */
+#define RCVDBDI_MODE			0x00002400
+#define  RCVDBDI_MODE_RESET		 0x00000001
+#define  RCVDBDI_MODE_ENABLE		 0x00000002
+#define  RCVDBDI_MODE_JUMBOBD_NEEDED	 0x00000004
+#define  RCVDBDI_MODE_FRM_TOO_BIG	 0x00000008
+#define  RCVDBDI_MODE_INV_RING_SZ	 0x00000010
+#define RCVDBDI_STATUS			0x00002404
+#define  RCVDBDI_STATUS_JUMBOBD_NEEDED	 0x00000004
+#define  RCVDBDI_STATUS_FRM_TOO_BIG	 0x00000008
+#define  RCVDBDI_STATUS_INV_RING_SZ	 0x00000010
+#define RCVDBDI_SPLIT_FRAME_MINSZ	0x00002408
+/* 0x240c --> 0x2440 unused */
+#define RCVDBDI_JUMBO_BD		0x00002440 /* TG3_BDINFO_... */
+#define RCVDBDI_STD_BD			0x00002450 /* TG3_BDINFO_... */
+#define RCVDBDI_MINI_BD			0x00002460 /* TG3_BDINFO_... */
+#define RCVDBDI_JUMBO_CON_IDX		0x00002470
+#define RCVDBDI_STD_CON_IDX		0x00002474
+#define RCVDBDI_MINI_CON_IDX		0x00002478
+/* 0x247c --> 0x2480 unused */
+#define RCVDBDI_BD_PROD_IDX_0		0x00002480
+#define RCVDBDI_BD_PROD_IDX_1		0x00002484
+#define RCVDBDI_BD_PROD_IDX_2		0x00002488
+#define RCVDBDI_BD_PROD_IDX_3		0x0000248c
+#define RCVDBDI_BD_PROD_IDX_4		0x00002490
+#define RCVDBDI_BD_PROD_IDX_5		0x00002494
+#define RCVDBDI_BD_PROD_IDX_6		0x00002498
+#define RCVDBDI_BD_PROD_IDX_7		0x0000249c
+#define RCVDBDI_BD_PROD_IDX_8		0x000024a0
+#define RCVDBDI_BD_PROD_IDX_9		0x000024a4
+#define RCVDBDI_BD_PROD_IDX_10		0x000024a8
+#define RCVDBDI_BD_PROD_IDX_11		0x000024ac
+#define RCVDBDI_BD_PROD_IDX_12		0x000024b0
+#define RCVDBDI_BD_PROD_IDX_13		0x000024b4
+#define RCVDBDI_BD_PROD_IDX_14		0x000024b8
+#define RCVDBDI_BD_PROD_IDX_15		0x000024bc
+#define RCVDBDI_HWDIAG			0x000024c0
+/* 0x24c4 --> 0x2800 unused */
+
+/* Receive Data Completion Control */
+#define RCVDCC_MODE			0x00002800
+#define  RCVDCC_MODE_RESET		 0x00000001
+#define  RCVDCC_MODE_ENABLE		 0x00000002
+#define  RCVDCC_MODE_ATTN_ENABLE	 0x00000004
+/* 0x2804 --> 0x2c00 unused */
+
+/* Receive BD Initiator Control Registers */
+#define RCVBDI_MODE			0x00002c00
+#define  RCVBDI_MODE_RESET		 0x00000001
+#define  RCVBDI_MODE_ENABLE		 0x00000002
+#define  RCVBDI_MODE_RCB_ATTN_ENAB	 0x00000004
+#define RCVBDI_STATUS			0x00002c04
+#define  RCVBDI_STATUS_RCB_ATTN		 0x00000004
+#define RCVBDI_JUMBO_PROD_IDX		0x00002c08
+#define RCVBDI_STD_PROD_IDX		0x00002c0c
+#define RCVBDI_MINI_PROD_IDX		0x00002c10
+#define RCVBDI_MINI_THRESH		0x00002c14
+#define RCVBDI_STD_THRESH		0x00002c18
+#define RCVBDI_JUMBO_THRESH		0x00002c1c
+/* 0x2c20 --> 0x3000 unused */
+
+/* Receive BD Completion Control Registers */
+#define RCVCC_MODE			0x00003000
+#define  RCVCC_MODE_RESET		 0x00000001
+#define  RCVCC_MODE_ENABLE		 0x00000002
+#define  RCVCC_MODE_ATTN_ENABLE		 0x00000004
+#define RCVCC_STATUS			0x00003004
+#define  RCVCC_STATUS_ERROR_ATTN	 0x00000004
+#define RCVCC_JUMP_PROD_IDX		0x00003008
+#define RCVCC_STD_PROD_IDX		0x0000300c
+#define RCVCC_MINI_PROD_IDX		0x00003010
+/* 0x3014 --> 0x3400 unused */
+
+/* Receive list selector control registers */
+#define RCVLSC_MODE			0x00003400
+#define  RCVLSC_MODE_RESET		 0x00000001
+#define  RCVLSC_MODE_ENABLE		 0x00000002
+#define  RCVLSC_MODE_ATTN_ENABLE	 0x00000004
+#define RCVLSC_STATUS			0x00003404
+#define  RCVLSC_STATUS_ERROR_ATTN	 0x00000004
+/* 0x3408 --> 0x3800 unused */
+
+/* Mbuf cluster free registers */
+#define MBFREE_MODE			0x00003800
+#define  MBFREE_MODE_RESET		 0x00000001
+#define  MBFREE_MODE_ENABLE		 0x00000002
+#define MBFREE_STATUS			0x00003804
+/* 0x3808 --> 0x3c00 unused */
+
+/* Host coalescing control registers */
+#define HOSTCC_MODE			0x00003c00
+#define  HOSTCC_MODE_RESET		 0x00000001
+#define  HOSTCC_MODE_ENABLE		 0x00000002
+#define  HOSTCC_MODE_ATTN		 0x00000004
+#define  HOSTCC_MODE_NOW		 0x00000008
+#define  HOSTCC_MODE_FULL_STATUS	 0x00000000
+#define  HOSTCC_MODE_64BYTE		 0x00000080
+#define  HOSTCC_MODE_32BYTE		 0x00000100
+#define  HOSTCC_MODE_CLRTICK_RXBD	 0x00000200
+#define  HOSTCC_MODE_CLRTICK_TXBD	 0x00000400
+#define  HOSTCC_MODE_NOINT_ON_NOW	 0x00000800
+#define  HOSTCC_MODE_NOINT_ON_FORCE	 0x00001000
+#define HOSTCC_STATUS			0x00003c04
+#define  HOSTCC_STATUS_ERROR_ATTN	 0x00000004
+#define HOSTCC_RXCOL_TICKS		0x00003c08
+#define  LOW_RXCOL_TICKS		 0x00000032
+#define  DEFAULT_RXCOL_TICKS		 0x00000048
+#define  HIGH_RXCOL_TICKS		 0x00000096
+#define HOSTCC_TXCOL_TICKS		0x00003c0c
+#define  LOW_TXCOL_TICKS		 0x00000096
+#define  DEFAULT_TXCOL_TICKS		 0x0000012c
+#define  HIGH_TXCOL_TICKS		 0x00000145
+#define HOSTCC_RXMAX_FRAMES		0x00003c10
+#define  LOW_RXMAX_FRAMES		 0x00000005
+#define  DEFAULT_RXMAX_FRAMES		 0x00000008
+#define  HIGH_RXMAX_FRAMES		 0x00000012
+#define HOSTCC_TXMAX_FRAMES		0x00003c14
+#define  LOW_TXMAX_FRAMES		 0x00000035
+#define  DEFAULT_TXMAX_FRAMES		 0x0000004b
+#define  HIGH_TXMAX_FRAMES		 0x00000052
+#define HOSTCC_RXCOAL_TICK_INT		0x00003c18
+#define  DEFAULT_RXCOAL_TICK_INT	 0x00000019
+#define HOSTCC_TXCOAL_TICK_INT		0x00003c1c
+#define  DEFAULT_TXCOAL_TICK_INT	 0x00000019
+#define HOSTCC_RXCOAL_MAXF_INT		0x00003c20
+#define  DEFAULT_RXCOAL_MAXF_INT	 0x00000005
+#define HOSTCC_TXCOAL_MAXF_INT		0x00003c24
+#define  DEFAULT_TXCOAL_MAXF_INT	 0x00000005
+#define HOSTCC_STAT_COAL_TICKS		0x00003c28
+#define  DEFAULT_STAT_COAL_TICKS	 0x000f4240
+/* 0x3c2c --> 0x3c30 unused */
+#define HOSTCC_STATS_BLK_HOST_ADDR	0x00003c30 /* 64-bit */
+#define HOSTCC_STATUS_BLK_HOST_ADDR	0x00003c38 /* 64-bit */
+#define HOSTCC_STATS_BLK_NIC_ADDR	0x00003c40
+#define HOSTCC_STATUS_BLK_NIC_ADDR	0x00003c44
+#define HOSTCC_FLOW_ATTN		0x00003c48
+/* 0x3c4c --> 0x3c50 unused */
+#define HOSTCC_JUMBO_CON_IDX		0x00003c50
+#define HOSTCC_STD_CON_IDX		0x00003c54
+#define HOSTCC_MINI_CON_IDX		0x00003c58
+/* 0x3c5c --> 0x3c80 unused */
+#define HOSTCC_RET_PROD_IDX_0		0x00003c80
+#define HOSTCC_RET_PROD_IDX_1		0x00003c84
+#define HOSTCC_RET_PROD_IDX_2		0x00003c88
+#define HOSTCC_RET_PROD_IDX_3		0x00003c8c
+#define HOSTCC_RET_PROD_IDX_4		0x00003c90
+#define HOSTCC_RET_PROD_IDX_5		0x00003c94
+#define HOSTCC_RET_PROD_IDX_6		0x00003c98
+#define HOSTCC_RET_PROD_IDX_7		0x00003c9c
+#define HOSTCC_RET_PROD_IDX_8		0x00003ca0
+#define HOSTCC_RET_PROD_IDX_9		0x00003ca4
+#define HOSTCC_RET_PROD_IDX_10		0x00003ca8
+#define HOSTCC_RET_PROD_IDX_11		0x00003cac
+#define HOSTCC_RET_PROD_IDX_12		0x00003cb0
+#define HOSTCC_RET_PROD_IDX_13		0x00003cb4
+#define HOSTCC_RET_PROD_IDX_14		0x00003cb8
+#define HOSTCC_RET_PROD_IDX_15		0x00003cbc
+#define HOSTCC_SND_CON_IDX_0		0x00003cc0
+#define HOSTCC_SND_CON_IDX_1		0x00003cc4
+#define HOSTCC_SND_CON_IDX_2		0x00003cc8
+#define HOSTCC_SND_CON_IDX_3		0x00003ccc
+#define HOSTCC_SND_CON_IDX_4		0x00003cd0
+#define HOSTCC_SND_CON_IDX_5		0x00003cd4
+#define HOSTCC_SND_CON_IDX_6		0x00003cd8
+#define HOSTCC_SND_CON_IDX_7		0x00003cdc
+#define HOSTCC_SND_CON_IDX_8		0x00003ce0
+#define HOSTCC_SND_CON_IDX_9		0x00003ce4
+#define HOSTCC_SND_CON_IDX_10		0x00003ce8
+#define HOSTCC_SND_CON_IDX_11		0x00003cec
+#define HOSTCC_SND_CON_IDX_12		0x00003cf0
+#define HOSTCC_SND_CON_IDX_13		0x00003cf4
+#define HOSTCC_SND_CON_IDX_14		0x00003cf8
+#define HOSTCC_SND_CON_IDX_15		0x00003cfc
+/* 0x3d00 --> 0x4000 unused */
+
+/* Memory arbiter control registers */
+#define MEMARB_MODE			0x00004000
+#define  MEMARB_MODE_RESET		 0x00000001
+#define  MEMARB_MODE_ENABLE		 0x00000002
+#define MEMARB_STATUS			0x00004004
+#define MEMARB_TRAP_ADDR_LOW		0x00004008
+#define MEMARB_TRAP_ADDR_HIGH		0x0000400c
+/* 0x4010 --> 0x4400 unused */
+
+/* Buffer manager control registers */
+#define BUFMGR_MODE			0x00004400
+#define  BUFMGR_MODE_RESET		 0x00000001
+#define  BUFMGR_MODE_ENABLE		 0x00000002
+#define  BUFMGR_MODE_ATTN_ENABLE	 0x00000004
+#define  BUFMGR_MODE_BM_TEST		 0x00000008
+#define  BUFMGR_MODE_MBLOW_ATTN_ENAB	 0x00000010
+#define BUFMGR_STATUS			0x00004404
+#define  BUFMGR_STATUS_ERROR		 0x00000004
+#define  BUFMGR_STATUS_MBLOW		 0x00000010
+#define BUFMGR_MB_POOL_ADDR		0x00004408
+#define BUFMGR_MB_POOL_SIZE		0x0000440c
+#define BUFMGR_MB_RDMA_LOW_WATER	0x00004410
+#define  DEFAULT_MB_RDMA_LOW_WATER	 0x00000050
+#define  DEFAULT_MB_RDMA_LOW_WATER_5705	 0x00000000
+#define  DEFAULT_MB_RDMA_LOW_WATER_JUMBO 0x00000130
+#define BUFMGR_MB_MACRX_LOW_WATER	0x00004414
+#define  DEFAULT_MB_MACRX_LOW_WATER	  0x00000020
+#define  DEFAULT_MB_MACRX_LOW_WATER_5705  0x00000010
+#define  DEFAULT_MB_MACRX_LOW_WATER_JUMBO 0x00000098
+#define BUFMGR_MB_HIGH_WATER		0x00004418
+#define  DEFAULT_MB_HIGH_WATER		 0x00000060
+#define  DEFAULT_MB_HIGH_WATER_5705	 0x00000060
+#define  DEFAULT_MB_HIGH_WATER_JUMBO	 0x0000017c
+#define BUFMGR_RX_MB_ALLOC_REQ		0x0000441c
+#define  BUFMGR_MB_ALLOC_BIT		 0x10000000
+#define BUFMGR_RX_MB_ALLOC_RESP		0x00004420
+#define BUFMGR_TX_MB_ALLOC_REQ		0x00004424
+#define BUFMGR_TX_MB_ALLOC_RESP		0x00004428
+#define BUFMGR_DMA_DESC_POOL_ADDR	0x0000442c
+#define BUFMGR_DMA_DESC_POOL_SIZE	0x00004430
+#define BUFMGR_DMA_LOW_WATER		0x00004434
+#define  DEFAULT_DMA_LOW_WATER		 0x00000005
+#define BUFMGR_DMA_HIGH_WATER		0x00004438
+#define  DEFAULT_DMA_HIGH_WATER		 0x0000000a
+#define BUFMGR_RX_DMA_ALLOC_REQ		0x0000443c
+#define BUFMGR_RX_DMA_ALLOC_RESP	0x00004440
+#define BUFMGR_TX_DMA_ALLOC_REQ		0x00004444
+#define BUFMGR_TX_DMA_ALLOC_RESP	0x00004448
+#define BUFMGR_HWDIAG_0			0x0000444c
+#define BUFMGR_HWDIAG_1			0x00004450
+#define BUFMGR_HWDIAG_2			0x00004454
+/* 0x4458 --> 0x4800 unused */
+
+/* Read DMA control registers */
+#define RDMAC_MODE			0x00004800
+#define  RDMAC_MODE_RESET		 0x00000001
+#define  RDMAC_MODE_ENABLE		 0x00000002
+#define  RDMAC_MODE_TGTABORT_ENAB	 0x00000004
+#define  RDMAC_MODE_MSTABORT_ENAB	 0x00000008
+#define  RDMAC_MODE_PARITYERR_ENAB	 0x00000010
+#define  RDMAC_MODE_ADDROFLOW_ENAB	 0x00000020
+#define  RDMAC_MODE_FIFOOFLOW_ENAB	 0x00000040
+#define  RDMAC_MODE_FIFOURUN_ENAB	 0x00000080
+#define  RDMAC_MODE_FIFOOREAD_ENAB	 0x00000100
+#define  RDMAC_MODE_LNGREAD_ENAB	 0x00000200
+#define  RDMAC_MODE_SPLIT_ENABLE	 0x00000800
+#define  RDMAC_MODE_SPLIT_RESET		 0x00001000
+#define  RDMAC_MODE_FIFO_SIZE_128	 0x00020000
+#define  RDMAC_MODE_FIFO_LONG_BURST	 0x00030000
+#define RDMAC_STATUS			0x00004804
+#define  RDMAC_STATUS_TGTABORT		 0x00000004
+#define  RDMAC_STATUS_MSTABORT		 0x00000008
+#define  RDMAC_STATUS_PARITYERR		 0x00000010
+#define  RDMAC_STATUS_ADDROFLOW		 0x00000020
+#define  RDMAC_STATUS_FIFOOFLOW		 0x00000040
+#define  RDMAC_STATUS_FIFOURUN		 0x00000080
+#define  RDMAC_STATUS_FIFOOREAD		 0x00000100
+#define  RDMAC_STATUS_LNGREAD		 0x00000200
+/* 0x4808 --> 0x4c00 unused */
+
+/* Write DMA control registers */
+#define WDMAC_MODE			0x00004c00
+#define  WDMAC_MODE_RESET		 0x00000001
+#define  WDMAC_MODE_ENABLE		 0x00000002
+#define  WDMAC_MODE_TGTABORT_ENAB	 0x00000004
+#define  WDMAC_MODE_MSTABORT_ENAB	 0x00000008
+#define  WDMAC_MODE_PARITYERR_ENAB	 0x00000010
+#define  WDMAC_MODE_ADDROFLOW_ENAB	 0x00000020
+#define  WDMAC_MODE_FIFOOFLOW_ENAB	 0x00000040
+#define  WDMAC_MODE_FIFOURUN_ENAB	 0x00000080
+#define  WDMAC_MODE_FIFOOREAD_ENAB	 0x00000100
+#define  WDMAC_MODE_LNGREAD_ENAB	 0x00000200
+#define  WDMAC_MODE_RX_ACCEL	 	 0x00000400
+#define WDMAC_STATUS			0x00004c04
+#define  WDMAC_STATUS_TGTABORT		 0x00000004
+#define  WDMAC_STATUS_MSTABORT		 0x00000008
+#define  WDMAC_STATUS_PARITYERR		 0x00000010
+#define  WDMAC_STATUS_ADDROFLOW		 0x00000020
+#define  WDMAC_STATUS_FIFOOFLOW		 0x00000040
+#define  WDMAC_STATUS_FIFOURUN		 0x00000080
+#define  WDMAC_STATUS_FIFOOREAD		 0x00000100
+#define  WDMAC_STATUS_LNGREAD		 0x00000200
+/* 0x4c08 --> 0x5000 unused */
+
+/* Per-cpu register offsets (arm9) */
+#define CPU_MODE			0x00000000
+#define  CPU_MODE_RESET			 0x00000001
+#define  CPU_MODE_HALT			 0x00000400
+#define CPU_STATE			0x00000004
+#define CPU_EVTMASK			0x00000008
+/* 0xc --> 0x1c reserved */
+#define CPU_PC				0x0000001c
+#define CPU_INSN			0x00000020
+#define CPU_SPAD_UFLOW			0x00000024
+#define CPU_WDOG_CLEAR			0x00000028
+#define CPU_WDOG_VECTOR			0x0000002c
+#define CPU_WDOG_PC			0x00000030
+#define CPU_HW_BP			0x00000034
+/* 0x38 --> 0x44 unused */
+#define CPU_WDOG_SAVED_STATE		0x00000044
+#define CPU_LAST_BRANCH_ADDR		0x00000048
+#define CPU_SPAD_UFLOW_SET		0x0000004c
+/* 0x50 --> 0x200 unused */
+#define CPU_R0				0x00000200
+#define CPU_R1				0x00000204
+#define CPU_R2				0x00000208
+#define CPU_R3				0x0000020c
+#define CPU_R4				0x00000210
+#define CPU_R5				0x00000214
+#define CPU_R6				0x00000218
+#define CPU_R7				0x0000021c
+#define CPU_R8				0x00000220
+#define CPU_R9				0x00000224
+#define CPU_R10				0x00000228
+#define CPU_R11				0x0000022c
+#define CPU_R12				0x00000230
+#define CPU_R13				0x00000234
+#define CPU_R14				0x00000238
+#define CPU_R15				0x0000023c
+#define CPU_R16				0x00000240
+#define CPU_R17				0x00000244
+#define CPU_R18				0x00000248
+#define CPU_R19				0x0000024c
+#define CPU_R20				0x00000250
+#define CPU_R21				0x00000254
+#define CPU_R22				0x00000258
+#define CPU_R23				0x0000025c
+#define CPU_R24				0x00000260
+#define CPU_R25				0x00000264
+#define CPU_R26				0x00000268
+#define CPU_R27				0x0000026c
+#define CPU_R28				0x00000270
+#define CPU_R29				0x00000274
+#define CPU_R30				0x00000278
+#define CPU_R31				0x0000027c
+/* 0x280 --> 0x400 unused */
+
+#define RX_CPU_BASE			0x00005000
+#define TX_CPU_BASE			0x00005400
+
+/* Mailboxes */
+#define GRCMBOX_INTERRUPT_0		0x00005800 /* 64-bit */
+#define GRCMBOX_INTERRUPT_1		0x00005808 /* 64-bit */
+#define GRCMBOX_INTERRUPT_2		0x00005810 /* 64-bit */
+#define GRCMBOX_INTERRUPT_3		0x00005818 /* 64-bit */
+#define GRCMBOX_GENERAL_0		0x00005820 /* 64-bit */
+#define GRCMBOX_GENERAL_1		0x00005828 /* 64-bit */
+#define GRCMBOX_GENERAL_2		0x00005830 /* 64-bit */
+#define GRCMBOX_GENERAL_3		0x00005838 /* 64-bit */
+#define GRCMBOX_GENERAL_4		0x00005840 /* 64-bit */
+#define GRCMBOX_GENERAL_5		0x00005848 /* 64-bit */
+#define GRCMBOX_GENERAL_6		0x00005850 /* 64-bit */
+#define GRCMBOX_GENERAL_7		0x00005858 /* 64-bit */
+#define GRCMBOX_RELOAD_STAT		0x00005860 /* 64-bit */
+#define GRCMBOX_RCVSTD_PROD_IDX		0x00005868 /* 64-bit */
+#define GRCMBOX_RCVJUMBO_PROD_IDX	0x00005870 /* 64-bit */
+#define GRCMBOX_RCVMINI_PROD_IDX	0x00005878 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_0	0x00005880 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_1	0x00005888 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_2	0x00005890 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_3	0x00005898 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_4	0x000058a0 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_5	0x000058a8 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_6	0x000058b0 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_7	0x000058b8 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_8	0x000058c0 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_9	0x000058c8 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_10	0x000058d0 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_11	0x000058d8 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_12	0x000058e0 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_13	0x000058e8 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_14	0x000058f0 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_15	0x000058f8 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_0	0x00005900 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_1	0x00005908 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_2	0x00005910 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_3	0x00005918 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_4	0x00005920 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_5	0x00005928 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_6	0x00005930 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_7	0x00005938 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_8	0x00005940 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_9	0x00005948 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_10	0x00005950 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_11	0x00005958 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_12	0x00005960 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_13	0x00005968 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_14	0x00005970 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_15	0x00005978 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_0	0x00005980 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_1	0x00005988 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_2	0x00005990 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_3	0x00005998 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_4	0x000059a0 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_5	0x000059a8 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_6	0x000059b0 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_7	0x000059b8 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_8	0x000059c0 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_9	0x000059c8 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_10	0x000059d0 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_11	0x000059d8 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_12	0x000059e0 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_13	0x000059e8 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_14	0x000059f0 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_15	0x000059f8 /* 64-bit */
+#define GRCMBOX_HIGH_PRIO_EV_VECTOR	0x00005a00
+#define GRCMBOX_HIGH_PRIO_EV_MASK	0x00005a04
+#define GRCMBOX_LOW_PRIO_EV_VEC		0x00005a08
+#define GRCMBOX_LOW_PRIO_EV_MASK	0x00005a0c
+/* 0x5a10 --> 0x5c00 */
+
+/* Flow Through queues */
+#define FTQ_RESET			0x00005c00
+/* 0x5c04 --> 0x5c10 unused */
+#define FTQ_DMA_NORM_READ_CTL		0x00005c10
+#define FTQ_DMA_NORM_READ_FULL_CNT	0x00005c14
+#define FTQ_DMA_NORM_READ_FIFO_ENQDEQ	0x00005c18
+#define FTQ_DMA_NORM_READ_WRITE_PEEK	0x00005c1c
+#define FTQ_DMA_HIGH_READ_CTL		0x00005c20
+#define FTQ_DMA_HIGH_READ_FULL_CNT	0x00005c24
+#define FTQ_DMA_HIGH_READ_FIFO_ENQDEQ	0x00005c28
+#define FTQ_DMA_HIGH_READ_WRITE_PEEK	0x00005c2c
+#define FTQ_DMA_COMP_DISC_CTL		0x00005c30
+#define FTQ_DMA_COMP_DISC_FULL_CNT	0x00005c34
+#define FTQ_DMA_COMP_DISC_FIFO_ENQDEQ	0x00005c38
+#define FTQ_DMA_COMP_DISC_WRITE_PEEK	0x00005c3c
+#define FTQ_SEND_BD_COMP_CTL		0x00005c40
+#define FTQ_SEND_BD_COMP_FULL_CNT	0x00005c44
+#define FTQ_SEND_BD_COMP_FIFO_ENQDEQ	0x00005c48
+#define FTQ_SEND_BD_COMP_WRITE_PEEK	0x00005c4c
+#define FTQ_SEND_DATA_INIT_CTL		0x00005c50
+#define FTQ_SEND_DATA_INIT_FULL_CNT	0x00005c54
+#define FTQ_SEND_DATA_INIT_FIFO_ENQDEQ	0x00005c58
+#define FTQ_SEND_DATA_INIT_WRITE_PEEK	0x00005c5c
+#define FTQ_DMA_NORM_WRITE_CTL		0x00005c60
+#define FTQ_DMA_NORM_WRITE_FULL_CNT	0x00005c64
+#define FTQ_DMA_NORM_WRITE_FIFO_ENQDEQ	0x00005c68
+#define FTQ_DMA_NORM_WRITE_WRITE_PEEK	0x00005c6c
+#define FTQ_DMA_HIGH_WRITE_CTL		0x00005c70
+#define FTQ_DMA_HIGH_WRITE_FULL_CNT	0x00005c74
+#define FTQ_DMA_HIGH_WRITE_FIFO_ENQDEQ	0x00005c78
+#define FTQ_DMA_HIGH_WRITE_WRITE_PEEK	0x00005c7c
+#define FTQ_SWTYPE1_CTL			0x00005c80
+#define FTQ_SWTYPE1_FULL_CNT		0x00005c84
+#define FTQ_SWTYPE1_FIFO_ENQDEQ		0x00005c88
+#define FTQ_SWTYPE1_WRITE_PEEK		0x00005c8c
+#define FTQ_SEND_DATA_COMP_CTL		0x00005c90
+#define FTQ_SEND_DATA_COMP_FULL_CNT	0x00005c94
+#define FTQ_SEND_DATA_COMP_FIFO_ENQDEQ	0x00005c98
+#define FTQ_SEND_DATA_COMP_WRITE_PEEK	0x00005c9c
+#define FTQ_HOST_COAL_CTL		0x00005ca0
+#define FTQ_HOST_COAL_FULL_CNT		0x00005ca4
+#define FTQ_HOST_COAL_FIFO_ENQDEQ	0x00005ca8
+#define FTQ_HOST_COAL_WRITE_PEEK	0x00005cac
+#define FTQ_MAC_TX_CTL			0x00005cb0
+#define FTQ_MAC_TX_FULL_CNT		0x00005cb4
+#define FTQ_MAC_TX_FIFO_ENQDEQ		0x00005cb8
+#define FTQ_MAC_TX_WRITE_PEEK		0x00005cbc
+#define FTQ_MB_FREE_CTL			0x00005cc0
+#define FTQ_MB_FREE_FULL_CNT		0x00005cc4
+#define FTQ_MB_FREE_FIFO_ENQDEQ		0x00005cc8
+#define FTQ_MB_FREE_WRITE_PEEK		0x00005ccc
+#define FTQ_RCVBD_COMP_CTL		0x00005cd0
+#define FTQ_RCVBD_COMP_FULL_CNT		0x00005cd4
+#define FTQ_RCVBD_COMP_FIFO_ENQDEQ	0x00005cd8
+#define FTQ_RCVBD_COMP_WRITE_PEEK	0x00005cdc
+#define FTQ_RCVLST_PLMT_CTL		0x00005ce0
+#define FTQ_RCVLST_PLMT_FULL_CNT	0x00005ce4
+#define FTQ_RCVLST_PLMT_FIFO_ENQDEQ	0x00005ce8
+#define FTQ_RCVLST_PLMT_WRITE_PEEK	0x00005cec
+#define FTQ_RCVDATA_INI_CTL		0x00005cf0
+#define FTQ_RCVDATA_INI_FULL_CNT	0x00005cf4
+#define FTQ_RCVDATA_INI_FIFO_ENQDEQ	0x00005cf8
+#define FTQ_RCVDATA_INI_WRITE_PEEK	0x00005cfc
+#define FTQ_RCVDATA_COMP_CTL		0x00005d00
+#define FTQ_RCVDATA_COMP_FULL_CNT	0x00005d04
+#define FTQ_RCVDATA_COMP_FIFO_ENQDEQ	0x00005d08
+#define FTQ_RCVDATA_COMP_WRITE_PEEK	0x00005d0c
+#define FTQ_SWTYPE2_CTL			0x00005d10
+#define FTQ_SWTYPE2_FULL_CNT		0x00005d14
+#define FTQ_SWTYPE2_FIFO_ENQDEQ		0x00005d18
+#define FTQ_SWTYPE2_WRITE_PEEK		0x00005d1c
+/* 0x5d20 --> 0x6000 unused */
+
+/* Message signaled interrupt registers */
+#define MSGINT_MODE			0x00006000
+#define  MSGINT_MODE_RESET		 0x00000001
+#define  MSGINT_MODE_ENABLE		 0x00000002
+#define MSGINT_STATUS			0x00006004
+#define MSGINT_FIFO			0x00006008
+/* 0x600c --> 0x6400 unused */
+
+/* DMA completion registers */
+#define DMAC_MODE			0x00006400
+#define  DMAC_MODE_RESET		 0x00000001
+#define  DMAC_MODE_ENABLE		 0x00000002
+/* 0x6404 --> 0x6800 unused */
+
+/* GRC registers */
+#define GRC_MODE			0x00006800
+#define  GRC_MODE_UPD_ON_COAL		0x00000001
+#define  GRC_MODE_BSWAP_NONFRM_DATA	0x00000002
+#define  GRC_MODE_WSWAP_NONFRM_DATA	0x00000004
+#define  GRC_MODE_BSWAP_DATA		0x00000010
+#define  GRC_MODE_WSWAP_DATA		0x00000020
+#define  GRC_MODE_SPLITHDR		0x00000100
+#define  GRC_MODE_NOFRM_CRACKING	0x00000200
+#define  GRC_MODE_INCL_CRC		0x00000400
+#define  GRC_MODE_ALLOW_BAD_FRMS	0x00000800
+#define  GRC_MODE_NOIRQ_ON_SENDS	0x00002000
+#define  GRC_MODE_NOIRQ_ON_RCV		0x00004000
+#define  GRC_MODE_FORCE_PCI32BIT	0x00008000
+#define  GRC_MODE_HOST_STACKUP		0x00010000
+#define  GRC_MODE_HOST_SENDBDS		0x00020000
+#define  GRC_MODE_NO_TX_PHDR_CSUM	0x00100000
+#define  GRC_MODE_NO_RX_PHDR_CSUM	0x00800000
+#define  GRC_MODE_IRQ_ON_TX_CPU_ATTN	0x01000000
+#define  GRC_MODE_IRQ_ON_RX_CPU_ATTN	0x02000000
+#define  GRC_MODE_IRQ_ON_MAC_ATTN	0x04000000
+#define  GRC_MODE_IRQ_ON_DMA_ATTN	0x08000000
+#define  GRC_MODE_IRQ_ON_FLOW_ATTN	0x10000000
+#define  GRC_MODE_4X_NIC_SEND_RINGS	0x20000000
+#define  GRC_MODE_MCAST_FRM_ENABLE	0x40000000
+#define GRC_MISC_CFG			0x00006804
+#define  GRC_MISC_CFG_CORECLK_RESET	0x00000001
+#define  GRC_MISC_CFG_PRESCALAR_MASK	0x000000fe
+#define  GRC_MISC_CFG_PRESCALAR_SHIFT	1
+#define  GRC_MISC_CFG_BOARD_ID_MASK	0x0001e000
+#define  GRC_MISC_CFG_BOARD_ID_5700	0x0001e000
+#define  GRC_MISC_CFG_BOARD_ID_5701	0x00000000
+#define  GRC_MISC_CFG_BOARD_ID_5702FE	0x00004000
+#define  GRC_MISC_CFG_BOARD_ID_5703	0x00000000
+#define  GRC_MISC_CFG_BOARD_ID_5703S	0x00002000
+#define  GRC_MISC_CFG_BOARD_ID_5704	0x00000000
+#define  GRC_MISC_CFG_BOARD_ID_5704CIOBE 0x00004000
+#define  GRC_MISC_CFG_BOARD_ID_5704_A2	0x00008000
+#define  GRC_MISC_CFG_BOARD_ID_5788	0x00010000
+#define  GRC_MISC_CFG_BOARD_ID_5788M	0x00018000
+#define  GRC_MISC_CFG_BOARD_ID_AC91002A1 0x00018000
+#define  GRC_MISC_CFG_KEEP_GPHY_POWER	0x04000000
+#define GRC_LOCAL_CTRL			0x00006808
+#define  GRC_LCLCTRL_INT_ACTIVE		0x00000001
+#define  GRC_LCLCTRL_CLEARINT		0x00000002
+#define  GRC_LCLCTRL_SETINT		0x00000004
+#define  GRC_LCLCTRL_INT_ON_ATTN	0x00000008
+#define  GRC_LCLCTRL_GPIO_INPUT0	0x00000100
+#define  GRC_LCLCTRL_GPIO_INPUT1	0x00000200
+#define  GRC_LCLCTRL_GPIO_INPUT2	0x00000400
+#define  GRC_LCLCTRL_GPIO_OE0		0x00000800
+#define  GRC_LCLCTRL_GPIO_OE1		0x00001000
+#define  GRC_LCLCTRL_GPIO_OE2		0x00002000
+#define  GRC_LCLCTRL_GPIO_OUTPUT0	0x00004000
+#define  GRC_LCLCTRL_GPIO_OUTPUT1	0x00008000
+#define  GRC_LCLCTRL_GPIO_OUTPUT2	0x00010000
+#define  GRC_LCLCTRL_EXTMEM_ENABLE	0x00020000
+#define  GRC_LCLCTRL_MEMSZ_MASK		0x001c0000
+#define  GRC_LCLCTRL_MEMSZ_256K		0x00000000
+#define  GRC_LCLCTRL_MEMSZ_512K		0x00040000
+#define  GRC_LCLCTRL_MEMSZ_1M		0x00080000
+#define  GRC_LCLCTRL_MEMSZ_2M		0x000c0000
+#define  GRC_LCLCTRL_MEMSZ_4M		0x00100000
+#define  GRC_LCLCTRL_MEMSZ_8M		0x00140000
+#define  GRC_LCLCTRL_MEMSZ_16M		0x00180000
+#define  GRC_LCLCTRL_BANK_SELECT	0x00200000
+#define  GRC_LCLCTRL_SSRAM_TYPE		0x00400000
+#define  GRC_LCLCTRL_AUTO_SEEPROM	0x01000000
+#define GRC_TIMER			0x0000680c
+#define GRC_RX_CPU_EVENT		0x00006810
+#define GRC_RX_TIMER_REF		0x00006814
+#define GRC_RX_CPU_SEM			0x00006818
+#define GRC_REMOTE_RX_CPU_ATTN		0x0000681c
+#define GRC_TX_CPU_EVENT		0x00006820
+#define GRC_TX_TIMER_REF		0x00006824
+#define GRC_TX_CPU_SEM			0x00006828
+#define GRC_REMOTE_TX_CPU_ATTN		0x0000682c
+#define GRC_MEM_POWER_UP		0x00006830 /* 64-bit */
+#define GRC_EEPROM_ADDR			0x00006838
+#define  EEPROM_ADDR_WRITE		0x00000000
+#define  EEPROM_ADDR_READ		0x80000000
+#define  EEPROM_ADDR_COMPLETE		0x40000000
+#define  EEPROM_ADDR_FSM_RESET		0x20000000
+#define  EEPROM_ADDR_DEVID_MASK		0x1c000000
+#define  EEPROM_ADDR_DEVID_SHIFT	26
+#define  EEPROM_ADDR_START		0x02000000
+#define  EEPROM_ADDR_CLKPERD_SHIFT	16
+#define  EEPROM_ADDR_ADDR_MASK		0x0000ffff
+#define  EEPROM_ADDR_ADDR_SHIFT		0
+#define  EEPROM_DEFAULT_CLOCK_PERIOD	0x60
+#define  EEPROM_CHIP_SIZE		(64 * 1024)
+#define GRC_EEPROM_DATA			0x0000683c
+#define GRC_EEPROM_CTRL			0x00006840
+#define GRC_MDI_CTRL			0x00006844
+#define GRC_SEEPROM_DELAY		0x00006848
+/* 0x684c --> 0x6c00 unused */
+
+/* 0x6c00 --> 0x7000 unused */
+
+/* NVRAM Control registers */
+#define NVRAM_CMD			0x00007000
+#define  NVRAM_CMD_RESET		 0x00000001
+#define  NVRAM_CMD_DONE			 0x00000008
+#define  NVRAM_CMD_GO			 0x00000010
+#define  NVRAM_CMD_WR			 0x00000020
+#define  NVRAM_CMD_RD			 0x00000000
+#define  NVRAM_CMD_ERASE		 0x00000040
+#define  NVRAM_CMD_FIRST		 0x00000080
+#define  NVRAM_CMD_LAST			 0x00000100
+#define NVRAM_STAT			0x00007004
+#define NVRAM_WRDATA			0x00007008
+#define NVRAM_ADDR			0x0000700c
+#define  NVRAM_ADDR_MSK			0x00ffffff
+#define NVRAM_RDDATA			0x00007010
+#define NVRAM_CFG1			0x00007014
+#define  NVRAM_CFG1_FLASHIF_ENAB	 0x00000001
+#define  NVRAM_CFG1_BUFFERED_MODE	 0x00000002
+#define  NVRAM_CFG1_PASS_THRU		 0x00000004
+#define  NVRAM_CFG1_BIT_BANG		 0x00000008
+#define  NVRAM_CFG1_COMPAT_BYPASS	 0x80000000
+#define NVRAM_CFG2			0x00007018
+#define NVRAM_CFG3			0x0000701c
+#define NVRAM_SWARB			0x00007020
+#define  SWARB_REQ_SET0			 0x00000001
+#define  SWARB_REQ_SET1			 0x00000002
+#define  SWARB_REQ_SET2			 0x00000004
+#define  SWARB_REQ_SET3			 0x00000008
+#define  SWARB_REQ_CLR0			 0x00000010
+#define  SWARB_REQ_CLR1			 0x00000020
+#define  SWARB_REQ_CLR2			 0x00000040
+#define  SWARB_REQ_CLR3			 0x00000080
+#define  SWARB_GNT0			 0x00000100
+#define  SWARB_GNT1			 0x00000200
+#define  SWARB_GNT2			 0x00000400
+#define  SWARB_GNT3			 0x00000800
+#define  SWARB_REQ0			 0x00001000
+#define  SWARB_REQ1			 0x00002000
+#define  SWARB_REQ2			 0x00004000
+#define  SWARB_REQ3			 0x00008000
+#define    NVRAM_BUFFERED_PAGE_SIZE	   264
+#define    NVRAM_BUFFERED_PAGE_POS	   9
+/* 0x7024 --> 0x7400 unused */
+
+/* 0x7400 --> 0x8000 unused */
+
+/* 32K Window into NIC internal memory */
+#define NIC_SRAM_WIN_BASE		0x00008000
+
+/* Offsets into first 32k of NIC internal memory. */
+#define NIC_SRAM_PAGE_ZERO		0x00000000
+#define NIC_SRAM_SEND_RCB		0x00000100 /* 16 * TG3_BDINFO_... */
+#define NIC_SRAM_RCV_RET_RCB		0x00000200 /* 16 * TG3_BDINFO_... */
+#define NIC_SRAM_STATS_BLK		0x00000300
+#define NIC_SRAM_STATUS_BLK		0x00000b00
+
+#define NIC_SRAM_FIRMWARE_MBOX		0x00000b50
+#define  NIC_SRAM_FIRMWARE_MBOX_MAGIC1	 0x4B657654
+#define  NIC_SRAM_FIRMWARE_MBOX_MAGIC2	 0x4861764b /* !dma on linkchg */
+
+#define NIC_SRAM_DATA_SIG		0x00000b54
+#define  NIC_SRAM_DATA_SIG_MAGIC	 0x4b657654 /* ascii for 'KevT' */
+
+#define NIC_SRAM_DATA_CFG			0x00000b58
+#define  NIC_SRAM_DATA_CFG_LED_MODE_MASK	 0x0000000c
+#define  NIC_SRAM_DATA_CFG_LED_MODE_UNKNOWN	 0x00000000
+#define  NIC_SRAM_DATA_CFG_LED_TRIPLE_SPD	 0x00000004
+#define  NIC_SRAM_DATA_CFG_LED_OPEN_DRAIN	 0x00000004
+#define  NIC_SRAM_DATA_CFG_LED_LINK_SPD		 0x00000008
+#define  NIC_SRAM_DATA_CFG_LED_OUTPUT		 0x00000008
+#define  NIC_SRAM_DATA_CFG_PHY_TYPE_MASK	 0x00000030
+#define  NIC_SRAM_DATA_CFG_PHY_TYPE_UNKNOWN	 0x00000000
+#define  NIC_SRAM_DATA_CFG_PHY_TYPE_COPPER	 0x00000010
+#define  NIC_SRAM_DATA_CFG_PHY_TYPE_FIBER	 0x00000020
+#define  NIC_SRAM_DATA_CFG_WOL_ENABLE		 0x00000040
+#define  NIC_SRAM_DATA_CFG_ASF_ENABLE		 0x00000080
+#define  NIC_SRAM_DATA_CFG_EEPROM_WP		 0x00000100
+#define  NIC_SRAM_DATA_CFG_MINI_PCI		 0x00001000
+#define  NIC_SRAM_DATA_CFG_FIBER_WOL		 0x00004000
+
+#define NIC_SRAM_DATA_PHY_ID		0x00000b74
+#define  NIC_SRAM_DATA_PHY_ID1_MASK	 0xffff0000
+#define  NIC_SRAM_DATA_PHY_ID2_MASK	 0x0000ffff
+
+#define NIC_SRAM_FW_CMD_MBOX		0x00000b78
+#define  FWCMD_NICDRV_ALIVE		 0x00000001
+#define  FWCMD_NICDRV_PAUSE_FW		 0x00000002
+#define  FWCMD_NICDRV_IPV4ADDR_CHG	 0x00000003
+#define  FWCMD_NICDRV_IPV6ADDR_CHG	 0x00000004
+#define  FWCMD_NICDRV_FIX_DMAR		 0x00000005
+#define  FWCMD_NICDRV_FIX_DMAW		 0x00000006
+#define NIC_SRAM_FW_CMD_LEN_MBOX	0x00000b7c
+#define NIC_SRAM_FW_CMD_DATA_MBOX	0x00000b80
+#define NIC_SRAM_FW_ASF_STATUS_MBOX	0x00000c00
+#define NIC_SRAM_FW_DRV_STATE_MBOX	0x00000c04
+#define  DRV_STATE_START		 0x00000001
+#define  DRV_STATE_UNLOAD		 0x00000002
+#define  DRV_STATE_WOL			 0x00000003
+#define  DRV_STATE_SUSPEND		 0x00000004
+
+#define NIC_SRAM_FW_RESET_TYPE_MBOX	0x00000c08
+
+#define NIC_SRAM_MAC_ADDR_HIGH_MBOX	0x00000c14
+#define NIC_SRAM_MAC_ADDR_LOW_MBOX	0x00000c18
+
+#define NIC_SRAM_RX_MINI_BUFFER_DESC	0x00001000
+
+#define NIC_SRAM_DMA_DESC_POOL_BASE	0x00002000
+#define  NIC_SRAM_DMA_DESC_POOL_SIZE	 0x00002000
+#define NIC_SRAM_TX_BUFFER_DESC		0x00004000 /* 512 entries */
+#define NIC_SRAM_RX_BUFFER_DESC		0x00006000 /* 256 entries */
+#define NIC_SRAM_RX_JUMBO_BUFFER_DESC	0x00007000 /* 256 entries */
+#define NIC_SRAM_MBUF_POOL_BASE		0x00008000
+#define  NIC_SRAM_MBUF_POOL_SIZE96	 0x00018000
+#define  NIC_SRAM_MBUF_POOL_SIZE64	 0x00010000
+#define  NIC_SRAM_MBUF_POOL_BASE5705	0x00010000
+#define  NIC_SRAM_MBUF_POOL_SIZE5705	0x0000e000
+
+/* Currently this is fixed. */
+#define PHY_ADDR		0x01
+
+/* Tigon3 specific PHY MII registers. */
+#define  TG3_BMCR_SPEED1000		0x0040
+
+#define MII_TG3_CTRL			0x09 /* 1000-baseT control register */
+#define  MII_TG3_CTRL_ADV_1000_HALF	0x0100
+#define  MII_TG3_CTRL_ADV_1000_FULL	0x0200
+#define  MII_TG3_CTRL_AS_MASTER		0x0800
+#define  MII_TG3_CTRL_ENABLE_AS_MASTER	0x1000
+
+#define MII_TG3_EXT_CTRL		0x10 /* Extended control register */
+#define  MII_TG3_EXT_CTRL_LNK3_LED_MODE	0x0002
+#define  MII_TG3_EXT_CTRL_TBI		0x8000
+
+#define MII_TG3_EXT_STAT		0x11 /* Extended status register */
+#define  MII_TG3_EXT_STAT_LPASS		0x0100
+
+#define MII_TG3_DSP_RW_PORT		0x15 /* DSP coefficient read/write port */
+
+#define MII_TG3_DSP_ADDRESS		0x17 /* DSP address register */
+
+#define MII_TG3_AUX_CTRL		0x18 /* auxilliary control register */
+
+#define MII_TG3_AUX_STAT		0x19 /* auxilliary status register */
+#define MII_TG3_AUX_STAT_LPASS		0x0004
+#define MII_TG3_AUX_STAT_SPDMASK	0x0700
+#define MII_TG3_AUX_STAT_10HALF		0x0100
+#define MII_TG3_AUX_STAT_10FULL		0x0200
+#define MII_TG3_AUX_STAT_100HALF	0x0300
+#define MII_TG3_AUX_STAT_100_4		0x0400
+#define MII_TG3_AUX_STAT_100FULL	0x0500
+#define MII_TG3_AUX_STAT_1000HALF	0x0600
+#define MII_TG3_AUX_STAT_1000FULL	0x0700
+
+#define MII_TG3_ISTAT			0x1a /* IRQ status register */
+#define MII_TG3_IMASK			0x1b /* IRQ mask register */
+
+/* ISTAT/IMASK event bits */
+#define MII_TG3_INT_LINKCHG		0x0002
+#define MII_TG3_INT_SPEEDCHG		0x0004
+#define MII_TG3_INT_DUPLEXCHG		0x0008
+#define MII_TG3_INT_ANEG_PAGE_RX	0x0400
+
+/* XXX Add this to mii.h */
+#ifndef ADVERTISE_PAUSE
+#define ADVERTISE_PAUSE_CAP		0x0400
+#endif
+#ifndef ADVERTISE_PAUSE_ASYM
+#define ADVERTISE_PAUSE_ASYM		0x0800
+#endif
+#ifndef LPA_PAUSE
+#define LPA_PAUSE_CAP			0x0400
+#endif
+#ifndef LPA_PAUSE_ASYM
+#define LPA_PAUSE_ASYM			0x0800
+#endif
+
+/* There are two ways to manage the TX descriptors on the tigon3.
+ * Either the descriptors are in host DMA'able memory, or they
+ * exist only in the cards on-chip SRAM.  All 16 send bds are under
+ * the same mode, they may not be configured individually.
+ *
+ * The mode we use is controlled by TG3_FLAG_HOST_TXDS in tp->tg3_flags.
+ *
+ * To use host memory TX descriptors:
+ *	1) Set GRC_MODE_HOST_SENDBDS in GRC_MODE register.
+ *	   Make sure GRC_MODE_4X_NIC_SEND_RINGS is clear.
+ *	2) Allocate DMA'able memory.
+ *	3) In NIC_SRAM_SEND_RCB (of desired index) of on-chip SRAM:
+ *	   a) Set TG3_BDINFO_HOST_ADDR to DMA address of memory
+ *	      obtained in step 2
+ *	   b) Set TG3_BDINFO_NIC_ADDR to NIC_SRAM_TX_BUFFER_DESC.
+ *	   c) Set len field of TG3_BDINFO_MAXLEN_FLAGS to number
+ *            of TX descriptors.  Leave flags field clear.
+ *	4) Access TX descriptors via host memory.  The chip
+ *	   will refetch into local SRAM as needed when producer
+ *	   index mailboxes are updated.
+ *
+ * To use on-chip TX descriptors:
+ *	1) Set GRC_MODE_4X_NIC_SEND_RINGS in GRC_MODE register.
+ *	   Make sure GRC_MODE_HOST_SENDBDS is clear.
+ *	2) In NIC_SRAM_SEND_RCB (of desired index) of on-chip SRAM:
+ *	   a) Set TG3_BDINFO_HOST_ADDR to zero.
+ *	   b) Set TG3_BDINFO_NIC_ADDR to NIC_SRAM_TX_BUFFER_DESC
+ *	   c) TG3_BDINFO_MAXLEN_FLAGS is don't care.
+ *	3) Access TX descriptors directly in on-chip SRAM
+ *	   using normal {read,write}l().  (and not using
+ *         pointer dereferencing of ioremap()'d memory like
+ *	   the broken Broadcom driver does)
+ *
+ * Note that BDINFO_FLAGS_DISABLED should be set in the flags field of
+ * TG3_BDINFO_MAXLEN_FLAGS of all unused SEND_RCB indices.
+ */
+struct tg3_tx_buffer_desc {
+	uint32_t			addr_hi;
+	uint32_t			addr_lo;
+
+	uint32_t			len_flags;
+#define TXD_FLAG_TCPUDP_CSUM		0x0001
+#define TXD_FLAG_IP_CSUM		0x0002
+#define TXD_FLAG_END			0x0004
+#define TXD_FLAG_IP_FRAG		0x0008
+#define TXD_FLAG_IP_FRAG_END		0x0010
+#define TXD_FLAG_VLAN			0x0040
+#define TXD_FLAG_COAL_NOW		0x0080
+#define TXD_FLAG_CPU_PRE_DMA		0x0100
+#define TXD_FLAG_CPU_POST_DMA		0x0200
+#define TXD_FLAG_ADD_SRC_ADDR		0x1000
+#define TXD_FLAG_CHOOSE_SRC_ADDR	0x6000
+#define TXD_FLAG_NO_CRC			0x8000
+#define TXD_LEN_SHIFT			16
+
+	uint32_t			vlan_tag;
+#define TXD_VLAN_TAG_SHIFT		0
+#define TXD_MSS_SHIFT			16
+};
+
+#define TXD_ADDR			0x00UL /* 64-bit */
+#define TXD_LEN_FLAGS			0x08UL /* 32-bit (upper 16-bits are len) */
+#define TXD_VLAN_TAG			0x0cUL /* 32-bit (upper 16-bits are tag) */
+#define TXD_SIZE			0x10UL
+
+struct tg3_rx_buffer_desc {
+	uint32_t			addr_hi;
+	uint32_t			addr_lo;
+
+	uint32_t			idx_len;
+#define RXD_IDX_MASK	0xffff0000
+#define RXD_IDX_SHIFT	16
+#define RXD_LEN_MASK	0x0000ffff
+#define RXD_LEN_SHIFT	0
+
+	uint32_t			type_flags;
+#define RXD_TYPE_SHIFT	16
+#define RXD_FLAGS_SHIFT	0
+
+#define RXD_FLAG_END			0x0004
+#define RXD_FLAG_MINI			0x0800
+#define RXD_FLAG_JUMBO			0x0020
+#define RXD_FLAG_VLAN			0x0040
+#define RXD_FLAG_ERROR			0x0400
+#define RXD_FLAG_IP_CSUM		0x1000
+#define RXD_FLAG_TCPUDP_CSUM		0x2000
+#define RXD_FLAG_IS_TCP			0x4000
+
+	uint32_t			ip_tcp_csum;
+#define RXD_IPCSUM_MASK		0xffff0000
+#define RXD_IPCSUM_SHIFT	16
+#define RXD_TCPCSUM_MASK	0x0000ffff
+#define RXD_TCPCSUM_SHIFT	0
+
+	uint32_t			err_vlan;
+
+#define RXD_VLAN_MASK			0x0000ffff
+
+#define RXD_ERR_BAD_CRC			0x00010000
+#define RXD_ERR_COLLISION		0x00020000
+#define RXD_ERR_LINK_LOST		0x00040000
+#define RXD_ERR_PHY_DECODE		0x00080000
+#define RXD_ERR_ODD_NIBBLE_RCVD_MII	0x00100000
+#define RXD_ERR_MAC_ABRT		0x00200000
+#define RXD_ERR_TOO_SMALL		0x00400000
+#define RXD_ERR_NO_RESOURCES		0x00800000
+#define RXD_ERR_HUGE_FRAME		0x01000000
+#define RXD_ERR_MASK			0xffff0000
+
+	uint32_t			reserved;
+	uint32_t			opaque;
+#define RXD_OPAQUE_INDEX_MASK		0x0000ffff
+#define RXD_OPAQUE_INDEX_SHIFT		0
+#define RXD_OPAQUE_RING_STD		0x00010000
+#define RXD_OPAQUE_RING_JUMBO		0x00020000
+#define RXD_OPAQUE_RING_MINI		0x00040000
+#define RXD_OPAQUE_RING_MASK		0x00070000
+};
+
+struct tg3_ext_rx_buffer_desc {
+	struct {
+		uint32_t		addr_hi;
+		uint32_t		addr_lo;
+	}				addrlist[3];
+	uint32_t			len2_len1;
+	uint32_t			resv_len3;
+	struct tg3_rx_buffer_desc	std;
+};
+
+/* We only use this when testing out the DMA engine
+ * at probe time.  This is the internal format of buffer
+ * descriptors used by the chip at NIC_SRAM_DMA_DESCS.
+ */
+struct tg3_internal_buffer_desc {
+	uint32_t			addr_hi;
+	uint32_t			addr_lo;
+	uint32_t			nic_mbuf;
+	/* XXX FIX THIS */
+#if __BYTE_ORDER == __BIG_ENDIAN
+	uint16_t			cqid_sqid;
+	uint16_t			len;
+#else
+	uint16_t			len;
+	uint16_t			cqid_sqid;
+#endif
+	uint32_t			flags;
+	uint32_t			__cookie1;
+	uint32_t			__cookie2;
+	uint32_t			__cookie3;
+};
+
+#define TG3_HW_STATUS_SIZE		0x50
+struct tg3_hw_status {
+	uint32_t			status;
+#define SD_STATUS_UPDATED		0x00000001
+#define SD_STATUS_LINK_CHG		0x00000002
+#define SD_STATUS_ERROR			0x00000004
+
+	uint32_t			status_tag;
+
+#if __BYTE_ORDER == __BIG_ENDIAN
+	uint16_t			rx_consumer;
+	uint16_t			rx_jumbo_consumer;
+#else
+	uint16_t			rx_jumbo_consumer;
+	uint16_t			rx_consumer;
+#endif
+
+#if __BYTE_ORDER ==  __BIG_ENDIAN
+	uint16_t			reserved;
+	uint16_t			rx_mini_consumer;
+#else
+	uint16_t			rx_mini_consumer;
+	uint16_t			reserved;
+#endif
+	struct {
+#if __BYTE_ORDER ==  __BIG_ENDIAN
+		uint16_t		tx_consumer;
+		uint16_t		rx_producer;
+#else
+		uint16_t		rx_producer;
+		uint16_t		tx_consumer;
+#endif
+	}				idx[16];
+};
+
+typedef struct {
+	uint32_t high, low;
+} tg3_stat64_t;
+
+struct tg3_hw_stats {
+	uint8_t				__reserved0[0x400-0x300];
+
+	/* Statistics maintained by Receive MAC. */
+	tg3_stat64_t			rx_octets;
+	uint64_t			__reserved1;
+	tg3_stat64_t			rx_fragments;
+	tg3_stat64_t			rx_ucast_packets;
+	tg3_stat64_t			rx_mcast_packets;
+	tg3_stat64_t			rx_bcast_packets;
+	tg3_stat64_t			rx_fcs_errors;
+	tg3_stat64_t			rx_align_errors;
+	tg3_stat64_t			rx_xon_pause_rcvd;
+	tg3_stat64_t			rx_xoff_pause_rcvd;
+	tg3_stat64_t			rx_mac_ctrl_rcvd;
+	tg3_stat64_t			rx_xoff_entered;
+	tg3_stat64_t			rx_frame_too_long_errors;
+	tg3_stat64_t			rx_jabbers;
+	tg3_stat64_t			rx_undersize_packets;
+	tg3_stat64_t			rx_in_length_errors;
+	tg3_stat64_t			rx_out_length_errors;
+	tg3_stat64_t			rx_64_or_less_octet_packets;
+	tg3_stat64_t			rx_65_to_127_octet_packets;
+	tg3_stat64_t			rx_128_to_255_octet_packets;
+	tg3_stat64_t			rx_256_to_511_octet_packets;
+	tg3_stat64_t			rx_512_to_1023_octet_packets;
+	tg3_stat64_t			rx_1024_to_1522_octet_packets;
+	tg3_stat64_t			rx_1523_to_2047_octet_packets;
+	tg3_stat64_t			rx_2048_to_4095_octet_packets;
+	tg3_stat64_t			rx_4096_to_8191_octet_packets;
+	tg3_stat64_t			rx_8192_to_9022_octet_packets;
+
+	uint64_t			__unused0[37];
+
+	/* Statistics maintained by Transmit MAC. */
+	tg3_stat64_t			tx_octets;
+	uint64_t			__reserved2;
+	tg3_stat64_t			tx_collisions;
+	tg3_stat64_t			tx_xon_sent;
+	tg3_stat64_t			tx_xoff_sent;
+	tg3_stat64_t			tx_flow_control;
+	tg3_stat64_t			tx_mac_errors;
+	tg3_stat64_t			tx_single_collisions;
+	tg3_stat64_t			tx_mult_collisions;
+	tg3_stat64_t			tx_deferred;
+	uint64_t			__reserved3;
+	tg3_stat64_t			tx_excessive_collisions;
+	tg3_stat64_t			tx_late_collisions;
+	tg3_stat64_t			tx_collide_2times;
+	tg3_stat64_t			tx_collide_3times;
+	tg3_stat64_t			tx_collide_4times;
+	tg3_stat64_t			tx_collide_5times;
+	tg3_stat64_t			tx_collide_6times;
+	tg3_stat64_t			tx_collide_7times;
+	tg3_stat64_t			tx_collide_8times;
+	tg3_stat64_t			tx_collide_9times;
+	tg3_stat64_t			tx_collide_10times;
+	tg3_stat64_t			tx_collide_11times;
+	tg3_stat64_t			tx_collide_12times;
+	tg3_stat64_t			tx_collide_13times;
+	tg3_stat64_t			tx_collide_14times;
+	tg3_stat64_t			tx_collide_15times;
+	tg3_stat64_t			tx_ucast_packets;
+	tg3_stat64_t			tx_mcast_packets;
+	tg3_stat64_t			tx_bcast_packets;
+	tg3_stat64_t			tx_carrier_sense_errors;
+	tg3_stat64_t			tx_discards;
+	tg3_stat64_t			tx_errors;
+
+	uint64_t			__unused1[31];
+
+	/* Statistics maintained by Receive List Placement. */
+	tg3_stat64_t			COS_rx_packets[16];
+	tg3_stat64_t			COS_rx_filter_dropped;
+	tg3_stat64_t			dma_writeq_full;
+	tg3_stat64_t			dma_write_prioq_full;
+	tg3_stat64_t			rxbds_empty;
+	tg3_stat64_t			rx_discards;
+	tg3_stat64_t			rx_errors;
+	tg3_stat64_t			rx_threshold_hit;
+
+	uint64_t			__unused2[9];
+
+	/* Statistics maintained by Send Data Initiator. */
+	tg3_stat64_t			COS_out_packets[16];
+	tg3_stat64_t			dma_readq_full;
+	tg3_stat64_t			dma_read_prioq_full;
+	tg3_stat64_t			tx_comp_queue_full;
+
+	/* Statistics maintained by Host Coalescing. */
+	tg3_stat64_t			ring_set_send_prod_index;
+	tg3_stat64_t			ring_status_update;
+	tg3_stat64_t			nic_irqs;
+	tg3_stat64_t			nic_avoided_irqs;
+	tg3_stat64_t			nic_tx_threshold_hit;
+
+	uint8_t				__reserved4[0xb00-0x9c0];
+};
+
+enum phy_led_mode {
+	led_mode_auto,
+	led_mode_three_link,
+	led_mode_link10
+};
+
+#if 0
+/* 'mapping' is superfluous as the chip does not write into
+ * the tx/rx post rings so we could just fetch it from there.
+ * But the cache behavior is better how we are doing it now.
+ */
+struct ring_info {
+	struct sk_buff			*skb;
+	DECLARE_PCI_UNMAP_ADDR(mapping)
+};
+
+struct tx_ring_info {
+	struct sk_buff			*skb;
+	DECLARE_PCI_UNMAP_ADDR(mapping)
+	uint32_t			prev_vlan_tag;
+};
+#endif
+
+struct tg3_config_info {
+	uint32_t			flags;
+};
+
+struct tg3_link_config {
+	/* Describes what we're trying to get. */
+	uint32_t			advertising;
+#if 0
+	uint16_t			speed;
+	uint8_t				duplex;
+	uint8_t				autoneg;
+#define SPEED_INVALID		0xffff
+#define DUPLEX_INVALID		0xff
+#define AUTONEG_INVALID		0xff
+#endif
+
+	/* Describes what we actually have. */
+	uint8_t				active_speed;
+	uint8_t				active_duplex;
+
+	/* When we go in and out of low power mode we need
+	 * to swap with this state.
+	 */
+#if 0
+	int				phy_is_low_power;
+	uint16_t			orig_speed;
+	uint8_t				orig_duplex;
+	uint8_t				orig_autoneg;
+#endif
+};
+
+struct tg3_bufmgr_config {
+	uint32_t		mbuf_read_dma_low_water;
+	uint32_t		mbuf_mac_rx_low_water;
+	uint32_t		mbuf_high_water;
+
+	uint32_t		mbuf_read_dma_low_water_jumbo;
+	uint32_t		mbuf_mac_rx_low_water_jumbo;
+	uint32_t		mbuf_high_water_jumbo;
+
+	uint32_t		dma_low_water;
+	uint32_t		dma_high_water;
+};
+
+struct tg3 {
+#if 0
+	/* SMP locking strategy:
+	 *
+	 * lock: Held during all operations except TX packet
+	 *       processing.
+	 *
+	 * tx_lock: Held during tg3_start_xmit{,_4gbug} and tg3_tx
+	 *
+	 * If you want to shut up all asynchronous processing you must
+	 * acquire both locks, 'lock' taken before 'tx_lock'.  IRQs must
+	 * be disabled to take 'lock' but only softirq disabling is
+	 * necessary for acquisition of 'tx_lock'.
+	 */
+	spinlock_t			lock;
+	spinlock_t			tx_lock;
+#endif
+
+	uint32_t			tx_prod;
+#if 0
+	uint32_t			tx_cons;
+#endif
+	uint32_t			rx_rcb_ptr;
+	uint32_t			rx_std_ptr;
+#if 0
+	uint32_t			rx_jumbo_ptr;
+	spinlock_t			indirect_lock;
+
+	struct net_device_stats		net_stats;
+	struct net_device_stats		net_stats_prev;
+#endif
+	unsigned long			phy_crc_errors;
+
+#if 0
+	uint32_t			rx_offset;
+#endif
+	uint32_t			tg3_flags;
+#if 0
+#define TG3_FLAG_HOST_TXDS		0x00000001
+#endif
+#define TG3_FLAG_TXD_MBOX_HWBUG		0x00000002
+#define TG3_FLAG_RX_CHECKSUMS		0x00000004
+#define TG3_FLAG_USE_LINKCHG_REG	0x00000008
+#define TG3_FLAG_USE_MI_INTERRUPT	0x00000010
+#define TG3_FLAG_ENABLE_ASF		0x00000020
+#define TG3_FLAG_5701_REG_WRITE_BUG	0x00000040
+#define TG3_FLAG_POLL_SERDES		0x00000080
+#define TG3_FLAG_MBOX_WRITE_REORDER	0x00000100
+#define TG3_FLAG_PCIX_TARGET_HWBUG	0x00000200
+#define TG3_FLAG_WOL_SPEED_100MB	0x00000400
+#define TG3_FLAG_WOL_ENABLE		0x00000800
+#define TG3_FLAG_EEPROM_WRITE_PROT	0x00001000
+#define TG3_FLAG_NVRAM			0x00002000
+#define TG3_FLAG_NVRAM_BUFFERED		0x00004000
+#define TG3_FLAG_RX_PAUSE		0x00008000
+#define TG3_FLAG_TX_PAUSE		0x00010000
+#define TG3_FLAG_PCIX_MODE		0x00020000
+#define TG3_FLAG_PCI_HIGH_SPEED		0x00040000
+#define TG3_FLAG_PCI_32BIT		0x00080000
+#define TG3_FLAG_NO_TX_PSEUDO_CSUM	0x00100000
+#define TG3_FLAG_NO_RX_PSEUDO_CSUM	0x00200000
+#define TG3_FLAG_SERDES_WOL_CAP		0x00400000
+#define TG3_FLAG_JUMBO_ENABLE		0x00800000
+#define TG3_FLAG_10_100_ONLY		0x01000000
+#define TG3_FLAG_PAUSE_AUTONEG		0x02000000
+#define TG3_FLAG_PAUSE_RX		0x04000000
+#define TG3_FLAG_PAUSE_TX		0x08000000
+#define TG3_FLAG_BROKEN_CHECKSUMS	0x10000000
+#define TG3_FLAG_GOT_SERDES_FLOWCTL	0x20000000
+#define TG3_FLAG_SPLIT_MODE		0x40000000
+#define TG3_FLAG_INIT_COMPLETE		0x80000000
+
+	uint32_t			tg3_flags2;
+#define TG3_FLG2_RESTART_TIMER		0x00000001
+#define TG3_FLG2_SUN_5704		0x00000002
+#define TG3_FLG2_NO_ETH_WIRE_SPEED	0x00000004
+#define TG3_FLG2_IS_5788		0x00000008
+#define TG3_FLG2_MAX_RXPEND_64		0x00000010
+#define TG3_FLG2_TSO_CAPABLE		0x00000020
+
+
+
+	uint32_t			split_mode_max_reqs;
+#define SPLIT_MODE_5704_MAX_REQ		3
+
+#if 0
+	struct timer_list		timer;
+	uint16_t			timer_counter;
+	uint16_t			timer_multiplier;
+	uint32_t			timer_offset;
+	uint16_t			asf_counter;
+	uint16_t			asf_multiplier;
+#endif
+
+	struct tg3_link_config		link_config;
+	struct tg3_bufmgr_config	bufmgr_config;
+
+#if 0
+	uint32_t			rx_pending;
+	uint32_t			rx_jumbo_pending;
+	uint32_t			tx_pending;
+#endif
+
+	/* cache h/w values, often passed straight to h/w */
+	uint32_t			rx_mode;
+	uint32_t			tx_mode;
+	uint32_t			mac_mode;
+	uint32_t			mi_mode;
+	uint32_t			misc_host_ctrl;
+	uint32_t			grc_mode;
+	uint32_t			grc_local_ctrl;
+	uint32_t			dma_rwctrl;
+#if 0
+	uint32_t			coalesce_mode;
+#endif
+
+	/* PCI block */
+	uint16_t			pci_chip_rev_id;
+#if 0
+	uint8_t				pci_cacheline_sz;
+	uint8_t				pci_lat_timer;
+	uint8_t				pci_hdr_type;
+	uint8_t				pci_bist;
+#endif
+	uint32_t			pci_cfg_state[64 / sizeof(uint32_t)];
+
+	int				pm_cap;
+
+	/* PHY info */
+	uint32_t			phy_id;
+#define PHY_ID_MASK			0xfffffff0
+#define PHY_ID_BCM5400			0x60008040
+#define PHY_ID_BCM5401			0x60008050
+#define PHY_ID_BCM5411			0x60008070
+#define PHY_ID_BCM5701			0x60008110
+#define PHY_ID_BCM5703			0x60008160
+#define PHY_ID_BCM5704			0x60008190
+#define PHY_ID_BCM5705			0x600081a0
+#define PHY_ID_BCM8002			0x60010140
+#define PHY_ID_SERDES			0xfeedbee0
+#define PHY_ID_INVALID			0xffffffff
+#define PHY_ID_REV_MASK			0x0000000f
+#define PHY_REV_BCM5401_B0		0x1
+#define PHY_REV_BCM5401_B2		0x3
+#define PHY_REV_BCM5401_C0		0x6
+#define PHY_REV_BCM5411_X0		0x1 /* Found on Netgear GA302T */
+
+	enum phy_led_mode		led_mode;
+
+	char				board_part_number[24];
+	uint32_t			nic_sram_data_cfg;
+	uint32_t			pci_clock_ctrl;
+#if 0
+	struct pci_device		*pdev_peer;
+#endif
+
+	/* This macro assumes the passed PHY ID is already masked
+	 * with PHY_ID_MASK.
+	 */
+#define KNOWN_PHY_ID(X)		\
+	((X) == PHY_ID_BCM5400 || (X) == PHY_ID_BCM5401 || \
+	 (X) == PHY_ID_BCM5411 || (X) == PHY_ID_BCM5701 || \
+	 (X) == PHY_ID_BCM5703 || (X) == PHY_ID_BCM5704 || \
+	 (X) == PHY_ID_BCM5705 || \
+	 (X) == PHY_ID_BCM8002 || (X) == PHY_ID_SERDES)
+
+	unsigned long			regs;
+	struct pci_device		*pdev;
+	struct nic			*nic;
+#if 0
+	struct net_device		*dev;
+#endif
+#if TG3_VLAN_TAG_USED
+	struct vlan_group		*vlgrp;
+#endif
+
+	struct tg3_rx_buffer_desc	*rx_std;
+#if 0
+	struct ring_info		*rx_std_buffers;
+	dma_addr_t			rx_std_mapping;
+	struct tg3_rx_buffer_desc	*rx_jumbo;
+	struct ring_info		*rx_jumbo_buffers;
+	dma_addr_t			rx_jumbo_mapping;
+#endif
+
+	struct tg3_rx_buffer_desc	*rx_rcb;
+#if 0
+	dma_addr_t			rx_rcb_mapping;
+#endif
+
+	/* TX descs are only used if TG3_FLAG_HOST_TXDS is set. */
+	struct tg3_tx_buffer_desc	*tx_ring;
+#if 0
+	struct tx_ring_info		*tx_buffers;
+	dma_addr_t			tx_desc_mapping;
+#endif
+
+	struct tg3_hw_status		*hw_status;
+#if 0
+	dma_addr_t			status_mapping;
+#endif
+#if 0
+	uint32_t			msg_enable;
+#endif
+
+	struct tg3_hw_stats		*hw_stats;
+#if 0
+	dma_addr_t			stats_mapping;
+#endif
+
+	int				carrier_ok;
+	uint16_t			subsystem_vendor;
+	uint16_t			subsystem_device;
+};
+
+#endif /* !(_T3_H) */
diff -Naur grub-0.97.orig/netboot/tiara.c grub-0.97/netboot/tiara.c
--- grub-0.97.orig/netboot/tiara.c	2003-07-09 11:45:38.000000000 +0000
+++ grub-0.97/netboot/tiara.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,255 +0,0 @@
-/**************************************************************************
-Etherboot -  BOOTP/TFTP Bootstrap Program
-
-TIARA (Fujitsu Etherstar) NIC driver for Etherboot
-Copyright (c) Ken Yap 1998
-
-Information gleaned from:
-
-TIARA.ASM Packet driver by Brian Fisher, Queens U, Kingston, Ontario
-Fujitsu MB86960 spec sheet (different chip but same family)
-***************************************************************************/
-
-/*
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2, or (at
- * your option) any later version.
- */
-
-/* to get some global routines like printf */
-#include "etherboot.h"
-/* to get the interface to the body of the program */
-#include "nic.h"
-#include "cards.h"
-
-/*
-	EtherStar I/O Register offsets
-*/
-
-/* Offsets of registers */
-#define	DLCR_XMIT_STAT	0x00
-#define	DLCR_XMIT_MASK	0x01
-#define	DLCR_RECV_STAT	0x02
-#define	DLCR_RECV_MASK	0x03
-#define	DLCR_XMIT_MODE	0x04
-#define	DLCR_RECV_MODE	0x05
-#define	DLCR_ENABLE	0x06
-#define	DLCR_TDR_LOW	0x07
-#define	DLCR_NODE_ID	0x08
-#define	DLCR_TDR_HIGH	0x0F
-#define	BMPR_MEM_PORT	0x10
-#define	BMPR_PKT_LEN	0x12
-#define	BMPR_DMA_ENABLE	0x14
-#define	PROM_ID		0x18
-
-#define	TMST		0x80
-#define	TMT_OK		0x80
-#define	TMT_16COLL	0x02
-#define	BUF_EMPTY	0x40
-
-#define	CARD_DISABLE	0x80	/* written to DLCR_ENABLE to disable card */
-#define	CARD_ENABLE	0	/* written to DLCR_ENABLE to enable card */
-
-#define	CLEAR_STATUS	0x0F	/* used to clear status info */
-/*
-	00001111B
-	!!!!!!!!--------
-	!!!!!!!+--------CLEAR BUS WRITE ERROR
-	!!!!!!+---------CLEAR 16 COLLISION
-	!!!!!+----------CLEAR COLLISION
-	!!!!+-----------CLEAR UNDERFLOW
-	!!!+------------NC
-	!!+-------------NC
-	!+--------------NC
-	+---------------NC
-*/
-
-#define	NO_TX_IRQS	0	/* written to clear transmit IRQs */
-
-#define	CLR_RCV_STATUS	0xCF	/* clears receive status */
-
-#define	EN_RCV_IRQS	0x80	/* enable receive interrupts */
-/*
-	10000000B
-	!!!!!!!!--------
-	!!!!!!!+--------ENABLE OVERFLOW
-	!!!!!!+---------ENABLE CRC
-	!!!!!+----------ENABLE ALIGN
-	!!!!+-----------ENABLE SHORT PKT
-	!!!+------------DISABLE REMOTE RESET
-	!!+-------------RESERVED
-	!+--------------RESERVED
-	+---------------ENABLE PKT READY
-*/
-
-#define	XMIT_MODE	0x02
-/*
-	00000010B
-	!!!!!!!!---------ENABLE CARRIER DETECT
-	!!!!!!!+---------DISABLE LOOPBACK
-*/
-
-#define	RECV_MODE	0x02
-/*
-	00000010B
-	!!!!!!!!---------ACCEPT ALL PACKETS
-	!!!!!!!+---------ACCEPT PHYSICAL, MULTICAST, AND
-	!!!!!!+----------BROADCAST PACKETS
-	!!!!!+-----------DISABLE REMOTE RESET
-	!!!!+------------DISABLE SHORT PACKETS
-	!!!+-------------USE 6 BYTE ADDRESS
-	!!+--------------NC
-	!+---------------NC
-	+----------------DISABLE CRC TEST MODE
-*/
-
-/* NIC specific static variables go here */
-
-static unsigned short	ioaddr;
-
-/**************************************************************************
-RESET - Reset adapter
-***************************************************************************/
-static void tiara_reset(struct nic *nic)
-{
-	int		i;
-
-	outb(CARD_DISABLE, ioaddr + DLCR_ENABLE);
-	outb(CLEAR_STATUS, ioaddr + DLCR_XMIT_STAT);
-	outb(NO_TX_IRQS, ioaddr + DLCR_XMIT_MASK);
-	outb(CLR_RCV_STATUS, ioaddr + DLCR_RECV_STAT);
-	outb(XMIT_MODE, ioaddr + DLCR_XMIT_MODE);
-	outb(RECV_MODE, ioaddr + DLCR_RECV_MODE);
-	/* Vacuum recv buffer */
-	while ((inb(ioaddr + DLCR_RECV_MODE) & BUF_EMPTY) == 0)
-		inb(ioaddr + BMPR_MEM_PORT);
-	/* Set node address */
-	for (i = 0; i < ETH_ALEN; ++i)
-		outb(nic->node_addr[i], ioaddr + DLCR_NODE_ID + i);
-	outb(CLR_RCV_STATUS, ioaddr + DLCR_RECV_STAT);
-	outb(CARD_ENABLE, ioaddr + DLCR_ENABLE);
-}
-
-/**************************************************************************
-POLL - Wait for a frame
-***************************************************************************/
-static int tiara_poll(struct nic *nic)
-{
-	unsigned int		len;
-
-	if (inb(ioaddr + DLCR_RECV_MODE) & BUF_EMPTY)
-		return (0);
-	/* Ack packet */
-	outw(CLR_RCV_STATUS, ioaddr + DLCR_RECV_STAT);
-	len = inw(ioaddr + BMPR_MEM_PORT);		/* throw away status */
-	len = inw(ioaddr + BMPR_MEM_PORT);
-	/* Drop overlength packets */
-	if (len > ETH_FRAME_LEN)
-		return (0);		/* should we drain the buffer? */
-	insw(ioaddr + BMPR_MEM_PORT, nic->packet, len / 2);
-	/* If it's our own, drop it */
-	if (memcmp(nic->packet + ETH_ALEN, nic->node_addr, ETH_ALEN) == 0)
-		return (0);
-	nic->packetlen = len;
-	return (1);
-}
-
-/**************************************************************************
-TRANSMIT - Transmit a frame
-***************************************************************************/
-static void tiara_transmit(
-struct nic *nic,
-const char *d,			/* Destination */
-unsigned int t,			/* Type */
-unsigned int s,			/* size */
-const char *p)			/* Packet */
-{
-	unsigned int	len;
-	unsigned long	time;
-
-	len = s + ETH_HLEN;
-	if (len < ETH_ZLEN)
-		len = ETH_ZLEN;
-	t = htons(t);
-	outsw(ioaddr + BMPR_MEM_PORT, d, ETH_ALEN / 2);
-	outsw(ioaddr + BMPR_MEM_PORT, nic->node_addr, ETH_ALEN / 2);
-	outw(t, ioaddr + BMPR_MEM_PORT);
-	outsw(ioaddr + BMPR_MEM_PORT, p, s / 2);
-	if (s & 1)					/* last byte */
-		outb(p[s-1], ioaddr + BMPR_MEM_PORT);
-	while (s++ < ETH_ZLEN - ETH_HLEN)	/* pad */
-		outb(0, ioaddr + BMPR_MEM_PORT);
-	outw(len | (TMST << 8), ioaddr + BMPR_PKT_LEN);
-	/* wait for transmit complete */
-	time = currticks() + TICKS_PER_SEC;		/* wait one second */
-	while (currticks() < time && (inb(ioaddr) & (TMT_OK|TMT_16COLL)) == 0)
-		;
-	if ((inb(ioaddr) & (TMT_OK|TMT_16COLL)) == 0)
-		printf("Tiara timed out on transmit\n");
-	/* Do we need to ack the transmit? */
-}
-
-/**************************************************************************
-DISABLE - Turn off ethernet interface
-***************************************************************************/
-static void tiara_disable(struct nic *nic)
-{
-	/* Apparently only a power down can do this properly */
-	outb(CARD_DISABLE, ioaddr + DLCR_ENABLE);
-}
-
-static int tiara_probe1(struct nic *nic)
-{
-	/* Hope all the Tiara cards have this vendor prefix */
-	static char	vendor_prefix[] = { 0x08, 0x00, 0x1A };
-	static char	all_ones[] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
-	int		i;
-
-	for (i = 0; i < ETH_ALEN; ++i)
-		nic->node_addr[i] = inb(ioaddr + PROM_ID + i);
-	if (memcmp(nic->node_addr, vendor_prefix, sizeof(vendor_prefix)) != 0)
-		return (0);
-	if (memcmp(nic->node_addr, all_ones, sizeof(all_ones)) == 0)
-		return (0);
-	printf("\nTiara ioaddr %#hX, addr %!\n", ioaddr, nic->node_addr);
-	return (1);
-}
-
-/**************************************************************************
-PROBE - Look for an adapter, this routine's visible to the outside
-***************************************************************************/
-struct nic *tiara_probe(struct nic *nic, unsigned short *probe_addrs)
-{
-	/* missing entries are addresses usually already used */
-	static unsigned short	io_addrs[] = {
-		0x100, 0x120, 0x140, 0x160,
-		0x180, 0x1A0, 0x1C0, 0x1E0,
-		0x200, 0x220, 0x240, /*Par*/
-		0x280, 0x2A0, 0x2C0, /*Ser*/
-		0x300, 0x320, 0x340, /*Par*/
-		0x380, /*Vid,Par*/ 0x3C0, /*Ser*/
-		0x0
-	};
-	unsigned short		*p;
-
-	/* if probe_addrs is 0, then routine can use a hardwired default */
-	if (probe_addrs == 0)
-		probe_addrs = io_addrs;
-	for (p = probe_addrs; (ioaddr = *p) != 0; ++p)
-		if (tiara_probe1(nic))
-			break;
-	/* if board found */
-	if (ioaddr != 0)
-	{
-		tiara_reset(nic);
-		/* point to NIC specific routines */
-		nic->reset = tiara_reset;
-		nic->poll = tiara_poll;
-		nic->transmit = tiara_transmit;
-		nic->disable = tiara_disable;
-		return nic;
-	}
-	else
-		return (0);
-}
diff -Naur grub-0.97.orig/netboot/timer.c grub-0.97/netboot/timer.c
--- grub-0.97.orig/netboot/timer.c	2003-07-09 11:45:38.000000000 +0000
+++ grub-0.97/netboot/timer.c	2005-08-31 19:03:35.000000000 +0000
@@ -6,122 +6,24 @@
  * published by the Free Software Foundation; either version 2, or (at
  * your option) any later version.
  */
-
-#include	"etherboot.h"
+#include        "grub.h"
 #include	"timer.h"
 
-void load_timer2(unsigned int ticks)
-{
-	/* Set up the timer gate, turn off the speaker */
-	outb((inb(PPC_PORTB) & ~PPCB_SPKR) | PPCB_T2GATE, PPC_PORTB);
-	outb(TIMER2_SEL|WORD_ACCESS|MODE0|BINARY_COUNT, TIMER_MODE_PORT);
-	outb(ticks & 0xFF, TIMER2_PORT);
-	outb(ticks >> 8, TIMER2_PORT);
-}
-
-#if defined(CONFIG_TSC_CURRTICKS)
-#define rdtsc(low,high) \
-     __asm__ __volatile__("rdtsc" : "=a" (low), "=d" (high))
-
-#define rdtscll(val) \
-     __asm__ __volatile__ ("rdtsc" : "=A" (val))
-
-
-#define HZ TICKS_PER_SEC
-#define CLOCK_TICK_RATE	1193180U /* Underlying HZ */
-/* LATCH is used in the interval timer and ftape setup. */
-#define LATCH  ((CLOCK_TICK_RATE + HZ/2) / HZ)	/* For divider */
+/* Machine Independant timer helper functions */
 
-
-/* ------ Calibrate the TSC ------- 
- * Return 2^32 * (1 / (TSC clocks per usec)) for do_fast_gettimeoffset().
- * Too much 64-bit arithmetic here to do this cleanly in C, and for
- * accuracy's sake we want to keep the overhead on the CTC speaker (channel 2)
- * output busy loop as low as possible. We avoid reading the CTC registers
- * directly because of the awkward 8-bit access mechanism of the 82C54
- * device.
- */
-
-#define CALIBRATE_LATCH	(5 * LATCH)
-
-static unsigned long long calibrate_tsc(void)
+void mdelay(unsigned int msecs)
 {
-	/* Set the Gate high, disable speaker */
-	outb((inb(0x61) & ~0x02) | 0x01, 0x61);
-
-	/*
-	 * Now let's take care of CTC channel 2
-	 *
-	 * Set the Gate high, program CTC channel 2 for mode 0,
-	 * (interrupt on terminal count mode), binary count,
-	 * load 5 * LATCH count, (LSB and MSB) to begin countdown.
-	 */
-	outb(0xb0, 0x43);			/* binary, mode 0, LSB/MSB, Ch 2 */
-	outb(CALIBRATE_LATCH & 0xff, 0x42);	/* LSB of count */
-	outb(CALIBRATE_LATCH >> 8, 0x42);	/* MSB of count */
-
-	{
-		unsigned long startlow, starthigh;
-		unsigned long endlow, endhigh;
-		unsigned long count;
-
-		rdtsc(startlow,starthigh);
-		count = 0;
-		do {
-			count++;
-		} while ((inb(0x61) & 0x20) == 0);
-		rdtsc(endlow,endhigh);
-
-		/* Error: ECTCNEVERSET */
-		if (count <= 1)
-			goto bad_ctc;
-
-		/* 64-bit subtract - gcc just messes up with long longs */
-		__asm__("subl %2,%0\n\t"
-			"sbbl %3,%1"
-			:"=a" (endlow), "=d" (endhigh)
-			:"g" (startlow), "g" (starthigh),
-			 "0" (endlow), "1" (endhigh));
-
-		/* Error: ECPUTOOFAST */
-		if (endhigh)
-			goto bad_ctc;
-
-		endlow /= 5;
-		return endlow;
+	unsigned int i;
+	for(i = 0; i < msecs; i++) {
+		udelay(1000);
+		poll_interruptions();
 	}
-
-	/*
-	 * The CTC wasn't reliable: we got a hit on the very first read,
-	 * or the CPU was so fast/slow that the quotient wouldn't fit in
-	 * 32 bits..
-	 */
-bad_ctc:
-	printf("bad_ctc\n");
-	return 0;
 }
 
-
-unsigned long currticks(void)
+void waiton_timer2(unsigned int ticks)
 {
-	static unsigned long clocks_per_tick;
-	unsigned long clocks_high, clocks_low;
-	unsigned long currticks;
-	if (!clocks_per_tick) {
-		clocks_per_tick = calibrate_tsc();
-		printf("clocks_per_tick = %d\n", clocks_per_tick);
+	load_timer2(ticks);
+	while(timer2_running()) {
+		poll_interruptions();
 	}
-
-	/* Read the Time Stamp Counter */
-	rdtsc(clocks_low, clocks_high);
-
-	/* currticks = clocks / clocks_per_tick; */
-	__asm__("divl %1"
-		:"=a" (currticks)
-		:"r" (clocks_per_tick), "0" (clocks_low), "d" (clocks_high));
-
-
-	return currticks;
 }
-
-#endif /* RTC_CURRTICKS */
diff -Naur grub-0.97.orig/netboot/timer.h grub-0.97/netboot/timer.h
--- grub-0.97.orig/netboot/timer.h	2003-07-09 11:45:38.000000000 +0000
+++ grub-0.97/netboot/timer.h	2005-08-31 19:03:35.000000000 +0000
@@ -36,7 +36,8 @@
 #define	BCD_COUNT	0x01
 
 /* Timers tick over at this rate */
-#define	TICKS_PER_MS	1193
+#define CLOCK_TICK_RATE	1193180U
+#define	TICKS_PER_MS	(CLOCK_TICK_RATE/1000)
 
 /* Parallel Peripheral Controller Port B */
 #define	PPC_PORTB	0x61
@@ -49,16 +50,19 @@
 /* Ticks must be between 0 and 65535 (0 == 65536)
    because it is a 16 bit counter */
 extern void load_timer2(unsigned int ticks);
-extern inline int timer2_running(void)
-{
-	return ((inb(PPC_PORTB) & PPCB_T2OUT) == 0);
-}
-
-extern inline void waiton_timer2(unsigned int ticks)
-{
-	load_timer2(ticks);
-	while ((inb(PPC_PORTB) & PPCB_T2OUT) == 0)
-		;
-}
+extern inline int timer2_running(void);
+extern void waiton_timer2(unsigned int ticks);
+extern void __load_timer2(unsigned int ticks);
+
+extern void setup_timers(void);
+extern void ndelay(unsigned int nsecs);
+extern void udelay(unsigned int usecs);
+extern void mdelay(unsigned int msecs);
+//extern unsigned long currticks(void);
+
+struct timeval {
+	long tv_sec;
+	long tv_usec;
+};
 
 #endif	/* TIMER_H */
diff -Naur grub-0.97.orig/netboot/tlan.c grub-0.97/netboot/tlan.c
--- grub-0.97.orig/netboot/tlan.c	2003-07-09 11:45:38.000000000 +0000
+++ grub-0.97/netboot/tlan.c	2005-09-01 00:05:20.000000000 +0000
@@ -1,3746 +1,1814 @@
+#define EB51
+
+#ifdef EB50
+#define __unused __attribute__((unused))
+#endif
+
 /**************************************************************************
-Etherboot -  BOOTP/TFTP Bootstrap Program
-TLAN driver for Etherboot
+*
+*    tlan.c -- Etherboot device driver for the Texas Instruments ThunderLAN
+*    Written 2003-2003 by Timothy Legge <tlegge@rogers.com>
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the License, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not, write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*    Portions of this code based on:
+*	lan.c: Linux ThunderLan Driver:
+*
+*	by James Banks
+*
+*  	(C) 1997-1998 Caldera, Inc.
+*	(C) 1998 James Banks
+*	(C) 1999-2001 Torben Mathiasen
+*	(C) 2002 Samuel Chessman
+*
+*    REVISION HISTORY:
+*    ================
+*    v1.0	07-08-2003	timlegge	Initial not quite working version
+*    v1.1	07-27-2003	timlegge	Sync 5.0 and 5.1 versions
+*    v1.2	08-19-2003	timlegge	Implement Multicast Support
+*    v1.3	08-23-2003	timlegge	Fix the transmit Function
+*    v1.4	01-17-2004	timlegge	Initial driver output cleanup    
+*    
+*    Indent Options: indent -kr -i8
 ***************************************************************************/
 
-/*
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2, or (at
- * your option) any later version.
- */
-
 /* to get some global routines like printf */
 #include "etherboot.h"
 /* to get the interface to the body of the program */
 #include "nic.h"
 /* to get the PCI support functions, if this is a PCI NIC */
 #include "pci.h"
-/* to get our own prototype */
-#include "cards.h"
-
-	/*****************************************************************
-	 * TLan Definitions
-	 *
-	 ****************************************************************/
+#include "timer.h"
+#include "tlan.h"
 
-#define TLAN_MIN_FRAME_SIZE	64
-#define TLAN_MAX_FRAME_SIZE	1600
+#define drv_version "v1.4"
+#define drv_date "01-17-2004"
 
-#define TLAN_NUM_RX_LISTS	32
-#define TLAN_NUM_TX_LISTS	64
+/* NIC specific static variables go here */
+#define HZ 100
+#define TX_TIME_OUT	  (6*HZ)
 
-#define TLAN_IGNORE		0
-#define TLAN_RECORD		1
+#ifdef EB50
+#define	cpu_to_le32(val) (val)
+#define	le32_to_cpu(val) (val)
+#define	virt_to_bus(x) ((unsigned long) x)
+#define	bus_to_virt(x) ((unsigned long) x)
+#endif
 
-#define TLAN_DBG(lvl, format, args...)	if (debug&lvl) printf("TLAN: " format, ##args );
-#define TLAN_DEBUG_GNRL		0x0001
-#define TLAN_DEBUG_TX		0x0002
-#define TLAN_DEBUG_RX		0x0004 
-#define TLAN_DEBUG_LIST		0x0008
-#define TLAN_DEBUG_PROBE	0x0010
+/* Condensed operations for readability. */
+#define virt_to_le32desc(addr)  cpu_to_le32(virt_to_bus(addr))
+#define le32desc_to_virt(addr)  bus_to_virt(le32_to_cpu(addr))
 
-#define MAX_TLAN_BOARDS		8	 /* Max number of boards installed at a time */
 
-	/*****************************************************************
-	 * Device Identification Definitions
-	 *
-	 ****************************************************************/
-		
-#define PCI_DEVICE_ID_NETELLIGENT_10_T2			0xB012
-#define PCI_DEVICE_ID_NETELLIGENT_10_100_WS_5100	0xB030
-#ifndef PCI_DEVICE_ID_OLICOM_OC2183
-#define PCI_DEVICE_ID_OLICOM_OC2183			0x0013
-#endif
-#ifndef PCI_DEVICE_ID_OLICOM_OC2325
-#define PCI_DEVICE_ID_OLICOM_OC2325			0x0012
-#endif
-#ifndef PCI_DEVICE_ID_OLICOM_OC2326
-#define PCI_DEVICE_ID_OLICOM_OC2326			0x0014
-#endif
-#define TLAN_ADAPTER_NONE		0x00000000
-#define TLAN_ADAPTER_UNMANAGED_PHY	0x00000001
-#define TLAN_ADAPTER_BIT_RATE_PHY	0x00000002
-#define TLAN_ADAPTER_USE_INTERN_10	0x00000004
-#define TLAN_ADAPTER_ACTIVITY_LED	0x00000008
-#define TLAN_SPEED_DEFAULT	0
-#define TLAN_SPEED_10		10
-#define TLAN_SPEED_100		100
-#define TLAN_DUPLEX_DEFAULT	0
-#define TLAN_DUPLEX_HALF	1
-#define TLAN_DUPLEX_FULL	2
-#define TLAN_BUFFERS_PER_LIST	10
-#define TLAN_LAST_BUFFER	0x80000000
-#define TLAN_CSTAT_UNUSED	0x8000
-#define TLAN_CSTAT_FRM_CMP	0x4000
-#define TLAN_CSTAT_READY	0x3000
-#define TLAN_CSTAT_EOC		0x0800
-#define TLAN_CSTAT_RX_ERROR	0x0400
-#define TLAN_CSTAT_PASS_CRC	0x0200
-#define TLAN_CSTAT_DP_PR	0x0100
-
-	/*****************************************************************
-	 * PHY definitions
-	 *
-	 ****************************************************************/
-
-#define TLAN_PHY_MAX_ADDR	0x1F
-#define TLAN_PHY_NONE		0x20
-
-	/*****************************************************************
-	 * TLan Driver Timer Definitions
-	 *
-	 ****************************************************************/
-
-#define TLAN_TIMER_LINK_BEAT		1
-#define TLAN_TIMER_ACTIVITY		2
-#define TLAN_TIMER_PHY_PDOWN		3
-#define TLAN_TIMER_PHY_PUP		4
-#define TLAN_TIMER_PHY_RESET		5
-#define TLAN_TIMER_PHY_START_LINK	6
-#define TLAN_TIMER_PHY_FINISH_AN	7
-#define TLAN_TIMER_FINISH_RESET		8
-#define TLAN_TIMER_ACT_DELAY		(HZ/10)
-
-	/*****************************************************************
-	 * TLan Driver Eeprom Definitions
-	 *
-	 ****************************************************************/
-
-#define TLAN_EEPROM_ACK		0
-#define TLAN_EEPROM_STOP	1
-
-	/*****************************************************************
-	 * Host Register Offsets and Contents
-	 *
-	 ****************************************************************/
-
-#define TLAN_HOST_CMD			0x00
-#define 	TLAN_HC_GO		0x80000000
-#define		TLAN_HC_STOP		0x40000000
-#define		TLAN_HC_ACK		0x20000000
-#define		TLAN_HC_CS_MASK		0x1FE00000
-#define		TLAN_HC_EOC		0x00100000
-#define		TLAN_HC_RT		0x00080000
-#define		TLAN_HC_NES		0x00040000
-#define		TLAN_HC_AD_RST		0x00008000
-#define		TLAN_HC_LD_TMR		0x00004000
-#define		TLAN_HC_LD_THR		0x00002000
-#define		TLAN_HC_REQ_INT		0x00001000
-#define		TLAN_HC_INT_OFF		0x00000800
-#define		TLAN_HC_INT_ON		0x00000400
-#define		TLAN_HC_AC_MASK		0x000000FF
-#define TLAN_CH_PARM			0x04
-#define TLAN_DIO_ADR			0x08
-#define		TLAN_DA_ADR_INC		0x8000
-#define		TLAN_DA_RAM_ADR		0x4000
-#define TLAN_HOST_INT			0x0A
-#define		TLAN_HI_IV_MASK		0x1FE0
-#define		TLAN_HI_IT_MASK		0x001C
-#define TLAN_DIO_DATA			0x0C
-
-/* ThunderLAN Internal Register DIO Offsets */
-
-#define TLAN_NET_CMD			0x00
-#define		TLAN_NET_CMD_NRESET	0x80
-#define		TLAN_NET_CMD_NWRAP	0x40
-#define		TLAN_NET_CMD_CSF	0x20
-#define		TLAN_NET_CMD_CAF	0x10
-#define		TLAN_NET_CMD_NOBRX	0x08
-#define		TLAN_NET_CMD_DUPLEX	0x04
-#define		TLAN_NET_CMD_TRFRAM	0x02
-#define		TLAN_NET_CMD_TXPACE	0x01
-#define TLAN_NET_SIO			0x01
-#define 	TLAN_NET_SIO_MINTEN	0x80
-#define		TLAN_NET_SIO_ECLOK	0x40
-#define		TLAN_NET_SIO_ETXEN	0x20
-#define		TLAN_NET_SIO_EDATA	0x10
-#define		TLAN_NET_SIO_NMRST	0x08
-#define		TLAN_NET_SIO_MCLK	0x04
-#define		TLAN_NET_SIO_MTXEN	0x02
-#define		TLAN_NET_SIO_MDATA	0x01
-#define TLAN_NET_STS			0x02
-#define		TLAN_NET_STS_MIRQ	0x80
-#define		TLAN_NET_STS_HBEAT	0x40
-#define		TLAN_NET_STS_TXSTOP	0x20
-#define		TLAN_NET_STS_RXSTOP	0x10
-#define		TLAN_NET_STS_RSRVD	0x0F
-#define TLAN_NET_MASK			0x03
-#define		TLAN_NET_MASK_MASK7	0x80
-#define		TLAN_NET_MASK_MASK6	0x40
-#define		TLAN_NET_MASK_MASK5	0x20
-#define		TLAN_NET_MASK_MASK4	0x10
-#define		TLAN_NET_MASK_RSRVD	0x0F
-#define TLAN_NET_CONFIG			0x04
-#define 	TLAN_NET_CFG_RCLK	0x8000
-#define		TLAN_NET_CFG_TCLK	0x4000
-#define		TLAN_NET_CFG_BIT	0x2000
-#define		TLAN_NET_CFG_RXCRC	0x1000
-#define		TLAN_NET_CFG_PEF	0x0800
-#define		TLAN_NET_CFG_1FRAG	0x0400
-#define		TLAN_NET_CFG_1CHAN	0x0200
-#define		TLAN_NET_CFG_MTEST	0x0100
-#define		TLAN_NET_CFG_PHY_EN	0x0080
-#define		TLAN_NET_CFG_MSMASK	0x007F
-#define TLAN_MAN_TEST			0x06
-#define TLAN_DEF_VENDOR_ID		0x08
-#define TLAN_DEF_DEVICE_ID		0x0A
-#define TLAN_DEF_REVISION		0x0C
-#define TLAN_DEF_SUBCLASS		0x0D
-#define TLAN_DEF_MIN_LAT		0x0E
-#define TLAN_DEF_MAX_LAT		0x0F
-#define TLAN_AREG_0			0x10
-#define TLAN_AREG_1			0x16
-#define TLAN_AREG_2			0x1C
-#define TLAN_AREG_3			0x22
-#define TLAN_HASH_1			0x28
-#define TLAN_HASH_2			0x2C
-#define TLAN_GOOD_TX_FRMS		0x30
-#define TLAN_TX_UNDERUNS		0x33
-#define TLAN_GOOD_RX_FRMS		0x34
-#define TLAN_RX_OVERRUNS		0x37
-#define TLAN_DEFERRED_TX		0x38
-#define TLAN_CRC_ERRORS			0x3A
-#define TLAN_CODE_ERRORS		0x3B
-#define TLAN_MULTICOL_FRMS		0x3C
-#define TLAN_SINGLECOL_FRMS		0x3E
-#define TLAN_EXCESSCOL_FRMS		0x40
-#define TLAN_LATE_COLS			0x41
-#define TLAN_CARRIER_LOSS		0x42
-#define TLAN_ACOMMIT			0x43
-#define TLAN_LED_REG			0x44
-#define		TLAN_LED_ACT		0x10
-#define		TLAN_LED_LINK		0x01
-#define TLAN_BSIZE_REG			0x45
-#define TLAN_MAX_RX			0x46
-#define TLAN_INT_DIS			0x48
-#define		TLAN_ID_TX_EOC		0x04
-#define		TLAN_ID_RX_EOF		0x02
-#define		TLAN_ID_RX_EOC		0x01
-
-/* ThunderLAN Interrupt Codes */
-
-#define TLAN_INT_NUMBER_OF_INTS	8
-
-#define TLAN_INT_NONE			0x0000
-#define TLAN_INT_TX_EOF			0x0001
-#define TLAN_INT_STAT_OVERFLOW		0x0002
-#define TLAN_INT_RX_EOF			0x0003
-#define TLAN_INT_DUMMY			0x0004
-#define TLAN_INT_TX_EOC			0x0005
-#define TLAN_INT_STATUS_CHECK		0x0006
-#define TLAN_INT_RX_EOC			0x0007
-#define TLAN_TLPHY_ID			0x10
-#define TLAN_TLPHY_CTL			0x11
-#define 	TLAN_TC_IGLINK		0x8000
-#define		TLAN_TC_SWAPOL		0x4000
-#define		TLAN_TC_AUISEL		0x2000
-#define		TLAN_TC_SQEEN		0x1000
-#define		TLAN_TC_MTEST		0x0800
-#define		TLAN_TC_RESERVED	0x07F8
-#define		TLAN_TC_NFEW		0x0004
-#define		TLAN_TC_INTEN		0x0002
-#define		TLAN_TC_TINT		0x0001
-#define TLAN_TLPHY_STS			0x12
-#define		TLAN_TS_MINT		0x8000
-#define		TLAN_TS_PHOK		0x4000
-#define		TLAN_TS_POLOK		0x2000
-#define		TLAN_TS_TPENERGY	0x1000
-#define		TLAN_TS_RESERVED	0x0FFF
-#define TLAN_TLPHY_PAR			0x19
-#define		TLAN_PHY_CIM_STAT	0x0020
-#define		TLAN_PHY_SPEED_100	0x0040
-#define		TLAN_PHY_DUPLEX_FULL	0x0080
-#define		TLAN_PHY_AN_EN_STAT     0x0400
-
-
-/* ThunderLAN MII Registers */
-
-/* Generic MII/PHY Registers */
-
-#define MII_GEN_CTL			0x00
-#define 	MII_GC_RESET		0x8000
-#define		MII_GC_LOOPBK		0x4000
-#define		MII_GC_SPEEDSEL		0x2000
-#define		MII_GC_AUTOENB		0x1000
-#define		MII_GC_PDOWN		0x0800
-#define		MII_GC_ISOLATE		0x0400
-#define		MII_GC_AUTORSRT		0x0200
-#define		MII_GC_DUPLEX		0x0100
-#define		MII_GC_COLTEST		0x0080
-#define		MII_GC_RESERVED		0x007F
-#define MII_GEN_STS			0x01
-#define		MII_GS_100BT4		0x8000
-#define		MII_GS_100BTXFD		0x4000
-#define		MII_GS_100BTXHD		0x2000
-#define		MII_GS_10BTFD		0x1000
-#define		MII_GS_10BTHD		0x0800
-#define		MII_GS_RESERVED		0x07C0
-#define		MII_GS_AUTOCMPLT	0x0020
-#define		MII_GS_RFLT		0x0010
-#define		MII_GS_AUTONEG		0x0008
-#define		MII_GS_LINK		0x0004
-#define		MII_GS_JABBER		0x0002
-#define		MII_GS_EXTCAP		0x0001
-#define MII_GEN_ID_HI			0x02
-#define MII_GEN_ID_LO			0x03
-#define 	MII_GIL_OUI		0xFC00
-#define 	MII_GIL_MODEL		0x03F0
-#define 	MII_GIL_REVISION	0x000F
-#define MII_AN_ADV			0x04
-#define MII_AN_LPA			0x05
-#define MII_AN_EXP			0x06
-
-/* ThunderLAN Specific MII/PHY Registers */
-
-#define 	TLAN_TC_IGLINK		0x8000
-#define		TLAN_TC_SWAPOL		0x4000
-#define		TLAN_TC_AUISEL		0x2000
-#define		TLAN_TC_SQEEN		0x1000
-#define		TLAN_TC_MTEST		0x0800
-#define		TLAN_TC_RESERVED	0x07F8
-#define		TLAN_TC_NFEW		0x0004
-#define		TLAN_TC_INTEN		0x0002
-#define		TLAN_TC_TINT		0x0001
-#define		TLAN_TS_MINT		0x8000
-#define		TLAN_TS_PHOK		0x4000
-#define		TLAN_TS_POLOK		0x2000
-#define		TLAN_TS_TPENERGY	0x1000
-#define		TLAN_TS_RESERVED	0x0FFF
-#define		TLAN_PHY_CIM_STAT	0x0020
-#define		TLAN_PHY_SPEED_100	0x0040
-#define		TLAN_PHY_DUPLEX_FULL	0x0080
-#define		TLAN_PHY_AN_EN_STAT     0x0400
-
-/* National Sem. & Level1 PHY id's */
-#define NAT_SEM_ID1			0x2000
-#define NAT_SEM_ID2			0x5C01
-#define LEVEL1_ID1			0x7810
-#define LEVEL1_ID2			0x0000
-
-#define TLan_ClearBit( bit, port )	outb_p(inb_p(port) & ~bit, port)
-#define TLan_GetBit( bit, port )	((int) (inb_p(port) & bit))
-#define TLan_SetBit( bit, port )	outb_p(inb_p(port) | bit, port)
-
-typedef	unsigned int	u32;
-typedef	unsigned short	u16;
-typedef	unsigned char	u8;
+static void TLan_ResetLists(struct nic *nic __unused);
+static void TLan_ResetAdapter(struct nic *nic __unused);
+static void TLan_FinishReset(struct nic *nic __unused);
 
-/* Routines to access internal registers. */
+static void TLan_EeSendStart(u16);
+static int TLan_EeSendByte(u16, u8, int);
+static void TLan_EeReceiveByte(u16, u8 *, int);
+static int TLan_EeReadByte(u16 io_base, u8, u8 *);
 
-inline u8 TLan_DioRead8(u16 base_addr, u16 internal_addr)
-{
-	outw(internal_addr, base_addr + TLAN_DIO_ADR);
-	return (inb((base_addr + TLAN_DIO_DATA) + (internal_addr & 0x3)));
-	
-} /* TLan_DioRead8 */
+static void TLan_PhyDetect(struct nic *nic);
+static void TLan_PhyPowerDown(struct nic *nic);
+static void TLan_PhyPowerUp(struct nic *nic);
 
-inline u16 TLan_DioRead16(u16 base_addr, u16 internal_addr)
-{
-	outw(internal_addr, base_addr + TLAN_DIO_ADR);
-	return (inw((base_addr + TLAN_DIO_DATA) + (internal_addr & 0x2)));
 
-} /* TLan_DioRead16 */
+static void TLan_SetMac(struct nic *nic __unused, int areg, char *mac);
 
-inline u32 TLan_DioRead32(u16 base_addr, u16 internal_addr)
-{
-	outw(internal_addr, base_addr + TLAN_DIO_ADR);
-	return (inl(base_addr + TLAN_DIO_DATA));
+static void TLan_PhyReset(struct nic *nic);
+static void TLan_PhyStartLink(struct nic *nic);
+static void TLan_PhyFinishAutoNeg(struct nic *nic);
 
-} /* TLan_DioRead32 */
+#ifdef MONITOR
+static void TLan_PhyMonitor(struct nic *nic);
+#endif
 
-inline void TLan_DioWrite8(u16 base_addr, u16 internal_addr, u8 data)
-{
-	outw(internal_addr, base_addr + TLAN_DIO_ADR);
-	outb(data, base_addr + TLAN_DIO_DATA + (internal_addr & 0x3));
 
-}
+static void refill_rx(struct nic *nic __unused);
 
-inline void TLan_DioWrite16(u16 base_addr, u16 internal_addr, u16 data)
-{
-	outw(internal_addr, base_addr + TLAN_DIO_ADR);
-	outw(data, base_addr + TLAN_DIO_DATA + (internal_addr & 0x2));
+static int TLan_MiiReadReg(struct nic *nic __unused, u16, u16, u16 *);
+static void TLan_MiiSendData(u16, u32, unsigned);
+static void TLan_MiiSync(u16);
+static void TLan_MiiWriteReg(struct nic *nic __unused, u16, u16, u16);
 
-}
 
-inline void TLan_DioWrite32(u16 base_addr, u16 internal_addr, u32 data)
-{
-	outw(internal_addr, base_addr + TLAN_DIO_ADR);
-	outl(data, base_addr + TLAN_DIO_DATA + (internal_addr & 0x2));
+const char *media[] = {
+	"10BaseT-HD ", "10BaseT-FD ", "100baseTx-HD ",
+	"100baseTx-FD", "100baseT4", 0
+};
 
-}
+/* This much match tlan_pci_tbl[]!  */
+enum tlan_nics {
+	NETEL10 = 0, NETEL100 = 1, NETFLEX3I = 2, THUNDER = 3, NETFLEX3B =
+	    4, NETEL100PI = 5,
+	NETEL100D = 6, NETEL100I = 7, OC2183 = 8, OC2325 = 9, OC2326 =
+	    10, NETELLIGENT_10_100_WS_5100 = 11,
+	NETELLIGENT_10_T2 = 12
+};
 
-/* NIC specific static variables go here */
+struct pci_id_info {
+	const char *name;
+	int nic_id;
+	struct match_info {
+		u32 pci, pci_mask, subsystem, subsystem_mask;
+		u32 revision, revision_mask;	/* Only 8 bits. */
+	} id;
+	u32 flags;
+	u16 addrOfs;		/* Address Offset */
+};
 
-/*****************************************************************************
-******************************************************************************
+static struct pci_id_info tlan_pci_tbl[] = {
+	{"Compaq Netelligent 10 T PCI UTP", NETEL10,
+	 {0xae340e11, 0xffffffff, 0, 0, 0, 0},
+	 TLAN_ADAPTER_ACTIVITY_LED, 0x83},
+	{"Compaq Netelligent 10/100 TX PCI UTP", NETEL100,
+	 {0xae320e11, 0xffffffff, 0, 0, 0, 0},
+	 TLAN_ADAPTER_ACTIVITY_LED, 0x83},
+	{"Compaq Integrated NetFlex-3/P", NETFLEX3I,
+	 {0xae350e11, 0xffffffff, 0, 0, 0, 0},
+	 TLAN_ADAPTER_NONE, 0x83},
+	{"Compaq NetFlex-3/P", THUNDER,
+	 {0xf1300e11, 0xffffffff, 0, 0, 0, 0},
+	 TLAN_ADAPTER_UNMANAGED_PHY | TLAN_ADAPTER_BIT_RATE_PHY, 0x83},
+	{"Compaq NetFlex-3/P", NETFLEX3B,
+	 {0xf1500e11, 0xffffffff, 0, 0, 0, 0},
+	 TLAN_ADAPTER_NONE, 0x83},
+	{"Compaq Netelligent Integrated 10/100 TX UTP", NETEL100PI,
+	 {0xae430e11, 0xffffffff, 0, 0, 0, 0},
+	 TLAN_ADAPTER_ACTIVITY_LED, 0x83},
+	{"Compaq Netelligent Dual 10/100 TX PCI UTP", NETEL100D,
+	 {0xae400e11, 0xffffffff, 0, 0, 0, 0},
+	 TLAN_ADAPTER_NONE, 0x83},
+	{"Compaq Netelligent 10/100 TX Embedded UTP", NETEL100I,
+	 {0xb0110e11, 0xffffffff, 0, 0, 0, 0},
+	 TLAN_ADAPTER_NONE, 0x83},
+	{"Olicom OC-2183/2185", OC2183,
+	 {0x0013108d, 0xffffffff, 0, 0, 0, 0},
+	 TLAN_ADAPTER_USE_INTERN_10, 0x83},
+	{"Olicom OC-2325", OC2325,
+	 {0x0012108d, 0xffffffff, 0, 0, 0, 0},
+	 TLAN_ADAPTER_UNMANAGED_PHY, 0xF8},
+	{"Olicom OC-2326", OC2326,
+	 {0x0014108d, 0xffffffff, 0, 0, 0, 0},
+	 TLAN_ADAPTER_USE_INTERN_10, 0xF8},
+	{"Compaq Netelligent 10/100 TX UTP", NETELLIGENT_10_100_WS_5100,
+	 {0xb0300e11, 0xffffffff, 0, 0, 0, 0},
+	 TLAN_ADAPTER_ACTIVITY_LED, 0x83},
+	{"Compaq Netelligent 10 T/2 PCI UTP/Coax", NETELLIGENT_10_T2,
+	 {0xb0120e11, 0xffffffff, 0, 0, 0, 0},
+	 TLAN_ADAPTER_NONE, 0x83},
+	{"Compaq NetFlex-3/E", 0,	/* EISA card */
+	 {0, 0, 0, 0, 0, 0},
+	 TLAN_ADAPTER_ACTIVITY_LED | TLAN_ADAPTER_UNMANAGED_PHY |
+	 TLAN_ADAPTER_BIT_RATE_PHY, 0x83},
+	{"Compaq NetFlex-3/E", 0,	/* EISA card */
+	 {0, 0, 0, 0, 0, 0},
+	 TLAN_ADAPTER_ACTIVITY_LED, 0x83},
+	{0, 0,
+	 {0, 0, 0, 0, 0, 0},
+	 0, 0},
+};
 
-	ThunderLAN Driver Eeprom routines
 
-	The Compaq Netelligent 10 and 10/100 cards use a Microchip 24C02A
-	EEPROM.  These functions are based on information in Microchip's
-	data sheet.  I don't know how well this functions will work with
-	other EEPROMs.
+struct TLanList {
+	u32 forward;
+	u16 cStat;
+	u16 frameSize;
+	struct {
+		u32 count;
+		u32 address;
+	} buffer[TLAN_BUFFERS_PER_LIST];
+};
 
-******************************************************************************
-*****************************************************************************/
 
-	/***************************************************************
-	 *	TLan_EeSendStart
-	 *
-	 *	Returns:
-	 *		Nothing
-	 *	Parms:	
-	 *		io_base		The IO port base address for the
-	 *				TLAN device with the EEPROM to
-	 *				use.
-	 *
-	 *	This function sends a start cycle to an EEPROM attached
-	 *	to a TLAN chip.
-	 *
-	 **************************************************************/
 
-static void TLan_EeSendStart( u16 io_base )
-{
-	u16	sio;
+struct TLanList tx_ring[TLAN_NUM_TX_LISTS];
+static unsigned char txb[TLAN_MAX_FRAME_SIZE * TLAN_NUM_TX_LISTS];
 
-	outw( TLAN_NET_SIO, io_base + TLAN_DIO_ADR );
-	sio = io_base + TLAN_DIO_DATA + TLAN_NET_SIO;
+struct TLanList rx_ring[TLAN_NUM_RX_LISTS];
+static unsigned char rxb[TLAN_MAX_FRAME_SIZE * TLAN_NUM_RX_LISTS];
 
-	TLan_SetBit( TLAN_NET_SIO_ECLOK, sio );
-	TLan_SetBit( TLAN_NET_SIO_EDATA, sio );
-	TLan_SetBit( TLAN_NET_SIO_ETXEN, sio );
-	TLan_ClearBit( TLAN_NET_SIO_EDATA, sio );
-	TLan_ClearBit( TLAN_NET_SIO_ECLOK, sio );
+typedef u8 TLanBuffer[TLAN_MAX_FRAME_SIZE];
 
-} /* TLan_EeSendStart */
 
-	/***************************************************************
-	 *	TLan_EeSendByte
-	 *
-	 *	Returns:
-	 *		If the correct ack was received, 0, otherwise 1
-	 *	Parms:	io_base		The IO port base address for the
-	 *				TLAN device with the EEPROM to
-	 *				use.
-	 *		data		The 8 bits of information to
-	 *				send to the EEPROM.
-	 *		stop		If TLAN_EEPROM_STOP is passed, a
-	 *				stop cycle is sent after the
-	 *				byte is sent after the ack is
-	 *				read.
-	 *
-	 *	This function sends a byte on the serial EEPROM line,
-	 *	driving the clock to send each bit. The function then
-	 *	reverses transmission direction and reads an acknowledge
-	 *	bit.
-	 *
-	 **************************************************************/
+int chip_idx;
 
-static int TLan_EeSendByte( u16 io_base, u8 data, int stop )
-{
-	int	err;
-	u8	place;
-	u16	sio;
 
-	outw( TLAN_NET_SIO, io_base + TLAN_DIO_ADR );
-	sio = io_base + TLAN_DIO_DATA + TLAN_NET_SIO;
+/*****************************************************************
+* TLAN Private Information Structure
+*
+****************************************************************/
+struct tlan_private {
+	unsigned short vendor_id;	/* PCI Vendor code */
+	unsigned short dev_id;	/* PCI Device code */
+	const char *nic_name;
+	u8 *padBuffer;
+	u8 *rxBuffer;
+	struct TLanList *rx_head_desc;
+	u32 rxHead;
+	u32 rxTail;
+	u32 rxEocCount;
+	unsigned int cur_rx, dirty_rx;	/* Producer/consumer ring indicies */
+	unsigned int cur_tx, dirty_tx;
+	unsigned rx_buf_sz;	/* Based on mtu + Slack */
+	struct TLanList *txList;
+	struct TLanList *rxList;
+	u8 *txBuffer;
+	u32 txHead;
+	u32 txInProgress;
+	u32 txTail;
+	int eoc;
+	u32 txBusyCount;
+	u32 phyOnline;
+	u32 timerSetAt;
+	u32 timerType;
+	u32 adapterRev;
+	u32 aui;
+	u32 debug;
+	u32 duplex;
+	u32 phy[2];
+	u32 phyNum;
+	u32 speed;
+	u8 tlanRev;
+	u8 tlanFullDuplex;
+	char devName[8];
+	u8 link;
+	u8 is_eisa;
+	u8 neg_be_verbose;
+} TLanPrivateInfo;
 
-	/* Assume clock is low, tx is enabled; */
-	for ( place = 0x80; place != 0; place >>= 1 ) {
-		if ( place & data )
-			TLan_SetBit( TLAN_NET_SIO_EDATA, sio );
-		else
-			TLan_ClearBit( TLAN_NET_SIO_EDATA, sio );
-		TLan_SetBit( TLAN_NET_SIO_ECLOK, sio );
-		TLan_ClearBit( TLAN_NET_SIO_ECLOK, sio );
-	}
-	TLan_ClearBit( TLAN_NET_SIO_ETXEN, sio );
-	TLan_SetBit( TLAN_NET_SIO_ECLOK, sio );
-	err = TLan_GetBit( TLAN_NET_SIO_EDATA, sio );
-	TLan_ClearBit( TLAN_NET_SIO_ECLOK, sio );
-	TLan_SetBit( TLAN_NET_SIO_ETXEN, sio );
+static struct tlan_private *priv;
 
-	if ( ( ! err ) && stop ) {
-		TLan_ClearBit( TLAN_NET_SIO_EDATA, sio );	/* STOP, raise data while clock is high */
-		TLan_SetBit( TLAN_NET_SIO_ECLOK, sio );
-		TLan_SetBit( TLAN_NET_SIO_EDATA, sio );
-	}
+u32 BASE;
 
-	return ( err );
 
-} /* TLan_EeSendByte */
 
-	/***************************************************************
-	 *	TLan_EeReceiveByte
-	 *
-	 *	Returns:
-	 *		Nothing
-	 *	Parms:
-	 *		io_base		The IO port base address for the
-	 *				TLAN device with the EEPROM to
-	 *				use.
-	 *		data		An address to a char to hold the
-	 *				data sent from the EEPROM.
-	 *		stop		If TLAN_EEPROM_STOP is passed, a
-	 *				stop cycle is sent after the
-	 *				byte is received, and no ack is
-	 *				sent.
-	 *
-	 *	This function receives 8 bits of data from the EEPROM
-	 *	over the serial link.  It then sends and ack bit, or no
-	 *	ack and a stop bit.  This function is used to retrieve
-	 *	data after the address of a byte in the EEPROM has been
-	 *	sent.
-	 *
-	 **************************************************************/
+/***************************************************************
+*	TLan_ResetLists
+*
+*	Returns:
+*		Nothing
+*	Parms:
+*		dev	The device structure with the list
+*			stuctures to be reset.
+*
+*	This routine sets the variables associated with managing
+*	the TLAN lists to their initial values.
+*
+**************************************************************/
 
-static void TLan_EeReceiveByte( u16 io_base, u8 *data, int stop )
+void TLan_ResetLists(struct nic *nic __unused)
 {
-	u8  place;
-	u16 sio;
 
-	outw( TLAN_NET_SIO, io_base + TLAN_DIO_ADR );
-	sio = io_base + TLAN_DIO_DATA + TLAN_NET_SIO;
-	*data = 0;
+	int i;
+	struct TLanList *list;
+	priv->txHead = 0;
+	priv->txTail = 0;
 
-	/* Assume clock is low, tx is enabled; */
-	TLan_ClearBit( TLAN_NET_SIO_ETXEN, sio );
-	for ( place = 0x80; place; place >>= 1 ) {
-		TLan_SetBit( TLAN_NET_SIO_ECLOK, sio );
-		if ( TLan_GetBit( TLAN_NET_SIO_EDATA, sio ) )
-			*data |= place;
-		TLan_ClearBit( TLAN_NET_SIO_ECLOK, sio );
+	for (i = 0; i < TLAN_NUM_TX_LISTS; i++) {
+		list = &tx_ring[i];
+		list->cStat = TLAN_CSTAT_UNUSED;
+/*		list->buffer[0].address = 0; */
+		list->buffer[0].address = virt_to_bus(txb + 
+				(i * TLAN_MAX_FRAME_SIZE)); 
+		list->buffer[2].count = 0;
+		list->buffer[2].address = 0;
+		list->buffer[9].address = 0;
+/*		list->forward = 0; */
 	}
 
-	TLan_SetBit( TLAN_NET_SIO_ETXEN, sio );
-	if ( ! stop ) {
-		TLan_ClearBit( TLAN_NET_SIO_EDATA, sio );	/* Ack = 0 */
-		TLan_SetBit( TLAN_NET_SIO_ECLOK, sio );
-		TLan_ClearBit( TLAN_NET_SIO_ECLOK, sio );
-	} else {
-		TLan_SetBit( TLAN_NET_SIO_EDATA, sio );		/* No ack = 1 (?) */
-		TLan_SetBit( TLAN_NET_SIO_ECLOK, sio );
-		TLan_ClearBit( TLAN_NET_SIO_ECLOK, sio );
-		TLan_ClearBit( TLAN_NET_SIO_EDATA, sio );	/* STOP, raise data while clock is high */
-		TLan_SetBit( TLAN_NET_SIO_ECLOK, sio );
-		TLan_SetBit( TLAN_NET_SIO_EDATA, sio );
-	}
+	priv->cur_rx = 0;
+	priv->rx_buf_sz = (TLAN_MAX_FRAME_SIZE);
+	priv->rx_head_desc = &rx_ring[0];
+
+	/* Initialize all the Rx descriptors */
+	for (i = 0; i < TLAN_NUM_RX_LISTS; i++) {
+		rx_ring[i].forward = virt_to_le32desc(&rx_ring[i + 1]);
+		rx_ring[i].cStat = TLAN_CSTAT_READY;
+		rx_ring[i].frameSize = TLAN_MAX_FRAME_SIZE;
+		rx_ring[i].buffer[0].count =
+		    TLAN_MAX_FRAME_SIZE | TLAN_LAST_BUFFER;
+		rx_ring[i].buffer[0].address =
+		    virt_to_le32desc(&rxb[i * TLAN_MAX_FRAME_SIZE]);
+		rx_ring[i].buffer[1].count = 0;
+		rx_ring[i].buffer[1].address = 0;
+	}
+
+	/* Mark the last entry as wrapping the ring */
+	rx_ring[i - 1].forward = virt_to_le32desc(&rx_ring[0]);
+	priv->dirty_rx = (unsigned int) (i - TLAN_NUM_RX_LISTS);
 
-} /* TLan_EeReceiveByte */
+} /* TLan_ResetLists */
 
-	/***************************************************************
-	 *	TLan_EeReadByte
-	 *
-	 *	Returns:
-	 *		No error = 0, else, the stage at which the error
-	 *		occurred.
-	 *	Parms:
-	 *		io_base		The IO port base address for the
-	 *				TLAN device with the EEPROM to
-	 *				use.
-	 *		ee_addr		The address of the byte in the
-	 *				EEPROM whose contents are to be
-	 *				retrieved.
-	 *		data		An address to a char to hold the
-	 *				data obtained from the EEPROM.
-	 *
-	 *	This function reads a byte of information from an byte
-	 *	cell in the EEPROM.
-	 *
-	 **************************************************************/
+/***************************************************************
+*	TLan_Reset
+*
+*	Returns:
+*		0
+*	Parms:
+*		dev	Pointer to device structure of adapter
+*			to be reset.
+*
+*	This function resets the adapter and it's physical
+*	device.  See Chap. 3, pp. 9-10 of the "ThunderLAN
+*	Programmer's Guide" for details.  The routine tries to
+*	implement what is detailed there, though adjustments
+*	have been made.
+*
+**************************************************************/
 
-static int TLan_EeReadByte( u16 io_base, u8 ee_addr, u8 *data )
+void TLan_ResetAdapter(struct nic *nic __unused)
 {
-	int err;
-	unsigned long flags = 0;
-	int ret=0;
+	int i;
+	u32 addr;
+	u32 data;
+	u8 data8;
 
-	TLan_EeSendStart( io_base );
-	err = TLan_EeSendByte( io_base, 0xA0, TLAN_EEPROM_ACK );
-	if (err)
-	{
-		ret=1;
-		goto fail;
-	}
-	err = TLan_EeSendByte( io_base, ee_addr, TLAN_EEPROM_ACK );
-	if (err)
-	{
-		ret=2;
-		goto fail;
-	}
-	TLan_EeSendStart( io_base );
-	err = TLan_EeSendByte( io_base, 0xA1, TLAN_EEPROM_ACK );
-	if (err)
-	{
-		ret=3;
-		goto fail;
-	}
-	TLan_EeReceiveByte( io_base, data, TLAN_EEPROM_STOP );
-fail:
+	priv->tlanFullDuplex = FALSE;
+	priv->phyOnline = 0;
+/*  1.	Assert reset bit. */
 
-	return ret;
+	data = inl(BASE + TLAN_HOST_CMD);
+	data |= TLAN_HC_AD_RST;
+	outl(data, BASE + TLAN_HOST_CMD);
 
-} /* TLan_EeReadByte */
+	udelay(1000);
 
-#if	0
-/* Not yet converted from Linux driver */
-/*****************************************************************************
-******************************************************************************
+/*  2.	Turn off interrupts. ( Probably isn't necessary ) */
 
-	ThunderLAN Driver PHY Layer Routines
+	data = inl(BASE + TLAN_HOST_CMD);
+	data |= TLAN_HC_INT_OFF;
+	outl(data, BASE + TLAN_HOST_CMD);
+/*  3.	Clear AREGs and HASHs. */
 
-******************************************************************************
-*****************************************************************************/
+	for (i = TLAN_AREG_0; i <= TLAN_HASH_2; i += 4) {
+		TLan_DioWrite32(BASE, (u16) i, 0);
+	}
 
-	/*********************************************************************
-	 *	TLan_PhyPrint
-	 *
-	 *	Returns:
-	 *		Nothing
-	 *	Parms:
-	 *		dev	A pointer to the device structure of the
-	 *			TLAN device having the PHYs to be detailed.
-	 *				
-	 *	This function prints the registers a PHY (aka tranceiver).
-	 *
-	 ********************************************************************/
+/*  4.	Setup NetConfig register. */
 
-void TLan_PhyPrint( struct net_device *dev )
-{
-	TLanPrivateInfo *priv = dev->priv;
-	u16 i, data0, data1, data2, data3, phy;
+	data =
+	    TLAN_NET_CFG_1FRAG | TLAN_NET_CFG_1CHAN | TLAN_NET_CFG_PHY_EN;
+	TLan_DioWrite16(BASE, TLAN_NET_CONFIG, (u16) data);
 
-	phy = priv->phy[priv->phyNum];
+/*  5.	Load Ld_Tmr and Ld_Thr in HOST_CMD. */
 
-	if ( priv->adapter->flags & TLAN_ADAPTER_UNMANAGED_PHY ) {
-		printk( "TLAN:   Device %s, Unmanaged PHY.\n", dev->name );
-	} else if ( phy <= TLAN_PHY_MAX_ADDR ) {
-		printk( "TLAN:   Device %s, PHY 0x%02x.\n", dev->name, phy );
-		printk( "TLAN:      Off.  +0     +1     +2     +3 \n" );
-                for ( i = 0; i < 0x20; i+= 4 ) {
-			printk( "TLAN:      0x%02x", i );
-			TLan_MiiReadReg( dev, phy, i, &data0 );
-			printk( " 0x%04hx", data0 );
-			TLan_MiiReadReg( dev, phy, i + 1, &data1 );
-			printk( " 0x%04hx", data1 );
-			TLan_MiiReadReg( dev, phy, i + 2, &data2 );
-			printk( " 0x%04hx", data2 );
-			TLan_MiiReadReg( dev, phy, i + 3, &data3 );
-			printk( " 0x%04hx\n", data3 );
-		}
-	} else {
-		printk( "TLAN:   Device %s, Invalid PHY.\n", dev->name );
-	}
+	outl(TLAN_HC_LD_TMR | 0x3f, BASE + TLAN_HOST_CMD);
+	outl(TLAN_HC_LD_THR | 0x0, BASE + TLAN_HOST_CMD);
 
-} /* TLan_PhyPrint */
+/*  6.	Unreset the MII by setting NMRST (in NetSio) to 1. */
 
-	/*********************************************************************
-	 *	TLan_PhyDetect
-	 *
-	 *	Returns:
-	 *		Nothing
-	 *	Parms:
-	 *		dev	A pointer to the device structure of the adapter
-	 *			for which the PHY needs determined.
-	 *
-	 *	So far I've found that adapters which have external PHYs
-	 *	may also use the internal PHY for part of the functionality.
-	 *	(eg, AUI/Thinnet).  This function finds out if this TLAN
-	 *	chip has an internal PHY, and then finds the first external
-	 *	PHY (starting from address 0) if it exists).
-	 *
-	 ********************************************************************/
+	outw(TLAN_NET_SIO, BASE + TLAN_DIO_ADR);
+	addr = BASE + TLAN_DIO_DATA + TLAN_NET_SIO;
+	TLan_SetBit(TLAN_NET_SIO_NMRST, addr);
 
-void TLan_PhyDetect( struct net_device *dev )
-{
-	TLanPrivateInfo *priv = dev->priv;
-	u16		control;
-	u16		hi;
-	u16		lo;
-	u32		phy;
+/*  7.	Setup the remaining registers. */
 
-	if ( priv->adapter->flags & TLAN_ADAPTER_UNMANAGED_PHY ) {
-		priv->phyNum = 0xFFFF;
-		return;
+	if (priv->tlanRev >= 0x30) {
+		data8 = TLAN_ID_TX_EOC | TLAN_ID_RX_EOC;
+		TLan_DioWrite8(BASE, TLAN_INT_DIS, data8);
 	}
+	TLan_PhyDetect(nic);
+	data = TLAN_NET_CFG_1FRAG | TLAN_NET_CFG_1CHAN;
 
-	TLan_MiiReadReg( dev, TLAN_PHY_MAX_ADDR, MII_GEN_ID_HI, &hi );
-	
-	if ( hi != 0xFFFF ) {
-		priv->phy[0] = TLAN_PHY_MAX_ADDR;
-	} else {
-		priv->phy[0] = TLAN_PHY_NONE;
+	if (tlan_pci_tbl[chip_idx].flags & TLAN_ADAPTER_BIT_RATE_PHY) {
+		data |= TLAN_NET_CFG_BIT;
+		if (priv->aui == 1) {
+			TLan_DioWrite8(BASE, TLAN_ACOMMIT, 0x0a);
+		} else if (priv->duplex == TLAN_DUPLEX_FULL) {
+			TLan_DioWrite8(BASE, TLAN_ACOMMIT, 0x00);
+			priv->tlanFullDuplex = TRUE;
+		} else {
+			TLan_DioWrite8(BASE, TLAN_ACOMMIT, 0x08);
+		}
 	}
 
-	priv->phy[1] = TLAN_PHY_NONE;
-	for ( phy = 0; phy <= TLAN_PHY_MAX_ADDR; phy++ ) {
-		TLan_MiiReadReg( dev, phy, MII_GEN_CTL, &control );
-		TLan_MiiReadReg( dev, phy, MII_GEN_ID_HI, &hi );
-		TLan_MiiReadReg( dev, phy, MII_GEN_ID_LO, &lo );
-		if ( ( control != 0xFFFF ) || ( hi != 0xFFFF ) || ( lo != 0xFFFF ) ) {
-			TLAN_DBG( TLAN_DEBUG_GNRL, "PHY found at %02x %04x %04x %04x\n", phy, control, hi, lo );
-			if ( ( priv->phy[1] == TLAN_PHY_NONE ) && ( phy != TLAN_PHY_MAX_ADDR ) ) {
-				priv->phy[1] = phy;
-			}
-		}
+	if (priv->phyNum == 0) {
+		data |= TLAN_NET_CFG_PHY_EN;
 	}
+	TLan_DioWrite16(BASE, TLAN_NET_CONFIG, (u16) data);
 
-	if ( priv->phy[1] != TLAN_PHY_NONE ) {
-		priv->phyNum = 1;
-	} else if ( priv->phy[0] != TLAN_PHY_NONE ) {
-		priv->phyNum = 0;
+	if (tlan_pci_tbl[chip_idx].flags & TLAN_ADAPTER_UNMANAGED_PHY) {
+		TLan_FinishReset(nic);
 	} else {
-		printk( "TLAN:  Cannot initialize device, no PHY was found!\n" );
+		TLan_PhyPowerDown(nic);
 	}
 
-} /* TLan_PhyDetect */
+}	/* TLan_ResetAdapter */
 
-void TLan_PhyPowerDown( struct net_device *dev )
+void TLan_FinishReset(struct nic *nic)
 {
-	TLanPrivateInfo	*priv = dev->priv;
-	u16		value;
 
-	TLAN_DBG( TLAN_DEBUG_GNRL, "%s: Powering down PHY(s).\n", dev->name );
-	value = MII_GC_PDOWN | MII_GC_LOOPBK | MII_GC_ISOLATE;
-	TLan_MiiSync( dev->base_addr );
-	TLan_MiiWriteReg( dev, priv->phy[priv->phyNum], MII_GEN_CTL, value );
-	if ( ( priv->phyNum == 0 ) && ( priv->phy[1] != TLAN_PHY_NONE ) && ( ! ( priv->adapter->flags & TLAN_ADAPTER_USE_INTERN_10 ) ) ) {
-		TLan_MiiSync( dev->base_addr );
-		TLan_MiiWriteReg( dev, priv->phy[1], MII_GEN_CTL, value );
+	u8 data;
+	u32 phy;
+	u8 sio;
+	u16 status;
+	u16 partner;
+	u16 tlphy_ctl;
+	u16 tlphy_par;
+	u16 tlphy_id1, tlphy_id2;
+	int i;
+
+	phy = priv->phy[priv->phyNum];
+
+	data = TLAN_NET_CMD_NRESET | TLAN_NET_CMD_NWRAP;
+	if (priv->tlanFullDuplex) {
+		data |= TLAN_NET_CMD_DUPLEX;
 	}
+	TLan_DioWrite8(BASE, TLAN_NET_CMD, data);
+	data = TLAN_NET_MASK_MASK4 | TLAN_NET_MASK_MASK5;
+	if (priv->phyNum == 0) {
+		data |= TLAN_NET_MASK_MASK7;
+	}
+	TLan_DioWrite8(BASE, TLAN_NET_MASK, data);
+	TLan_DioWrite16(BASE, TLAN_MAX_RX, ((1536) + 7) & ~7);
+	TLan_MiiReadReg(nic, phy, MII_GEN_ID_HI, &tlphy_id1);
+	TLan_MiiReadReg(nic, phy, MII_GEN_ID_LO, &tlphy_id2);
 
-	/* Wait for 50 ms and powerup
-	 * This is abitrary.  It is intended to make sure the
-	 * tranceiver settles.
-	 */
-	TLan_SetTimer( dev, (HZ/20), TLAN_TIMER_PHY_PUP );
+	if ((tlan_pci_tbl[chip_idx].flags & TLAN_ADAPTER_UNMANAGED_PHY)
+	    || (priv->aui)) {
+		status = MII_GS_LINK;
+		printf("TLAN:  %s: Link forced.\n", priv->nic_name);
+	} else {
+		TLan_MiiReadReg(nic, phy, MII_GEN_STS, &status);
+		udelay(1000);
+		TLan_MiiReadReg(nic, phy, MII_GEN_STS, &status);
+		if ((status & MII_GS_LINK) &&	/* We only support link info on Nat.Sem. PHY's */
+		    (tlphy_id1 == NAT_SEM_ID1)
+		    && (tlphy_id2 == NAT_SEM_ID2)) {
+			TLan_MiiReadReg(nic, phy, MII_AN_LPA, &partner);
+			TLan_MiiReadReg(nic, phy, TLAN_TLPHY_PAR,
+					&tlphy_par);
 
-} /* TLan_PhyPowerDown */
+			printf("TLAN: %s: Link active with ",
+			       priv->nic_name);
+			if (!(tlphy_par & TLAN_PHY_AN_EN_STAT)) {
+				printf("forced 10%sMbps %s-Duplex\n",
+				       tlphy_par & TLAN_PHY_SPEED_100 ? ""
+				       : "0",
+				       tlphy_par & TLAN_PHY_DUPLEX_FULL ?
+				       "Full" : "Half");
+			} else {
+				printf
+				    ("AutoNegotiation enabled, at 10%sMbps %s-Duplex\n",
+				     tlphy_par & TLAN_PHY_SPEED_100 ? "" :
+				     "0",
+				     tlphy_par & TLAN_PHY_DUPLEX_FULL ?
+				     "Full" : "Half");
+				printf("TLAN: Partner capability: ");
+				for (i = 5; i <= 10; i++)
+					if (partner & (1 << i))
+						printf("%s", media[i - 5]);
+				printf("\n");
+			}
 
-void TLan_PhyPowerUp( struct net_device *dev )
-{
-	TLanPrivateInfo	*priv = dev->priv;
-	u16		value;
+			TLan_DioWrite8(BASE, TLAN_LED_REG, TLAN_LED_LINK);
+#ifdef MONITOR
+			/* We have link beat..for now anyway */
+			priv->link = 1;
+			/*Enabling link beat monitoring */
+			/* TLan_SetTimer( nic, (10*HZ), TLAN_TIMER_LINK_BEAT ); */
+			mdelay(10000);
+			TLan_PhyMonitor(nic);
+#endif
+		} else if (status & MII_GS_LINK) {
+			printf("TLAN: %s: Link active\n", priv->nic_name);
+			TLan_DioWrite8(BASE, TLAN_LED_REG, TLAN_LED_LINK);
+		}
+	}
 
-	TLAN_DBG( TLAN_DEBUG_GNRL, "%s: Powering up PHY.\n", dev->name );
-	TLan_MiiSync( dev->base_addr );
-	value = MII_GC_LOOPBK;
-	TLan_MiiWriteReg( dev, priv->phy[priv->phyNum], MII_GEN_CTL, value );
-	TLan_MiiSync(dev->base_addr);
-	/* Wait for 500 ms and reset the
-	 * tranceiver.  The TLAN docs say both 50 ms and
-	 * 500 ms, so do the longer, just in case.
-	 */
-	TLan_SetTimer( dev, (HZ/20), TLAN_TIMER_PHY_RESET );
+	if (priv->phyNum == 0) {
+		TLan_MiiReadReg(nic, phy, TLAN_TLPHY_CTL, &tlphy_ctl);
+		tlphy_ctl |= TLAN_TC_INTEN;
+		TLan_MiiWriteReg(nic, phy, TLAN_TLPHY_CTL, tlphy_ctl);
+		sio = TLan_DioRead8(BASE, TLAN_NET_SIO);
+		sio |= TLAN_NET_SIO_MINTEN;
+		TLan_DioWrite8(BASE, TLAN_NET_SIO, sio);
+	}
 
-} /* TLan_PhyPowerUp */
+	if (status & MII_GS_LINK) {
+		TLan_SetMac(nic, 0, nic->node_addr);
+		priv->phyOnline = 1;
+		outb((TLAN_HC_INT_ON >> 8), BASE + TLAN_HOST_CMD + 1);
+/*		if ( debug >= 1 && debug != TLAN_DEBUG_PROBE ) {
+			outb( ( TLAN_HC_REQ_INT >> 8 ), BASE + TLAN_HOST_CMD + 1 );
+		}
 
-void TLan_PhyReset( struct net_device *dev )
-{
-	TLanPrivateInfo	*priv = dev->priv;
-	u16		phy;
-	u16		value;
+		*/
+		outl(virt_to_bus(&rx_ring), BASE + TLAN_CH_PARM);
+		outl(TLAN_HC_GO | TLAN_HC_RT, BASE + TLAN_HOST_CMD);
+	} else {
+		printf
+		    ("TLAN: %s: Link inactive, will retry in 10 secs...\n",
+		     priv->nic_name);
+		/* TLan_SetTimer( nic, (10*HZ), TLAN_TIMER_FINISH_RESET ); */
+		mdelay(10000);
+		TLan_FinishReset(nic);
+		return;
 
-	phy = priv->phy[priv->phyNum];
+	}
 
-	TLAN_DBG( TLAN_DEBUG_GNRL, "%s: Reseting PHY.\n", dev->name );
-	TLan_MiiSync( dev->base_addr );
-	value = MII_GC_LOOPBK | MII_GC_RESET;
-	TLan_MiiWriteReg( dev, phy, MII_GEN_CTL, value );
-	TLan_MiiReadReg( dev, phy, MII_GEN_CTL, &value );
-	while ( value & MII_GC_RESET ) {
-		TLan_MiiReadReg( dev, phy, MII_GEN_CTL, &value );
-	}
-
-	/* Wait for 500 ms and initialize.
-	 * I don't remember why I wait this long.
-	 * I've changed this to 50ms, as it seems long enough.
-	 */
-	TLan_SetTimer( dev, (HZ/20), TLAN_TIMER_PHY_START_LINK );
-
-} /* TLan_PhyReset */
-
-void TLan_PhyStartLink( struct net_device *dev )
-{
-	TLanPrivateInfo	*priv = dev->priv;
-	u16		ability;
-	u16		control;
-	u16		data;
-	u16		phy;
-	u16		status;
-	u16		tctl;
-
-	phy = priv->phy[priv->phyNum];
-	TLAN_DBG( TLAN_DEBUG_GNRL, "%s: Trying to activate link.\n", dev->name );
-	TLan_MiiReadReg( dev, phy, MII_GEN_STS, &status );
-	TLan_MiiReadReg( dev, phy, MII_GEN_STS, &ability );
-
-	if ( ( status & MII_GS_AUTONEG ) && 
-	     ( ! priv->aui ) ) {
-		ability = status >> 11;
-		if ( priv->speed  == TLAN_SPEED_10 && 
-		     priv->duplex == TLAN_DUPLEX_HALF) {
-			TLan_MiiWriteReg( dev, phy, MII_GEN_CTL, 0x0000);
-		} else if ( priv->speed == TLAN_SPEED_10 &&
-			    priv->duplex == TLAN_DUPLEX_FULL) {
-			priv->tlanFullDuplex = TRUE;
-			TLan_MiiWriteReg( dev, phy, MII_GEN_CTL, 0x0100);
-		} else if ( priv->speed == TLAN_SPEED_100 &&
-			    priv->duplex == TLAN_DUPLEX_HALF) {
-			TLan_MiiWriteReg( dev, phy, MII_GEN_CTL, 0x2000);
-		} else if ( priv->speed == TLAN_SPEED_100 &&
-			    priv->duplex == TLAN_DUPLEX_FULL) {
-			priv->tlanFullDuplex = TRUE;
-			TLan_MiiWriteReg( dev, phy, MII_GEN_CTL, 0x2100);
-		} else {
-	
-			/* Set Auto-Neg advertisement */
-			TLan_MiiWriteReg( dev, phy, MII_AN_ADV, (ability << 5) | 1);
-			/* Enablee Auto-Neg */
-			TLan_MiiWriteReg( dev, phy, MII_GEN_CTL, 0x1000 );
-			/* Restart Auto-Neg */
-			TLan_MiiWriteReg( dev, phy, MII_GEN_CTL, 0x1200 );
-			/* Wait for 4 sec for autonegotiation
-		 	* to complete.  The max spec time is less than this
-		 	* but the card need additional time to start AN.
-		 	* .5 sec should be plenty extra.
-		 	*/
-			printk( "TLAN: %s: Starting autonegotiation.\n", dev->name );
-			TLan_SetTimer( dev, (2*HZ), TLAN_TIMER_PHY_FINISH_AN );
-			return;
-		}
-		
-	}	
-	
-	if ( ( priv->aui ) && ( priv->phyNum != 0 ) ) {
-		priv->phyNum = 0;
-		data = TLAN_NET_CFG_1FRAG | TLAN_NET_CFG_1CHAN | TLAN_NET_CFG_PHY_EN;
-		TLan_DioWrite16( dev->base_addr, TLAN_NET_CONFIG, data );
-		TLan_SetTimer( dev, (40*HZ/1000), TLAN_TIMER_PHY_PDOWN );
-		return;
-	}  else if ( priv->phyNum == 0 ) {
-        	TLan_MiiReadReg( dev, phy, TLAN_TLPHY_CTL, &tctl );
-		if ( priv->aui ) {
-                	tctl |= TLAN_TC_AUISEL;
-		} else { 
-                	tctl &= ~TLAN_TC_AUISEL;
-			control = 0;
-			if ( priv->duplex == TLAN_DUPLEX_FULL ) {
-				control |= MII_GC_DUPLEX;
-				priv->tlanFullDuplex = TRUE;
-			}
-			if ( priv->speed == TLAN_SPEED_100 ) {
-				control |= MII_GC_SPEEDSEL;
-			}
-       			TLan_MiiWriteReg( dev, phy, MII_GEN_CTL, control );
-		}
-        	TLan_MiiWriteReg( dev, phy, TLAN_TLPHY_CTL, tctl );
-	}
-
-	/* Wait for 2 sec to give the tranceiver time
-	 * to establish link.
-	 */
-	TLan_SetTimer( dev, (4*HZ), TLAN_TIMER_FINISH_RESET );
-
-} /* TLan_PhyStartLink */
-
-void TLan_PhyFinishAutoNeg( struct net_device *dev )
-{
-	TLanPrivateInfo	*priv = dev->priv;
-	u16		an_adv;
-	u16		an_lpa;
-	u16		data;
-	u16		mode;
-	u16		phy;
-	u16		status;
-	
-	phy = priv->phy[priv->phyNum];
-
-	TLan_MiiReadReg( dev, phy, MII_GEN_STS, &status );
-	udelay( 1000 );
-	TLan_MiiReadReg( dev, phy, MII_GEN_STS, &status );
-
-	if ( ! ( status & MII_GS_AUTOCMPLT ) ) {
-		/* Wait for 8 sec to give the process
-		 * more time.  Perhaps we should fail after a while.
-		 */
-		 if (!priv->neg_be_verbose++) {
-			 printk(KERN_INFO "TLAN:  Giving autonegotiation more time.\n");
-		 	 printk(KERN_INFO "TLAN:  Please check that your adapter has\n");
-		 	 printk(KERN_INFO "TLAN:  been properly connected to a HUB or Switch.\n");
-			 printk(KERN_INFO "TLAN:  Trying to establish link in the background...\n");
-		 }
-		TLan_SetTimer( dev, (8*HZ), TLAN_TIMER_PHY_FINISH_AN );
-		return;
-	}
-
-	printk( "TLAN: %s: Autonegotiation complete.\n", dev->name );
-	TLan_MiiReadReg( dev, phy, MII_AN_ADV, &an_adv );
-	TLan_MiiReadReg( dev, phy, MII_AN_LPA, &an_lpa );
-	mode = an_adv & an_lpa & 0x03E0;
-	if ( mode & 0x0100 ) {
-		priv->tlanFullDuplex = TRUE;
-	} else if ( ! ( mode & 0x0080 ) && ( mode & 0x0040 ) ) {
-		priv->tlanFullDuplex = TRUE;
-	}
-
-	if ( ( ! ( mode & 0x0180 ) ) && ( priv->adapter->flags & TLAN_ADAPTER_USE_INTERN_10 ) && ( priv->phyNum != 0 ) ) {
-		priv->phyNum = 0;
-		data = TLAN_NET_CFG_1FRAG | TLAN_NET_CFG_1CHAN | TLAN_NET_CFG_PHY_EN;
-		TLan_DioWrite16( dev->base_addr, TLAN_NET_CONFIG, data );
-		TLan_SetTimer( dev, (400*HZ/1000), TLAN_TIMER_PHY_PDOWN );
-		return;
-	}
-
-	if ( priv->phyNum == 0 ) {
-		if ( ( priv->duplex == TLAN_DUPLEX_FULL ) || ( an_adv & an_lpa & 0x0040 ) ) {
-			TLan_MiiWriteReg( dev, phy, MII_GEN_CTL, MII_GC_AUTOENB | MII_GC_DUPLEX );
-			printk( "TLAN:  Starting internal PHY with FULL-DUPLEX\n" );
-		} else {
-			TLan_MiiWriteReg( dev, phy, MII_GEN_CTL, MII_GC_AUTOENB );
-			printk( "TLAN:  Starting internal PHY with HALF-DUPLEX\n" );
-		}
-	}
-
-	/* Wait for 100 ms.  No reason in partiticular.
-	 */
-	TLan_SetTimer( dev, (HZ/10), TLAN_TIMER_FINISH_RESET );
-		
-} /* TLan_PhyFinishAutoNeg */
-
-#ifdef MONITOR
-
-        /*********************************************************************
-        *
-        *      TLan_phyMonitor
-        *
-        *      Returns: 
-        *              None
-        *
-        *      Params:
-        *              dev             The device structure of this device.
-        *
-        *      
-        *      This function monitors PHY condition by reading the status
-        *      register via the MII bus. This can be used to give info
-        *      about link changes (up/down), and possible switch to alternate
-        *      media.
-        *
-        * ******************************************************************/
-
-void TLan_PhyMonitor( struct net_device *dev )
-{
-	TLanPrivateInfo *priv = dev->priv;
-	u16     phy;
-	u16     phy_status;
-
-	phy = priv->phy[priv->phyNum];
-
-        /* Get PHY status register */
-        TLan_MiiReadReg( dev, phy, MII_GEN_STS, &phy_status );
-
-        /* Check if link has been lost */
-        if (!(phy_status & MII_GS_LINK)) { 
- 	       if (priv->link) {
-		      priv->link = 0;
-	              printk(KERN_DEBUG "TLAN: %s has lost link\n", dev->name);
-	              dev->flags &= ~IFF_RUNNING;
-		      TLan_SetTimer( dev, (2*HZ), TLAN_TIMER_LINK_BEAT );
-		      return;
-		}
-	}
-
-        /* Link restablished? */
-        if ((phy_status & MII_GS_LINK) && !priv->link) {
- 		priv->link = 1;
-        	printk(KERN_DEBUG "TLAN: %s has reestablished link\n", dev->name);
-        	dev->flags |= IFF_RUNNING;
-        }
-
-	/* Setup a new monitor */
-	TLan_SetTimer( dev, (2*HZ), TLAN_TIMER_LINK_BEAT );
-}	
-
-#endif /* MONITOR */
-
-/*****************************************************************************
-******************************************************************************
-
-	ThunderLAN Driver MII Routines
-
-	These routines are based on the information in Chap. 2 of the
-	"ThunderLAN Programmer's Guide", pp. 15-24.
-
-******************************************************************************
-*****************************************************************************/
-
-	/***************************************************************
-	 *	TLan_MiiReadReg
-	 *
-	 *	Returns:
-	 *		0	if ack received ok
-	 *		1	otherwise.
-	 *
-	 *	Parms:
-	 *		dev		The device structure containing
-	 *				The io address and interrupt count
-	 *				for this device.
-	 *		phy		The address of the PHY to be queried.
-	 *		reg		The register whose contents are to be
-	 *				retreived.
-	 *		val		A pointer to a variable to store the
-	 *				retrieved value.
-	 *
-	 *	This function uses the TLAN's MII bus to retreive the contents
-	 *	of a given register on a PHY.  It sends the appropriate info
-	 *	and then reads the 16-bit register value from the MII bus via
-	 *	the TLAN SIO register.
-	 *
-	 **************************************************************/
-
-int TLan_MiiReadReg( struct net_device *dev, u16 phy, u16 reg, u16 *val )
-{
-	u8	nack;
-	u16	sio, tmp;
- 	u32	i;
-	int	err;
-	int	minten;
-	TLanPrivateInfo *priv = dev->priv;
-	unsigned long flags = 0;
-
-	err = FALSE;
-	outw(TLAN_NET_SIO, dev->base_addr + TLAN_DIO_ADR);
-	sio = dev->base_addr + TLAN_DIO_DATA + TLAN_NET_SIO;
-	
-	if (!in_irq())
-		spin_lock_irqsave(&priv->lock, flags);
-
-	TLan_MiiSync(dev->base_addr);
-
-	minten = TLan_GetBit( TLAN_NET_SIO_MINTEN, sio );
-	if ( minten )
-		TLan_ClearBit(TLAN_NET_SIO_MINTEN, sio);
-
-	TLan_MiiSendData( dev->base_addr, 0x1, 2 );	/* Start ( 01b ) */
-	TLan_MiiSendData( dev->base_addr, 0x2, 2 );	/* Read  ( 10b ) */
-	TLan_MiiSendData( dev->base_addr, phy, 5 );	/* Device #      */
-	TLan_MiiSendData( dev->base_addr, reg, 5 );	/* Register #    */
-
-	TLan_ClearBit(TLAN_NET_SIO_MTXEN, sio);		/* Change direction */
-
-	TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);		/* Clock Idle bit */
-	TLan_SetBit(TLAN_NET_SIO_MCLK, sio);
-	TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);		/* Wait 300ns */
-
-	nack = TLan_GetBit(TLAN_NET_SIO_MDATA, sio);	/* Check for ACK */
-	TLan_SetBit(TLAN_NET_SIO_MCLK, sio);		/* Finish ACK */
-	if (nack) {					/* No ACK, so fake it */
-		for (i = 0; i < 16; i++) {
-			TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);
-			TLan_SetBit(TLAN_NET_SIO_MCLK, sio);
-		}
-		tmp = 0xffff;
-		err = TRUE;
-	} else {					/* ACK, so read data */
-		for (tmp = 0, i = 0x8000; i; i >>= 1) {
-			TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);
-			if (TLan_GetBit(TLAN_NET_SIO_MDATA, sio))
-				tmp |= i;
-			TLan_SetBit(TLAN_NET_SIO_MCLK, sio);
-		}
-	}
-
-	TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);		/* Idle cycle */
-	TLan_SetBit(TLAN_NET_SIO_MCLK, sio);
-
-	if ( minten )
-		TLan_SetBit(TLAN_NET_SIO_MINTEN, sio);
-
-	*val = tmp;
-	
-	if (!in_irq())
-		spin_unlock_irqrestore(&priv->lock, flags);
-
-	return err;
-
-} /* TLan_MiiReadReg */
-
-	/***************************************************************
-	 *	TLan_MiiSendData
-	 *
-	 *	Returns:
-	 *		Nothing
-	 *	Parms:
-	 *		base_port	The base IO port of the adapter	in
-	 *				question.
-	 *		dev		The address of the PHY to be queried.
-	 *		data		The value to be placed on the MII bus.
-	 *		num_bits	The number of bits in data that are to
-	 *				be placed on the MII bus.
-	 *
-	 *	This function sends on sequence of bits on the MII
-	 *	configuration bus.
-	 *
-	 **************************************************************/
-
-void TLan_MiiSendData( u16 base_port, u32 data, unsigned num_bits )
-{
-	u16 sio;
-	u32 i;
-
-	if ( num_bits == 0 )
-		return;
-
-	outw( TLAN_NET_SIO, base_port + TLAN_DIO_ADR );
-	sio = base_port + TLAN_DIO_DATA + TLAN_NET_SIO;
-	TLan_SetBit( TLAN_NET_SIO_MTXEN, sio );
-
-	for ( i = ( 0x1 << ( num_bits - 1 ) ); i; i >>= 1 ) {
-		TLan_ClearBit( TLAN_NET_SIO_MCLK, sio );
-		(void) TLan_GetBit( TLAN_NET_SIO_MCLK, sio );
-		if ( data & i )
-			TLan_SetBit( TLAN_NET_SIO_MDATA, sio );
-		else
-			TLan_ClearBit( TLAN_NET_SIO_MDATA, sio );
-		TLan_SetBit( TLAN_NET_SIO_MCLK, sio );
-		(void) TLan_GetBit( TLAN_NET_SIO_MCLK, sio );
-	}
-
-} /* TLan_MiiSendData */
-
-	/***************************************************************
-	 *	TLan_MiiSync
-	 *
-	 *	Returns:
-	 *		Nothing
-	 *	Parms:
-	 *		base_port	The base IO port of the adapter in
-	 *				question.
-	 *
-	 *	This functions syncs all PHYs in terms of the MII configuration
-	 *	bus.
-	 *
-	 **************************************************************/
-
-void TLan_MiiSync( u16 base_port )
-{
-	int i;
-	u16 sio;
-
-	outw( TLAN_NET_SIO, base_port + TLAN_DIO_ADR );
-	sio = base_port + TLAN_DIO_DATA + TLAN_NET_SIO;
-
-	TLan_ClearBit( TLAN_NET_SIO_MTXEN, sio );
-	for ( i = 0; i < 32; i++ ) {
-		TLan_ClearBit( TLAN_NET_SIO_MCLK, sio );
-		TLan_SetBit( TLAN_NET_SIO_MCLK, sio );
-	}
-
-} /* TLan_MiiSync */
-
-	/***************************************************************
-	 *	TLan_MiiWriteReg
-	 *
-	 *	Returns:
-	 *		Nothing
-	 *	Parms:
-	 *		dev		The device structure for the device
-	 *				to write to.
-	 *		phy		The address of the PHY to be written to.
-	 *		reg		The register whose contents are to be
-	 *				written.
-	 *		val		The value to be written to the register.
-	 *
-	 *	This function uses the TLAN's MII bus to write the contents of a
-	 *	given register on a PHY.  It sends the appropriate info and then
-	 *	writes the 16-bit register value from the MII configuration bus
-	 *	via the TLAN SIO register.
-	 *
-	 **************************************************************/
-
-void TLan_MiiWriteReg( struct net_device *dev, u16 phy, u16 reg, u16 val )
-{
-	u16	sio;
-	int	minten;
-	unsigned long flags = 0;
-	TLanPrivateInfo *priv = dev->priv;
-
-	outw(TLAN_NET_SIO, dev->base_addr + TLAN_DIO_ADR);
-	sio = dev->base_addr + TLAN_DIO_DATA + TLAN_NET_SIO;
-	
-	if (!in_irq())
-		spin_lock_irqsave(&priv->lock, flags);
-
-	TLan_MiiSync( dev->base_addr );
-
-	minten = TLan_GetBit( TLAN_NET_SIO_MINTEN, sio );
-	if ( minten )
-		TLan_ClearBit( TLAN_NET_SIO_MINTEN, sio );
-
-	TLan_MiiSendData( dev->base_addr, 0x1, 2 );	/* Start ( 01b ) */
-	TLan_MiiSendData( dev->base_addr, 0x1, 2 );	/* Write ( 01b ) */
-	TLan_MiiSendData( dev->base_addr, phy, 5 );	/* Device #      */
-	TLan_MiiSendData( dev->base_addr, reg, 5 );	/* Register #    */
-
-	TLan_MiiSendData( dev->base_addr, 0x2, 2 );	/* Send ACK */
-	TLan_MiiSendData( dev->base_addr, val, 16 );	/* Send Data */
-
-	TLan_ClearBit( TLAN_NET_SIO_MCLK, sio );	/* Idle cycle */
-	TLan_SetBit( TLAN_NET_SIO_MCLK, sio );
-
-	if ( minten )
-		TLan_SetBit( TLAN_NET_SIO_MINTEN, sio );
-	
-	if (!in_irq())
-		spin_unlock_irqrestore(&priv->lock, flags);
-
-} /* TLan_MiiWriteReg */
-#endif
-
-/**************************************************************************
-RESET - Reset adapter
-***************************************************************************/
-static void skel_reset(struct nic *nic)
-{
-	/* put the card in its initial state */
-}
-
-/**************************************************************************
-POLL - Wait for a frame
-***************************************************************************/
-static int skel_poll(struct nic *nic)
-{
-	/* return true if there's an ethernet packet ready to read */
-	/* nic->packet should contain data on return */
-	/* nic->packetlen should contain length of data */
-	return (0);	/* initially as this is called to flush the input */
-}
-
-/**************************************************************************
-TRANSMIT - Transmit a frame
-***************************************************************************/
-static void skel_transmit(
-	struct nic *nic,
-	const char *d,			/* Destination */
-	unsigned int t,			/* Type */
-	unsigned int s,			/* size */
-	const char *p)			/* Packet */
-{
-	/* send the packet to destination */
-}
-
-/**************************************************************************
-DISABLE - Turn off ethernet interface
-***************************************************************************/
-static void skel_disable(struct nic *nic)
-{
-}
-
-/**************************************************************************
-PROBE - Look for an adapter, this routine's visible to the outside
-You should omit the last argument struct pci_device * for a non-PCI NIC
-***************************************************************************/
-struct nic *tlan_probe(struct nic *nic, unsigned short *probe_addrs,
-	struct pci_device *p)
-{
-	/* if probe_addrs is 0, then routine can use a hardwired default */
-	/* if board found */
-	{
-		/* point to NIC specific routines */
-		nic->reset = skel_reset;
-		nic->poll = skel_poll;
-		nic->transmit = skel_transmit;
-		nic->disable = skel_disable;
-		return nic;
-	}
-	/* else */
-	return 0;
-}
-
-#if	0
-#ifndef TLAN_H
-#define TLAN_H
-/********************************************************************
- *
- *  Linux ThunderLAN Driver
- *
- *  tlan.h
- *  by James Banks
- *
- *  (C) 1997-1998 Caldera, Inc.
- *  (C) 1999-2001 Torben Mathiasen
- * 
- *  This software may be used and distributed according to the terms
- *  of the GNU General Public License, incorporated herein by reference.
- *
- ** This file is best viewed/edited with tabstop=4, colums>=132
- *
- *  
- *  Dec 10, 1999	Torben Mathiasen <torben.mathiasen@compaq.com>
- *			New Maintainer
- *
- ********************************************************************/
-
-#include <asm/io.h>
-#include <asm/types.h>
-#include <linux/netdevice.h>
-
-#define FALSE			0
-#define TRUE			1
-
-#define TX_TIMEOUT		(10*HZ)	 /* We need time for auto-neg */
-
-typedef struct tlan_adapter_entry {
-	u16	vendorId;
-	u16	deviceId;
-	char	*deviceLabel;
-	u32	flags;
-	u16	addrOfs;
-} TLanAdapterEntry;
-
-	/*****************************************************************
-	 * EISA Definitions
-	 *
-	 ****************************************************************/
-
-#define EISA_ID      0xc80   /* EISA ID Registers */ 
-#define EISA_ID0     0xc80   /* EISA ID Register 0 */ 
-#define EISA_ID1     0xc81   /* EISA ID Register 1 */ 
-#define EISA_ID2     0xc82   /* EISA ID Register 2 */ 
-#define EISA_ID3     0xc83   /* EISA ID Register 3 */ 
-#define EISA_CR      0xc84   /* EISA Control Register */
-#define EISA_REG0    0xc88   /* EISA Configuration Register 0 */
-#define EISA_REG1    0xc89   /* EISA Configuration Register 1 */
-#define EISA_REG2    0xc8a   /* EISA Configuration Register 2 */
-#define EISA_REG3    0xc8f   /* EISA Configuration Register 3 */
-#define EISA_APROM   0xc90   /* Ethernet Address PROM */
-
-	/*****************************************************************
-	 * Rx/Tx List Definitions
-	 *
-	 ****************************************************************/
-
-typedef struct tlan_buffer_ref_tag {
-	u32	count;
-	u32	address;
-} TLanBufferRef;
-
-typedef struct tlan_list_tag {
-	u32		forward;
-	u16		cStat;
-	u16		frameSize;
-	TLanBufferRef	buffer[TLAN_BUFFERS_PER_LIST];
-} TLanList;
-
-typedef u8 TLanBuffer[TLAN_MAX_FRAME_SIZE];
-
-	/*****************************************************************
-	 * TLAN Private Information Structure
-	 *
-	 ****************************************************************/
-
-typedef struct tlan_private_tag {
-	struct net_device       *nextDevice;
-	void			*dmaStorage;
-	u8			*padBuffer;
-	TLanList                *rxList;
-	u8			*rxBuffer;
-	u32                     rxHead;
-	u32                     rxTail;
-	u32			rxEocCount;
-	TLanList                *txList;
-	u8			*txBuffer;
-	u32                     txHead;
-	u32                     txInProgress;
-	u32                     txTail;
-	u32			txBusyCount;
-	u32                     phyOnline;
-	u32			timerSetAt;
-	u32			timerType;
-	struct timer_list	timer;
-	struct net_device_stats	stats;
-	struct board		*adapter;
-	u32			adapterRev;
-	u32			aui;
-	u32			debug;
-	u32			duplex;
-	u32			phy[2];
-	u32			phyNum;
-	u32			speed;
-	u8			tlanRev;
-	u8			tlanFullDuplex;
-	char                    devName[8];
-	spinlock_t		lock;
-	u8			link;
-	u8			is_eisa;
-	struct tq_struct	tlan_tqueue;
-	u8			neg_be_verbose;
-} TLanPrivateInfo;
-
-#define 	TLAN_HC_GO		0x80000000
-#define		TLAN_HC_STOP		0x40000000
-#define		TLAN_HC_ACK		0x20000000
-#define		TLAN_HC_CS_MASK		0x1FE00000
-#define		TLAN_HC_EOC		0x00100000
-#define		TLAN_HC_RT		0x00080000
-#define		TLAN_HC_NES		0x00040000
-#define		TLAN_HC_AD_RST		0x00008000
-#define		TLAN_HC_LD_TMR		0x00004000
-#define		TLAN_HC_LD_THR		0x00002000
-#define		TLAN_HC_REQ_INT		0x00001000
-#define		TLAN_HC_INT_OFF		0x00000800
-#define		TLAN_HC_INT_ON		0x00000400
-#define		TLAN_HC_AC_MASK		0x000000FF
-#define		TLAN_DA_ADR_INC		0x8000
-#define		TLAN_DA_RAM_ADR		0x4000
-#define		TLAN_HI_IV_MASK		0x1FE0
-#define		TLAN_HI_IT_MASK		0x001C
-
-#define		TLAN_NET_CMD_NRESET	0x80
-#define		TLAN_NET_CMD_NWRAP	0x40
-#define		TLAN_NET_CMD_CSF	0x20
-#define		TLAN_NET_CMD_CAF	0x10
-#define		TLAN_NET_CMD_NOBRX	0x08
-#define		TLAN_NET_CMD_DUPLEX	0x04
-#define		TLAN_NET_CMD_TRFRAM	0x02
-#define		TLAN_NET_CMD_TXPACE	0x01
-#define 	TLAN_NET_SIO_MINTEN	0x80
-#define		TLAN_NET_SIO_ECLOK	0x40
-#define		TLAN_NET_SIO_ETXEN	0x20
-#define		TLAN_NET_SIO_EDATA	0x10
-#define		TLAN_NET_SIO_NMRST	0x08
-#define		TLAN_NET_SIO_MCLK	0x04
-#define		TLAN_NET_SIO_MTXEN	0x02
-#define		TLAN_NET_SIO_MDATA	0x01
-#define		TLAN_NET_STS_MIRQ	0x80
-#define		TLAN_NET_STS_HBEAT	0x40
-#define		TLAN_NET_STS_TXSTOP	0x20
-#define		TLAN_NET_STS_RXSTOP	0x10
-#define		TLAN_NET_STS_RSRVD	0x0F
-#define		TLAN_NET_MASK_MASK7	0x80
-#define		TLAN_NET_MASK_MASK6	0x40
-#define		TLAN_NET_MASK_MASK5	0x20
-#define		TLAN_NET_MASK_MASK4	0x10
-#define		TLAN_NET_MASK_RSRVD	0x0F
-#define 	TLAN_NET_CFG_RCLK	0x8000
-#define		TLAN_NET_CFG_TCLK	0x4000
-#define		TLAN_NET_CFG_BIT	0x2000
-#define		TLAN_NET_CFG_RXCRC	0x1000
-#define		TLAN_NET_CFG_PEF	0x0800
-#define		TLAN_NET_CFG_1FRAG	0x0400
-#define		TLAN_NET_CFG_1CHAN	0x0200
-#define		TLAN_NET_CFG_MTEST	0x0100
-#define		TLAN_NET_CFG_PHY_EN	0x0080
-#define		TLAN_NET_CFG_MSMASK	0x007F
-#define		TLAN_LED_ACT		0x10
-#define		TLAN_LED_LINK		0x01
-#define		TLAN_ID_TX_EOC		0x04
-#define		TLAN_ID_RX_EOF		0x02
-#define		TLAN_ID_RX_EOC		0x01
-
-#define CIRC_INC( a, b ) if ( ++a >= b ) a = 0
-
-#ifdef I_LIKE_A_FAST_HASH_FUNCTION
-/* given 6 bytes, view them as 8 6-bit numbers and return the XOR of those */
-/* the code below is about seven times as fast as the original code */
-inline u32 TLan_HashFunc( u8 *a )
-{
-        u8     hash;
-
-        hash = (a[0]^a[3]);             /* & 077 */
-        hash ^= ((a[0]^a[3])>>6);       /* & 003 */
-        hash ^= ((a[1]^a[4])<<2);       /* & 074 */
-        hash ^= ((a[1]^a[4])>>4);       /* & 017 */
-        hash ^= ((a[2]^a[5])<<4);       /* & 060 */
-        hash ^= ((a[2]^a[5])>>2);       /* & 077 */
-
-        return (hash & 077);
-}
-
-#else /* original code */
-
-inline	u32	xor( u32 a, u32 b )
-{
-	return ( ( a && ! b ) || ( ! a && b ) );
-}
-#define XOR8( a, b, c, d, e, f, g, h )	xor( a, xor( b, xor( c, xor( d, xor( e, xor( f, xor( g, h ) ) ) ) ) ) )
-#define DA( a, bit )					( ( (u8) a[bit/8] ) & ( (u8) ( 1 << bit%8 ) ) )
-
-inline u32 TLan_HashFunc( u8 *a )
-{
-	u32	hash;
-
-	hash  = XOR8( DA(a,0), DA(a, 6), DA(a,12), DA(a,18), DA(a,24), DA(a,30), DA(a,36), DA(a,42) );
-	hash |= XOR8( DA(a,1), DA(a, 7), DA(a,13), DA(a,19), DA(a,25), DA(a,31), DA(a,37), DA(a,43) ) << 1;
-	hash |= XOR8( DA(a,2), DA(a, 8), DA(a,14), DA(a,20), DA(a,26), DA(a,32), DA(a,38), DA(a,44) ) << 2;
-	hash |= XOR8( DA(a,3), DA(a, 9), DA(a,15), DA(a,21), DA(a,27), DA(a,33), DA(a,39), DA(a,45) ) << 3;
-	hash |= XOR8( DA(a,4), DA(a,10), DA(a,16), DA(a,22), DA(a,28), DA(a,34), DA(a,40), DA(a,46) ) << 4;
-	hash |= XOR8( DA(a,5), DA(a,11), DA(a,17), DA(a,23), DA(a,29), DA(a,35), DA(a,41), DA(a,47) ) << 5;
-
-	return hash;
-
-} 
-
-#endif /* I_LIKE_A_FAST_HASH_FUNCTION */
-#endif
-/*******************************************************************************
- *
- *  Linux ThunderLAN Driver
- *
- *  tlan.c
- *  by James Banks
- *
- *  (C) 1997-1998 Caldera, Inc.
- *  (C) 1998 James Banks
- *  (C) 1999-2001 Torben Mathiasen
- *
- *  This software may be used and distributed according to the terms
- *  of the GNU General Public License, incorporated herein by reference.
- *
- ** This file is best viewed/edited with columns>=132.
- *
- ** Useful (if not required) reading:
- *
- *		Texas Instruments, ThunderLAN Programmer's Guide,
- *			TI Literature Number SPWU013A
- *			available in PDF format from www.ti.com
- *		Level One, LXT901 and LXT970 Data Sheets
- *			available in PDF format from www.level1.com
- *		National Semiconductor, DP83840A Data Sheet
- *			available in PDF format from www.national.com
- *		Microchip Technology, 24C01A/02A/04A Data Sheet
- *			available in PDF format from www.microchip.com
- *
- * Change History
- *
- *	Tigran Aivazian <tigran@sco.com>:	TLan_PciProbe() now uses
- *						new PCI BIOS interface.
- *	Alan Cox	<alan@redhat.com>:	Fixed the out of memory
- *						handling.
- *      
- *	Torben Mathiasen <torben.mathiasen@compaq.com> New Maintainer!
- *
- *	v1.1 Dec 20, 1999    - Removed linux version checking
- *			       Patch from Tigran Aivazian. 
- *			     - v1.1 includes Alan's SMP updates.
- *			     - We still have problems on SMP though,
- *			       but I'm looking into that. 
- *			
- *	v1.2 Jan 02, 2000    - Hopefully fixed the SMP deadlock.
- *			     - Removed dependency of HZ being 100.
- *			     - We now allow higher priority timers to 
- *			       overwrite timers like TLAN_TIMER_ACTIVITY
- *			       Patch from John Cagle <john.cagle@compaq.com>.
- *			     - Fixed a few compiler warnings.
- *
- *	v1.3 Feb 04, 2000    - Fixed the remaining HZ issues.
- *			     - Removed call to pci_present(). 
- *			     - Removed SA_INTERRUPT flag from irq handler.
- *			     - Added __init and __initdata to reduce resisdent 
- *			       code size.
- *			     - Driver now uses module_init/module_exit.
- *			     - Rewrote init_module and tlan_probe to
- *			       share a lot more code. We now use tlan_probe
- *			       with builtin and module driver.
- *			     - Driver ported to new net API. 
- *			     - tlan.txt has been reworked to reflect current 
- *			       driver (almost)
- *			     - Other minor stuff
- *
- *	v1.4 Feb 10, 2000    - Updated with more changes required after Dave's
- *	                       network cleanup in 2.3.43pre7 (Tigran & myself)
- *	                     - Minor stuff.
- *
- *	v1.5 March 22, 2000  - Fixed another timer bug that would hang the driver
- *			       if no cable/link were present.
- *			     - Cosmetic changes.
- *			     - TODO: Port completely to new PCI/DMA API
- *			     	     Auto-Neg fallback.
- *
- * 	v1.6 April 04, 2000  - Fixed driver support for kernel-parameters. Haven't
- * 			       tested it though, as the kernel support is currently 
- * 			       broken (2.3.99p4p3).
- * 			     - Updated tlan.txt accordingly.
- * 			     - Adjusted minimum/maximum frame length.
- * 			     - There is now a TLAN website up at 
- * 			       http://tlan.kernel.dk
- *
- * 	v1.7 April 07, 2000  - Started to implement custom ioctls. Driver now
- * 			       reports PHY information when used with Donald
- * 			       Beckers userspace MII diagnostics utility.
- *
- * 	v1.8 April 23, 2000  - Fixed support for forced speed/duplex settings.
- * 			     - Added link information to Auto-Neg and forced
- * 			       modes. When NIC operates with auto-neg the driver
- * 			       will report Link speed & duplex modes as well as
- * 			       link partner abilities. When forced link is used,
- * 			       the driver will report status of the established
- * 			       link.
- * 			       Please read tlan.txt for additional information. 
- * 			     - Removed call to check_region(), and used 
- * 			       return value of request_region() instead.
- *	
- *	v1.8a May 28, 2000   - Minor updates.
- *
- *	v1.9 July 25, 2000   - Fixed a few remaining Full-Duplex issues.
- *	                     - Updated with timer fixes from Andrew Morton.
- *	                     - Fixed module race in TLan_Open.
- *	                     - Added routine to monitor PHY status.
- *	                     - Added activity led support for Proliant devices.
- *
- *	v1.10 Aug 30, 2000   - Added support for EISA based tlan controllers 
- *			       like the Compaq NetFlex3/E. 
- *			     - Rewrote tlan_probe to better handle multiple
- *			       bus probes. Probing and device setup is now
- *			       done through TLan_Probe and TLan_init_one. Actual
- *			       hardware probe is done with kernel API and 
- *			       TLan_EisaProbe.
- *			     - Adjusted debug information for probing.
- *			     - Fixed bug that would cause general debug information 
- *			       to be printed after driver removal. 
- *			     - Added transmit timeout handling.
- *			     - Fixed OOM return values in tlan_probe. 
- *			     - Fixed possible mem leak in tlan_exit 
- *			       (now tlan_remove_one).
- *			     - Fixed timer bug in TLan_phyMonitor.
- *			     - This driver version is alpha quality, please
- *			       send me any bug issues you may encounter.
- *
- *	v1.11 Aug 31, 2000   - Do not try to register irq 0 if no irq line was 
- *			       set for EISA cards.
- *			     - Added support for NetFlex3/E with nibble-rate
- *			       10Base-T PHY. This is untestet as I haven't got
- *			       one of these cards.
- *			     - Fixed timer being added twice.
- *			     - Disabled PhyMonitoring by default as this is
- *			       work in progress. Define MONITOR to enable it.
- *			     - Now we don't display link info with PHYs that
- *			       doesn't support it (level1).
- *			     - Incresed tx_timeout beacuse of auto-neg.
- *			     - Adjusted timers for forced speeds.
- *
- *	v1.12 Oct 12, 2000   - Minor fixes (memleak, init, etc.)
- *
- * 	v1.13 Nov 28, 2000   - Stop flooding console with auto-neg issues
- * 			       when link can't be established.
- *			     - Added the bbuf option as a kernel parameter.
- *			     - Fixed ioaddr probe bug.
- *			     - Fixed stupid deadlock with MII interrupts.
- *			     - Added support for speed/duplex selection with 
- *			       multiple nics.
- *			     - Added partly fix for TX Channel lockup with
- *			       TLAN v1.0 silicon. This needs to be investigated
- *			       further.
- *
- * 	v1.14 Dec 16, 2000   - Added support for servicing multiple frames per.
- * 			       interrupt. Thanks goes to
- * 			       Adam Keys <adam@ti.com>
- * 			       Denis Beaudoin <dbeaudoin@ti.com>
- * 			       for providing the patch.
- * 			     - Fixed auto-neg output when using multiple
- * 			       adapters.
- * 			     - Converted to use new taskq interface.
- *
- * 	v1.14a Jan 6, 2001   - Minor adjustments (spinlocks, etc.)
- *
- *******************************************************************************/
-
-                                                                                
-#include <linux/module.h>
-
-#include "tlan.h"
-
-#include <linux/init.h>
-#include <linux/ioport.h>
-#include <linux/pci.h>
-#include <linux/etherdevice.h>
-#include <linux/delay.h>
-#include <linux/spinlock.h>
-#include <linux/mii.h>
-
-typedef u32 (TLanIntVectorFunc)( struct net_device *, u16 );
-
-/* For removing EISA devices */
-static	struct net_device	*TLan_Eisa_Devices;
-
-static	int		TLanDevicesInstalled;
-
-/* Set speed, duplex and aui settings */
-static  int aui[MAX_TLAN_BOARDS];
-static  int duplex[MAX_TLAN_BOARDS];
-static  int speed[MAX_TLAN_BOARDS];
-static  int boards_found;
-
-MODULE_AUTHOR("Maintainer: Torben Mathiasen <torben.mathiasen@compaq.com>");
-MODULE_DESCRIPTION("Driver for TI ThunderLAN based ethernet PCI adapters");
-MODULE_LICENSE("GPL");
-
-MODULE_PARM(aui, "1-" __MODULE_STRING(MAX_TLAN_BOARDS) "i");
-MODULE_PARM(duplex, "1-" __MODULE_STRING(MAX_TLAN_BOARDS) "i");
-MODULE_PARM(speed, "1-" __MODULE_STRING(MAX_TLAN_BOARDS) "i");
-MODULE_PARM(debug, "i");
-MODULE_PARM(bbuf, "i");
-MODULE_PARM_DESC(aui, "ThunderLAN use AUI port(s) (0-1)");
-MODULE_PARM_DESC(duplex, "ThunderLAN duplex setting(s) (0-default, 1-half, 2-full)");
-MODULE_PARM_DESC(speed, "ThunderLAN port speen setting(s) (0,10,100)");
-MODULE_PARM_DESC(debug, "ThunderLAN debug mask");
-MODULE_PARM_DESC(bbuf, "ThunderLAN use big buffer (0-1)");
-EXPORT_NO_SYMBOLS;
-
-/* Define this to enable Link beat monitoring */
-#undef MONITOR
-
-/* Turn on debugging. See linux/Documentation/networking/tlan.txt for details */
-static  int		debug;
-
-static	int		bbuf;
-static	u8		*TLanPadBuffer;
-static	char		TLanSignature[] = "TLAN";
-static const char tlan_banner[] = "ThunderLAN driver v1.14a\n";
-static int tlan_have_pci;
-static int tlan_have_eisa;
-
-const char *media[] = {
-	"10BaseT-HD ", "10BaseT-FD ","100baseTx-HD ", 
-	"100baseTx-FD", "100baseT4", 0
-};
-
-int media_map[] = { 0x0020, 0x0040, 0x0080, 0x0100, 0x0200,};
-
-static struct board {
-	const char	*deviceLabel;
-	u32	   	flags;
-	u16	   	addrOfs;
-} board_info[] __devinitdata = {
-	{ "Compaq Netelligent 10 T PCI UTP", TLAN_ADAPTER_ACTIVITY_LED, 0x83 },
-	{ "Compaq Netelligent 10/100 TX PCI UTP", TLAN_ADAPTER_ACTIVITY_LED, 0x83 },
-	{ "Compaq Integrated NetFlex-3/P", TLAN_ADAPTER_NONE, 0x83 },
-	{ "Compaq NetFlex-3/P", TLAN_ADAPTER_UNMANAGED_PHY | TLAN_ADAPTER_BIT_RATE_PHY, 0x83 },
-	{ "Compaq NetFlex-3/P", TLAN_ADAPTER_NONE, 0x83 },
-	{ "Compaq Netelligent Integrated 10/100 TX UTP", TLAN_ADAPTER_ACTIVITY_LED, 0x83 },
-	{ "Compaq Netelligent Dual 10/100 TX PCI UTP", TLAN_ADAPTER_NONE, 0x83 },
-	{ "Compaq Netelligent 10/100 TX Embedded UTP", TLAN_ADAPTER_NONE, 0x83 },
-	{ "Olicom OC-2183/2185", TLAN_ADAPTER_USE_INTERN_10, 0x83 },
-	{ "Olicom OC-2325", TLAN_ADAPTER_UNMANAGED_PHY, 0xF8 },
-	{ "Olicom OC-2326", TLAN_ADAPTER_USE_INTERN_10, 0xF8 },
-	{ "Compaq Netelligent 10/100 TX UTP", TLAN_ADAPTER_ACTIVITY_LED, 0x83 },
-	{ "Compaq Netelligent 10 T/2 PCI UTP/Coax", TLAN_ADAPTER_NONE, 0x83 },
-	{ "Compaq NetFlex-3/E", TLAN_ADAPTER_ACTIVITY_LED | 	/* EISA card */
-	                        TLAN_ADAPTER_UNMANAGED_PHY | TLAN_ADAPTER_BIT_RATE_PHY, 0x83 },	
-	{ "Compaq NetFlex-3/E", TLAN_ADAPTER_ACTIVITY_LED, 0x83 }, /* EISA card */
-};
-
-static struct pci_device_id tlan_pci_tbl[] __devinitdata = {
-	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_NETEL10,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_NETEL100,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 1 },
-	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_NETFLEX3I,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 2 },
-	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_THUNDER,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 3 },
-	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_NETFLEX3B,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 4 },
-	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_NETEL100PI,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 5 },
-	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_NETEL100D,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 6 },
-	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_NETEL100I,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 7 },
-	{ PCI_VENDOR_ID_OLICOM, PCI_DEVICE_ID_OLICOM_OC2183,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 8 },
-	{ PCI_VENDOR_ID_OLICOM, PCI_DEVICE_ID_OLICOM_OC2325,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 9 },
-	{ PCI_VENDOR_ID_OLICOM, PCI_DEVICE_ID_OLICOM_OC2326,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 10 },
-	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_NETELLIGENT_10_100_WS_5100,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 11 },
-	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_NETELLIGENT_10_T2,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 12 },
-	{ 0,}
-};
-MODULE_DEVICE_TABLE(pci, tlan_pci_tbl);		
-
-static void	TLan_EisaProbe( void );
-static void	TLan_Eisa_Cleanup( void );
-static int      TLan_Init( struct net_device * );
-static int	TLan_Open( struct net_device *dev );
-static int	TLan_StartTx( struct sk_buff *, struct net_device *);
-static void	TLan_HandleInterrupt( int, void *, struct pt_regs *);
-static int	TLan_Close( struct net_device *);
-static struct	net_device_stats *TLan_GetStats( struct net_device *);
-static void	TLan_SetMulticastList( struct net_device *);
-static int	TLan_ioctl( struct net_device *dev, struct ifreq *rq, int cmd);
-static int      TLan_probe1( struct pci_dev *pdev, long ioaddr, int irq, int rev, const struct pci_device_id *ent);
-static void	TLan_tx_timeout( struct net_device *dev);
-static int 	tlan_init_one( struct pci_dev *pdev, const struct pci_device_id *ent);
-
-static u32	TLan_HandleInvalid( struct net_device *, u16 );
-static u32	TLan_HandleTxEOF( struct net_device *, u16 );
-static u32	TLan_HandleStatOverflow( struct net_device *, u16 );
-static u32	TLan_HandleRxEOF( struct net_device *, u16 );
-static u32	TLan_HandleDummy( struct net_device *, u16 );
-static u32	TLan_HandleTxEOC( struct net_device *, u16 );
-static u32	TLan_HandleStatusCheck( struct net_device *, u16 );
-static u32	TLan_HandleRxEOC( struct net_device *, u16 );
-
-static void	TLan_Timer( unsigned long );
-
-static void	TLan_ResetLists( struct net_device * );
-static void	TLan_FreeLists( struct net_device * );
-static void	TLan_PrintDio( u16 );
-static void	TLan_PrintList( TLanList *, char *, int );
-static void	TLan_ReadAndClearStats( struct net_device *, int );
-static void	TLan_ResetAdapter( struct net_device * );
-static void	TLan_FinishReset( struct net_device * );
-static void	TLan_SetMac( struct net_device *, int areg, char *mac );
-
-static void	TLan_PhyPrint( struct net_device * );
-static void	TLan_PhyDetect( struct net_device * );
-static void	TLan_PhyPowerDown( struct net_device * );
-static void	TLan_PhyPowerUp( struct net_device * );
-static void	TLan_PhyReset( struct net_device * );
-static void	TLan_PhyStartLink( struct net_device * );
-static void	TLan_PhyFinishAutoNeg( struct net_device * );
-#ifdef MONITOR
-static void     TLan_PhyMonitor( struct net_device * );
-#endif
-
-/*
-static int	TLan_PhyNop( struct net_device * );
-static int	TLan_PhyInternalCheck( struct net_device * );
-static int	TLan_PhyInternalService( struct net_device * );
-static int	TLan_PhyDp83840aCheck( struct net_device * );
-*/
-
-static int	TLan_MiiReadReg( struct net_device *, u16, u16, u16 * );
-static void	TLan_MiiSendData( u16, u32, unsigned );
-static void	TLan_MiiSync( u16 );
-static void	TLan_MiiWriteReg( struct net_device *, u16, u16, u16 );
-
-static void	TLan_EeSendStart( u16 );
-static int	TLan_EeSendByte( u16, u8, int );
-static void	TLan_EeReceiveByte( u16, u8 *, int );
-static int	TLan_EeReadByte( struct net_device *, u8, u8 * );
-
-static TLanIntVectorFunc *TLanIntVector[TLAN_INT_NUMBER_OF_INTS] = {
-	TLan_HandleInvalid,
-	TLan_HandleTxEOF,
-	TLan_HandleStatOverflow,
-	TLan_HandleRxEOF,
-	TLan_HandleDummy,
-	TLan_HandleTxEOC,
-	TLan_HandleStatusCheck,
-	TLan_HandleRxEOC
-};
-
-static inline void
-TLan_SetTimer( struct net_device *dev, u32 ticks, u32 type )
-{
-	TLanPrivateInfo *priv = dev->priv;
-	unsigned long flags = 0;
-	
-	if (!in_irq())
-		spin_lock_irqsave(&priv->lock, flags);
-	if ( priv->timer.function != NULL &&
-		priv->timerType != TLAN_TIMER_ACTIVITY ) { 
-		if (!in_irq())
-			spin_unlock_irqrestore(&priv->lock, flags);
-		return;
-	}
-	priv->timer.function = &TLan_Timer;
-	if (!in_irq())
-		spin_unlock_irqrestore(&priv->lock, flags);
-
-	priv->timer.data = (unsigned long) dev;
-	priv->timerSetAt = jiffies;
-	priv->timerType = type;
-	mod_timer(&priv->timer, jiffies + ticks);
-	
-} /* TLan_SetTimer */
-
-/*****************************************************************************
-******************************************************************************
-
-	ThunderLAN Driver Primary Functions
-
-	These functions are more or less common to all Linux network drivers.
-
-******************************************************************************
-*****************************************************************************/
-
-	/***************************************************************
-	 *	tlan_remove_one
-	 *
-	 *	Returns:
-	 *		Nothing
-	 *	Parms:
-	 *		None
-	 *
-	 *	Goes through the TLanDevices list and frees the device
-	 *	structs and memory associated with each device (lists
-	 *	and buffers).  It also ureserves the IO port regions
-	 *	associated with this device.
-	 *
-	 **************************************************************/
-
-static void __devexit tlan_remove_one( struct pci_dev *pdev)
-{
-	struct net_device *dev = pci_get_drvdata( pdev );
-	TLanPrivateInfo	*priv = dev->priv;
-	
-	unregister_netdev( dev );
-
-	if ( priv->dmaStorage ) {
-		kfree( priv->dmaStorage );
-	}
-
-	release_region( dev->base_addr, 0x10 );
-	
-	kfree( dev );
-		
-	pci_set_drvdata( pdev, NULL );
-} 
-
-static struct pci_driver tlan_driver = {
-	name:		"tlan",
-	id_table:	tlan_pci_tbl,
-	probe:		tlan_init_one,
-	remove:		tlan_remove_one,	
-};
-
-static int __init tlan_probe(void)
-{
-	static int	pad_allocated;
-	
-	printk(KERN_INFO "%s", tlan_banner);
-	
-	TLanPadBuffer = (u8 *) kmalloc(TLAN_MIN_FRAME_SIZE, 
-					GFP_KERNEL);
-
-	if (TLanPadBuffer == NULL) {
-		printk(KERN_ERR "TLAN: Could not allocate memory for pad buffer.\n");
-		return -ENOMEM;
-	}
-
-	memset(TLanPadBuffer, 0, TLAN_MIN_FRAME_SIZE);
-	pad_allocated = 1;
-
-	TLAN_DBG(TLAN_DEBUG_PROBE, "Starting PCI Probe....\n");
-	
-	/* Use new style PCI probing. Now the kernel will
-	   do most of this for us */
-	pci_register_driver(&tlan_driver);
-
-	TLAN_DBG(TLAN_DEBUG_PROBE, "Starting EISA Probe....\n");
-	TLan_EisaProbe();
-		
-	printk(KERN_INFO "TLAN: %d device%s installed, PCI: %d  EISA: %d\n", 
-		 TLanDevicesInstalled, TLanDevicesInstalled == 1 ? "" : "s",
-		 tlan_have_pci, tlan_have_eisa);
-
-	if (TLanDevicesInstalled == 0) {
-		pci_unregister_driver(&tlan_driver);
-		kfree(TLanPadBuffer);
-		return -ENODEV;
-	}
-	return 0;
-}
-	
-
-static int __devinit tlan_init_one( struct pci_dev *pdev,
-				    const struct pci_device_id *ent)
-{
-	return TLan_probe1( pdev, -1, -1, 0, ent);
-}
-
-/*
-	***************************************************************
-	 *	tlan_probe1
-	 *
-	 *	Returns:
-	 *		0 on success, error code on error
-	 *	Parms: 
-	 *		none
-	 *
-	 *	The name is lower case to fit in with all the rest of
-	 *	the netcard_probe names.  This function looks for 
-	 *	another TLan based adapter, setting it up with the
-	 *	allocated device struct if one is found.
-	 *	tlan_probe has been ported to the new net API and
-	 *	now allocates its own device structure. This function
-	 *	is also used by modules.
-	 *
-	 **************************************************************/
-
-static int __devinit TLan_probe1(struct pci_dev *pdev, 
-				long ioaddr, int irq, int rev, const struct pci_device_id *ent )
-{
-
-	struct net_device  *dev;
-	TLanPrivateInfo    *priv;
-	u8		   pci_rev;
-	u16		   device_id;
-	int		   reg;
-
-	if (pdev && pci_enable_device(pdev))
-		return -EIO;
-
-	dev = init_etherdev(NULL, sizeof(TLanPrivateInfo));
-	if (dev == NULL) {
-		printk(KERN_ERR "TLAN: Could not allocate memory for device.\n");
-		return -ENOMEM;
-	}
-	SET_MODULE_OWNER(dev);
-	
-	priv = dev->priv;
-
-	/* Is this a PCI device? */
-	if (pdev) {
-		u32 		   pci_io_base = 0;
-
-		priv->adapter = &board_info[ent->driver_data];
-
-		pci_read_config_byte ( pdev, PCI_REVISION_ID, &pci_rev);
-
-		for ( reg= 0; reg <= 5; reg ++ ) {
-			if (pci_resource_flags(pdev, reg) & IORESOURCE_IO) {
-				pci_io_base = pci_resource_start(pdev, reg);
-				TLAN_DBG( TLAN_DEBUG_GNRL, "IO mapping is available at %x.\n",
-						pci_io_base);
-				break;
-			}
-		}
-		if (!pci_io_base) {
-			printk(KERN_ERR "TLAN: No IO mappings available\n");
-			unregister_netdev(dev);
-			kfree(dev);
-			return -ENODEV;
-		}
-		
-		dev->base_addr = pci_io_base;
-		dev->irq = pdev->irq;
-		priv->adapterRev = pci_rev; 
-		pci_set_master(pdev);
-		pci_set_drvdata(pdev, dev);
-
-	} else	{     /* EISA card */
-		/* This is a hack. We need to know which board structure
-		 * is suited for this adapter */
-		device_id = inw(ioaddr + EISA_ID2);
-		priv->is_eisa = 1;
-		if (device_id == 0x20F1) {
-			priv->adapter = &board_info[13]; 	/* NetFlex-3/E */
-			priv->adapterRev = 23;			/* TLAN 2.3 */
-		} else {
-			priv->adapter = &board_info[14];
-			priv->adapterRev = 10;			/* TLAN 1.0 */
-		}
-		dev->base_addr = ioaddr;
-		dev->irq = irq;
-	}
-
-	/* Kernel parameters */
-	if (dev->mem_start) {
-		priv->aui    = dev->mem_start & 0x01;
-		priv->duplex = ((dev->mem_start & 0x06) == 0x06) ? 0 : (dev->mem_start & 0x06) >> 1;
-		priv->speed  = ((dev->mem_start & 0x18) == 0x18) ? 0 : (dev->mem_start & 0x18) >> 3;
-	
-		if (priv->speed == 0x1) {
-			priv->speed = TLAN_SPEED_10;
-		} else if (priv->speed == 0x2) {
-			priv->speed = TLAN_SPEED_100;
-		}
-		debug = priv->debug = dev->mem_end;
-	} else {
-		priv->aui    = aui[boards_found];
-		priv->speed  = speed[boards_found];
-		priv->duplex = duplex[boards_found];
-		priv->debug = debug;
-	}
-	
-	/* This will be used when we get an adapter error from
-	 * within our irq handler */
-	INIT_LIST_HEAD(&priv->tlan_tqueue.list);
-	priv->tlan_tqueue.sync = 0;
-	priv->tlan_tqueue.routine = (void *)(void*)TLan_tx_timeout;
-	priv->tlan_tqueue.data = dev;
-
-	spin_lock_init(&priv->lock);
-	
-	if (TLan_Init(dev)) {
-		printk(KERN_ERR "TLAN: Could not register device.\n");
-		unregister_netdev(dev);
-		kfree(dev);
-		return -EAGAIN;
-	} else {
-	
-	TLanDevicesInstalled++;
-	boards_found++;
-	
-	/* pdev is NULL if this is an EISA device */
-	if (pdev)
-		tlan_have_pci++;
-	else {
-		priv->nextDevice = TLan_Eisa_Devices;
-		TLan_Eisa_Devices = dev;
-		tlan_have_eisa++;
-	}
-	
-	printk(KERN_INFO "TLAN: %s irq=%2d, io=%04x, %s, Rev. %d\n",
-			dev->name,
-			(int) dev->irq,
-			(int) dev->base_addr,
-			priv->adapter->deviceLabel,
-			priv->adapterRev);
-	return 0;
-	}
-
-}
+}	/* TLan_FinishReset */
 
-static void TLan_Eisa_Cleanup(void)
-{
-	struct net_device *dev;
-	TLanPrivateInfo *priv;
-	
-	while( tlan_have_eisa ) {
-		dev = TLan_Eisa_Devices;
-		priv = dev->priv;
-		if (priv->dmaStorage) {
-			kfree(priv->dmaStorage);
-		}
-		release_region( dev->base_addr, 0x10);
-		unregister_netdev( dev );
-		TLan_Eisa_Devices = priv->nextDevice;
-		kfree( dev );
-		tlan_have_eisa--;
-	}
-}
-	
-		
-static void __exit tlan_exit(void)
-{
-	pci_unregister_driver(&tlan_driver);
-
-	if (tlan_have_eisa)
-		TLan_Eisa_Cleanup();
-
-	kfree( TLanPadBuffer );
-
-}
-
-/* Module loading/unloading */
-module_init(tlan_probe);
-module_exit(tlan_exit);
-
-	/**************************************************************
-	 * 	TLan_EisaProbe
-	 *
-	 *  	Returns: 0 on success, 1 otherwise
-	 *
-	 *  	Parms:	 None
-	 *
-	 *
-	 *  	This functions probes for EISA devices and calls 
-	 *  	TLan_probe1 when one is found. 
-	 *
-	 *************************************************************/
-
-static void  __init TLan_EisaProbe (void) 
+/**************************************************************************
+POLL - Wait for a frame
+***************************************************************************/
+static int tlan_poll(struct nic *nic, int retrieve)
 {
-	long 	ioaddr;
-	int 	rc = -ENODEV;
-	int 	irq;
-	u16	device_id;
-
-	if (!EISA_bus) {	
-		TLAN_DBG(TLAN_DEBUG_PROBE, "No EISA bus present\n");
-		return;
-	}
-	
-	/* Loop through all slots of the EISA bus */
-	for (ioaddr = 0x1000; ioaddr < 0x9000; ioaddr += 0x1000) {
-		
-	TLAN_DBG(TLAN_DEBUG_PROBE,"EISA_ID 0x%4x: 0x%4x\n", (int) ioaddr + 0xC80, inw(ioaddr + EISA_ID));	
-	TLAN_DBG(TLAN_DEBUG_PROBE,"EISA_ID 0x%4x: 0x%4x\n", (int) ioaddr + 0xC82, inw(ioaddr + EISA_ID2));
+	/* return true if there's an ethernet packet ready to read */
+	/* nic->packet should contain data on return */
+	/* nic->packetlen should contain length of data */
+	u32 framesize;
+	u32 host_cmd = 0;
+	u32 ack = 1;
+	int eoc = 0;
+	int entry = priv->cur_rx % TLAN_NUM_RX_LISTS;
+	u16 tmpCStat = le32_to_cpu(rx_ring[entry].cStat);
+	u16 host_int = inw(BASE + TLAN_HOST_INT);
 
-		TLAN_DBG(TLAN_DEBUG_PROBE, "Probing for EISA adapter at IO: 0x%4x : ",
-				   	(int) ioaddr);
-		if (request_region(ioaddr, 0x10, TLanSignature) == NULL) 
-			goto out;
-
-		if (inw(ioaddr + EISA_ID) != 0x110E) {		
-			release_region(ioaddr, 0x10);
-			goto out;
-		}
-		
-		device_id = inw(ioaddr + EISA_ID2);
-		if (device_id !=  0x20F1 && device_id != 0x40F1) { 		
-			release_region (ioaddr, 0x10);
-			goto out;
-		}
-		
-	 	if (inb(ioaddr + EISA_CR) != 0x1) { 	/* Check if adapter is enabled */
-			release_region (ioaddr, 0x10);
-			goto out2;
-		}
-		
-		if (debug == 0x10)		
-			printk("Found one\n");
+	if ((tmpCStat & TLAN_CSTAT_FRM_CMP) && !retrieve)
+	  return 1;
 
-		/* Get irq from board */
-		switch (inb(ioaddr + 0xCC0)) {
-			case(0x10):
-				irq=5;
-				break;
-			case(0x20):
-				irq=9;
-				break;
-			case(0x40):
-				irq=10;
-				break;
-			case(0x80):
-				irq=11;
-				break;
-			default:
-				goto out;
-		}               
-		
-		
-		/* Setup the newly found eisa adapter */
-		rc = TLan_probe1( NULL, ioaddr, irq,
-					12, NULL);
-		continue;
-		
-		out:
-			if (debug == 0x10)
-				printk("None found\n");
-			continue;
-
-		out2:	if (debug == 0x10)
-				printk("Card found but it is not enabled, skipping\n");
-			continue;
-		
-	}
+	outw(host_int, BASE + TLAN_HOST_INT);
 
-} /* TLan_EisaProbe */
+	if (!(tmpCStat & TLAN_CSTAT_FRM_CMP))
+		return 0;
 
-	
+	/* printf("PI-1: 0x%hX\n", host_int); */
+	if (tmpCStat & TLAN_CSTAT_EOC)
+		eoc = 1;
 
-	/***************************************************************
-	 *	TLan_Init
-	 *
-	 *	Returns:
-	 *		0 on success, error code otherwise.
-	 *	Parms:
-	 *		dev	The structure of the device to be
-	 *			init'ed.
-	 *
-	 *	This function completes the initialization of the
-	 *	device structure and driver.  It reserves the IO
-	 *	addresses, allocates memory for the lists and bounce
-	 *	buffers, retrieves the MAC address from the eeprom
-	 *	and assignes the device's methods.
-	 *	
-	 **************************************************************/
+	framesize = rx_ring[entry].frameSize;
 
-static int TLan_Init( struct net_device *dev )
-{
-	int		dma_size;
-	int 		err;
-	int		i;
-	TLanPrivateInfo	*priv;
+	nic->packetlen = framesize;
 
-	priv = dev->priv;
-	
-	if (!priv->is_eisa)	/* EISA devices have already requested IO */
-		if (!request_region( dev->base_addr, 0x10, TLanSignature )) {
-			printk(KERN_ERR "TLAN: %s: IO port region 0x%lx size 0x%x in use.\n",
-				dev->name,
-				dev->base_addr,
-				0x10 );
-			return -EIO;
+#ifdef EBDEBUG
+     printf(".%d.", framesize); 
+#endif
+     
+	memcpy(nic->packet, rxb +
+	       (priv->cur_rx * TLAN_MAX_FRAME_SIZE), nic->packetlen);
+
+	rx_ring[entry].cStat = 0;
+#ifdef EBDEBUG
+	//hex_dump(nic->packet, nic->packetlen);
+	printf("%d", entry);  
+#endif
+	entry = (entry + 1) % TLAN_NUM_RX_LISTS;
+	priv->cur_rx = entry;
+	if (eoc) {
+		if ((rx_ring[entry].cStat & TLAN_CSTAT_READY) ==
+		    TLAN_CSTAT_READY) {
+			ack |= TLAN_HC_GO | TLAN_HC_RT;
+			host_cmd = TLAN_HC_ACK | ack | 0x001C0000;
+			outl(host_cmd, BASE + TLAN_HOST_CMD);
 		}
-	
-	if ( bbuf ) {
-		dma_size = ( TLAN_NUM_RX_LISTS + TLAN_NUM_TX_LISTS )
-	           * ( sizeof(TLanList) + TLAN_MAX_FRAME_SIZE );
 	} else {
-		dma_size = ( TLAN_NUM_RX_LISTS + TLAN_NUM_TX_LISTS )
-	           * ( sizeof(TLanList) );
-	}
-	priv->dmaStorage = kmalloc(dma_size, GFP_KERNEL | GFP_DMA);
-	if ( priv->dmaStorage == NULL ) {
-		printk(KERN_ERR "TLAN:  Could not allocate lists and buffers for %s.\n",
-			dev->name );
-		release_region( dev->base_addr, 0x10 );
-		return -ENOMEM;
-	}
-	memset( priv->dmaStorage, 0, dma_size );
-	priv->rxList = (TLanList *) 
-		       ( ( ( (u32) priv->dmaStorage ) + 7 ) & 0xFFFFFFF8 );
-	priv->txList = priv->rxList + TLAN_NUM_RX_LISTS;
-	if ( bbuf ) {
-		priv->rxBuffer = (u8 *) ( priv->txList + TLAN_NUM_TX_LISTS );
-		priv->txBuffer = priv->rxBuffer
-				 + ( TLAN_NUM_RX_LISTS * TLAN_MAX_FRAME_SIZE );
-	}
-
-	err = 0;
-	for ( i = 0;  i < 6 ; i++ )
-		err |= TLan_EeReadByte( dev,
-					(u8) priv->adapter->addrOfs + i,
-					(u8 *) &dev->dev_addr[i] );
-	if ( err ) {
-		printk(KERN_ERR "TLAN: %s: Error reading MAC from eeprom: %d\n",
-			dev->name,
-			err );
-	}
-	dev->addr_len = 6;
-	
-	/* Device methods */
-	dev->open = &TLan_Open;
-	dev->hard_start_xmit = &TLan_StartTx;
-	dev->stop = &TLan_Close;
-	dev->get_stats = &TLan_GetStats;
-	dev->set_multicast_list = &TLan_SetMulticastList;
-	dev->do_ioctl = &TLan_ioctl;
-	dev->tx_timeout = &TLan_tx_timeout;
-	dev->watchdog_timeo = TX_TIMEOUT;
-
-	return 0;
-
-} /* TLan_Init */
-
-	/***************************************************************
-	 *	TLan_Open
-	 *
-	 *	Returns:
-	 *		0 on success, error code otherwise.
-	 *	Parms:
-	 *		dev	Structure of device to be opened.
-	 *
-	 *	This routine puts the driver and TLAN adapter in a
-	 *	state where it is ready to send and receive packets.
-	 *	It allocates the IRQ, resets and brings the adapter
-	 *	out of reset, and allows interrupts.  It also delays
-	 *	the startup for autonegotiation or sends a Rx GO
-	 *	command to the adapter, as appropriate.
-	 *
-	 **************************************************************/
-
-static int TLan_Open( struct net_device *dev )
-{
-	TLanPrivateInfo	*priv = dev->priv;
-	int		err;
-	
-	priv->tlanRev = TLan_DioRead8( dev->base_addr, TLAN_DEF_REVISION );
-	err = request_irq( dev->irq, TLan_HandleInterrupt, SA_SHIRQ, TLanSignature, dev );
-	
-	if ( err ) {
-		printk(KERN_ERR "TLAN:  Cannot open %s because IRQ %d is already in use.\n", dev->name, dev->irq );
-		return err;
+		host_cmd = TLAN_HC_ACK | ack | (0x000C0000);
+		outl(host_cmd, BASE + TLAN_HOST_CMD);
+#ifdef EBDEBUG
+		printf("AC: 0x%hX\n", inw(BASE + TLAN_CH_PARM)); 
+		host_int = inw(BASE + TLAN_HOST_INT);
+		printf("PI-2: 0x%hX\n", host_int); 
+#endif
 	}
-	
-	init_timer(&priv->timer);
-	netif_start_queue(dev);
-	
-	/* NOTE: It might not be necessary to read the stats before a
-			 reset if you don't care what the values are.
-	*/
-	TLan_ResetLists( dev );
-	TLan_ReadAndClearStats( dev, TLAN_IGNORE );
-	TLan_ResetAdapter( dev );
-
-	TLAN_DBG( TLAN_DEBUG_GNRL, "%s: Opened.  TLAN Chip Rev: %x\n", dev->name, priv->tlanRev );
-
-	return 0;
-
-} /* TLan_Open */
-
-	/**************************************************************
-	 *	TLan_ioctl
-	 *	
-	 *	Returns:
-	 *		0 on success, error code otherwise
-	 *	Params:
-	 *		dev	structure of device to receive ioctl.
-	 *		
-	 *		rq	ifreq structure to hold userspace data.
-	 *
-	 *		cmd	ioctl command.
-	 *
-	 *
-	 *************************************************************/
+	refill_rx(nic);
+	return (1);		/* initially as this is called to flush the input */
+}
 
-static int TLan_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+static void refill_rx(struct nic *nic __unused)
 {
-	TLanPrivateInfo *priv = dev->priv;
-	struct mii_ioctl_data *data = (struct mii_ioctl_data *)&rq->ifr_data;
-	u32 phy   = priv->phy[priv->phyNum];
-	
-	if (!priv->phyOnline)
-		return -EAGAIN;
-
-	switch(cmd) {
-	case SIOCGMIIPHY:		/* Get address of MII PHY in use. */
-	case SIOCDEVPRIVATE:		/* for binary compat, remove in 2.5 */
-			data->phy_id = phy;
-
-	case SIOCGMIIREG:		/* Read MII PHY register. */
-	case SIOCDEVPRIVATE+1:		/* for binary compat, remove in 2.5 */
-			TLan_MiiReadReg(dev, data->phy_id & 0x1f, data->reg_num & 0x1f, &data->val_out);
-			return 0;
-		
+	int entry = 0;
 
-	case SIOCSMIIREG:		/* Write MII PHY register. */
-	case SIOCDEVPRIVATE+2:		/* for binary compat, remove in 2.5 */
-			if (!capable(CAP_NET_ADMIN))
-				return -EPERM;
-			TLan_MiiWriteReg(dev, data->phy_id & 0x1f, data->reg_num & 0x1f, data->val_in);
-			return 0;
-		default:
-			return -EOPNOTSUPP;
+	for (;
+	     (priv->cur_rx - priv->dirty_rx +
+	      TLAN_NUM_RX_LISTS) % TLAN_NUM_RX_LISTS > 0;
+	     priv->dirty_rx = (priv->dirty_rx + 1) % TLAN_NUM_RX_LISTS) {
+		entry = priv->dirty_rx % TLAN_NUM_TX_LISTS;
+		rx_ring[entry].frameSize = TLAN_MAX_FRAME_SIZE;
+		rx_ring[entry].cStat = TLAN_CSTAT_READY;
 	}
-} /* tlan_ioctl */
-
-	/***************************************************************
-	 * 	TLan_tx_timeout
-	 *
-	 * 	Returns: nothing
-	 *
-	 * 	Params:
-	 * 		dev	structure of device which timed out 
-	 * 			during transmit.
-	 *
-	 **************************************************************/
-
-static void TLan_tx_timeout(struct net_device *dev)
-{
-	
-	TLAN_DBG( TLAN_DEBUG_GNRL, "%s: Transmit timed out.\n", dev->name);
-	
-	/* Ok so we timed out, lets see what we can do about it...*/
-	TLan_FreeLists( dev );
-	TLan_ResetLists( dev );		
-	TLan_ReadAndClearStats( dev, TLAN_IGNORE );
-	TLan_ResetAdapter( dev );
-	dev->trans_start = jiffies;
-	netif_wake_queue( dev );	
 
 }
-	
 
-	/***************************************************************
-	 *	TLan_StartTx
-	 *  
-	 *	Returns:
-	 *		0 on success, non-zero on failure.
-	 *	Parms:
-	 *		skb	A pointer to the sk_buff containing the
-	 *			frame to be sent.
-	 *		dev	The device to send the data on.
-	 *
-	 *	This function adds a frame to the Tx list to be sent
-	 *	ASAP.  First it	verifies that the adapter is ready and
-	 *	there is room in the queue.  Then it sets up the next
-	 *	available list, copies the frame to the	corresponding
-	 *	buffer.  If the adapter Tx channel is idle, it gives
-	 *	the adapter a Tx Go command on the list, otherwise it
-	 *	sets the forward address of the previous list to point
-	 *	to this one.  Then it frees the sk_buff.
-	 *
-	 **************************************************************/
+/* #define EBDEBUG */
+/**************************************************************************
+TRANSMIT - Transmit a frame
+***************************************************************************/
+static void tlan_transmit(struct nic *nic, const char *d,	/* Destination */
+			  unsigned int t,	/* Type */
+			  unsigned int s,	/* size */
+			  const char *p)
+{				/* Packet */
+	u16 nstype;
+	u32 to;
+	struct TLanList *tail_list;
+	struct TLanList *head_list;
+	u8 *tail_buffer;
+	u32 ack = 0;
+	u32 host_cmd;
+	int eoc = 0;
+	u16 tmpCStat;
+#ifdef EBDEBUG
+	u16 host_int = inw(BASE + TLAN_HOST_INT);
+#endif
+	int entry = 0;
 
-static int TLan_StartTx( struct sk_buff *skb, struct net_device *dev )
-{
-	TLanPrivateInfo *priv = dev->priv;
-	TLanList	*tail_list;
-	u8		*tail_buffer;
-	int		pad;
-	unsigned long	flags;
-
-	if ( ! priv->phyOnline ) {
-		TLAN_DBG( TLAN_DEBUG_TX, "TRANSMIT:  %s PHY is not ready\n", dev->name );
-		dev_kfree_skb_any(skb);
-		return 0;
+#ifdef EBDEBUG
+	printf("INT0-0x%hX\n", host_int);
+#endif
+
+	if (!priv->phyOnline) {
+		printf("TRANSMIT:  %s PHY is not ready\n", priv->nic_name);
+		return;
 	}
 
 	tail_list = priv->txList + priv->txTail;
-	
-	if ( tail_list->cStat != TLAN_CSTAT_UNUSED ) {
-		TLAN_DBG( TLAN_DEBUG_TX, "TRANSMIT:  %s is busy (Head=%d Tail=%d)\n", dev->name, priv->txHead, priv->txTail );
-		netif_stop_queue(dev);
+
+	if (tail_list->cStat != TLAN_CSTAT_UNUSED) {
+		printf("TRANSMIT: %s is busy (Head=%d Tail=%d)\n",
+		       priv->nic_name, priv->txList, priv->txTail);
+		tx_ring[entry].cStat = TLAN_CSTAT_UNUSED;
 		priv->txBusyCount++;
-		return 1;
+		return;
 	}
 
 	tail_list->forward = 0;
 
-	if ( bbuf ) {
-		tail_buffer = priv->txBuffer + ( priv->txTail * TLAN_MAX_FRAME_SIZE );
-		memcpy( tail_buffer, skb->data, skb->len );
-	} else {
-		tail_list->buffer[0].address = virt_to_bus( skb->data );
-		tail_list->buffer[9].address = (u32) skb;
-	}
+	tail_buffer = txb + (priv->txTail * TLAN_MAX_FRAME_SIZE);
 
-	pad = TLAN_MIN_FRAME_SIZE - skb->len;
-
-	if ( pad > 0 ) {
-		tail_list->frameSize = (u16) skb->len + pad;
-		tail_list->buffer[0].count = (u32) skb->len;
-		tail_list->buffer[1].count = TLAN_LAST_BUFFER | (u32) pad;
-		tail_list->buffer[1].address = virt_to_bus( TLanPadBuffer );
-	} else {
-		tail_list->frameSize = (u16) skb->len;
-		tail_list->buffer[0].count = TLAN_LAST_BUFFER | (u32) skb->len;
-		tail_list->buffer[1].count = 0;
-		tail_list->buffer[1].address = 0;
-	}
+	/* send the packet to destination */
+	memcpy(tail_buffer, d, ETH_ALEN);
+	memcpy(tail_buffer + ETH_ALEN, nic->node_addr, ETH_ALEN);
+	nstype = htons((u16) t);
+	memcpy(tail_buffer + 2 * ETH_ALEN, (u8 *) & nstype, 2);
+	memcpy(tail_buffer + ETH_HLEN, p, s);
+
+	s += ETH_HLEN;
+	s &= 0x0FFF;
+	while (s < ETH_ZLEN)
+		tail_buffer[s++] = '\0';
+
+	/*=====================================================*/
+	/* Receive
+	 * 0000 0000 0001 1100
+	 * 0000 0000 0000 1100
+	 * 0000 0000 0000 0011 = 0x0003
+	 *
+	 * 0000 0000 0000 0000 0000 0000 0000 0011
+	 * 0000 0000 0000 1100 0000 0000 0000 0000 = 0x000C0000
+	 *
+	 * Transmit
+	 * 0000 0000 0001 1100
+	 * 0000 0000 0000 0100
+	 * 0000 0000 0000 0001 = 0x0001
+	 *
+	 * 0000 0000 0000 0000 0000 0000 0000 0001
+	 * 0000 0000 0000 0100 0000 0000 0000 0000 = 0x00040000
+	 * */
+
+	/* Setup the transmit descriptor */
+	tail_list->frameSize = (u16) s;
+	tail_list->buffer[0].count = TLAN_LAST_BUFFER | (u32) s;
+	tail_list->buffer[1].count = 0;
+	tail_list->buffer[1].address = 0;
 
-	spin_lock_irqsave(&priv->lock, flags);
 	tail_list->cStat = TLAN_CSTAT_READY;
-	if ( ! priv->txInProgress ) {
+
+#ifdef EBDEBUG
+	host_int = inw(BASE + TLAN_HOST_INT);
+	printf("INT1-0x%hX\n", host_int);
+#endif
+
+	if (!priv->txInProgress) {
 		priv->txInProgress = 1;
-		TLAN_DBG( TLAN_DEBUG_TX, "TRANSMIT:  Starting TX on buffer %d\n", priv->txTail );
-		outl( virt_to_bus( tail_list ), dev->base_addr + TLAN_CH_PARM );
-		outl( TLAN_HC_GO, dev->base_addr + TLAN_HOST_CMD );
+		outl(virt_to_le32desc(tail_list), BASE + TLAN_CH_PARM);
+		outl(TLAN_HC_GO, BASE + TLAN_HOST_CMD);
 	} else {
-		TLAN_DBG( TLAN_DEBUG_TX, "TRANSMIT:  Adding buffer %d to TX channel\n", priv->txTail );
-		if ( priv->txTail == 0 ) {
-			( priv->txList + ( TLAN_NUM_TX_LISTS - 1 ) )->forward = virt_to_bus( tail_list );
+		if (priv->txTail == 0) {
+#ifdef EBDEBUG
+			printf("Out buffer\n");
+#endif
+			(priv->txList + (TLAN_NUM_TX_LISTS - 1))->forward =
+			    virt_to_le32desc(tail_list);
 		} else {
-			( priv->txList + ( priv->txTail - 1 ) )->forward = virt_to_bus( tail_list );
+#ifdef EBDEBUG
+			printf("Fix this \n");
+#endif
+			(priv->txList + (priv->txTail - 1))->forward =
+			    virt_to_le32desc(tail_list);
 		}
 	}
-	spin_unlock_irqrestore(&priv->lock, flags);
-
-	CIRC_INC( priv->txTail, TLAN_NUM_TX_LISTS );
-
-	if ( bbuf )
-		dev_kfree_skb_any(skb);
-		
-	dev->trans_start = jiffies;
-	return 0;
-
-} /* TLan_StartTx */
-
-	/***************************************************************
-	 *	TLan_HandleInterrupt
-	 *  
-	 *	Returns:	
-	 *		Nothing
-	 *	Parms:
-	 *		irq	The line on which the interrupt
-	 *			occurred.
-	 *		dev_id	A pointer to the device assigned to
-	 *			this irq line.
-	 *		regs	???
-	 *
-	 *	This function handles an interrupt generated by its
-	 *	assigned TLAN adapter.  The function deactivates
-	 *	interrupts on its adapter, records the type of
-	 *	interrupt, executes the appropriate subhandler, and
-	 *	acknowdges the interrupt to the adapter (thus
-	 *	re-enabling adapter interrupts.
-	 *
-	 **************************************************************/
-
-static void TLan_HandleInterrupt(int irq, void *dev_id, struct pt_regs *regs)
-{
-	u32		ack;
-	struct net_device	*dev;
-	u32		host_cmd;
-	u16		host_int;
-	int		type;
-	TLanPrivateInfo *priv;
-
-	dev = dev_id;
-	priv = dev->priv;
-
-	spin_lock(&priv->lock);
-
-	host_int = inw( dev->base_addr + TLAN_HOST_INT );
-	outw( host_int, dev->base_addr + TLAN_HOST_INT );
+	
+	CIRC_INC(priv->txTail, TLAN_NUM_TX_LISTS);
 
-	type = ( host_int & TLAN_HI_IT_MASK ) >> 2;
+#ifdef EBDEBUG
+	host_int = inw(BASE + TLAN_HOST_INT);
+	printf("INT2-0x%hX\n", host_int);
+#endif
 
-	ack = TLanIntVector[type]( dev, host_int );
+	to = currticks() + TX_TIME_OUT;
+	while ((tail_list->cStat == TLAN_CSTAT_READY) && currticks() < to);
 
-	if ( ack ) {
-		host_cmd = TLAN_HC_ACK | ack | ( type << 18 );
-		outl( host_cmd, dev->base_addr + TLAN_HOST_CMD );
+	head_list = priv->txList + priv->txHead;
+	while (((tmpCStat = head_list->cStat) & TLAN_CSTAT_FRM_CMP) 
+			&& (ack < 255)) {
+		ack++;
+		if(tmpCStat & TLAN_CSTAT_EOC)
+			eoc =1;
+		head_list->cStat = TLAN_CSTAT_UNUSED;
+		CIRC_INC(priv->txHead, TLAN_NUM_TX_LISTS);
+		head_list = priv->txList + priv->txHead;
+		
 	}
+	if(!ack)
+		printf("Incomplete TX Frame\n");
 
-	spin_unlock(&priv->lock);
-
-} /* TLan_HandleInterrupts */
-
-	/***************************************************************
-	 *	TLan_Close
-	 *  
-	 * 	Returns:
-	 *		An error code.
-	 *	Parms:
-	 *		dev	The device structure of the device to
-	 *			close.
-	 *
-	 *	This function shuts down the adapter.  It records any
-	 *	stats, puts the adapter into reset state, deactivates
-	 *	its time as needed, and	frees the irq it is using.
-	 *
-	 **************************************************************/
-
-static int TLan_Close(struct net_device *dev)
-{
-	TLanPrivateInfo *priv = dev->priv;
-
-	netif_stop_queue(dev);
-	priv->neg_be_verbose = 0;
-
-	TLan_ReadAndClearStats( dev, TLAN_RECORD );
-	outl( TLAN_HC_AD_RST, dev->base_addr + TLAN_HOST_CMD );
-	if ( priv->timer.function != NULL ) {
-		del_timer_sync( &priv->timer );
-		priv->timer.function = NULL;
+	if(eoc) {
+		head_list = priv->txList + priv->txHead;
+		if ((head_list->cStat & TLAN_CSTAT_READY) == TLAN_CSTAT_READY) {
+			outl(virt_to_le32desc(head_list), BASE + TLAN_CH_PARM);
+			ack |= TLAN_HC_GO;
+		} else {
+			priv->txInProgress = 0;
+		}
 	}
-	
-	free_irq( dev->irq, dev );
-	TLan_FreeLists( dev );
-	TLAN_DBG( TLAN_DEBUG_GNRL, "Device %s closed.\n", dev->name );
-
-	return 0;
-
-} /* TLan_Close */
-
-	/***************************************************************
-	 *	TLan_GetStats
-	 *  
-	 *	Returns:
-	 *		A pointer to the device's statistics structure.
-	 *	Parms:
-	 *		dev	The device structure to return the
-	 *			stats for.
-	 *
-	 *	This function updates the devices statistics by reading
-	 *	the TLAN chip's onboard registers.  Then it returns the
-	 *	address of the statistics structure.
-	 *
-	 **************************************************************/
-
-static struct net_device_stats *TLan_GetStats( struct net_device *dev )
-{
-	TLanPrivateInfo	*priv = dev->priv;
-	int i;
-
-	/* Should only read stats if open ? */
-	TLan_ReadAndClearStats( dev, TLAN_RECORD );
-
-	TLAN_DBG( TLAN_DEBUG_RX, "RECEIVE:  %s EOC count = %d\n", dev->name, priv->rxEocCount );
-	TLAN_DBG( TLAN_DEBUG_TX, "TRANSMIT:  %s Busy count = %d\n", dev->name, priv->txBusyCount );
-	if ( debug & TLAN_DEBUG_GNRL ) {
-		TLan_PrintDio( dev->base_addr );
-		TLan_PhyPrint( dev );		
-	}
-	if ( debug & TLAN_DEBUG_LIST ) {
-		for ( i = 0; i < TLAN_NUM_RX_LISTS; i++ )
-			TLan_PrintList( priv->rxList + i, "RX", i );
-		for ( i = 0; i < TLAN_NUM_TX_LISTS; i++ )
-			TLan_PrintList( priv->txList + i, "TX", i );
+	if(ack) {
+		host_cmd = TLAN_HC_ACK | ack;
+		outl(host_cmd, BASE + TLAN_HOST_CMD);
 	}
 	
-	return ( &( (TLanPrivateInfo *) dev->priv )->stats );
-
-} /* TLan_GetStats */
-
-	/***************************************************************
-	 *	TLan_SetMulticastList
-	 *  
-	 *	Returns:
-	 *		Nothing
-	 *	Parms:
-	 *		dev	The device structure to set the
-	 *			multicast list for.
-	 *
-	 *	This function sets the TLAN adaptor to various receive
-	 *	modes.  If the IFF_PROMISC flag is set, promiscuous
-	 *	mode is acitviated.  Otherwise,	promiscuous mode is
-	 *	turned off.  If the IFF_ALLMULTI flag is set, then
-	 *	the hash table is set to receive all group addresses.
-	 *	Otherwise, the first three multicast addresses are
-	 *	stored in AREG_1-3, and the rest are selected via the
-	 *	hash table, as necessary.
-	 *
-	 **************************************************************/
-
-static void TLan_SetMulticastList( struct net_device *dev )
-{	
-	struct dev_mc_list	*dmi = dev->mc_list;
-	u32			hash1 = 0;
-	u32			hash2 = 0;
-	int			i;
-	u32			offset;
-	u8			tmp;
-
-	if ( dev->flags & IFF_PROMISC ) {
-		tmp = TLan_DioRead8( dev->base_addr, TLAN_NET_CMD );
-		TLan_DioWrite8( dev->base_addr, TLAN_NET_CMD, tmp | TLAN_NET_CMD_CAF );
-	} else {
-		tmp = TLan_DioRead8( dev->base_addr, TLAN_NET_CMD );
-		TLan_DioWrite8( dev->base_addr, TLAN_NET_CMD, tmp & ~TLAN_NET_CMD_CAF );
-		if ( dev->flags & IFF_ALLMULTI ) {
-			for ( i = 0; i < 3; i++ ) 
-				TLan_SetMac( dev, i + 1, NULL );
-			TLan_DioWrite32( dev->base_addr, TLAN_HASH_1, 0xFFFFFFFF );
-			TLan_DioWrite32( dev->base_addr, TLAN_HASH_2, 0xFFFFFFFF );
+	if(priv->tlanRev < 0x30 ) {
+		ack = 1;
+		head_list = priv->txList + priv->txHead;
+		if ((head_list->cStat & TLAN_CSTAT_READY) == TLAN_CSTAT_READY) {
+			outl(virt_to_le32desc(head_list), BASE + TLAN_CH_PARM);
+			ack |= TLAN_HC_GO;
 		} else {
-			for ( i = 0; i < dev->mc_count; i++ ) {
-				if ( i < 3 ) {
-					TLan_SetMac( dev, i + 1, (char *) &dmi->dmi_addr );
-				} else {
-					offset = TLan_HashFunc( (u8 *) &dmi->dmi_addr );
-					if ( offset < 32 ) 
-						hash1 |= ( 1 << offset );
-					else
-						hash2 |= ( 1 << ( offset - 32 ) );
-				}
-				dmi = dmi->next;
-			}
-			for ( ; i < 3; i++ ) 
-				TLan_SetMac( dev, i + 1, NULL );
-			TLan_DioWrite32( dev->base_addr, TLAN_HASH_1, hash1 );
-			TLan_DioWrite32( dev->base_addr, TLAN_HASH_2, hash2 );
+			priv->txInProgress = 0;
 		}
+		host_cmd = TLAN_HC_ACK | ack | 0x00140000;
+		outl(host_cmd, BASE + TLAN_HOST_CMD);
+		
 	}
+			
+	if (currticks() >= to) {
+		printf("TX Time Out");
+	}
+}
 
-} /* TLan_SetMulticastList */
-
-/*****************************************************************************
-******************************************************************************
-
-        ThunderLAN Driver Interrupt Vectors and Table
-
-	Please see Chap. 4, "Interrupt Handling" of the "ThunderLAN
-	Programmer's Guide" for more informations on handling interrupts
-	generated by TLAN based adapters.  
-
-******************************************************************************
-*****************************************************************************/
-
-	/***************************************************************
-	 *	TLan_HandleInvalid
-	 *
-	 *	Returns:
-	 *		0
-	 *	Parms:
-	 *		dev		Device assigned the IRQ that was
-	 *				raised.
-	 *		host_int	The contents of the HOST_INT
-	 *				port.
-	 *
-	 *	This function handles invalid interrupts.  This should
-	 *	never happen unless some other adapter is trying to use
-	 *	the IRQ line assigned to the device.
-	 *
-	 **************************************************************/
-
-u32 TLan_HandleInvalid( struct net_device *dev, u16 host_int )
+/**************************************************************************
+DISABLE - Turn off ethernet interface
+***************************************************************************/
+#ifdef EB51
+static void tlan_disable(struct dev *dev __unused)
+#else
+static void tlan_disable(struct nic *nic __unused)
+#endif
 {
-	/* printk( "TLAN:  Invalid interrupt on %s.\n", dev->name ); */
-	return 0;
-
-} /* TLan_HandleInvalid */
-
-	/***************************************************************
-	 *	TLan_HandleTxEOF
-	 *
-	 *	Returns:
-	 *		1
-	 *	Parms:
-	 *		dev		Device assigned the IRQ that was
-	 *				raised.
-	 *		host_int	The contents of the HOST_INT
-	 *				port.
-	 *
-	 *	This function handles Tx EOF interrupts which are raised
-	 *	by the adapter when it has completed sending the
-	 *	contents of a buffer.  If detemines which list/buffer
-	 *	was completed and resets it.  If the buffer was the last
-	 *	in the channel (EOC), then the function checks to see if
-	 *	another buffer is ready to send, and if so, sends a Tx
-	 *	Go command.  Finally, the driver activates/continues the
-	 *	activity LED.
+	/* put the card in its initial state */
+	/* This function serves 3 purposes.
+	 * This disables DMA and interrupts so we don't receive
+	 *  unexpected packets or interrupts from the card after
+	 *  etherboot has finished.
+	 * This frees resources so etherboot may use
+	 *  this driver on another interface
+	 * This allows etherboot to reinitialize the interface
+	 *  if something is something goes wrong.
 	 *
-	 **************************************************************/
+	 */
+	outl(TLAN_HC_AD_RST, BASE + TLAN_HOST_CMD);
+}
 
-u32 TLan_HandleTxEOF( struct net_device *dev, u16 host_int )
+/**************************************************************************
+IRQ - Enable, Disable, or Force interrupts
+***************************************************************************/
+static void tlan_irq(struct nic *nic __unused, irq_action_t action __unused)
 {
-	TLanPrivateInfo	*priv = dev->priv;
-	int		eoc = 0;
-	TLanList	*head_list;
-	u32		ack = 0;
-	u16		tmpCStat;
-	
-	TLAN_DBG( TLAN_DEBUG_TX, "TRANSMIT:  Handling TX EOF (Head=%d Tail=%d)\n", priv->txHead, priv->txTail );
-	head_list = priv->txList + priv->txHead;
+  switch ( action ) {
+  case DISABLE :
+    break;
+  case ENABLE :
+    break;
+  case FORCE :
+    break;
+  }
+}
 
-	while (((tmpCStat = head_list->cStat ) & TLAN_CSTAT_FRM_CMP) && (ack < 255)) {
-		ack++;
-		if ( ! bbuf ) {
-			dev_kfree_skb_any( (struct sk_buff *) head_list->buffer[9].address );
-			head_list->buffer[9].address = 0;
-		}
-	
-		if ( tmpCStat & TLAN_CSTAT_EOC )
-			eoc = 1;
-			
-		priv->stats.tx_bytes += head_list->frameSize;
+static void TLan_SetMulticastList(struct nic *nic) {
+	int i;
+	u8 tmp;
 
-		head_list->cStat = TLAN_CSTAT_UNUSED;
-		netif_start_queue(dev);		
-		CIRC_INC( priv->txHead, TLAN_NUM_TX_LISTS ); 
-		head_list = priv->txList + priv->txHead;
-	}
+	/* !IFF_PROMISC */
+	tmp = TLan_DioRead8(BASE, TLAN_NET_CMD);
+	TLan_DioWrite8(BASE, TLAN_NET_CMD, tmp & ~TLAN_NET_CMD_CAF);
+
+	/* IFF_ALLMULTI */
+	for(i = 0; i< 3; i++)
+		TLan_SetMac(nic, i + 1, NULL);
+	TLan_DioWrite32(BASE, TLAN_HASH_1, 0xFFFFFFFF);
+	TLan_DioWrite32(BASE, TLAN_HASH_2, 0xFFFFFFFF);
 
-	if (!ack)
-		printk(KERN_INFO "TLAN: Received interrupt for uncompleted TX frame.\n");
-	
-	if ( eoc ) {
-		TLAN_DBG( TLAN_DEBUG_TX, "TRANSMIT:  Handling TX EOC (Head=%d Tail=%d)\n", priv->txHead, priv->txTail );
-		head_list = priv->txList + priv->txHead;
-		if ( ( head_list->cStat & TLAN_CSTAT_READY ) == TLAN_CSTAT_READY ) {
-			outl( virt_to_bus( head_list ), dev->base_addr + TLAN_CH_PARM );
-			ack |= TLAN_HC_GO;
-		} else {
-			priv->txInProgress = 0;
-		}
-	}
 	
-	if ( priv->adapter->flags & TLAN_ADAPTER_ACTIVITY_LED ) {
-		TLan_DioWrite8( dev->base_addr, TLAN_LED_REG, TLAN_LED_LINK | TLAN_LED_ACT );
-		if ( priv->timer.function == NULL ) {
-			 priv->timer.function = &TLan_Timer;
-			 priv->timer.data = (unsigned long) dev;
-			 priv->timer.expires = jiffies + TLAN_TIMER_ACT_DELAY;
-			 priv->timerSetAt = jiffies;
-			 priv->timerType = TLAN_TIMER_ACTIVITY;
-			 add_timer(&priv->timer);
-		} else if ( priv->timerType == TLAN_TIMER_ACTIVITY ) {
-			priv->timerSetAt = jiffies;
+}
+/**************************************************************************
+PROBE - Look for an adapter, this routine's visible to the outside
+***************************************************************************/
+
+#define board_found 1
+#define valid_link 0
+#ifdef EB51
+static int tlan_probe(struct dev *dev, struct pci_device *pci)
+{
+	struct nic *nic = (struct nic *) dev;
+#else
+struct nic *tlan_probe(struct nic *nic, unsigned short *io_addrs, struct pci_device *pci)
+{
+#endif
+		u16 data = 0;
+	int err;
+	int i;
+
+	if (pci->ioaddr == 0)
+		return 0;
+
+	nic->irqno  = 0;
+	nic->ioaddr = pci->ioaddr & ~3;
+
+	BASE = pci->ioaddr;
+	printf("\n");
+	printf("tlan.c: %s, %s\n", drv_version, drv_date);
+	printf("%s: Probing for Vendor 0x%hX, Device 0x%hX",
+	       pci->name, pci->vendor, pci->dev_id);
+
+
+	/* I really must find out what this does */
+	adjust_pci_device(pci);
+
+	/* Point to private storage */
+	priv = &TLanPrivateInfo;
+	/* Figure out which chip we're dealing with */
+	i = 0;
+	chip_idx = -1;
+
+	while (tlan_pci_tbl[i].name) {
+		if ((((u32) pci->dev_id << 16) | pci->vendor) ==
+		    (tlan_pci_tbl[i].id.pci & 0xffffffff)) {
+			chip_idx = i;
+			break;
 		}
+		i++;
 	}
 
-	return ack;
+	priv->vendor_id = pci->vendor;
+	priv->dev_id = pci->dev_id;
+	priv->nic_name = pci->name;
+	priv->eoc = 0;
 
-} /* TLan_HandleTxEOF */
+	err = 0;
+	for (i = 0; i < 6; i++)
+		err |= TLan_EeReadByte(BASE,
+				       (u8) tlan_pci_tbl[chip_idx].
+				       addrOfs + i,
+				       (u8 *) & nic->node_addr[i]);
+	if (err) {
+		printf("TLAN: %s: Error reading MAC from eeprom: %d\n",
+		       pci->name, err);
+	} else
+		printf("\nAddress: %!\n", nic->node_addr);
 
-	/***************************************************************
-	 *	TLan_HandleStatOverflow
-	 *
-	 *	Returns:
-	 *		1
-	 *	Parms:
-	 *		dev		Device assigned the IRQ that was
-	 *				raised.
-	 *		host_int	The contents of the HOST_INT
-	 *				port.
-	 *
-	 *	This function handles the Statistics Overflow interrupt
-	 *	which means that one or more of the TLAN statistics
-	 *	registers has reached 1/2 capacity and needs to be read.
-	 *
-	 **************************************************************/
+	priv->tlanRev = TLan_DioRead8(BASE, TLAN_DEF_REVISION);
+	printf("\nRevision = 0x%hX\n", priv->tlanRev);
 
-u32 TLan_HandleStatOverflow( struct net_device *dev, u16 host_int )
-{
-	TLan_ReadAndClearStats( dev, TLAN_RECORD );
+	TLan_ResetLists(nic);
+	TLan_ResetAdapter(nic);
+/*
+	data = inl(BASE + TLAN_HOST_CMD);
+	data |= TLAN_HC_EOC;
+	outw(data, BASE + TLAN_HOST_CMD);
+*/
+
+	data = inl(BASE + TLAN_HOST_CMD);
+	data |= TLAN_HC_INT_OFF;
+	outw(data, BASE + TLAN_HOST_CMD);
 
+	TLan_SetMulticastList(nic);
+	udelay(100); 
+	priv->txList = tx_ring;
+	priv->rxList = rx_ring;
+/*	if (board_found && valid_link)
+	{*/
+	/* point to NIC specific routines */
+#ifdef EB51
+	dev->disable = tlan_disable;
+	nic->poll = tlan_poll;
+	nic->transmit = tlan_transmit;
+	nic->irq    = tlan_irq;
 	return 1;
+#else
+	nic->disable = tlan_disable;
+	nic->poll = tlan_poll;
+	nic->transmit = tlan_transmit;
+	nic->irq    = tlan_irq;
+	return nic;
+#endif
+}
+
+
+/*****************************************************************************
+******************************************************************************
+
+	ThunderLAN Driver Eeprom routines
+
+	The Compaq Netelligent 10 and 10/100 cards use a Microchip 24C02A
+	EEPROM.  These functions are based on information in Microchip's
+	data sheet.  I don't know how well this functions will work with
+	other EEPROMs.
+
+******************************************************************************
+*****************************************************************************/
 
-} /* TLan_HandleStatOverflow */
 
 	/***************************************************************
-	 *	TLan_HandleRxEOF
+	 *	TLan_EeSendStart
 	 *
 	 *	Returns:
-	 *		1
+	 *		Nothing
 	 *	Parms:
-	 *		dev		Device assigned the IRQ that was
-	 *				raised.
-	 *		host_int	The contents of the HOST_INT
-	 *				port.
-	 *
-	 *	This function handles the Rx EOF interrupt which
-	 *	indicates a frame has been received by the adapter from
-	 *	the net and the frame has been transferred to memory.
-	 *	The function determines the bounce buffer the frame has
-	 *	been loaded into, creates a new sk_buff big enough to
-	 *	hold the frame, and sends it to protocol stack.  It
-	 *	then resets the used buffer and appends it to the end
-	 *	of the list.  If the frame was the last in the Rx
-	 *	channel (EOC), the function restarts the receive channel
-	 *	by sending an Rx Go command to the adapter.  Then it
-	 *	activates/continues the activity LED.
+	 *		io_base		The IO port base address for the
+	 *				TLAN device with the EEPROM to
+	 *				use.
+	 *
+	 *	This function sends a start cycle to an EEPROM attached
+	 *	to a TLAN chip.
 	 *
 	 **************************************************************/
 
-u32 TLan_HandleRxEOF( struct net_device *dev, u16 host_int )
+void TLan_EeSendStart(u16 io_base)
 {
-	TLanPrivateInfo	*priv = dev->priv;
-	u32		ack = 0;
-	int		eoc = 0;
-	u8		*head_buffer;
-	TLanList	*head_list;
-	struct sk_buff	*skb;
-	TLanList	*tail_list;
-	void		*t;
-	u32		frameSize;
-	u16		tmpCStat;
-
-	TLAN_DBG( TLAN_DEBUG_RX, "RECEIVE:  Handling RX EOF (Head=%d Tail=%d)\n", priv->rxHead, priv->rxTail );
-	head_list = priv->rxList + priv->rxHead;
-	
-	while (((tmpCStat = head_list->cStat) & TLAN_CSTAT_FRM_CMP) && (ack < 255)) {
-		frameSize = head_list->frameSize;
-		ack++;
-		if (tmpCStat & TLAN_CSTAT_EOC)
-			eoc = 1;
-		
-		if (bbuf) {
-			skb = dev_alloc_skb(frameSize + 7);
-			if (skb == NULL)
-				printk(KERN_INFO "TLAN: Couldn't allocate memory for received data.\n");
-			else {
-				head_buffer = priv->rxBuffer + (priv->rxHead * TLAN_MAX_FRAME_SIZE);
-				skb->dev = dev;
-				skb_reserve(skb, 2);
-				t = (void *) skb_put(skb, frameSize);
-		
-				priv->stats.rx_bytes += head_list->frameSize;
-
-				memcpy( t, head_buffer, frameSize );
-				skb->protocol = eth_type_trans( skb, dev );
-				netif_rx( skb );
-			}
-		} else {
-			struct sk_buff *new_skb;
-		
-			/*
-		 	*	I changed the algorithm here. What we now do
-		 	*	is allocate the new frame. If this fails we
-		 	*	simply recycle the frame.
-		 	*/
-		
-			new_skb = dev_alloc_skb( TLAN_MAX_FRAME_SIZE + 7 );
-			
-			if ( new_skb != NULL ) {
-				/* If this ever happened it would be a problem */
-				/* not any more - ac */
-				skb = (struct sk_buff *) head_list->buffer[9].address;
-				skb_trim( skb, frameSize );
-
-				priv->stats.rx_bytes += frameSize;
+	u16 sio;
 
-				skb->protocol = eth_type_trans( skb, dev );
-				netif_rx( skb );
-	
-				new_skb->dev = dev;
-				skb_reserve( new_skb, 2 );
-				t = (void *) skb_put( new_skb, TLAN_MAX_FRAME_SIZE );
-				head_list->buffer[0].address = virt_to_bus( t );
-				head_list->buffer[8].address = (u32) t;
-				head_list->buffer[9].address = (u32) new_skb;
-			} else 
-				printk(KERN_WARNING "TLAN:  Couldn't allocate memory for received data.\n" );
-		}
+	outw(TLAN_NET_SIO, io_base + TLAN_DIO_ADR);
+	sio = io_base + TLAN_DIO_DATA + TLAN_NET_SIO;
 
-		head_list->forward = 0;
-		head_list->cStat = 0;
-		tail_list = priv->rxList + priv->rxTail;
-		tail_list->forward = virt_to_bus( head_list );
-
-		CIRC_INC( priv->rxHead, TLAN_NUM_RX_LISTS );
-		CIRC_INC( priv->rxTail, TLAN_NUM_RX_LISTS );
-		head_list = priv->rxList + priv->rxHead;
-	}
+	TLan_SetBit(TLAN_NET_SIO_ECLOK, sio);
+	TLan_SetBit(TLAN_NET_SIO_EDATA, sio);
+	TLan_SetBit(TLAN_NET_SIO_ETXEN, sio);
+	TLan_ClearBit(TLAN_NET_SIO_EDATA, sio);
+	TLan_ClearBit(TLAN_NET_SIO_ECLOK, sio);
 
-	if (!ack)
-		printk(KERN_INFO "TLAN: Received interrupt for uncompleted RX frame.\n");
-	
+}				/* TLan_EeSendStart */
 
-	if ( eoc ) { 
-		TLAN_DBG( TLAN_DEBUG_RX, "RECEIVE:  Handling RX EOC (Head=%d Tail=%d)\n", priv->rxHead, priv->rxTail );
-		head_list = priv->rxList + priv->rxHead;
-		outl( virt_to_bus( head_list ), dev->base_addr + TLAN_CH_PARM );
-		ack |= TLAN_HC_GO | TLAN_HC_RT;
-		priv->rxEocCount++;
-	}
-
-	if ( priv->adapter->flags & TLAN_ADAPTER_ACTIVITY_LED ) {
-		TLan_DioWrite8( dev->base_addr, TLAN_LED_REG, TLAN_LED_LINK | TLAN_LED_ACT );
-		if ( priv->timer.function == NULL )  {
-			priv->timer.function = &TLan_Timer;
-			priv->timer.data = (unsigned long) dev;
-			priv->timer.expires = jiffies + TLAN_TIMER_ACT_DELAY;
-			priv->timerSetAt = jiffies;
-			priv->timerType = TLAN_TIMER_ACTIVITY;
-			add_timer(&priv->timer);
-		} else if ( priv->timerType == TLAN_TIMER_ACTIVITY ) {
-			priv->timerSetAt = jiffies;
-		}
-	}
 
-	dev->last_rx = jiffies;
-	
-	return ack;
 
-} /* TLan_HandleRxEOF */
 
 	/***************************************************************
-	 *	TLan_HandleDummy
+	 *	TLan_EeSendByte
 	 *
 	 *	Returns:
-	 *		1
-	 *	Parms:
-	 *		dev		Device assigned the IRQ that was
-	 *				raised.
-	 *		host_int	The contents of the HOST_INT
-	 *				port.
-	 *
-	 *	This function handles the Dummy interrupt, which is
-	 *	raised whenever a test interrupt is generated by setting
-	 *	the Req_Int bit of HOST_CMD to 1.
+	 *		If the correct ack was received, 0, otherwise 1
+	 *	Parms:	io_base		The IO port base address for the
+	 *				TLAN device with the EEPROM to
+	 *				use.
+	 *		data		The 8 bits of information to
+	 *				send to the EEPROM.
+	 *		stop		If TLAN_EEPROM_STOP is passed, a
+	 *				stop cycle is sent after the
+	 *				byte is sent after the ack is
+	 *				read.
+	 *
+	 *	This function sends a byte on the serial EEPROM line,
+	 *	driving the clock to send each bit. The function then
+	 *	reverses transmission direction and reads an acknowledge
+	 *	bit.
 	 *
 	 **************************************************************/
 
-u32 TLan_HandleDummy( struct net_device *dev, u16 host_int )
+int TLan_EeSendByte(u16 io_base, u8 data, int stop)
 {
-	printk( "TLAN:  Test interrupt on %s.\n", dev->name );
-	return 1;
+	int err;
+	u8 place;
+	u16 sio;
 
-} /* TLan_HandleDummy */
+	outw(TLAN_NET_SIO, io_base + TLAN_DIO_ADR);
+	sio = io_base + TLAN_DIO_DATA + TLAN_NET_SIO;
 
-	/***************************************************************
-	 *	TLan_HandleTxEOC
-	 *
-	 *	Returns:
-	 *		1
-	 *	Parms:
-	 *		dev		Device assigned the IRQ that was
-	 *				raised.
-	 *		host_int	The contents of the HOST_INT
-	 *				port.
-	 *
-	 *	This driver is structured to determine EOC occurances by
-	 *	reading the CSTAT member of the list structure.  Tx EOC
-	 *	interrupts are disabled via the DIO INTDIS register.
-	 *	However, TLAN chips before revision 3.0 didn't have this
-	 *	functionality, so process EOC events if this is the
-	 *	case.
-	 *
-	 **************************************************************/
+	/* Assume clock is low, tx is enabled; */
+	for (place = 0x80; place != 0; place >>= 1) {
+		if (place & data)
+			TLan_SetBit(TLAN_NET_SIO_EDATA, sio);
+		else
+			TLan_ClearBit(TLAN_NET_SIO_EDATA, sio);
+		TLan_SetBit(TLAN_NET_SIO_ECLOK, sio);
+		TLan_ClearBit(TLAN_NET_SIO_ECLOK, sio);
+	}
+	TLan_ClearBit(TLAN_NET_SIO_ETXEN, sio);
+	TLan_SetBit(TLAN_NET_SIO_ECLOK, sio);
+	err = TLan_GetBit(TLAN_NET_SIO_EDATA, sio);
+	TLan_ClearBit(TLAN_NET_SIO_ECLOK, sio);
+	TLan_SetBit(TLAN_NET_SIO_ETXEN, sio);
 
-u32 TLan_HandleTxEOC( struct net_device *dev, u16 host_int )
-{
-	TLanPrivateInfo	*priv = dev->priv;
-	TLanList		*head_list;
-	u32			ack = 1;
-	
-	host_int = 0;
-	if ( priv->tlanRev < 0x30 ) {
-		TLAN_DBG( TLAN_DEBUG_TX, "TRANSMIT:  Handling TX EOC (Head=%d Tail=%d) -- IRQ\n", priv->txHead, priv->txTail );
-		head_list = priv->txList + priv->txHead;
-		if ( ( head_list->cStat & TLAN_CSTAT_READY ) == TLAN_CSTAT_READY ) {
-			netif_stop_queue(dev);
-			outl( virt_to_bus( head_list ), dev->base_addr + TLAN_CH_PARM );
-			ack |= TLAN_HC_GO;
-		} else {
-			priv->txInProgress = 0;
-		}
+	if ((!err) && stop) {
+		TLan_ClearBit(TLAN_NET_SIO_EDATA, sio);	/* STOP, raise data while clock is high */
+		TLan_SetBit(TLAN_NET_SIO_ECLOK, sio);
+		TLan_SetBit(TLAN_NET_SIO_EDATA, sio);
 	}
 
-	return ack;
+	return (err);
+
+}				/* TLan_EeSendByte */
+
+
 
-} /* TLan_HandleTxEOC */
 
 	/***************************************************************
-	 *	TLan_HandleStatusCheck
+	 *	TLan_EeReceiveByte
 	 *
 	 *	Returns:
-	 *		0 if Adapter check, 1 if Network Status check.
+	 *		Nothing
 	 *	Parms:
-	 *		dev		Device assigned the IRQ that was
-	 *				raised.
-	 *		host_int	The contents of the HOST_INT
-	 *				port.
-	 *
-	 *	This function handles Adapter Check/Network Status
-	 *	interrupts generated by the adapter.  It checks the
-	 *	vector in the HOST_INT register to determine if it is
-	 *	an Adapter Check interrupt.  If so, it resets the
-	 *	adapter.  Otherwise it clears the status registers
-	 *	and services the PHY.
+	 *		io_base		The IO port base address for the
+	 *				TLAN device with the EEPROM to
+	 *				use.
+	 *		data		An address to a char to hold the
+	 *				data sent from the EEPROM.
+	 *		stop		If TLAN_EEPROM_STOP is passed, a
+	 *				stop cycle is sent after the
+	 *				byte is received, and no ack is
+	 *				sent.
+	 *
+	 *	This function receives 8 bits of data from the EEPROM
+	 *	over the serial link.  It then sends and ack bit, or no
+	 *	ack and a stop bit.  This function is used to retrieve
+	 *	data after the address of a byte in the EEPROM has been
+	 *	sent.
 	 *
 	 **************************************************************/
 
-u32 TLan_HandleStatusCheck( struct net_device *dev, u16 host_int )
-{	
-	TLanPrivateInfo	*priv = dev->priv;
-	u32		ack;
-	u32		error;
-	u8		net_sts;
-	u32		phy;
-	u16		tlphy_ctl;
-	u16		tlphy_sts;
-	
-	ack = 1;
-	if ( host_int & TLAN_HI_IV_MASK ) {
-		netif_stop_queue( dev );
-		error = inl( dev->base_addr + TLAN_CH_PARM );
-		printk( "TLAN:  %s: Adaptor Error = 0x%x\n", dev->name, error );
-		TLan_ReadAndClearStats( dev, TLAN_RECORD );
-		outl( TLAN_HC_AD_RST, dev->base_addr + TLAN_HOST_CMD );
-		
-		queue_task(&priv->tlan_tqueue, &tq_immediate);
-		mark_bh(IMMEDIATE_BH);
-		
-		netif_wake_queue(dev);
-		ack = 0;
-	} else {
-		TLAN_DBG( TLAN_DEBUG_GNRL, "%s: Status Check\n", dev->name );
-		phy = priv->phy[priv->phyNum];
+void TLan_EeReceiveByte(u16 io_base, u8 * data, int stop)
+{
+	u8 place;
+	u16 sio;
 
-		net_sts = TLan_DioRead8( dev->base_addr, TLAN_NET_STS );
-		if ( net_sts ) {
-			TLan_DioWrite8( dev->base_addr, TLAN_NET_STS, net_sts );
-			TLAN_DBG( TLAN_DEBUG_GNRL, "%s:    Net_Sts = %x\n", dev->name, (unsigned) net_sts );
-		}
-		if ( ( net_sts & TLAN_NET_STS_MIRQ ) &&  ( priv->phyNum == 0 ) ) {
-			TLan_MiiReadReg( dev, phy, TLAN_TLPHY_STS, &tlphy_sts );
-			TLan_MiiReadReg( dev, phy, TLAN_TLPHY_CTL, &tlphy_ctl );
-        		if ( ! ( tlphy_sts & TLAN_TS_POLOK ) && ! ( tlphy_ctl & TLAN_TC_SWAPOL ) ) {
-                		tlphy_ctl |= TLAN_TC_SWAPOL;
-                		TLan_MiiWriteReg( dev, phy, TLAN_TLPHY_CTL, tlphy_ctl);
-        		} else if ( ( tlphy_sts & TLAN_TS_POLOK ) && ( tlphy_ctl & TLAN_TC_SWAPOL ) ) {
-                		tlphy_ctl &= ~TLAN_TC_SWAPOL;
-                		TLan_MiiWriteReg( dev, phy, TLAN_TLPHY_CTL, tlphy_ctl);
-        		}
+	outw(TLAN_NET_SIO, io_base + TLAN_DIO_ADR);
+	sio = io_base + TLAN_DIO_DATA + TLAN_NET_SIO;
+	*data = 0;
 
-			if (debug) {
-				TLan_PhyPrint( dev );		
-			}
-		}
+	/* Assume clock is low, tx is enabled; */
+	TLan_ClearBit(TLAN_NET_SIO_ETXEN, sio);
+	for (place = 0x80; place; place >>= 1) {
+		TLan_SetBit(TLAN_NET_SIO_ECLOK, sio);
+		if (TLan_GetBit(TLAN_NET_SIO_EDATA, sio))
+			*data |= place;
+		TLan_ClearBit(TLAN_NET_SIO_ECLOK, sio);
+	}
+
+	TLan_SetBit(TLAN_NET_SIO_ETXEN, sio);
+	if (!stop) {
+		TLan_ClearBit(TLAN_NET_SIO_EDATA, sio);	/* Ack = 0 */
+		TLan_SetBit(TLAN_NET_SIO_ECLOK, sio);
+		TLan_ClearBit(TLAN_NET_SIO_ECLOK, sio);
+	} else {
+		TLan_SetBit(TLAN_NET_SIO_EDATA, sio);	/* No ack = 1 (?) */
+		TLan_SetBit(TLAN_NET_SIO_ECLOK, sio);
+		TLan_ClearBit(TLAN_NET_SIO_ECLOK, sio);
+		TLan_ClearBit(TLAN_NET_SIO_EDATA, sio);	/* STOP, raise data while clock is high */
+		TLan_SetBit(TLAN_NET_SIO_ECLOK, sio);
+		TLan_SetBit(TLAN_NET_SIO_EDATA, sio);
 	}
 
-	return ack;
+}				/* TLan_EeReceiveByte */
+
 
-} /* TLan_HandleStatusCheck */
 
 	/***************************************************************
-	 *	TLan_HandleRxEOC
+	 *	TLan_EeReadByte
 	 *
 	 *	Returns:
-	 *		1
+	 *		No error = 0, else, the stage at which the error
+	 *		occurred.
 	 *	Parms:
-	 *		dev		Device assigned the IRQ that was
-	 *				raised.
-	 *		host_int	The contents of the HOST_INT
-	 *				port.
-	 *
-	 *	This driver is structured to determine EOC occurances by
-	 *	reading the CSTAT member of the list structure.  Rx EOC
-	 *	interrupts are disabled via the DIO INTDIS register.
-	 *	However, TLAN chips before revision 3.0 didn't have this
-	 *	CSTAT member or a INTDIS register, so if this chip is
-	 *	pre-3.0, process EOC interrupts normally.
+	 *		io_base		The IO port base address for the
+	 *				TLAN device with the EEPROM to
+	 *				use.
+	 *		ee_addr		The address of the byte in the
+	 *				EEPROM whose contents are to be
+	 *				retrieved.
+	 *		data		An address to a char to hold the
+	 *				data obtained from the EEPROM.
+	 *
+	 *	This function reads a byte of information from an byte
+	 *	cell in the EEPROM.
 	 *
 	 **************************************************************/
 
-u32 TLan_HandleRxEOC( struct net_device *dev, u16 host_int )
+int TLan_EeReadByte(u16 io_base, u8 ee_addr, u8 * data)
 {
-	TLanPrivateInfo	*priv = dev->priv;
-	TLanList	*head_list;
-	u32		ack = 1;
+	int err;
+	int ret = 0;
 
-	if (  priv->tlanRev < 0x30 ) {
-		TLAN_DBG( TLAN_DEBUG_RX, "RECEIVE:  Handling RX EOC (Head=%d Tail=%d) -- IRQ\n", priv->rxHead, priv->rxTail );
-		head_list = priv->rxList + priv->rxHead;
-		outl( virt_to_bus( head_list ), dev->base_addr + TLAN_CH_PARM );
-		ack |= TLAN_HC_GO | TLAN_HC_RT;
-		priv->rxEocCount++;
+
+	TLan_EeSendStart(io_base);
+	err = TLan_EeSendByte(io_base, 0xA0, TLAN_EEPROM_ACK);
+	if (err) {
+		ret = 1;
+		goto fail;
+	}
+	err = TLan_EeSendByte(io_base, ee_addr, TLAN_EEPROM_ACK);
+	if (err) {
+		ret = 2;
+		goto fail;
+	}
+	TLan_EeSendStart(io_base);
+	err = TLan_EeSendByte(io_base, 0xA1, TLAN_EEPROM_ACK);
+	if (err) {
+		ret = 3;
+		goto fail;
 	}
+	TLan_EeReceiveByte(io_base, data, TLAN_EEPROM_STOP);
+      fail:
 
-	return ack;
+	return ret;
+
+}				/* TLan_EeReadByte */
 
-} /* TLan_HandleRxEOC */
 
 /*****************************************************************************
 ******************************************************************************
 
-	ThunderLAN Driver Timer Function
+	ThunderLAN Driver MII Routines
+
+	These routines are based on the information in Chap. 2 of the
+	"ThunderLAN Programmer's Guide", pp. 15-24.
 
 ******************************************************************************
 *****************************************************************************/
 
+
 	/***************************************************************
-	 *	TLan_Timer
+	 *	TLan_MiiReadReg
 	 *
 	 *	Returns:
-	 *		Nothing
+	 *		0	if ack received ok
+	 *		1	otherwise.
+	 *
 	 *	Parms:
-	 *		data	A value given to add timer when
-	 *			add_timer was called.
+	 *		dev		The device structure containing
+	 *				The io address and interrupt count
+	 *				for this device.
+	 *		phy		The address of the PHY to be queried.
+	 *		reg		The register whose contents are to be
+	 *				retreived.
+	 *		val		A pointer to a variable to store the
+	 *				retrieved value.
 	 *
-	 *	This function handles timed functionality for the
-	 *	TLAN driver.  The two current timer uses are for
-	 *	delaying for autonegotionation and driving the ACT LED.
-	 *	-	Autonegotiation requires being allowed about
-	 *		2 1/2 seconds before attempting to transmit a
-	 *		packet.  It would be a very bad thing to hang
-	 *		the kernel this long, so the driver doesn't
-	 *		allow transmission 'til after this time, for
-	 *		certain PHYs.  It would be much nicer if all
-	 *		PHYs were interrupt-capable like the internal
-	 *		PHY.
-	 *	-	The ACT LED, which shows adapter activity, is
-	 *		driven by the driver, and so must be left on
-	 *		for a short period to power up the LED so it
-	 *		can be seen.  This delay can be changed by
-	 *		changing the TLAN_TIMER_ACT_DELAY in tlan.h,
-	 *		if desired.  100 ms  produces a slightly
-	 *		sluggish response.
+	 *	This function uses the TLAN's MII bus to retreive the contents
+	 *	of a given register on a PHY.  It sends the appropriate info
+	 *	and then reads the 16-bit register value from the MII bus via
+	 *	the TLAN SIO register.
 	 *
 	 **************************************************************/
 
-void TLan_Timer( unsigned long data )
+int TLan_MiiReadReg(struct nic *nic __unused, u16 phy, u16 reg, u16 * val)
 {
-	struct net_device	*dev = (struct net_device *) data;
-	TLanPrivateInfo	*priv = dev->priv;
-	u32		elapsed;
-	unsigned long	flags = 0;
-
-	priv->timer.function = NULL;
-
-	switch ( priv->timerType ) {
-#ifdef MONITOR		
-		case TLAN_TIMER_LINK_BEAT:
-			TLan_PhyMonitor( dev );
-			break;
-#endif
-		case TLAN_TIMER_PHY_PDOWN:
-			TLan_PhyPowerDown( dev );
-			break;
-		case TLAN_TIMER_PHY_PUP:
-			TLan_PhyPowerUp( dev );
-			break;
-		case TLAN_TIMER_PHY_RESET:
-			TLan_PhyReset( dev );
-			break;
-		case TLAN_TIMER_PHY_START_LINK:
-			TLan_PhyStartLink( dev );
-			break;
-		case TLAN_TIMER_PHY_FINISH_AN:
-			TLan_PhyFinishAutoNeg( dev );
-			break;
-		case TLAN_TIMER_FINISH_RESET:
-			TLan_FinishReset( dev );
-			break;
-		case TLAN_TIMER_ACTIVITY:
-			spin_lock_irqsave(&priv->lock, flags);
-			if ( priv->timer.function == NULL ) {
-				elapsed = jiffies - priv->timerSetAt;
-				if ( elapsed >= TLAN_TIMER_ACT_DELAY ) {
-					TLan_DioWrite8( dev->base_addr, TLAN_LED_REG, TLAN_LED_LINK );
-				} else  {
-					priv->timer.function = &TLan_Timer;
-					priv->timer.expires = priv->timerSetAt + TLAN_TIMER_ACT_DELAY;
-					spin_unlock_irqrestore(&priv->lock, flags);
-					add_timer( &priv->timer );
-					break;
-				}
-			}
-			spin_unlock_irqrestore(&priv->lock, flags);
-			break;
-		default:
-			break;
+	u8 nack;
+	u16 sio, tmp;
+	u32 i;
+	int err;
+	int minten;
+
+	err = FALSE;
+	outw(TLAN_NET_SIO, BASE + TLAN_DIO_ADR);
+	sio = BASE + TLAN_DIO_DATA + TLAN_NET_SIO;
+
+	TLan_MiiSync(BASE);
+
+	minten = TLan_GetBit(TLAN_NET_SIO_MINTEN, sio);
+	if (minten)
+		TLan_ClearBit(TLAN_NET_SIO_MINTEN, sio);
+
+	TLan_MiiSendData(BASE, 0x1, 2);	/* Start ( 01b ) */
+	TLan_MiiSendData(BASE, 0x2, 2);	/* Read  ( 10b ) */
+	TLan_MiiSendData(BASE, phy, 5);	/* Device #      */
+	TLan_MiiSendData(BASE, reg, 5);	/* Register #    */
+
+
+	TLan_ClearBit(TLAN_NET_SIO_MTXEN, sio);	/* Change direction */
+
+	TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);	/* Clock Idle bit */
+	TLan_SetBit(TLAN_NET_SIO_MCLK, sio);
+	TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);	/* Wait 300ns */
+
+	nack = TLan_GetBit(TLAN_NET_SIO_MDATA, sio);	/* Check for ACK */
+	TLan_SetBit(TLAN_NET_SIO_MCLK, sio);	/* Finish ACK */
+	if (nack) {		/* No ACK, so fake it */
+		for (i = 0; i < 16; i++) {
+			TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);
+			TLan_SetBit(TLAN_NET_SIO_MCLK, sio);
+		}
+		tmp = 0xffff;
+		err = TRUE;
+	} else {		/* ACK, so read data */
+		for (tmp = 0, i = 0x8000; i; i >>= 1) {
+			TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);
+			if (TLan_GetBit(TLAN_NET_SIO_MDATA, sio))
+				tmp |= i;
+			TLan_SetBit(TLAN_NET_SIO_MCLK, sio);
+		}
 	}
 
-} /* TLan_Timer */
 
-/*****************************************************************************
-******************************************************************************
+	TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);	/* Idle cycle */
+	TLan_SetBit(TLAN_NET_SIO_MCLK, sio);
 
-	ThunderLAN Driver Adapter Related Routines
+	if (minten)
+		TLan_SetBit(TLAN_NET_SIO_MINTEN, sio);
 
-******************************************************************************
-*****************************************************************************/
+	*val = tmp;
+
+	return err;
+
+}				/* TLan_MiiReadReg */
 
 	/***************************************************************
-	 *	TLan_ResetLists
-	 *  
+	 *	TLan_MiiSendData
+	 *
 	 *	Returns:
 	 *		Nothing
 	 *	Parms:
-	 *		dev	The device structure with the list
-	 *			stuctures to be reset.
+	 *		base_port	The base IO port of the adapter	in
+	 *				question.
+	 *		dev		The address of the PHY to be queried.
+	 *		data		The value to be placed on the MII bus.
+	 *		num_bits	The number of bits in data that are to
+	 *				be placed on the MII bus.
 	 *
-	 *	This routine sets the variables associated with managing
-	 *	the TLAN lists to their initial values.
+	 *	This function sends on sequence of bits on the MII
+	 *	configuration bus.
 	 *
 	 **************************************************************/
 
-void TLan_ResetLists( struct net_device *dev )
+void TLan_MiiSendData(u16 base_port, u32 data, unsigned num_bits)
 {
-	TLanPrivateInfo *priv = dev->priv;
-	int		i;
-	TLanList	*list;
-	struct sk_buff	*skb;
-	void		*t = NULL;
+	u16 sio;
+	u32 i;
 
-	priv->txHead = 0;
-	priv->txTail = 0;
-	for ( i = 0; i < TLAN_NUM_TX_LISTS; i++ ) {
-		list = priv->txList + i;
-		list->cStat = TLAN_CSTAT_UNUSED;
-		if ( bbuf ) {
-			list->buffer[0].address = virt_to_bus( priv->txBuffer + ( i * TLAN_MAX_FRAME_SIZE ) );
-		} else {
-			list->buffer[0].address = 0;
-		}
-		list->buffer[2].count = 0;
-		list->buffer[2].address = 0;
-		list->buffer[9].address = 0;
-	}
+	if (num_bits == 0)
+		return;
+
+	outw(TLAN_NET_SIO, base_port + TLAN_DIO_ADR);
+	sio = base_port + TLAN_DIO_DATA + TLAN_NET_SIO;
+	TLan_SetBit(TLAN_NET_SIO_MTXEN, sio);
 
-	priv->rxHead = 0;
-	priv->rxTail = TLAN_NUM_RX_LISTS - 1;
-	for ( i = 0; i < TLAN_NUM_RX_LISTS; i++ ) {
-		list = priv->rxList + i;
-		list->cStat = TLAN_CSTAT_READY;
-		list->frameSize = TLAN_MAX_FRAME_SIZE;
-		list->buffer[0].count = TLAN_MAX_FRAME_SIZE | TLAN_LAST_BUFFER;
-		if ( bbuf ) {
-			list->buffer[0].address = virt_to_bus( priv->rxBuffer + ( i * TLAN_MAX_FRAME_SIZE ) );
-		} else {
-			skb = dev_alloc_skb( TLAN_MAX_FRAME_SIZE + 7 );
-			if ( skb == NULL ) {
-				printk( "TLAN:  Couldn't allocate memory for received data.\n" );
-				/* If this ever happened it would be a problem */
-			} else {
-				skb->dev = dev;
-				skb_reserve( skb, 2 );
-				t = (void *) skb_put( skb, TLAN_MAX_FRAME_SIZE );
-			}
-			list->buffer[0].address = virt_to_bus( t );
-			list->buffer[8].address = (u32) t;
-			list->buffer[9].address = (u32) skb;
-		}
-		list->buffer[1].count = 0;
-		list->buffer[1].address = 0;
-		if ( i < TLAN_NUM_RX_LISTS - 1 )
-			list->forward = virt_to_bus( list + 1 );
+	for (i = (0x1 << (num_bits - 1)); i; i >>= 1) {
+		TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);
+		(void) TLan_GetBit(TLAN_NET_SIO_MCLK, sio);
+		if (data & i)
+			TLan_SetBit(TLAN_NET_SIO_MDATA, sio);
 		else
-			list->forward = 0;
+			TLan_ClearBit(TLAN_NET_SIO_MDATA, sio);
+		TLan_SetBit(TLAN_NET_SIO_MCLK, sio);
+		(void) TLan_GetBit(TLAN_NET_SIO_MCLK, sio);
 	}
 
-} /* TLan_ResetLists */
+}				/* TLan_MiiSendData */
 
-void TLan_FreeLists( struct net_device *dev )
-{
-	TLanPrivateInfo *priv = dev->priv;
-	int		i;
-	TLanList	*list;
-	struct sk_buff	*skb;
-
-	if ( ! bbuf ) {
-		for ( i = 0; i < TLAN_NUM_TX_LISTS; i++ ) {
-			list = priv->txList + i;
-			skb = (struct sk_buff *) list->buffer[9].address;
-			if ( skb ) {
-				dev_kfree_skb_any( skb );
-				list->buffer[9].address = 0;
-			}
-		}
 
-		for ( i = 0; i < TLAN_NUM_RX_LISTS; i++ ) {
-			list = priv->rxList + i;
-			skb = (struct sk_buff *) list->buffer[9].address;
-			if ( skb ) {
-				dev_kfree_skb_any( skb );
-				list->buffer[9].address = 0;
-			}
-		}
-	}
 
-} /* TLan_FreeLists */
 
 	/***************************************************************
-	 *	TLan_PrintDio
-	 *  
+	 *	TLan_MiiSync
+	 *
 	 *	Returns:
 	 *		Nothing
 	 *	Parms:
-	 *		io_base		Base IO port of the device of
-	 *				which to print DIO registers.
+	 *		base_port	The base IO port of the adapter in
+	 *				question.
 	 *
-	 *	This function prints out all the internal (DIO)
-	 *	registers of a TLAN chip.
+	 *	This functions syncs all PHYs in terms of the MII configuration
+	 *	bus.
 	 *
 	 **************************************************************/
 
-void TLan_PrintDio( u16 io_base )
+void TLan_MiiSync(u16 base_port)
 {
-	u32 data0, data1;
-	int	i;
+	int i;
+	u16 sio;
 
-	printk( "TLAN:   Contents of internal registers for io base 0x%04hx.\n", io_base );
-	printk( "TLAN:      Off.  +0         +4\n" );
-	for ( i = 0; i < 0x4C; i+= 8 ) {
-		data0 = TLan_DioRead32( io_base, i );
-		data1 = TLan_DioRead32( io_base, i + 0x4 );
-		printk( "TLAN:      0x%02x  0x%08x 0x%08x\n", i, data0, data1 );
+	outw(TLAN_NET_SIO, base_port + TLAN_DIO_ADR);
+	sio = base_port + TLAN_DIO_DATA + TLAN_NET_SIO;
+
+	TLan_ClearBit(TLAN_NET_SIO_MTXEN, sio);
+	for (i = 0; i < 32; i++) {
+		TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);
+		TLan_SetBit(TLAN_NET_SIO_MCLK, sio);
 	}
 
-} /* TLan_PrintDio */
+}				/* TLan_MiiSync */
+
+
+
 
 	/***************************************************************
-	 *	TLan_PrintList
-	 *  
+	 *	TLan_MiiWriteReg
+	 *
 	 *	Returns:
 	 *		Nothing
 	 *	Parms:
-	 *		list	A pointer to the TLanList structure to
-	 *			be printed.
-	 *		type	A string to designate type of list,
-	 *			"Rx" or "Tx".
-	 *		num	The index of the list.
+	 *		dev		The device structure for the device
+	 *				to write to.
+	 *		phy		The address of the PHY to be written to.
+	 *		reg		The register whose contents are to be
+	 *				written.
+	 *		val		The value to be written to the register.
 	 *
-	 *	This function prints out the contents of the list
-	 *	pointed to by the list parameter.
+	 *	This function uses the TLAN's MII bus to write the contents of a
+	 *	given register on a PHY.  It sends the appropriate info and then
+	 *	writes the 16-bit register value from the MII configuration bus
+	 *	via the TLAN SIO register.
 	 *
 	 **************************************************************/
 
-void TLan_PrintList( TLanList *list, char *type, int num)
+void TLan_MiiWriteReg(struct nic *nic __unused, u16 phy, u16 reg, u16 val)
 {
-	int i;
+	u16 sio;
+	int minten;
+
+	outw(TLAN_NET_SIO, BASE + TLAN_DIO_ADR);
+	sio = BASE + TLAN_DIO_DATA + TLAN_NET_SIO;
+
+	TLan_MiiSync(BASE);
+
+	minten = TLan_GetBit(TLAN_NET_SIO_MINTEN, sio);
+	if (minten)
+		TLan_ClearBit(TLAN_NET_SIO_MINTEN, sio);
+
+	TLan_MiiSendData(BASE, 0x1, 2);	/* Start ( 01b ) */
+	TLan_MiiSendData(BASE, 0x1, 2);	/* Write ( 01b ) */
+	TLan_MiiSendData(BASE, phy, 5);	/* Device #      */
+	TLan_MiiSendData(BASE, reg, 5);	/* Register #    */
+
+	TLan_MiiSendData(BASE, 0x2, 2);	/* Send ACK */
+	TLan_MiiSendData(BASE, val, 16);	/* Send Data */
+
+	TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);	/* Idle cycle */
+	TLan_SetBit(TLAN_NET_SIO_MCLK, sio);
+
+	if (minten)
+		TLan_SetBit(TLAN_NET_SIO_MINTEN, sio);
 
-	printk( "TLAN:   %s List %d at 0x%08x\n", type, num, (u32) list );
-	printk( "TLAN:      Forward    = 0x%08x\n",  list->forward );
-	printk( "TLAN:      CSTAT      = 0x%04hx\n", list->cStat );
-	printk( "TLAN:      Frame Size = 0x%04hx\n", list->frameSize );
-	/* for ( i = 0; i < 10; i++ ) { */
-	for ( i = 0; i < 2; i++ ) {
-		printk( "TLAN:      Buffer[%d].count, addr = 0x%08x, 0x%08x\n", i, list->buffer[i].count, list->buffer[i].address );
-	}
 
-} /* TLan_PrintList */
+}				/* TLan_MiiWriteReg */
 
 	/***************************************************************
-	 *	TLan_ReadAndClearStats
+	 *	TLan_SetMac
 	 *
 	 *	Returns:
 	 *		Nothing
 	 *	Parms:
 	 *		dev	Pointer to device structure of adapter
-	 *			to which to read stats.
-	 *		record	Flag indicating whether to add 
+	 *			on which to change the AREG.
+	 *		areg	The AREG to set the address in (0 - 3).
+	 *		mac	A pointer to an array of chars.  Each
+	 *			element stores one byte of the address.
+	 *			IE, it isn't in ascii.
 	 *
-	 *	This functions reads all the internal status registers
-	 *	of the TLAN chip, which clears them as a side effect.
-	 *	It then either adds the values to the device's status
-	 *	struct, or discards them, depending on whether record
-	 *	is TLAN_RECORD (!=0)  or TLAN_IGNORE (==0).
+	 *	This function transfers a MAC address to one of the
+	 *	TLAN AREGs (address registers).  The TLAN chip locks
+	 *	the register on writing to offset 0 and unlocks the
+	 *	register after writing to offset 5.  If NULL is passed
+	 *	in mac, then the AREG is filled with 0's.
 	 *
 	 **************************************************************/
 
-void TLan_ReadAndClearStats( struct net_device *dev, int record )
+void TLan_SetMac(struct nic *nic __unused, int areg, char *mac)
 {
-	TLanPrivateInfo	*priv = dev->priv;
-	u32		tx_good, tx_under;
-	u32		rx_good, rx_over;
-	u32		def_tx, crc, code;
-	u32		multi_col, single_col;
-	u32		excess_col, late_col, loss;
-
-	outw( TLAN_GOOD_TX_FRMS, dev->base_addr + TLAN_DIO_ADR );
-	tx_good  = inb( dev->base_addr + TLAN_DIO_DATA );
-	tx_good += inb( dev->base_addr + TLAN_DIO_DATA + 1 ) << 8;
-	tx_good += inb( dev->base_addr + TLAN_DIO_DATA + 2 ) << 16;
-	tx_under = inb( dev->base_addr + TLAN_DIO_DATA + 3 );
-
-	outw( TLAN_GOOD_RX_FRMS, dev->base_addr + TLAN_DIO_ADR );
-	rx_good  = inb( dev->base_addr + TLAN_DIO_DATA );
-	rx_good += inb( dev->base_addr + TLAN_DIO_DATA + 1 ) << 8;
-	rx_good += inb( dev->base_addr + TLAN_DIO_DATA + 2 ) << 16;
-	rx_over  = inb( dev->base_addr + TLAN_DIO_DATA + 3 );
-		
-	outw( TLAN_DEFERRED_TX, dev->base_addr + TLAN_DIO_ADR );
-	def_tx  = inb( dev->base_addr + TLAN_DIO_DATA );
-	def_tx += inb( dev->base_addr + TLAN_DIO_DATA + 1 ) << 8;
-	crc     = inb( dev->base_addr + TLAN_DIO_DATA + 2 );
-	code    = inb( dev->base_addr + TLAN_DIO_DATA + 3 );
-	
-	outw( TLAN_MULTICOL_FRMS, dev->base_addr + TLAN_DIO_ADR );
-	multi_col   = inb( dev->base_addr + TLAN_DIO_DATA );
-	multi_col  += inb( dev->base_addr + TLAN_DIO_DATA + 1 ) << 8;
-	single_col  = inb( dev->base_addr + TLAN_DIO_DATA + 2 );
-	single_col += inb( dev->base_addr + TLAN_DIO_DATA + 3 ) << 8;
-
-	outw( TLAN_EXCESSCOL_FRMS, dev->base_addr + TLAN_DIO_ADR );
-	excess_col = inb( dev->base_addr + TLAN_DIO_DATA );
-	late_col   = inb( dev->base_addr + TLAN_DIO_DATA + 1 );
-	loss       = inb( dev->base_addr + TLAN_DIO_DATA + 2 );
-
-	if ( record ) {
-		priv->stats.rx_packets += rx_good;
-		priv->stats.rx_errors  += rx_over + crc + code;
-		priv->stats.tx_packets += tx_good;
-		priv->stats.tx_errors  += tx_under + loss;
-		priv->stats.collisions += multi_col + single_col + excess_col + late_col;
-
-		priv->stats.rx_over_errors    += rx_over;
-		priv->stats.rx_crc_errors     += crc;
-		priv->stats.rx_frame_errors   += code;
+	int i;
 
-		priv->stats.tx_aborted_errors += tx_under;
-		priv->stats.tx_carrier_errors += loss;
+	areg *= 6;
+
+	if (mac != NULL) {
+		for (i = 0; i < 6; i++)
+			TLan_DioWrite8(BASE, TLAN_AREG_0 + areg + i,
+				       mac[i]);
+	} else {
+		for (i = 0; i < 6; i++)
+			TLan_DioWrite8(BASE, TLAN_AREG_0 + areg + i, 0);
 	}
-			
-} /* TLan_ReadAndClearStats */
 
-	/***************************************************************
-	 *	TLan_Reset
+}				/* TLan_SetMac */
+
+	/*********************************************************************
+	 *	TLan_PhyDetect
 	 *
 	 *	Returns:
-	 *		0
+	 *		Nothing
 	 *	Parms:
-	 *		dev	Pointer to device structure of adapter
-	 *			to be reset.
+	 *		dev	A pointer to the device structure of the adapter
+	 *			for which the PHY needs determined.
 	 *
-	 *	This function resets the adapter and it's physical
-	 *	device.  See Chap. 3, pp. 9-10 of the "ThunderLAN
-	 *	Programmer's Guide" for details.  The routine tries to
-	 *	implement what is detailed there, though adjustments
-	 *	have been made.
+	 *	So far I've found that adapters which have external PHYs
+	 *	may also use the internal PHY for part of the functionality.
+	 *	(eg, AUI/Thinnet).  This function finds out if this TLAN
+	 *	chip has an internal PHY, and then finds the first external
+	 *	PHY (starting from address 0) if it exists).
 	 *
-	 **************************************************************/
+	 ********************************************************************/
 
-void
-TLan_ResetAdapter( struct net_device *dev )
+void TLan_PhyDetect(struct nic *nic)
 {
-	TLanPrivateInfo	*priv = dev->priv;
-	int		i;
-	u32		addr;
-	u32		data;
-	u8		data8;
+	u16 control;
+	u16 hi;
+	u16 lo;
+	u32 phy;
 
-	priv->tlanFullDuplex = FALSE;
-	priv->phyOnline=0;
-/*  1.	Assert reset bit. */
+	if (tlan_pci_tbl[chip_idx].flags & TLAN_ADAPTER_UNMANAGED_PHY) {
+		priv->phyNum = 0xFFFF;
+		return;
+	}
 
-	data = inl(dev->base_addr + TLAN_HOST_CMD);
-	data |= TLAN_HC_AD_RST;
-	outl(data, dev->base_addr + TLAN_HOST_CMD);
-	
-	udelay(1000);
+	TLan_MiiReadReg(nic, TLAN_PHY_MAX_ADDR, MII_GEN_ID_HI, &hi);
 
-/*  2.	Turn off interrupts. ( Probably isn't necessary ) */
+	if (hi != 0xFFFF) {
+		priv->phy[0] = TLAN_PHY_MAX_ADDR;
+	} else {
+		priv->phy[0] = TLAN_PHY_NONE;
+	}
 
-	data = inl(dev->base_addr + TLAN_HOST_CMD);
-	data |= TLAN_HC_INT_OFF;
-	outl(data, dev->base_addr + TLAN_HOST_CMD);
+	priv->phy[1] = TLAN_PHY_NONE;
+	for (phy = 0; phy <= TLAN_PHY_MAX_ADDR; phy++) {
+		TLan_MiiReadReg(nic, phy, MII_GEN_CTL, &control);
+		TLan_MiiReadReg(nic, phy, MII_GEN_ID_HI, &hi);
+		TLan_MiiReadReg(nic, phy, MII_GEN_ID_LO, &lo);
+		if ((control != 0xFFFF) || (hi != 0xFFFF)
+		    || (lo != 0xFFFF)) {
+			printf("PHY found at %hX %hX %hX %hX\n", phy,
+			       control, hi, lo);
+			if ((priv->phy[1] == TLAN_PHY_NONE)
+			    && (phy != TLAN_PHY_MAX_ADDR)) {
+				priv->phy[1] = phy;
+			}
+		}
+	}
 
-/*  3.	Clear AREGs and HASHs. */
+	if (priv->phy[1] != TLAN_PHY_NONE) {
+		priv->phyNum = 1;
+	} else if (priv->phy[0] != TLAN_PHY_NONE) {
+		priv->phyNum = 0;
+	} else {
+		printf
+		    ("TLAN:  Cannot initialize device, no PHY was found!\n");
+	}
+
+}				/* TLan_PhyDetect */
 
- 	for ( i = TLAN_AREG_0; i <= TLAN_HASH_2; i += 4 ) {
-		TLan_DioWrite32( dev->base_addr, (u16) i, 0 );
+void TLan_PhyPowerDown(struct nic *nic)
+{
+
+	u16 value;
+	printf("%s: Powering down PHY(s).\n", priv->nic_name);
+	value = MII_GC_PDOWN | MII_GC_LOOPBK | MII_GC_ISOLATE;
+	TLan_MiiSync(BASE);
+	TLan_MiiWriteReg(nic, priv->phy[priv->phyNum], MII_GEN_CTL, value);
+	if ((priv->phyNum == 0) && (priv->phy[1] != TLAN_PHY_NONE)
+	    &&
+	    (!(tlan_pci_tbl[chip_idx].
+	       flags & TLAN_ADAPTER_USE_INTERN_10))) {
+		TLan_MiiSync(BASE);
+		TLan_MiiWriteReg(nic, priv->phy[1], MII_GEN_CTL, value);
 	}
 
-/*  4.	Setup NetConfig register. */
+	/* Wait for 50 ms and powerup
+	 * This is abitrary.  It is intended to make sure the
+	 * tranceiver settles.
+	 */
+	/* TLan_SetTimer( dev, (HZ/20), TLAN_TIMER_PHY_PUP ); */
+	mdelay(50);
+	TLan_PhyPowerUp(nic);
 
-	data = TLAN_NET_CFG_1FRAG | TLAN_NET_CFG_1CHAN | TLAN_NET_CFG_PHY_EN;
-	TLan_DioWrite16( dev->base_addr, TLAN_NET_CONFIG, (u16) data );
+}				/* TLan_PhyPowerDown */
 
-/*  5.	Load Ld_Tmr and Ld_Thr in HOST_CMD. */
 
- 	outl( TLAN_HC_LD_TMR | 0x3f, dev->base_addr + TLAN_HOST_CMD );
- 	outl( TLAN_HC_LD_THR | 0x9, dev->base_addr + TLAN_HOST_CMD );
+void TLan_PhyPowerUp(struct nic *nic)
+{
+	u16 value;
 
-/*  6.	Unreset the MII by setting NMRST (in NetSio) to 1. */
+	printf("%s: Powering up PHY.\n", priv->nic_name);
+	TLan_MiiSync(BASE);
+	value = MII_GC_LOOPBK;
+	TLan_MiiWriteReg(nic, priv->phy[priv->phyNum], MII_GEN_CTL, value);
+	TLan_MiiSync(BASE);
+	/* Wait for 500 ms and reset the
+	 * tranceiver.  The TLAN docs say both 50 ms and
+	 * 500 ms, so do the longer, just in case.
+	 */
+	mdelay(500);
+	TLan_PhyReset(nic);
+	/* TLan_SetTimer( dev, (HZ/20), TLAN_TIMER_PHY_RESET ); */
 
-	outw( TLAN_NET_SIO, dev->base_addr + TLAN_DIO_ADR );
-	addr = dev->base_addr + TLAN_DIO_DATA + TLAN_NET_SIO;
-	TLan_SetBit( TLAN_NET_SIO_NMRST, addr );
+}				/* TLan_PhyPowerUp */
 
-/*  7.	Setup the remaining registers. */
+void TLan_PhyReset(struct nic *nic)
+{
+	u16 phy;
+	u16 value;
 
-	if ( priv->tlanRev >= 0x30 ) {
-		data8 = TLAN_ID_TX_EOC | TLAN_ID_RX_EOC;
-		TLan_DioWrite8( dev->base_addr, TLAN_INT_DIS, data8 );
+	phy = priv->phy[priv->phyNum];
+
+	printf("%s: Reseting PHY.\n", priv->nic_name);
+	TLan_MiiSync(BASE);
+	value = MII_GC_LOOPBK | MII_GC_RESET;
+	TLan_MiiWriteReg(nic, phy, MII_GEN_CTL, value);
+	TLan_MiiReadReg(nic, phy, MII_GEN_CTL, &value);
+	while (value & MII_GC_RESET) {
+		TLan_MiiReadReg(nic, phy, MII_GEN_CTL, &value);
 	}
-	TLan_PhyDetect( dev );
-	data = TLAN_NET_CFG_1FRAG | TLAN_NET_CFG_1CHAN;
-	
-	if ( priv->adapter->flags & TLAN_ADAPTER_BIT_RATE_PHY ) {
-		data |= TLAN_NET_CFG_BIT;
-		if ( priv->aui == 1 ) {
-			TLan_DioWrite8( dev->base_addr, TLAN_ACOMMIT, 0x0a );
-		} else if ( priv->duplex == TLAN_DUPLEX_FULL ) {
-			TLan_DioWrite8( dev->base_addr, TLAN_ACOMMIT, 0x00 );
+
+	/* Wait for 500 ms and initialize.
+	 * I don't remember why I wait this long.
+	 * I've changed this to 50ms, as it seems long enough.
+	 */
+	/* TLan_SetTimer( dev, (HZ/20), TLAN_TIMER_PHY_START_LINK ); */
+	mdelay(50);
+	TLan_PhyStartLink(nic);
+
+}				/* TLan_PhyReset */
+
+
+void TLan_PhyStartLink(struct nic *nic)
+{
+
+	u16 ability;
+	u16 control;
+	u16 data;
+	u16 phy;
+	u16 status;
+	u16 tctl;
+
+	phy = priv->phy[priv->phyNum];
+	printf("%s: Trying to activate link.\n", priv->nic_name);
+	TLan_MiiReadReg(nic, phy, MII_GEN_STS, &status);
+	TLan_MiiReadReg(nic, phy, MII_GEN_STS, &ability);
+
+	if ((status & MII_GS_AUTONEG) && (!priv->aui)) {
+		ability = status >> 11;
+		if (priv->speed == TLAN_SPEED_10 &&
+		    priv->duplex == TLAN_DUPLEX_HALF) {
+			TLan_MiiWriteReg(nic, phy, MII_GEN_CTL, 0x0000);
+		} else if (priv->speed == TLAN_SPEED_10 &&
+			   priv->duplex == TLAN_DUPLEX_FULL) {
+			priv->tlanFullDuplex = TRUE;
+			TLan_MiiWriteReg(nic, phy, MII_GEN_CTL, 0x0100);
+		} else if (priv->speed == TLAN_SPEED_100 &&
+			   priv->duplex == TLAN_DUPLEX_HALF) {
+			TLan_MiiWriteReg(nic, phy, MII_GEN_CTL, 0x2000);
+		} else if (priv->speed == TLAN_SPEED_100 &&
+			   priv->duplex == TLAN_DUPLEX_FULL) {
 			priv->tlanFullDuplex = TRUE;
+			TLan_MiiWriteReg(nic, phy, MII_GEN_CTL, 0x2100);
 		} else {
-			TLan_DioWrite8( dev->base_addr, TLAN_ACOMMIT, 0x08 );
+
+			/* Set Auto-Neg advertisement */
+			TLan_MiiWriteReg(nic, phy, MII_AN_ADV,
+					 (ability << 5) | 1);
+			/* Enablee Auto-Neg */
+			TLan_MiiWriteReg(nic, phy, MII_GEN_CTL, 0x1000);
+			/* Restart Auto-Neg */
+			TLan_MiiWriteReg(nic, phy, MII_GEN_CTL, 0x1200);
+			/* Wait for 4 sec for autonegotiation
+			 * to complete.  The max spec time is less than this
+			 * but the card need additional time to start AN.
+			 * .5 sec should be plenty extra.
+			 */
+			printf("TLAN: %s: Starting autonegotiation.\n",
+			       priv->nic_name);
+			mdelay(4000);
+			TLan_PhyFinishAutoNeg(nic);
+			/* TLan_SetTimer( dev, (2*HZ), TLAN_TIMER_PHY_FINISH_AN ); */
+			return;
 		}
-	}
 
-	if ( priv->phyNum == 0 ) {
-		data |= TLAN_NET_CFG_PHY_EN;
 	}
-	TLan_DioWrite16( dev->base_addr, TLAN_NET_CONFIG, (u16) data );
 
-	if ( priv->adapter->flags & TLAN_ADAPTER_UNMANAGED_PHY ) {
-		TLan_FinishReset( dev );
-	} else {
-		TLan_PhyPowerDown( dev );
+	if ((priv->aui) && (priv->phyNum != 0)) {
+		priv->phyNum = 0;
+		data =
+		    TLAN_NET_CFG_1FRAG | TLAN_NET_CFG_1CHAN |
+		    TLAN_NET_CFG_PHY_EN;
+		TLan_DioWrite16(BASE, TLAN_NET_CONFIG, data);
+		mdelay(50);
+		/* TLan_SetTimer( dev, (40*HZ/1000), TLAN_TIMER_PHY_PDOWN ); */
+		TLan_PhyPowerDown(nic);
+		return;
+	} else if (priv->phyNum == 0) {
+		control = 0;
+		TLan_MiiReadReg(nic, phy, TLAN_TLPHY_CTL, &tctl);
+		if (priv->aui) {
+			tctl |= TLAN_TC_AUISEL;
+		} else {
+			tctl &= ~TLAN_TC_AUISEL;
+			if (priv->duplex == TLAN_DUPLEX_FULL) {
+				control |= MII_GC_DUPLEX;
+				priv->tlanFullDuplex = TRUE;
+			}
+			if (priv->speed == TLAN_SPEED_100) {
+				control |= MII_GC_SPEEDSEL;
+			}
+		}
+		TLan_MiiWriteReg(nic, phy, MII_GEN_CTL, control);
+		TLan_MiiWriteReg(nic, phy, TLAN_TLPHY_CTL, tctl);
 	}
 
-} /* TLan_ResetAdapter */
+	/* Wait for 2 sec to give the tranceiver time
+	 * to establish link.
+	 */
+	/* TLan_SetTimer( dev, (4*HZ), TLAN_TIMER_FINISH_RESET ); */
+	mdelay(2000);
+	TLan_FinishReset(nic);
+
+}				/* TLan_PhyStartLink */
 
-void
-TLan_FinishReset( struct net_device *dev )
+void TLan_PhyFinishAutoNeg(struct nic *nic)
 {
-	TLanPrivateInfo	*priv = dev->priv;
-	u8		data;
-	u32		phy;
-	u8		sio;
-	u16		status;
-	u16		partner;
-	u16		tlphy_ctl;
-	u16 		tlphy_par;
-	u16		tlphy_id1, tlphy_id2;
-	int 		i;
+
+	u16 an_adv;
+	u16 an_lpa;
+	u16 data;
+	u16 mode;
+	u16 phy;
+	u16 status;
 
 	phy = priv->phy[priv->phyNum];
 
-	data = TLAN_NET_CMD_NRESET | TLAN_NET_CMD_NWRAP;
-	if ( priv->tlanFullDuplex ) {
-		data |= TLAN_NET_CMD_DUPLEX;
+	TLan_MiiReadReg(nic, phy, MII_GEN_STS, &status);
+	udelay(1000);
+	TLan_MiiReadReg(nic, phy, MII_GEN_STS, &status);
+
+	if (!(status & MII_GS_AUTOCMPLT)) {
+		/* Wait for 8 sec to give the process
+		 * more time.  Perhaps we should fail after a while.
+		 */
+		if (!priv->neg_be_verbose++) {
+			printf
+			    ("TLAN:  Giving autonegotiation more time.\n");
+			printf
+			    ("TLAN:  Please check that your adapter has\n");
+			printf
+			    ("TLAN:  been properly connected to a HUB or Switch.\n");
+			printf
+			    ("TLAN:  Trying to establish link in the background...\n");
+		}
+		mdelay(8000);
+		TLan_PhyFinishAutoNeg(nic);
+		/* TLan_SetTimer( dev, (8*HZ), TLAN_TIMER_PHY_FINISH_AN ); */
+		return;
 	}
-	TLan_DioWrite8( dev->base_addr, TLAN_NET_CMD, data );
-	data = TLAN_NET_MASK_MASK4 | TLAN_NET_MASK_MASK5; 
-	if ( priv->phyNum == 0 ) {
-		data |= TLAN_NET_MASK_MASK7; 
-	}
-	TLan_DioWrite8( dev->base_addr, TLAN_NET_MASK, data );
-	TLan_DioWrite16( dev->base_addr, TLAN_MAX_RX, ((1536)+7)&~7 );
-	TLan_MiiReadReg( dev, phy, MII_GEN_ID_HI, &tlphy_id1 );
-	TLan_MiiReadReg( dev, phy, MII_GEN_ID_LO, &tlphy_id2 );
-	
-	if ( ( priv->adapter->flags & TLAN_ADAPTER_UNMANAGED_PHY ) || ( priv->aui ) ) {
-		status = MII_GS_LINK;
-		printk( "TLAN:  %s: Link forced.\n", dev->name );
-	} else {
-		TLan_MiiReadReg( dev, phy, MII_GEN_STS, &status );
-		udelay( 1000 );
-		TLan_MiiReadReg( dev, phy, MII_GEN_STS, &status );
-		if ( (status & MII_GS_LINK) &&	 /* We only support link info on Nat.Sem. PHY's */ 
-			(tlphy_id1 == NAT_SEM_ID1) &&
-			(tlphy_id2 == NAT_SEM_ID2) ) {
-			TLan_MiiReadReg( dev, phy, MII_AN_LPA, &partner );
-			TLan_MiiReadReg( dev, phy, TLAN_TLPHY_PAR, &tlphy_par );
-			
-			printk( "TLAN: %s: Link active with ", dev->name );
-			if (!(tlphy_par & TLAN_PHY_AN_EN_STAT)) {
-			      	 printk( "forced 10%sMbps %s-Duplex\n", 
-						tlphy_par & TLAN_PHY_SPEED_100 ? "" : "0",
-						tlphy_par & TLAN_PHY_DUPLEX_FULL ? "Full" : "Half");
-			} else {
-				printk( "AutoNegotiation enabled, at 10%sMbps %s-Duplex\n",
-						tlphy_par & TLAN_PHY_SPEED_100 ? "" : "0",
-						tlphy_par & TLAN_PHY_DUPLEX_FULL ? "Full" : "Half");
-				printk("TLAN: Partner capability: ");
-					for (i = 5; i <= 10; i++)
-						if (partner & (1<<i))
-							printk("%s", media[i-5]);
-							printk("\n");
-			}
 
-			TLan_DioWrite8( dev->base_addr, TLAN_LED_REG, TLAN_LED_LINK );
-#ifdef MONITOR			
-			/* We have link beat..for now anyway */
-	        	priv->link = 1;
-	        	/*Enabling link beat monitoring */
-			TLan_SetTimer( dev, (10*HZ), TLAN_TIMER_LINK_BEAT );
-#endif 
-		} else if (status & MII_GS_LINK)  {
-			printk( "TLAN: %s: Link active\n", dev->name );
-			TLan_DioWrite8( dev->base_addr, TLAN_LED_REG, TLAN_LED_LINK );
-		}
+	printf("TLAN: %s: Autonegotiation complete.\n", priv->nic_name);
+	TLan_MiiReadReg(nic, phy, MII_AN_ADV, &an_adv);
+	TLan_MiiReadReg(nic, phy, MII_AN_LPA, &an_lpa);
+	mode = an_adv & an_lpa & 0x03E0;
+	if (mode & 0x0100) {
+		printf("Full Duplex\n");
+		priv->tlanFullDuplex = TRUE;
+	} else if (!(mode & 0x0080) && (mode & 0x0040)) {
+		priv->tlanFullDuplex = TRUE;
+		printf("Full Duplex\n");
 	}
 
-	if ( priv->phyNum == 0 ) {
-        	TLan_MiiReadReg( dev, phy, TLAN_TLPHY_CTL, &tlphy_ctl );
-        	tlphy_ctl |= TLAN_TC_INTEN;
-        	TLan_MiiWriteReg( dev, phy, TLAN_TLPHY_CTL, tlphy_ctl );
-        	sio = TLan_DioRead8( dev->base_addr, TLAN_NET_SIO );
-        	sio |= TLAN_NET_SIO_MINTEN;
-        	TLan_DioWrite8( dev->base_addr, TLAN_NET_SIO, sio );
+	if ((!(mode & 0x0180))
+	    && (tlan_pci_tbl[chip_idx].flags & TLAN_ADAPTER_USE_INTERN_10)
+	    && (priv->phyNum != 0)) {
+		priv->phyNum = 0;
+		data =
+		    TLAN_NET_CFG_1FRAG | TLAN_NET_CFG_1CHAN |
+		    TLAN_NET_CFG_PHY_EN;
+		TLan_DioWrite16(BASE, TLAN_NET_CONFIG, data);
+		/* TLan_SetTimer( nic, (400*HZ/1000), TLAN_TIMER_PHY_PDOWN ); */
+		mdelay(400);
+		TLan_PhyPowerDown(nic);
+		return;
 	}
 
-	if ( status & MII_GS_LINK ) {
-		TLan_SetMac( dev, 0, dev->dev_addr );
-		priv->phyOnline = 1;
-		outb( ( TLAN_HC_INT_ON >> 8 ), dev->base_addr + TLAN_HOST_CMD + 1 );
-		if ( debug >= 1 && debug != TLAN_DEBUG_PROBE ) {
-			outb( ( TLAN_HC_REQ_INT >> 8 ), dev->base_addr + TLAN_HOST_CMD + 1 );
+	if (priv->phyNum == 0) {
+		if ((priv->duplex == TLAN_DUPLEX_FULL)
+		    || (an_adv & an_lpa & 0x0040)) {
+			TLan_MiiWriteReg(nic, phy, MII_GEN_CTL,
+					 MII_GC_AUTOENB | MII_GC_DUPLEX);
+			printf
+			    ("TLAN:  Starting internal PHY with FULL-DUPLEX\n");
+		} else {
+			TLan_MiiWriteReg(nic, phy, MII_GEN_CTL,
+					 MII_GC_AUTOENB);
+			printf
+			    ("TLAN:  Starting internal PHY with HALF-DUPLEX\n");
 		}
-		outl( virt_to_bus( priv->rxList ), dev->base_addr + TLAN_CH_PARM );
-		outl( TLAN_HC_GO | TLAN_HC_RT, dev->base_addr + TLAN_HOST_CMD );
-	} else {
-		printk( "TLAN: %s: Link inactive, will retry in 10 secs...\n", dev->name );
-		TLan_SetTimer( dev, (10*HZ), TLAN_TIMER_FINISH_RESET );
-		return;
 	}
 
-} /* TLan_FinishReset */
+	/* Wait for 100 ms.  No reason in partiticular.
+	 */
+	/* TLan_SetTimer( dev, (HZ/10), TLAN_TIMER_FINISH_RESET ); */
+	mdelay(100);
+	TLan_FinishReset(nic);
 
-	/***************************************************************
-	 *	TLan_SetMac
-	 *
-	 *	Returns:
-	 *		Nothing
-	 *	Parms:
-	 *		dev	Pointer to device structure of adapter
-	 *			on which to change the AREG.
-	 *		areg	The AREG to set the address in (0 - 3).
-	 *		mac	A pointer to an array of chars.  Each
-	 *			element stores one byte of the address.
-	 *			IE, it isn't in ascii.
-	 *
-	 *	This function transfers a MAC address to one of the
-	 *	TLAN AREGs (address registers).  The TLAN chip locks
-	 *	the register on writing to offset 0 and unlocks the
-	 *	register after writing to offset 5.  If NULL is passed
-	 *	in mac, then the AREG is filled with 0's.
-	 *
-	 **************************************************************/
+}				/* TLan_PhyFinishAutoNeg */
+
+#ifdef MONITOR
+
+	/*********************************************************************
+        *
+        *      TLan_phyMonitor
+        *
+        *      Returns:
+        *              None
+        *
+        *      Params:
+        *              dev             The device structure of this device.
+        *
+        *
+        *      This function monitors PHY condition by reading the status
+        *      register via the MII bus. This can be used to give info
+        *      about link changes (up/down), and possible switch to alternate
+        *      media.
+        *
+        * ******************************************************************/
 
-void TLan_SetMac( struct net_device *dev, int areg, char *mac )
+void TLan_PhyMonitor(struct net_device *dev)
 {
-	int i;
-			
-	areg *= 6;
+	TLanPrivateInfo *priv = dev->priv;
+	u16 phy;
+	u16 phy_status;
 
-	if ( mac != NULL ) {
-		for ( i = 0; i < 6; i++ )
-			TLan_DioWrite8( dev->base_addr, TLAN_AREG_0 + areg + i, mac[i] );
-	} else {
-		for ( i = 0; i < 6; i++ )
-			TLan_DioWrite8( dev->base_addr, TLAN_AREG_0 + areg + i, 0 );
+	phy = priv->phy[priv->phyNum];
+
+	/* Get PHY status register */
+	TLan_MiiReadReg(nic, phy, MII_GEN_STS, &phy_status);
+
+	/* Check if link has been lost */
+	if (!(phy_status & MII_GS_LINK)) {
+		if (priv->link) {
+			priv->link = 0;
+			printf("TLAN: %s has lost link\n", priv->nic_name);
+			priv->flags &= ~IFF_RUNNING;
+			mdelay(2000);
+			TLan_PhyMonitor(nic);
+			/* TLan_SetTimer( dev, (2*HZ), TLAN_TIMER_LINK_BEAT ); */
+			return;
+		}
 	}
 
-} /* TLan_SetMac */
+	/* Link restablished? */
+	if ((phy_status & MII_GS_LINK) && !priv->link) {
+		priv->link = 1;
+		printf("TLAN: %s has reestablished link\n",
+		       priv->nic_name);
+		priv->flags |= IFF_RUNNING;
+	}
+
+	/* Setup a new monitor */
+	/* TLan_SetTimer( dev, (2*HZ), TLAN_TIMER_LINK_BEAT ); */
+	mdelay(2000);
+	TLan_PhyMonitor(nic);
+}
 
+#endif				/* MONITOR */
+
+#ifdef EB51
+static struct pci_id tlan_nics[] = {
+	PCI_ROM(0x0e11, 0xae34, "netel10", "Compaq Netelligent 10 T PCI UTP"),
+	PCI_ROM(0x0e11, 0xae32, "netel100","Compaq Netelligent 10/100 TX PCI UTP"),
+	PCI_ROM(0x0e11, 0xae35, "netflex3i", "Compaq Integrated NetFlex-3/P"),
+	PCI_ROM(0x0e11, 0xf130, "thunder", "Compaq NetFlex-3/P"),
+	PCI_ROM(0x0e11, 0xf150, "netflex3b", "Compaq NetFlex-3/P"),
+	PCI_ROM(0x0e11, 0xae43, "netel100pi", "Compaq Netelligent Integrated 10/100 TX UTP"),
+	PCI_ROM(0x0e11, 0xae40, "netel100d", "Compaq Netelligent Dual 10/100 TX PCI UTP"),
+	PCI_ROM(0x0e11, 0xb011, "netel100i", "Compaq Netelligent 10/100 TX Embedded UTP"),
+	PCI_ROM(0x108d, 0x0013, "oc2183", "Olicom OC-2183/2185"),
+	PCI_ROM(0x108d, 0x0012, "oc2325", "Olicom OC-2325"),
+	PCI_ROM(0x108d, 0x0014, "oc2326", "Olicom OC-2326"),
+	PCI_ROM(0x0e11, 0xb030, "netelligent_10_100_ws_5100", "Compaq Netelligent 10/100 TX UTP"),
+	PCI_ROM(0x0e11, 0xb012, "netelligent_10_t2", "Compaq Netelligent 10 T/2 PCI UTP/Coax"),
+};
+
+struct pci_driver tlan_driver = {
+	.type = NIC_DRIVER,
+	.name = "TLAN/PCI",
+	.probe = tlan_probe,
+	.ids = tlan_nics,
+	.id_count = sizeof(tlan_nics) / sizeof(tlan_nics[0]),
+	.class = 0,
+};
 #endif
diff -Naur grub-0.97.orig/netboot/tlan.h grub-0.97/netboot/tlan.h
--- grub-0.97.orig/netboot/tlan.h	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/tlan.h	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,536 @@
+/**************************************************************************
+*
+*    tlan.c -- Etherboot device driver for the Texas Instruments ThunderLAN
+*    Written 2003-2003 by Timothy Legge <tlegge@rogers.com>
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the License, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not, write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*    Portions of this code (almost all) based on:
+*               tlan.c: Linux ThunderLan Driver:
+*
+*				by James Banks
+*
+*  				(C) 1997-1998 Caldera, Inc.
+*			  	(C) 1998 James Banks
+*				(C) 1999-2001 Torben Mathiasen
+*				(C) 2002 Samuel Chessman
+*
+*    REVISION HISTORY:
+*    ================
+*    v1.0	07-08-2003	timlegge	Initial not quite working version
+*
+* Indent Style: indent -kr -i8
+***************************************************************************/
+
+/*
+#include <asm/io.h>
+#include <asm/types.h>
+#include <linux/netdevice.h>
+*/
+
+typedef unsigned char u8;
+typedef signed char s8;
+typedef unsigned short u16;
+typedef signed short s16;
+typedef unsigned int u32;
+typedef signed int s32;
+	/*****************************************************************
+	 * TLan Definitions
+	 *
+	 ****************************************************************/
+
+#define FALSE			0
+#define TRUE			1
+
+#define TLAN_MIN_FRAME_SIZE	64
+#define TLAN_MAX_FRAME_SIZE	1600
+
+#define TLAN_NUM_RX_LISTS	4
+#define TLAN_NUM_TX_LISTS	2
+
+#define TLAN_IGNORE		0
+#define TLAN_RECORD		1
+/*
+#define TLAN_DBG(lvl, format, args...)	if (debug&lvl) printf("TLAN: " format, ##args );
+*/
+#define TLAN_DEBUG_GNRL		0x0001
+#define TLAN_DEBUG_TX		0x0002
+#define TLAN_DEBUG_RX		0x0004
+#define TLAN_DEBUG_LIST		0x0008
+#define TLAN_DEBUG_PROBE	0x0010
+
+#define TX_TIMEOUT		(10*HZ)	/* We need time for auto-neg */
+#define MAX_TLAN_BOARDS		8	/* Max number of boards installed at a time */
+
+
+	/*****************************************************************
+	 * Device Identification Definitions
+	 *
+	 ****************************************************************/
+
+#define PCI_DEVICE_ID_NETELLIGENT_10_T2			0xB012
+#define PCI_DEVICE_ID_NETELLIGENT_10_100_WS_5100	0xB030
+#ifndef PCI_DEVICE_ID_OLICOM_OC2183
+#define PCI_DEVICE_ID_OLICOM_OC2183			0x0013
+#endif
+#ifndef PCI_DEVICE_ID_OLICOM_OC2325
+#define PCI_DEVICE_ID_OLICOM_OC2325			0x0012
+#endif
+#ifndef PCI_DEVICE_ID_OLICOM_OC2326
+#define PCI_DEVICE_ID_OLICOM_OC2326			0x0014
+#endif
+
+typedef struct tlan_adapter_entry {
+	u16 vendorId;
+	u16 deviceId;
+	char *deviceLabel;
+	u32 flags;
+	u16 addrOfs;
+} TLanAdapterEntry;
+
+#define TLAN_ADAPTER_NONE		0x00000000
+#define TLAN_ADAPTER_UNMANAGED_PHY	0x00000001
+#define TLAN_ADAPTER_BIT_RATE_PHY	0x00000002
+#define TLAN_ADAPTER_USE_INTERN_10	0x00000004
+#define TLAN_ADAPTER_ACTIVITY_LED	0x00000008
+
+#define TLAN_SPEED_DEFAULT	0
+#define TLAN_SPEED_10		10
+#define TLAN_SPEED_100		100
+
+#define TLAN_DUPLEX_DEFAULT	0
+#define TLAN_DUPLEX_HALF	1
+#define TLAN_DUPLEX_FULL	2
+
+
+
+	/*****************************************************************
+	 * EISA Definitions
+	 *
+	 ****************************************************************/
+
+#define EISA_ID      0xc80	/* EISA ID Registers */
+#define EISA_ID0     0xc80	/* EISA ID Register 0 */
+#define EISA_ID1     0xc81	/* EISA ID Register 1 */
+#define EISA_ID2     0xc82	/* EISA ID Register 2 */
+#define EISA_ID3     0xc83	/* EISA ID Register 3 */
+#define EISA_CR      0xc84	/* EISA Control Register */
+#define EISA_REG0    0xc88	/* EISA Configuration Register 0 */
+#define EISA_REG1    0xc89	/* EISA Configuration Register 1 */
+#define EISA_REG2    0xc8a	/* EISA Configuration Register 2 */
+#define EISA_REG3    0xc8f	/* EISA Configuration Register 3 */
+#define EISA_APROM   0xc90	/* Ethernet Address PROM */
+
+
+
+	/*****************************************************************
+	 * Rx/Tx List Definitions
+	 *
+	 ****************************************************************/
+
+#define TLAN_BUFFERS_PER_LIST	10
+#define TLAN_LAST_BUFFER	0x80000000
+#define TLAN_CSTAT_UNUSED	0x8000
+#define TLAN_CSTAT_FRM_CMP	0x4000
+#define TLAN_CSTAT_READY	0x3000
+#define TLAN_CSTAT_EOC		0x0800
+#define TLAN_CSTAT_RX_ERROR	0x0400
+#define TLAN_CSTAT_PASS_CRC	0x0200
+#define TLAN_CSTAT_DP_PR	0x0100
+
+
+
+
+
+
+	/*****************************************************************
+	 * PHY definitions
+	 *
+	 ****************************************************************/
+
+#define TLAN_PHY_MAX_ADDR	0x1F
+#define TLAN_PHY_NONE		0x20
+
+
+
+	/*****************************************************************
+	 * TLan Driver Timer Definitions
+	 *
+	 ****************************************************************/
+
+#define TLAN_TIMER_LINK_BEAT		1
+#define TLAN_TIMER_ACTIVITY		2
+#define TLAN_TIMER_PHY_PDOWN		3
+#define TLAN_TIMER_PHY_PUP		4
+#define TLAN_TIMER_PHY_RESET		5
+#define TLAN_TIMER_PHY_START_LINK	6
+#define TLAN_TIMER_PHY_FINISH_AN	7
+#define TLAN_TIMER_FINISH_RESET		8
+
+#define TLAN_TIMER_ACT_DELAY		(HZ/10)
+
+
+
+
+	/*****************************************************************
+	 * TLan Driver Eeprom Definitions
+	 *
+	 ****************************************************************/
+
+#define TLAN_EEPROM_ACK		0
+#define TLAN_EEPROM_STOP	1
+
+
+
+
+	/*****************************************************************
+	 * Host Register Offsets and Contents
+	 *
+	 ****************************************************************/
+
+#define TLAN_HOST_CMD			0x00
+#define 	TLAN_HC_GO		0x80000000
+#define		TLAN_HC_STOP		0x40000000
+#define		TLAN_HC_ACK		0x20000000
+#define		TLAN_HC_CS_MASK		0x1FE00000
+#define		TLAN_HC_EOC		0x00100000
+#define		TLAN_HC_RT		0x00080000
+#define		TLAN_HC_NES		0x00040000
+#define		TLAN_HC_AD_RST		0x00008000
+#define		TLAN_HC_LD_TMR		0x00004000
+#define		TLAN_HC_LD_THR		0x00002000
+#define		TLAN_HC_REQ_INT		0x00001000
+#define		TLAN_HC_INT_OFF		0x00000800
+#define		TLAN_HC_INT_ON		0x00000400
+#define		TLAN_HC_AC_MASK		0x000000FF
+#define TLAN_CH_PARM			0x04
+#define TLAN_DIO_ADR			0x08
+#define		TLAN_DA_ADR_INC		0x8000
+#define		TLAN_DA_RAM_ADR		0x4000
+#define TLAN_HOST_INT			0x0A
+#define		TLAN_HI_IV_MASK		0x1FE0
+#define		TLAN_HI_IT_MASK		0x001C
+#define TLAN_DIO_DATA			0x0C
+
+
+/* ThunderLAN Internal Register DIO Offsets */
+
+#define TLAN_NET_CMD			0x00
+#define		TLAN_NET_CMD_NRESET	0x80
+#define		TLAN_NET_CMD_NWRAP	0x40
+#define		TLAN_NET_CMD_CSF	0x20
+#define		TLAN_NET_CMD_CAF	0x10
+#define		TLAN_NET_CMD_NOBRX	0x08
+#define		TLAN_NET_CMD_DUPLEX	0x04
+#define		TLAN_NET_CMD_TRFRAM	0x02
+#define		TLAN_NET_CMD_TXPACE	0x01
+#define TLAN_NET_SIO			0x01
+#define 	TLAN_NET_SIO_MINTEN	0x80
+#define		TLAN_NET_SIO_ECLOK	0x40
+#define		TLAN_NET_SIO_ETXEN	0x20
+#define		TLAN_NET_SIO_EDATA	0x10
+#define		TLAN_NET_SIO_NMRST	0x08
+#define		TLAN_NET_SIO_MCLK	0x04
+#define		TLAN_NET_SIO_MTXEN	0x02
+#define		TLAN_NET_SIO_MDATA	0x01
+#define TLAN_NET_STS			0x02
+#define		TLAN_NET_STS_MIRQ	0x80
+#define		TLAN_NET_STS_HBEAT	0x40
+#define		TLAN_NET_STS_TXSTOP	0x20
+#define		TLAN_NET_STS_RXSTOP	0x10
+#define		TLAN_NET_STS_RSRVD	0x0F
+#define TLAN_NET_MASK			0x03
+#define		TLAN_NET_MASK_MASK7	0x80
+#define		TLAN_NET_MASK_MASK6	0x40
+#define		TLAN_NET_MASK_MASK5	0x20
+#define		TLAN_NET_MASK_MASK4	0x10
+#define		TLAN_NET_MASK_RSRVD	0x0F
+#define TLAN_NET_CONFIG			0x04
+#define 	TLAN_NET_CFG_RCLK	0x8000
+#define		TLAN_NET_CFG_TCLK	0x4000
+#define		TLAN_NET_CFG_BIT	0x2000
+#define		TLAN_NET_CFG_RXCRC	0x1000
+#define		TLAN_NET_CFG_PEF	0x0800
+#define		TLAN_NET_CFG_1FRAG	0x0400
+#define		TLAN_NET_CFG_1CHAN	0x0200
+#define		TLAN_NET_CFG_MTEST	0x0100
+#define		TLAN_NET_CFG_PHY_EN	0x0080
+#define		TLAN_NET_CFG_MSMASK	0x007F
+#define TLAN_MAN_TEST			0x06
+#define TLAN_DEF_VENDOR_ID		0x08
+#define TLAN_DEF_DEVICE_ID		0x0A
+#define TLAN_DEF_REVISION		0x0C
+#define TLAN_DEF_SUBCLASS		0x0D
+#define TLAN_DEF_MIN_LAT		0x0E
+#define TLAN_DEF_MAX_LAT		0x0F
+#define TLAN_AREG_0			0x10
+#define TLAN_AREG_1			0x16
+#define TLAN_AREG_2			0x1C
+#define TLAN_AREG_3			0x22
+#define TLAN_HASH_1			0x28
+#define TLAN_HASH_2			0x2C
+#define TLAN_GOOD_TX_FRMS		0x30
+#define TLAN_TX_UNDERUNS		0x33
+#define TLAN_GOOD_RX_FRMS		0x34
+#define TLAN_RX_OVERRUNS		0x37
+#define TLAN_DEFERRED_TX		0x38
+#define TLAN_CRC_ERRORS			0x3A
+#define TLAN_CODE_ERRORS		0x3B
+#define TLAN_MULTICOL_FRMS		0x3C
+#define TLAN_SINGLECOL_FRMS		0x3E
+#define TLAN_EXCESSCOL_FRMS		0x40
+#define TLAN_LATE_COLS			0x41
+#define TLAN_CARRIER_LOSS		0x42
+#define TLAN_ACOMMIT			0x43
+#define TLAN_LED_REG			0x44
+#define		TLAN_LED_ACT		0x10
+#define		TLAN_LED_LINK		0x01
+#define TLAN_BSIZE_REG			0x45
+#define TLAN_MAX_RX			0x46
+#define TLAN_INT_DIS			0x48
+#define		TLAN_ID_TX_EOC		0x04
+#define		TLAN_ID_RX_EOF		0x02
+#define		TLAN_ID_RX_EOC		0x01
+
+
+
+/* ThunderLAN Interrupt Codes */
+
+#define TLAN_INT_NUMBER_OF_INTS	8
+
+#define TLAN_INT_NONE			0x0000
+#define TLAN_INT_TX_EOF			0x0001
+#define TLAN_INT_STAT_OVERFLOW		0x0002
+#define TLAN_INT_RX_EOF			0x0003
+#define TLAN_INT_DUMMY			0x0004
+#define TLAN_INT_TX_EOC			0x0005
+#define TLAN_INT_STATUS_CHECK		0x0006
+#define TLAN_INT_RX_EOC			0x0007
+
+
+
+/* ThunderLAN MII Registers */
+
+/* Generic MII/PHY Registers */
+
+#define MII_GEN_CTL			0x00
+#define 	MII_GC_RESET		0x8000
+#define		MII_GC_LOOPBK		0x4000
+#define		MII_GC_SPEEDSEL		0x2000
+#define		MII_GC_AUTOENB		0x1000
+#define		MII_GC_PDOWN		0x0800
+#define		MII_GC_ISOLATE		0x0400
+#define		MII_GC_AUTORSRT		0x0200
+#define		MII_GC_DUPLEX		0x0100
+#define		MII_GC_COLTEST		0x0080
+#define		MII_GC_RESERVED		0x007F
+#define MII_GEN_STS			0x01
+#define		MII_GS_100BT4		0x8000
+#define		MII_GS_100BTXFD		0x4000
+#define		MII_GS_100BTXHD		0x2000
+#define		MII_GS_10BTFD		0x1000
+#define		MII_GS_10BTHD		0x0800
+#define		MII_GS_RESERVED		0x07C0
+#define		MII_GS_AUTOCMPLT	0x0020
+#define		MII_GS_RFLT		0x0010
+#define		MII_GS_AUTONEG		0x0008
+#define		MII_GS_LINK		0x0004
+#define		MII_GS_JABBER		0x0002
+#define		MII_GS_EXTCAP		0x0001
+#define MII_GEN_ID_HI			0x02
+#define MII_GEN_ID_LO			0x03
+#define 	MII_GIL_OUI		0xFC00
+#define 	MII_GIL_MODEL		0x03F0
+#define 	MII_GIL_REVISION	0x000F
+#define MII_AN_ADV			0x04
+#define MII_AN_LPA			0x05
+#define MII_AN_EXP			0x06
+
+/* ThunderLAN Specific MII/PHY Registers */
+
+#define TLAN_TLPHY_ID			0x10
+#define TLAN_TLPHY_CTL			0x11
+#define 	TLAN_TC_IGLINK		0x8000
+#define		TLAN_TC_SWAPOL		0x4000
+#define		TLAN_TC_AUISEL		0x2000
+#define		TLAN_TC_SQEEN		0x1000
+#define		TLAN_TC_MTEST		0x0800
+#define		TLAN_TC_RESERVED	0x07F8
+#define		TLAN_TC_NFEW		0x0004
+#define		TLAN_TC_INTEN		0x0002
+#define		TLAN_TC_TINT		0x0001
+#define TLAN_TLPHY_STS			0x12
+#define		TLAN_TS_MINT		0x8000
+#define		TLAN_TS_PHOK		0x4000
+#define		TLAN_TS_POLOK		0x2000
+#define		TLAN_TS_TPENERGY	0x1000
+#define		TLAN_TS_RESERVED	0x0FFF
+#define TLAN_TLPHY_PAR			0x19
+#define		TLAN_PHY_CIM_STAT	0x0020
+#define		TLAN_PHY_SPEED_100	0x0040
+#define		TLAN_PHY_DUPLEX_FULL	0x0080
+#define		TLAN_PHY_AN_EN_STAT     0x0400
+
+/* National Sem. & Level1 PHY id's */
+#define NAT_SEM_ID1			0x2000
+#define NAT_SEM_ID2			0x5C01
+#define LEVEL1_ID1			0x7810
+#define LEVEL1_ID2			0x0000
+
+#define CIRC_INC( a, b ) if ( ++a >= b ) a = 0
+
+/* Routines to access internal registers. */
+
+inline u8 TLan_DioRead8(u16 base_addr, u16 internal_addr)
+{
+	outw(internal_addr, base_addr + TLAN_DIO_ADR);
+	return (inb((base_addr + TLAN_DIO_DATA) + (internal_addr & 0x3)));
+
+}				/* TLan_DioRead8 */
+
+
+
+
+inline u16 TLan_DioRead16(u16 base_addr, u16 internal_addr)
+{
+	outw(internal_addr, base_addr + TLAN_DIO_ADR);
+	return (inw((base_addr + TLAN_DIO_DATA) + (internal_addr & 0x2)));
+
+}				/* TLan_DioRead16 */
+
+
+
+
+inline u32 TLan_DioRead32(u16 base_addr, u16 internal_addr)
+{
+	outw(internal_addr, base_addr + TLAN_DIO_ADR);
+	return (inl(base_addr + TLAN_DIO_DATA));
+
+}				/* TLan_DioRead32 */
+
+
+
+
+inline void TLan_DioWrite8(u16 base_addr, u16 internal_addr, u8 data)
+{
+	outw(internal_addr, base_addr + TLAN_DIO_ADR);
+	outb(data, base_addr + TLAN_DIO_DATA + (internal_addr & 0x3));
+
+}
+
+
+
+
+inline void TLan_DioWrite16(u16 base_addr, u16 internal_addr, u16 data)
+{
+	outw(internal_addr, base_addr + TLAN_DIO_ADR);
+	outw(data, base_addr + TLAN_DIO_DATA + (internal_addr & 0x2));
+
+}
+
+
+
+
+inline void TLan_DioWrite32(u16 base_addr, u16 internal_addr, u32 data)
+{
+	outw(internal_addr, base_addr + TLAN_DIO_ADR);
+	outl(data, base_addr + TLAN_DIO_DATA + (internal_addr & 0x2));
+
+}
+
+
+
+#if 0
+inline void TLan_ClearBit(u8 bit, u16 port)
+{
+	outb_p(inb_p(port) & ~bit, port);
+}
+
+
+
+
+inline int TLan_GetBit(u8 bit, u16 port)
+{
+	return ((int) (inb_p(port) & bit));
+}
+
+
+
+
+inline void TLan_SetBit(u8 bit, u16 port)
+{
+	outb_p(inb_p(port) | bit, port);
+}
+#endif
+
+#define TLan_ClearBit( bit, port )	outb_p(inb_p(port) & ~bit, port)
+#define TLan_GetBit( bit, port )	((int) (inb_p(port) & bit))
+#define TLan_SetBit( bit, port )	outb_p(inb_p(port) | bit, port)
+
+#ifdef I_LIKE_A_FAST_HASH_FUNCTION
+/* given 6 bytes, view them as 8 6-bit numbers and return the XOR of those */
+/* the code below is about seven times as fast as the original code */
+inline u32 TLan_HashFunc(u8 * a)
+{
+	u8 hash;
+
+	hash = (a[0] ^ a[3]);	/* & 077 */
+	hash ^= ((a[0] ^ a[3]) >> 6);	/* & 003 */
+	hash ^= ((a[1] ^ a[4]) << 2);	/* & 074 */
+	hash ^= ((a[1] ^ a[4]) >> 4);	/* & 017 */
+	hash ^= ((a[2] ^ a[5]) << 4);	/* & 060 */
+	hash ^= ((a[2] ^ a[5]) >> 2);	/* & 077 */
+
+	return (hash & 077);
+}
+
+#else				/* original code */
+
+inline u32 xor(u32 a, u32 b)
+{
+	return ((a && !b) || (!a && b));
+}
+
+#define XOR8( a, b, c, d, e, f, g, h )	xor( a, xor( b, xor( c, xor( d, xor( e, xor( f, xor( g, h ) ) ) ) ) ) )
+#define DA( a, bit )					( ( (u8) a[bit/8] ) & ( (u8) ( 1 << bit%8 ) ) )
+
+inline u32 TLan_HashFunc(u8 * a)
+{
+	u32 hash;
+
+	hash =
+	    XOR8(DA(a, 0), DA(a, 6), DA(a, 12), DA(a, 18), DA(a, 24),
+		 DA(a, 30), DA(a, 36), DA(a, 42));
+	hash |=
+	    XOR8(DA(a, 1), DA(a, 7), DA(a, 13), DA(a, 19), DA(a, 25),
+		 DA(a, 31), DA(a, 37), DA(a, 43)) << 1;
+	hash |=
+	    XOR8(DA(a, 2), DA(a, 8), DA(a, 14), DA(a, 20), DA(a, 26),
+		 DA(a, 32), DA(a, 38), DA(a, 44)) << 2;
+	hash |=
+	    XOR8(DA(a, 3), DA(a, 9), DA(a, 15), DA(a, 21), DA(a, 27),
+		 DA(a, 33), DA(a, 39), DA(a, 45)) << 3;
+	hash |=
+	    XOR8(DA(a, 4), DA(a, 10), DA(a, 16), DA(a, 22), DA(a, 28),
+		 DA(a, 34), DA(a, 40), DA(a, 46)) << 4;
+	hash |=
+	    XOR8(DA(a, 5), DA(a, 11), DA(a, 17), DA(a, 23), DA(a, 29),
+		 DA(a, 35), DA(a, 41), DA(a, 47)) << 5;
+
+	return hash;
+
+}
+
+#endif				/* I_LIKE_A_FAST_HASH_FUNCTION */
diff -Naur grub-0.97.orig/netboot/tulip.c grub-0.97/netboot/tulip.c
--- grub-0.97.orig/netboot/tulip.c	2003-07-09 11:45:38.000000000 +0000
+++ grub-0.97/netboot/tulip.c	2005-08-31 19:03:35.000000000 +0000
@@ -48,6 +48,7 @@
 /*********************************************************************/
 
 /*
+  07 Sep 2003  timlegge	Multicast Support Added
   11 Apr 2001  mdc     [patch to etherboot 4.7.24]
      Major rewrite to include Linux tulip driver media detection
      code.  This driver should support a lot more cards now.
@@ -98,7 +99,6 @@
      and thinguin mailing lists.
 */
 
-
 /*********************************************************************/
 /* Declarations                                                      */
 /*********************************************************************/
@@ -106,31 +106,29 @@
 #include "etherboot.h"
 #include "nic.h"
 #include "pci.h"
-#include "cards.h"
 
 /* User settable parameters */
 
-#undef   TULIP_DEBUG
-#undef   TULIP_DEBUG_WHERE
+#undef	TULIP_DEBUG
+#undef	TULIP_DEBUG_WHERE
+#ifdef	TULIP_DEBUG
 static int tulip_debug = 2;             /* 1 normal messages, 0 quiet .. 7 verbose. */
+#endif
 
 #define TX_TIME_OUT       2*TICKS_PER_SEC
 
-typedef unsigned char  u8;
-typedef   signed char  s8;
-typedef unsigned short u16;
-typedef   signed short s16;
-typedef unsigned int   u32;
-typedef   signed int   s32;
+typedef uint8_t    u8;
+typedef  int8_t    s8;
+typedef uint16_t   u16;
+typedef  int16_t   s16;
+typedef uint32_t   u32;
+typedef  int32_t   s32;
 
 /* helpful macros if on a big_endian machine for changing byte order.
    not strictly needed on Intel */
-#define le16_to_cpu(val) (val)
-#define cpu_to_le32(val) (val)
 #define get_unaligned(ptr) (*(ptr))
 #define put_unaligned(val, ptr) ((void)( *(ptr) = (val) ))
 #define get_u16(ptr) (*(u16 *)(ptr))
-#define virt_to_bus(x) ((unsigned long)x)
 #define virt_to_le32desc(addr)  virt_to_bus(addr)
 
 #define TULIP_IOTYPE  PCI_USES_MASTER | PCI_USES_IO | PCI_ADDR0
@@ -212,6 +210,8 @@
       TULIP_IOTYPE, 256, PNIC2 },
     { "ADMtek AN981 Comet", { 0x09811317, 0xffffffff, 0, 0, 0, 0 },
       TULIP_IOTYPE, 256, COMET },
+    { "ADMTek AN983 Comet", { 0x12161113, 0xffffffff, 0, 0, 0, 0 },
+      TULIP_IOTYPE, 256, COMET },
     { "ADMtek Centaur-P", { 0x09851317, 0xffffffff, 0, 0, 0, 0 },
       TULIP_IOTYPE, 256, COMET },
     { "ADMtek Centaur-C", { 0x19851317, 0xffffffff, 0, 0, 0, 0 },
@@ -280,9 +280,13 @@
 static u16 t21041_csr14[] = { 0xFFFF, 0xF7FD, 0xF7FD, 0x7F3F, 0x7F3D, };
 static u16 t21041_csr15[] = { 0x0008, 0x0006, 0x000E, 0x0008, 0x0008, };
 
+/* not used
 static u16 t21142_csr13[] = { 0x0001, 0x0009, 0x0009, 0x0000, 0x0001, };
+*/
 static u16 t21142_csr14[] = { 0xFFFF, 0x0705, 0x0705, 0x0000, 0x7F3D, };
+/* not used
 static u16 t21142_csr15[] = { 0x0008, 0x0006, 0x000E, 0x0008, 0x0008, };
+*/
 
 /* Offsets to the Command and Status Registers, "CSRs".  All accesses
    must be longword instructions and quadword aligned. */
@@ -300,6 +304,14 @@
     TxFIFOUnderflow=0x20, TxJabber=0x08, TxNoBuf=0x04, TxDied=0x02, TxIntr=0x01,
 };
 
+/* The configuration bits in CSR6. */
+enum csr6_mode_bits {
+	TxOn=0x2000, RxOn=0x0002, FullDuplex=0x0200,
+	AcceptBroadcast=0x0100, AcceptAllMulticast=0x0080,
+	AcceptAllPhys=0x0040, AcceptRunt=0x0008,
+};
+
+
 enum desc_status_bits {
     DescOwnded=0x80000000, RxDescFatalErr=0x8000, RxWholePkt=0x0300,
 };
@@ -384,21 +396,11 @@
 
 #define TX_RING_SIZE	2
 static struct tulip_tx_desc tx_ring[TX_RING_SIZE] __attribute__ ((aligned(4)));
-
-#ifdef USE_LOWMEM_BUFFER
-#define txb ((char *)0x10000 - BUFLEN)
-#else
 static unsigned char txb[BUFLEN] __attribute__ ((aligned(4)));
-#endif
 
 #define RX_RING_SIZE	4
 static struct tulip_rx_desc rx_ring[RX_RING_SIZE] __attribute__ ((aligned(4)));
-
-#ifdef USE_LOWMEM_BUFFER
-#define rxb ((char *)0x10000 - RX_RING_SIZE * BUFLEN - BUFLEN)
-#else
 static unsigned char rxb[RX_RING_SIZE * BUFLEN] __attribute__ ((aligned(4)));
-#endif
 
 static struct tulip_private {
     int cur_rx;
@@ -471,7 +473,6 @@
 static const char * block_name[] = {"21140 non-MII", "21140 MII PHY",
                                     "21142 Serial PHY", "21142 MII PHY", "21143 SYM PHY", "21143 reset method"};
 
-
 /*********************************************************************/
 /* Function Prototypes                                               */
 /*********************************************************************/
@@ -479,14 +480,13 @@
 static void mdio_write(struct nic *nic, int phy_id, int location, int value);
 static int read_eeprom(unsigned long ioaddr, int location, int addr_len);
 static void parse_eeprom(struct nic *nic);
-struct nic *tulip_probe(struct nic *nic, unsigned short *io_addrs,
-                        struct pci_device *pci);
+static int tulip_probe(struct dev *dev, struct pci_device *pci);
 static void tulip_init_ring(struct nic *nic);
 static void tulip_reset(struct nic *nic);
 static void tulip_transmit(struct nic *nic, const char *d, unsigned int t,
                            unsigned int s, const char *p);
-static int tulip_poll(struct nic *nic);
-static void tulip_disable(struct nic *nic);
+static int tulip_poll(struct nic *nic, int retrieve);
+static void tulip_disable(struct dev *dev);
 static void nway_start(struct nic *nic);
 static void pnic_do_nway(struct nic *nic);
 static void select_media(struct nic *nic, int startup);
@@ -504,7 +504,6 @@
 static void tulip_more(void);
 #endif
 
-
 /*********************************************************************/
 /* Utility Routines                                                  */
 /*********************************************************************/
@@ -535,7 +534,6 @@
         /* wait */ ;
 }
 
-
 /*********************************************************************/
 /* Media Descriptor Code                                             */
 /*********************************************************************/
@@ -565,7 +563,7 @@
    MDIO protocol.  See the MII specifications or DP83840A data sheet
    for details. */
 
-int mdio_read(struct nic *nic, int phy_id, int location)
+int mdio_read(struct nic *nic __unused, int phy_id, int location)
 {
     int i;
     int read_cmd = (0xf6 << 10) | (phy_id << 5) | location;
@@ -626,7 +624,7 @@
     return (retval>>1) & 0xffff;
 }
 
-void mdio_write(struct nic *nic, int phy_id, int location, int value)
+void mdio_write(struct nic *nic __unused, int phy_id, int location, int value)
 {
     int i;
     int cmd = (0x5002 << 16) | (phy_id << 23) | (location<<18) | value;
@@ -682,7 +680,6 @@
     }
 }
 
-
 /*********************************************************************/
 /* EEPROM Reading Code                                               */
 /*********************************************************************/
@@ -727,7 +724,6 @@
     return retval;
 }
 
-
 /*********************************************************************/
 /* EEPROM Parsing Code                                               */
 /*********************************************************************/
@@ -895,11 +891,10 @@
     }
 }
 
-
 /*********************************************************************/
 /* tulip_init_ring - setup the tx and rx descriptors                */
 /*********************************************************************/
-static void tulip_init_ring(struct nic *nic)
+static void tulip_init_ring(struct nic *nic __unused)
 {
     int i;
 
@@ -935,7 +930,22 @@
     /* Mark the last entry as wrapping the ring, though this should never happen */
     tx_ring[1].length  = cpu_to_le32(DESC_RING_WRAP | BUFLEN);
 }
-
+
+static void set_rx_mode(struct nic *nic __unused) {
+	int csr6 = inl(ioaddr + CSR6) & ~0x00D5;
+
+	tp->csr6 &= ~0x00D5;
+ 
+	/* !IFF_PROMISC */
+	tp->csr6 |= AcceptAllMulticast;
+	csr6 |= AcceptAllMulticast;
+
+	outl(csr6, ioaddr + CSR6);
+
+	
+	
+}
+
 /*********************************************************************/
 /* eth_reset - Reset adapter                                         */
 /*********************************************************************/
@@ -943,7 +953,6 @@
 {
     int i;
     unsigned long to;
-    u32 addr_low, addr_high;
 
 #ifdef TULIP_DEBUG_WHERE
     whereami("tulip_reset\n");
@@ -956,7 +965,7 @@
     if (tp->mii_cnt  ||  (tp->mtable  &&  tp->mtable->has_mii)) {
 	outl(0x814C0000, ioaddr + CSR6);
     }
-  
+ 
     /* Reset the chip, holding bit 0 set at least 50 PCI cycles. */
     outl(0x00000001, ioaddr + CSR0);
     tulip_wait(1);
@@ -1022,8 +1031,8 @@
     }
 
     /* Point to rx and tx descriptors */
-    outl((unsigned long)&rx_ring[0], ioaddr + CSR3);
-    outl((unsigned long)&tx_ring[0], ioaddr + CSR4);
+    outl(virt_to_le32desc(&rx_ring[0]), ioaddr + CSR3);
+    outl(virt_to_le32desc(&tx_ring[0]), ioaddr + CSR4);
 
     init_media(nic);
 
@@ -1049,11 +1058,12 @@
     if (tp->chip_id == LC82C168)
 	tulip_check_duplex(nic);
 
+    set_rx_mode(nic); 	
+        
     /* enable transmit and receive */
     outl(tp->csr6 | 0x00002002, ioaddr + CSR6);
 }
 
-
 /*********************************************************************/
 /* eth_transmit - Transmit a frame                                   */
 /*********************************************************************/
@@ -1095,7 +1105,7 @@
     tx_ring[0].status = cpu_to_le32(0x80000000);
 
     /* Point to transmit descriptor */
-    outl((u32)&tx_ring[0], ioaddr + CSR4);
+    outl(virt_to_le32desc(&tx_ring[0]), ioaddr + CSR4);
 
     /* Enable Tx */
     outl(csr6 | 0x00002000, ioaddr + CSR6);
@@ -1113,11 +1123,11 @@
     /* Disable Tx */
     outl(csr6 & ~0x00002000, ioaddr + CSR6);
 }
-
+
 /*********************************************************************/
 /* eth_poll - Wait for a frame                                       */
 /*********************************************************************/
-static int tulip_poll(struct nic *nic)
+static int tulip_poll(struct nic *nic, int retrieve)
 {
 
 #ifdef TULIP_DEBUG_WHERE
@@ -1128,6 +1138,8 @@
     if (rx_ring[tp->cur_rx].status & 0x80000000)
         return 0;
 
+    if ( ! retrieve ) return 1;
+
 #ifdef TULIP_DEBUG_WHERE
     whereami("tulip_poll got one\n");
 #endif
@@ -1151,17 +1163,20 @@
 
     return 1;
 }
-
+
 /*********************************************************************/
 /* eth_disable - Disable the interface                               */
 /*********************************************************************/
-static void tulip_disable(struct nic *nic)
+static void tulip_disable(struct dev *dev)
 {
-
+    struct nic *nic = (struct nic *)dev;
 #ifdef TULIP_DEBUG_WHERE
     whereami("tulip_disable\n");
 #endif
 
+    /* merge reset and disable */
+    tulip_reset(nic);
+
     /* disable interrupts */
     outl(0x00000000, ioaddr + CSR7);
 
@@ -1171,24 +1186,41 @@
     /* Clear the missed-packet counter. */
     (volatile unsigned long)inl(ioaddr + CSR8);
 }
-
+
+/*********************************************************************/
+/*IRQ - Enable, Disable, or Force interrupts                         */
+/*********************************************************************/
+static void tulip_irq(struct nic *nic __unused, irq_action_t action __unused)
+{
+  switch ( action ) {
+  case DISABLE :
+    break;
+  case ENABLE :
+    break;
+  case FORCE :
+    break;
+  }
+}
+
 /*********************************************************************/
 /* eth_probe - Look for an adapter                                   */
 /*********************************************************************/
-struct nic *tulip_probe(struct nic *nic, unsigned short *io_addrs,
-                        struct pci_device *pci)
+static int tulip_probe(struct dev *dev, struct pci_device *pci)
 {
-    u32 i, l1, l2;
+    struct nic *nic = (struct nic *)dev;
+    u32 i;
     u8  chip_rev;
     u8 ee_data[EEPROM_SIZE];
     unsigned short sum;
     int chip_idx;
     static unsigned char last_phys_addr[ETH_ALEN] = {0x00, 'L', 'i', 'n', 'u', 'x'};
 
-    if (io_addrs == 0 || *io_addrs == 0)
+    if (pci->ioaddr == 0)
         return 0;
 
-    ioaddr         = *io_addrs;
+    ioaddr         = pci->ioaddr;
+    nic->ioaddr    = pci->ioaddr & ~3;
+    nic->irqno     = 0;
 
     /* point to private storage */
     tp = &tpx;
@@ -1378,15 +1410,15 @@
     /* reset the device and make ready for tx and rx of packets */
     tulip_reset(nic);
 
-    nic->reset    = tulip_reset;
+    dev->disable  = tulip_disable;
     nic->poll     = tulip_poll;
     nic->transmit = tulip_transmit;
-    nic->disable  = tulip_disable;
+    nic->irq      = tulip_irq;
 
     /* give the board a chance to reset before returning */
     tulip_wait(4*TICKS_PER_SEC);
 
-    return nic;
+    return 1;
 }
 
 static void start_link(struct nic *nic)
@@ -1508,7 +1540,7 @@
     }
 }
 
-static void nway_start(struct nic *nic)
+static void nway_start(struct nic *nic __unused)
 {
     int csr14 = ((tp->sym_advertise & 0x0780) << 9)  |
         ((tp->sym_advertise&0x0020)<<1) | 0xffbf;
@@ -1662,7 +1694,7 @@
     }
 }
 
-static void pnic_do_nway(struct nic *nic)
+static void pnic_do_nway(struct nic *nic __unused)
 {
     u32 phy_reg = inl(ioaddr + 0xB8);
     u32 new_csr6 = tp->csr6 & ~0x40C40200;
@@ -1886,8 +1918,8 @@
         }
     } else if (tp->chip_id == DC21040) {                                        /* 21040 */
         /* Turn on the xcvr interface. */
-        int csr12 = inl(ioaddr + CSR12);
 #ifdef TULIP_DEBUG
+        int csr12 = inl(ioaddr + CSR12);
         if (tulip_debug > 1)
             printf("%s: 21040 media type is %s, CSR12 is %hhX.\n",
                    tp->nic_name, medianame[tp->if_port], csr12);
@@ -1987,3 +2019,51 @@
 
         return 0;
 }
+
+static struct pci_id tulip_nics[] = {
+PCI_ROM(0x1011, 0x0002, "dc21040",     "Digital Tulip"),
+PCI_ROM(0x1011, 0x0009, "ds21140",     "Digital Tulip Fast"),
+PCI_ROM(0x1011, 0x0014, "dc21041",     "Digital Tulip+"),
+PCI_ROM(0x1011, 0x0019, "ds21142",     "Digital Tulip 21142"),
+PCI_ROM(0x10b7, 0x9300, "3csoho100b-tx","3ComSOHO100B-TX"),
+PCI_ROM(0x10b9, 0x5261, "ali1563",     "ALi 1563 integrated ethernet"),
+PCI_ROM(0x10d9, 0x0512, "mx98713",     "Macronix MX987x3"),
+PCI_ROM(0x10d9, 0x0531, "mx98715",     "Macronix MX987x5"),
+PCI_ROM(0x1113, 0x1217, "mxic-98715",  "Macronix MX987x5"),
+PCI_ROM(0x11ad, 0xc115, "lc82c115",    "LinkSys LNE100TX"),
+PCI_ROM(0x11ad, 0x0002, "82c168",      "Netgear FA310TX"),
+PCI_ROM(0x1282, 0x9100, "dm9100",      "Davicom 9100"),
+PCI_ROM(0x1282, 0x9102, "dm9102",      "Davicom 9102"),
+PCI_ROM(0x1282, 0x9009, "dm9009",      "Davicom 9009"),
+PCI_ROM(0x1282, 0x9132, "dm9132",      "Davicom 9132"),
+PCI_ROM(0x1317, 0x0985, "centaur-p",   "ADMtek Centaur-P"),
+PCI_ROM(0x1317, 0x0981, "an981",       "ADMtek AN981 Comet"),		/* ADMTek Centaur-P (stmicro) */
+PCI_ROM(0x1113, 0x1216, "an983",       "ADMTek AN983 Comet"),
+PCI_ROM(0x1317, 0x9511, "an983b",      "ADMTek Comet 983b"),
+PCI_ROM(0x1317, 0x1985, "centaur-c",   "ADMTek Centaur-C"),
+PCI_ROM(0x8086, 0x0039, "intel21145",  "Intel Tulip"),
+PCI_ROM(0x125b, 0x1400, "ax88140",     "ASIX AX88140"),
+PCI_ROM(0x11f6, 0x9881, "rl100tx",     "Compex RL100-TX"),
+PCI_ROM(0x115d, 0x0003, "xircomtulip", "Xircom Tulip"),
+PCI_ROM(0x104a, 0x0981, "tulip-0981",  "Tulip 0x104a 0x0981"),
+PCI_ROM(0x104a, 0x2774, "tulip-2774",  "Tulip 0x104a 0x2774"),
+PCI_ROM(0x1113, 0x9511, "tulip-9511",  "Tulip 0x1113 0x9511"),
+PCI_ROM(0x1186, 0x1561, "tulip-1561",  "Tulip 0x1186 0x1561"),
+PCI_ROM(0x1259, 0xa120, "tulip-a120",  "Tulip 0x1259 0xa120"),
+PCI_ROM(0x13d1, 0xab02, "tulip-ab02",  "Tulip 0x13d1 0xab02"),
+PCI_ROM(0x13d1, 0xab03, "tulip-ab03",  "Tulip 0x13d1 0xab03"),
+PCI_ROM(0x13d1, 0xab08, "tulip-ab08",  "Tulip 0x13d1 0xab08"),
+PCI_ROM(0x14f1, 0x1803, "lanfinity",   "Conexant LANfinity"),
+PCI_ROM(0x1626, 0x8410, "tulip-8410",  "Tulip 0x1626 0x8410"),
+PCI_ROM(0x1737, 0xab08, "tulip-1737-ab08","Tulip 0x1737 0xab08"),
+PCI_ROM(0x1737, 0xab09, "tulip-ab09",  "Tulip 0x1737 0xab09"),
+};
+
+struct pci_driver tulip_driver = {
+	.type     = NIC_DRIVER,
+	.name     = "Tulip",
+	.probe    = tulip_probe,
+	.ids      = tulip_nics,
+	.id_count = sizeof(tulip_nics)/sizeof(tulip_nics[0]),
+	.class    = 0,
+};
diff -Naur grub-0.97.orig/netboot/tulip.txt grub-0.97/netboot/tulip.txt
--- grub-0.97.orig/netboot/tulip.txt	2003-07-09 11:45:38.000000000 +0000
+++ grub-0.97/netboot/tulip.txt	1970-01-01 00:00:00.000000000 +0000
@@ -1,53 +0,0 @@
-This software may be used and distributed according to the terms of
-the GNU Public License, incorporated herein by reference.
-
-This is a tulip and clone driver for Etherboot.  See the revision
-history in the tulip.c file for information on changes.  This version
-of the driver incorporates changes from Bob Edwards and Paul Mackerras
-who cantributed changes to support the TRENDnet TE100-PCIA NIC which
-uses a genuine Intel 21143-PD chipset.  There are also various code
-cleanups to make time-based activities more reliable.
-
-Of course you have to have all the usual Etherboot environment
-(bootp/dhcp/NFS) set up, and you need a Linux kernel with v0.91g
-(7.16.99) or later of the tulip.c driver compiled in to support some
-MX98715 based cards.  That file is available at:
-
-  http://cesdis.gsfc.nasa.gov/linux/drivers/test/tulip.c
-
-NOTES
-
-I've tested this driver with a SOHOware Fast 10/100 Model SDA110A,
-a Linksys LNE100TX v2.0, and a Netgear FA310TX card, and it worked at
-both 10 and 100 mbits. Other cards based on the tulip family may work as
-well.
-
-These cards are about 20$US, are supported by Linux and now Etherboot,
-and being PCI, they auto-configure IRQ and IOADDR and auto-negotiate
-10/100 half/full duplex. It seems like a pretty good value compared to
-some of the pricier cards, and can lower the cost of building/adapting
-thin client workstations substantially while giving a considerable
-performance increase.
-
-On some PCI tulip clone chipsets (MX987x5, LC82C115, LC82C168) this driver 
-lets the card choose the fastest speed it can negotiate with the peer
-device.  On other cards, it chooses 10mbit half-duplex.
-
-I burned an AM27C256 (32KByte) EPROM with mx987x5.lzrom and it worked.
-According to the data sheet the MX98715A supports up to 64K (27C512)
-EPROMs, 
-
-I've liberally commented the code and header files in the hope that it
-will help the next person who hacks the code or needs to support some
-tulip clone card, or wishes to add functionality.
-
-Anyway, please test this if you can on your tulip based card, and let
-me (mdc@thinguin.org) and the netboot list (netboot@baghira.han.de)
-know how things go.  I also would appreciate code review by people who
-program.  I'm a strong believer in "another set of eyes".
-
-Regards,
-
-Marty Connor
-mdc@thinguin.org
-http://www.thinguin.org/
diff -Naur grub-0.97.orig/netboot/types.h grub-0.97/netboot/types.h
--- grub-0.97.orig/netboot/types.h	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/types.h	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,44 @@
+#ifndef _TYPES_H
+#define _TYPES_H
+
+/* I'm architecture independed :-) */
+
+/* 
+ * It's architecture depended headers for common integer types
+ */
+#include "stdint.h"
+
+/* 
+ * Here are some RPC types define from linux /usr/include/rpc/types.h
+ */
+typedef int bool_t;
+typedef int enum_t;
+typedef uint32_t rpcprog_t;
+typedef uint32_t rpcvers_t;
+typedef uint32_t rpcproc_t;
+typedef uint32_t rpcprot_t;
+typedef uint32_t rpcport_t;
+
+/* For bool_t */
+/* typedef enum { */
+/*  	FALSE = 0, */
+/*  	TRUE = 1 */
+/* } boolean_t; */
+
+
+
+/* Some BSD or RPC style types */
+typedef unsigned char u_char;
+typedef unsigned short u_short;
+typedef unsigned int u_int;
+typedef unsigned long u_long;
+typedef long long quad_t;
+typedef unsigned long long u_quad_t;
+typedef struct {
+	int __val[2];
+}fsid_t;			/* Type of file system IDs, from bits/types.h */
+
+typedef int daddr_t;		/* The type of a disk address, from bits/types.h */
+typedef char * caddr_t;
+
+#endif /* _TYPES_H */
diff -Naur grub-0.97.orig/netboot/udp.h grub-0.97/netboot/udp.h
--- grub-0.97.orig/netboot/udp.h	1970-01-01 00:00:00.000000000 +0000
+++ grub-0.97/netboot/udp.h	2005-08-31 19:03:35.000000000 +0000
@@ -0,0 +1,30 @@
+#ifndef	_UDP_H
+#define	_UDP_H
+
+/* We need 'uint16_t' and 'uint8_t'  */
+#include "types.h"
+/* We need 'in_addr' */
+#include "in.h"
+
+struct udp_pseudo_hdr {
+	in_addr  src;
+	in_addr  dest;
+	uint8_t  unused;
+	uint8_t  protocol;
+	uint16_t len;
+};
+struct udphdr {
+	uint16_t src;
+	uint16_t dest;
+	uint16_t len;
+	uint16_t chksum;
+};
+
+extern void build_udp_hdr(unsigned long __destip, unsigned int __srcsock, 
+	      unsigned int __destsock, int __ttl, int __len, 
+	      const void * __buf);
+
+extern int udp_transmit(unsigned long __destip, unsigned int __srcsock,
+			unsigned int __destsock, int __len, const void * __buf);
+
+#endif	/* _UDP_H */
diff -Naur grub-0.97.orig/netboot/via-rhine.c grub-0.97/netboot/via-rhine.c
--- grub-0.97.orig/netboot/via-rhine.c	2003-07-09 11:45:38.000000000 +0000
+++ grub-0.97/netboot/via-rhine.c	2005-08-31 19:03:35.000000000 +0000
@@ -18,7 +18,7 @@
 
 */
 
-static const char *version = "rhine.c v1.0.0 2000-01-07\n";
+static const char *version = "rhine.c v1.0.1 2003-02-06\n";
 
 /* A few user-configurable values. */
 
@@ -46,7 +46,6 @@
 #include "etherboot.h"
 #include "nic.h"
 #include "pci.h"
-#include "cards.h"
 
 /* define all ioaddr */
 
@@ -103,6 +102,11 @@
 #define byCFGD				ioaddr + 0x7b
 #define wTallyCntMPA			ioaddr + 0x7c
 #define wTallyCntCRC			ioaddr + 0x7d
+#define bySTICKHW			ioaddr + 0x83
+#define byWOLcrClr			ioaddr + 0xA4
+#define byWOLcgClr			ioaddr + 0xA7
+#define byPwrcsrClr			ioaddr + 0xAC
+
 /*---------------------  Exioaddr Definitions -------------------------*/
 
 /*
@@ -617,9 +621,6 @@
 
 */
 
-#define PCI_VENDOR_ID_FET		0x1106
-#define PCI_DEVICE_ID_FET_3043		0x3043
-
 /* The rest of these values should never change. */
 #define NUM_TX_DESC	2	/* Number of Tx descriptor registers. */
 
@@ -652,23 +653,19 @@
 }
 rhine;
 
-static struct nic *rhine_probe1 (struct nic *dev, int ioaddr,
+static void rhine_probe1 (struct nic *nic, int ioaddr,
 				 int chip_id, int options);
 static int QueryAuto (int);
 static int ReadMII (int byMIIIndex, int);
 static void WriteMII (char, char, char, int);
 static void MIIDelay (void);
 static void rhine_init_ring (struct nic *dev);
-static void rhine_disable (struct nic *nic);
+static void rhine_disable (struct dev *dev);
 static void rhine_reset (struct nic *nic);
-static int rhine_poll (struct nic *nic);
+static int rhine_poll (struct nic *nic, int retreive);
 static void rhine_transmit (struct nic *nic, const char *d, unsigned int t,
 			    unsigned int s, const char *p);
 
-/* Linux support functions */
-#define virt_to_bus(x) ((unsigned long)x)
-#define bus_to_virt(x) ((void *)x)
-
 /* Initialize the Rx and Tx rings, along with various 'dev' bits. */
 static void
 rhine_init_ring (struct nic *nic)
@@ -854,26 +851,99 @@
     }
 }
 
-struct nic *
-rhine_probe (struct nic *nic, unsigned short *probeaddrs,
-	       struct pci_device *pci)
+/* Offsets to the device registers. */
+enum register_offsets {
+        StationAddr=0x00, RxConfig=0x06, TxConfig=0x07, ChipCmd=0x08,
+        IntrStatus=0x0C, IntrEnable=0x0E,
+        MulticastFilter0=0x10, MulticastFilter1=0x14,
+        RxRingPtr=0x18, TxRingPtr=0x1C, GFIFOTest=0x54,
+        MIIPhyAddr=0x6C, MIIStatus=0x6D, PCIBusConfig=0x6E,
+        MIICmd=0x70, MIIRegAddr=0x71, MIIData=0x72, MACRegEEcsr=0x74,
+        ConfigA=0x78, ConfigB=0x79, ConfigC=0x7A, ConfigD=0x7B,
+        RxMissed=0x7C, RxCRCErrs=0x7E, MiscCmd=0x81,
+        StickyHW=0x83, IntrStatus2=0x84, WOLcrClr=0xA4, WOLcgClr=0xA7,
+        PwrcsrClr=0xAC,
+};
+
+/* Bits in the interrupt status/mask registers. */
+enum intr_status_bits {
+        IntrRxDone=0x0001, IntrRxErr=0x0004, IntrRxEmpty=0x0020,
+        IntrTxDone=0x0002, IntrTxError=0x0008, IntrTxUnderrun=0x0210,
+        IntrPCIErr=0x0040,
+        IntrStatsMax=0x0080, IntrRxEarly=0x0100,
+        IntrRxOverflow=0x0400, IntrRxDropped=0x0800, IntrRxNoBuf=0x1000,
+        IntrTxAborted=0x2000, IntrLinkChange=0x4000,
+        IntrRxWakeUp=0x8000,
+        IntrNormalSummary=0x0003, IntrAbnormalSummary=0xC260,
+        IntrTxDescRace=0x080000,        /* mapped from IntrStatus2 */
+        IntrTxErrSummary=0x082218,
+};
+#define DEFAULT_INTR (IntrRxDone | IntrRxErr | IntrRxEmpty| IntrRxOverflow | \
+                   IntrRxDropped | IntrRxNoBuf) 
+
+/***************************************************************************
+ IRQ - PXE IRQ Handler
+***************************************************************************/
+void rhine_irq ( struct nic *nic, irq_action_t action ) {
+     struct rhine_private *tp = (struct rhine_private *) nic->priv_data;
+     /* Enable interrupts by setting the interrupt mask. */
+     unsigned int intr_status;
+
+     switch ( action ) {
+          case DISABLE :
+          case ENABLE :
+               intr_status = inw(nic->ioaddr + IntrStatus);
+               /* On Rhine-II, Bit 3 indicates Tx descriptor write-back race. */
+               if (tp->chip_id == 0x3065)
+                   intr_status |= inb(nic->ioaddr + IntrStatus2) << 16;
+               intr_status = (intr_status & ~DEFAULT_INTR);
+               if ( action == ENABLE ) 
+                   intr_status = intr_status | DEFAULT_INTR;
+               outw(intr_status, nic->ioaddr + IntrEnable);
+               break;
+         case FORCE :
+               outw(0x0010, nic->ioaddr + 0x84);
+               break;
+         }
+}
+
+static int
+rhine_probe (struct dev *dev, struct pci_device *pci)
 {
+    struct nic *nic = (struct nic *)dev;
+    struct rhine_private *tp = &rhine;
     if (!pci->ioaddr)
-	return NULL;
-    nic = rhine_probe1 (nic, pci->ioaddr, 0, -1);
+	return 0;
+    rhine_probe1 (nic, pci->ioaddr, pci->dev_id, -1);
 
-    if (nic)
-	adjust_pci_device(pci);
-    nic->poll = rhine_poll;
-    nic->transmit = rhine_transmit;
-    nic->reset = rhine_reset;
-    nic->disable = rhine_disable;
+    adjust_pci_device(pci);
     rhine_reset (nic);
 
-    return nic;
+    dev->disable  = rhine_disable;
+    nic->poll     = rhine_poll;
+    nic->transmit = rhine_transmit;
+    nic->irqno	  = pci->irq;
+    nic->irq      = rhine_irq;
+    nic->ioaddr   = tp->ioaddr;
+
+
+    return 1;
+}
+
+static void set_rx_mode(struct nic *nic __unused) {
+    	struct rhine_private *tp = (struct rhine_private *) nic->priv_data;
+	unsigned char rx_mode;
+    	int ioaddr = tp->ioaddr;
+
+	/* ! IFF_PROMISC */
+	outl(0xffffffff, byMAR0);
+	outl(0xffffffff, byMAR4);
+	rx_mode = 0x0C;
+
+	outb(0x60 /* thresh */ | rx_mode, byRCR );
 }
 
-static struct nic *
+static void
 rhine_probe1 (struct nic *nic, int ioaddr, int chip_id, int options)
 {
     struct rhine_private *tp;
@@ -885,6 +955,29 @@
 
     if (rhine_debug > 0 && did_version++ == 0)
 	printf (version);
+
+    /* D-Link provided reset code (with comment additions) */
+    if((chip_id != 0x3043) && (chip_id != 0x6100)) {
+	unsigned char byOrgValue;
+	
+	if(rhine_debug > 0)
+		printf("Enabling Sticky Bit Workaround for Chip_id: 0x%hX\n"
+				, chip_id);
+	/* clear sticky bit before reset & read ethernet address */
+	byOrgValue = inb(bySTICKHW);
+	byOrgValue = byOrgValue & 0xFC;
+	outb(byOrgValue, bySTICKHW);
+
+	/* (bits written are cleared?) */
+	/* disable force PME-enable */
+	outb(0x80, byWOLcgClr);
+	/* disable power-event config bit */
+	outb(0xFF, byWOLcrClr);
+	/* clear power status (undocumented in vt6102 docs?) */
+	outb(0xFF, byPwrcsrClr);
+	
+    }
+
     /* Perhaps this should be read from the EEPROM? */
     for (i = 0; i < ETH_ALEN; i++)
 	nic->node_addr[i] = inb (byPAR0 + i);
@@ -920,6 +1013,7 @@
 	}
 #endif
 
+    
     /* query MII to know LineSpeed,duplex mode */
     byMIIvalue = inb (ioaddr + 0x6d);
     LineSpeed = byMIIvalue & MIISR_SPEED;
@@ -971,15 +1065,19 @@
 	if (tp->default_port)
 	    tp->medialock = 1;
     }
-    return nic;
+    return;
 }
 
-static void
-rhine_disable (struct nic *nic)
+static void 
+rhine_disable (struct dev *dev)
 {
+    struct nic *nic = (struct nic *)dev;
     struct rhine_private *tp = (struct rhine_private *) nic->priv_data;
     int ioaddr = tp->ioaddr;
 
+    /* merge reset and disable */
+    rhine_reset(nic);
+
     printf ("rhine disable\n");
     /* Switch to loopback mode to avoid hardware races. */
     writeb(0x60 | 0x01, byTCR);
@@ -1002,17 +1100,10 @@
     int rx_bufs_tmp, rx_bufs_tmp1;
     int tx_bufs_tmp, tx_bufs_tmp1;
 
-#ifdef	USE_LOWMEM_BUFFER
-#define buf1 (0x10000 - (RX_RING_SIZE * PKT_BUF_SZ + 32))
-#define buf2 (buf1 - (RX_RING_SIZE * PKT_BUF_SZ + 32))
-#define desc1 (buf2 - (TX_RING_SIZE * sizeof (struct rhine_tx_desc) + 32))
-#define desc2 (desc1 - (TX_RING_SIZE * sizeof (struct rhine_tx_desc) + 32))
-#else
     static char buf1[RX_RING_SIZE * PKT_BUF_SZ + 32];
     static char buf2[RX_RING_SIZE * PKT_BUF_SZ + 32];
     static char desc1[TX_RING_SIZE * sizeof (struct rhine_tx_desc) + 32];
     static char desc2[TX_RING_SIZE * sizeof (struct rhine_tx_desc) + 32];
-#endif
 
     /* printf ("rhine_reset\n"); */
     /* Soft reset the chip. */
@@ -1069,6 +1160,9 @@
     outl (virt_to_bus (tp->rx_ring), dwCurrentRxDescAddr);
     outl (virt_to_bus (tp->tx_ring), dwCurrentTxDescAddr);
 
+    /* Setup Multicast */	
+    set_rx_mode(nic);
+
     /* close IMR */
     outw (0x0000, byIMR0);
 
@@ -1093,15 +1187,34 @@
     /*set IMR to work */
     outw (IMRShadow, byIMR0);
 }
+/* Beware of PCI posted writes */
+#define IOSYNC  do { readb(nic->ioaddr + StationAddr); } while (0)
 
 static int
-rhine_poll (struct nic *nic)
+rhine_poll (struct nic *nic, int retreive)
 {
     struct rhine_private *tp = (struct rhine_private *) nic->priv_data;
     int rxstatus, good = 0;;
 
     if (tp->rx_ring[tp->cur_rx].rx_status.bits.own_bit == 0)
     {
+        unsigned int intr_status;
+        /* There is a packet ready */
+        if(!retreive)
+            return 1;
+
+        intr_status = inw(nic->ioaddr + IntrStatus);
+        /* On Rhine-II, Bit 3 indicates Tx descriptor write-back race. */
+#if 0
+	if (tp->chip_id == 0x3065)
+	  intr_status |= inb(nic->ioaddr + IntrStatus2) << 16;
+#endif
+        /* Acknowledge all of the current interrupt sources ASAP. */
+        if (intr_status & IntrTxDescRace)
+           outb(0x08, nic->ioaddr + IntrStatus2);
+        outw(intr_status & 0xffff, nic->ioaddr + IntrStatus);
+	IOSYNC;
+
 	rxstatus = tp->rx_ring[tp->cur_rx].rx_status.lw;
 	if ((rxstatus & 0x0300) != 0x0300)
 	{
@@ -1124,6 +1237,11 @@
 	tp->cur_rx++;
 	tp->cur_rx = tp->cur_rx % RX_RING_SIZE;
     }
+        /* Acknowledge all of the current interrupt sources ASAP. */
+        outw(DEFAULT_INTR & ~IntrRxDone, nic->ioaddr + IntrStatus);
+
+        IOSYNC;
+
     return good;
 }
 
@@ -1152,7 +1270,7 @@
     while (s < ETH_ZLEN)
 	*((char *) tp->tx_buffs[entry] + ETH_HLEN + (s++)) = 0;
 
-    tp->tx_ring[entry].tx_ctrl.bits.tx_buf_size = ETH_HLEN + s;
+    tp->tx_ring[entry].tx_ctrl.bits.tx_buf_size = s;
 
     tp->tx_ring[entry].tx_status.bits.own_bit = 1;
 
@@ -1170,6 +1288,9 @@
     /*printf("td4=[%X]",inl(dwCurrentTDSE3)); */
 
     outb (CR1bak, byCR1);
+    /* Wait until transmit is finished */
+    while (tp->tx_ring[entry].tx_status.bits.own_bit != 0)
+	;
     tp->cur_tx++;
 
     /*outw(IMRShadow,byIMR0); */
@@ -1177,4 +1298,21 @@
     /*tp->tx_skbuff[entry] = 0; */
 }
 
+static struct pci_id rhine_nics[] = {
+PCI_ROM(0x1106, 0x3065, "dlink-530tx",     "VIA 6102"),
+PCI_ROM(0x1106, 0x3106, "via-rhine-6105",  "VIA 6105"),
+PCI_ROM(0x1106, 0x3043, "dlink-530tx-old", "VIA 3043"),		/* Rhine-I 86c100a */
+PCI_ROM(0x1106, 0x3053, "via6105m",        "VIA 6105M"),	
+PCI_ROM(0x1106, 0x6100, "via-rhine-old",   "VIA 86C100A"),	/* Rhine-II */
+};
+
+struct pci_driver rhine_driver = {
+	.type     = NIC_DRIVER,
+	.name     = "VIA 86C100",
+	.probe    = rhine_probe,
+	.ids      = rhine_nics,
+	.id_count = sizeof(rhine_nics)/sizeof(rhine_nics[0]),
+	.class    = 0,
+};
+
 /* EOF via-rhine.c */
diff -Naur grub-0.97.orig/netboot/w89c840.c grub-0.97/netboot/w89c840.c
--- grub-0.97.orig/netboot/w89c840.c	2003-07-09 11:45:38.000000000 +0000
+++ grub-0.97/netboot/w89c840.c	2005-08-31 19:03:35.000000000 +0000
@@ -43,6 +43,9 @@
  *                                       using timer2 routines. Proposed
  *                                       by Ken Yap to eliminate CPU speed
  *                                       dependency.
+ *             Dec 12 2003  V0.94   timlegge	Fixed issues in 5.2, removed 
+ *             					interrupt usage, enabled
+ *             					multicast support
  *
  * This is the etherboot driver for cards based on Winbond W89c840F chip.
  *
@@ -77,10 +80,9 @@
 #include "etherboot.h"
 #include "nic.h"
 #include "pci.h"
-#include "cards.h"
 #include "timer.h"
 
-static const char *w89c840_version = "diver Version 0.92 - August 27, 2000";
+static const char *w89c840_version = "driver Version 0.94 - December 12, 2003";
 
 typedef unsigned char  u8;
 typedef   signed char  s8;
@@ -90,9 +92,6 @@
 typedef   signed int   s32;
 
 /* Linux support functions */
-#define virt_to_bus(x) ((unsigned long)x)
-#define bus_to_virt(x) ((void *)x)
-
 #define virt_to_le32desc(addr)  virt_to_bus(addr)
 #define le32desc_to_virt(addr)  bus_to_virt(addr)
 
@@ -109,7 +108,6 @@
    bonding and packet priority.
    There are no ill effects from too-large receive rings. */
 #define TX_RING_SIZE    2
-
 #define RX_RING_SIZE    2
 
 /* The presumed FIFO size for working around the Tx-FIFO-overflow bug.
@@ -260,32 +258,20 @@
 
 static int ioaddr;
 static unsigned short eeprom [0x40];
-
-#ifdef    USE_LOWMEM_BUFFER
-#define rx_packet ((char *)0x10000 - PKT_BUF_SZ * RX_RING_SIZE)
-#define tx_packet ((char *)0x10000 - PKT_BUF_SZ * RX_RING_SIZE - PKT_BUF_SZ * TX_RING_SIZE)
-#else
 static char        rx_packet[PKT_BUF_SZ * RX_RING_SIZE];
 static char        tx_packet[PKT_BUF_SZ * TX_RING_SIZE];
-#endif
 
 static int  eeprom_read(long ioaddr, int location);
 static int  mdio_read(int base_address, int phy_id, int location);
+#if 0
 static void mdio_write(int base_address, int phy_id, int location, int value);
+#endif
 
 static void check_duplex(void);
 static void set_rx_mode(void);
 static void init_ring(void);
 
-/*
-static void wait_long_time(void)
-{
-    printf("Paused - please read output above this line\n");
-    sleep(3);
-}
-*/
-
-#if defined W89C840_DEBUG
+#if defined(W89C840_DEBUG)
 static void decode_interrupt(u32 intr_status)
 {
     printf("Interrupt status: ");
@@ -349,15 +335,17 @@
     check_duplex();
     set_rx_mode();
 
-    /* Clear and Enable interrupts by setting the interrupt mask. */
+    /* Do not enable the interrupts Etherboot doesn't need them */
+/*
     writel(0x1A0F5, ioaddr + IntrStatus);
     writel(0x1A0F5, ioaddr + IntrEnable);
-
+*/
 #if defined(W89C840_DEBUG)
     printf("winbond-840 : Done reset.\n");
 #endif
 }
 
+#if 0
 static void handle_intr(u32 intr_stat)
 {
     if ((intr_stat & (NormalIntr|AbnormalIntr)) == 0) {
@@ -372,7 +360,7 @@
         /* There was an abnormal interrupt */
         printf("\n-=- Abnormal interrupt.\n");
 
-#if defined (W89C840_DEBUG)
+#if defined(W89C840_DEBUG)
         decode_interrupt(intr_stat);
 #endif
 
@@ -383,19 +371,21 @@
         }
     }
 }
+#endif
 
 /**************************************************************************
 w89c840_poll - Wait for a frame
 ***************************************************************************/
-static int w89c840_poll(struct nic *nic)
+static int w89c840_poll(struct nic *nic, int retrieve)
 {
     /* return true if there's an ethernet packet ready to read */
     /* nic->packet should contain data on return */
     /* nic->packetlen should contain length of data */
     int packet_received = 0;
 
+#if defined(W89C840_DEBUG)
     u32 intr_status = readl(ioaddr + IntrStatus);
-    /* handle_intr(intr_status); */ /* -- handled later */
+#endif
 
     do {
         /* Code from netdev_rx(dev) */
@@ -411,6 +401,11 @@
             break;
         }
 
+        if ( !retrieve ) {
+            packet_received = 1;
+            break;
+        }
+
         if ((status & 0x38008300) != 0x0300) {
             if ((status & 0x38000300) != 0x0300) {
                 /* Ingore earlier buffers. */
@@ -478,11 +473,7 @@
         entry = (++w840private.cur_rx) % RX_RING_SIZE;
         w840private.rx_head_desc = &w840private.rx_ring[entry];
     } while (0);
-
-    if (intr_status & (AbnormalIntr | TxFIFOUnderflow | IntrPCIErr |TimerInt | IntrTxStopped)) {
-        handle_intr(intr_status);
-    }
-
+    
     return packet_received;
 }
 
@@ -521,13 +512,13 @@
 
     w840private.tx_ring[entry].buffer1 = virt_to_le32desc(tx_packet);
 
-    w840private.tx_ring[entry].length = (DescWholePkt | s);
+    w840private.tx_ring[entry].length = (DescWholePkt | (u32) s);
     if (entry >= TX_RING_SIZE-1)         /* Wrap ring */
         w840private.tx_ring[entry].length |= (DescIntr | DescEndRing);
     w840private.tx_ring[entry].status = (DescOwn);
     w840private.cur_tx++;
 
-    w840private.tx_q_bytes += s;
+    w840private.tx_q_bytes = (u16) s;
     writel(0, ioaddr + TxStartDemand);
 
     /* Work around horrible bug in the chip by marking the queue as full
@@ -550,33 +541,29 @@
     load_timer2(TX_TIMEOUT);
 
     {
+#if defined W89C840_DEBUG
         u32 intr_stat = 0;
-
+#endif
         while (1) {
 
-            intr_stat = readl(ioaddr + IntrStatus);
 #if defined(W89C840_DEBUG)
-            decode_interrupt(intr_stat);
+	      decode_interrupt(intr_stat);
 #endif
 
-            if (intr_stat & (NormalIntr | IntrTxDone)) {
-
                 while ( (transmit_status & DescOwn) && timer2_running()) {
 
                     transmit_status = w840private.tx_ring[entry].status;
                 }
 
-                writel(intr_stat & 0x0001ffff, ioaddr + IntrStatus);
                 break;
-            }
         }
     }
 
     if ((transmit_status & DescOwn) == 0) {
 
 #if defined(W89C840_DEBUG)
-        printf("winbond-840 : transmission complete after %d wait loop iterations, status %X\n",
-               TX_LOOP_COUNT - transmit_loop_counter, w840private.tx_ring[entry].status);
+        printf("winbond-840 : transmission complete after wait loop iterations, status %X\n",
+                w840private.tx_ring[entry].status);
 #endif
 
         return;
@@ -592,8 +579,12 @@
 /**************************************************************************
 w89c840_disable - Turn off ethernet interface
 ***************************************************************************/
-static void w89c840_disable(struct nic *nic)
+static void w89c840_disable(struct dev *dev)
 {
+    struct nic *nic = (struct nic *)dev;
+    /* merge reset and disable */
+    w89c840_reset(nic);
+
     /* Don't know what to do to disable the board. Is this needed at all? */
     /* Yes, a live NIC can corrupt the loaded memory later [Ken] */
     /* Stop the chip's Tx and Rx processes. */
@@ -601,20 +592,37 @@
 }
 
 /**************************************************************************
+w89c840_irq - Enable, Disable, or Force interrupts
+***************************************************************************/
+static void w89c840_irq(struct nic *nic __unused, irq_action_t action __unused)
+{
+  switch ( action ) {
+  case DISABLE :
+    break;
+  case ENABLE :
+    break;
+  case FORCE :
+    break;
+  }
+}
+
+/**************************************************************************
 w89c840_probe - Look for an adapter, this routine's visible to the outside
 ***************************************************************************/
-struct nic *w89c840_probe(struct nic *nic, unsigned short *probe_addrs, struct pci_device *p)
+static int w89c840_probe(struct dev *dev, struct pci_device *p)
 {
+    struct nic *nic = (struct nic *)dev;
     u16 sum = 0;
-    int i, j, to;
+    int i, j;
     unsigned short value;
-    int options;
-    int promisc;
 
-    if (probe_addrs == 0 || probe_addrs[0] == 0)
+    if (p->ioaddr == 0)
         return 0;
 
-    ioaddr = probe_addrs[0]; /* Mask the bit that says "this is an io addr" */
+    ioaddr      = p->ioaddr;
+    nic->ioaddr = p->ioaddr & ~3;
+    nic->irqno  = 0;
+
 
 #if defined(W89C840_DEBUG)
     printf("winbond-840: PCI bus %hhX device function %hhX: I/O address: %hX\n", p->bus, p->devfn, ioaddr);
@@ -622,8 +630,6 @@
 
     ioaddr = ioaddr & ~3; /* Mask the bit that says "this is an io addr" */
 
-    /* if probe_addrs is 0, then routine can use a hardwired default */
-
     /* From Matt Hortman <mbhortman@acpthinclient.com> */
     if (p->vendor == PCI_VENDOR_ID_WINBOND2
         && p->dev_id == PCI_DEVICE_ID_WINBOND2_89C840) {
@@ -689,14 +695,14 @@
     }
 
     /* point to NIC specific routines */
-    nic->reset = w89c840_reset;
-    nic->poll = w89c840_poll;
+    dev->disable  = w89c840_disable;
+    nic->poll     = w89c840_poll;
     nic->transmit = w89c840_transmit;
-    nic->disable = w89c840_disable;
+    nic->irq      = w89c840_irq;
 
     w89c840_reset(nic);
 
-    return nic;
+    return 1;
 }
 
 /* Read the EEPROM and MII Management Data I/O (MDIO) interfaces.  These are
@@ -814,6 +820,7 @@
     return (retval>>1) & 0xffff;
 }
 
+#if 0
 static void mdio_write(int base_address, int phy_id, int location, int value)
 {
     long mdio_addr = base_address + MIICtrl;
@@ -844,6 +851,7 @@
     }
     return;
 }
+#endif
 
 static void check_duplex(void)
 {
@@ -877,12 +885,10 @@
     memset(mc_filter, 0xff, sizeof(mc_filter));
 
 /*
- * Actually, should work OK with multicast enabled. -- iko
- */
-/*
- *  rx_mode = AcceptBroadcast | AcceptMyPhys | AcceptMulticast;
+ * works OK with multicast enabled. 
  */
-    rx_mode = AcceptBroadcast | AcceptMyPhys;
+
+    rx_mode = AcceptBroadcast | AcceptMyPhys | AcceptMulticast;
 
     writel(mc_filter[0], ioaddr + MulticastFilter0);
     writel(mc_filter[1], ioaddr + MulticastFilter1);
@@ -932,3 +938,18 @@
     }
     return;
 }
+
+
+static struct pci_id w89c840_nics[] = {
+PCI_ROM(0x1050, 0x0840, "winbond840",     "Winbond W89C840F"),
+PCI_ROM(0x11f6, 0x2011, "compexrl100atx", "Compex RL100ATX"),
+};
+
+struct pci_driver w89c840_driver = {
+	.type     = NIC_DRIVER,
+	.name     = "W89C840F",
+	.probe    = w89c840_probe,
+	.ids      = w89c840_nics,
+	.id_count = sizeof(w89c840_nics)/sizeof(w89c840_nics[0]),
+	.class    = 0,
+};
diff -Naur grub-0.97.orig/stage2/disk_io.c grub-0.97/stage2/disk_io.c
--- grub-0.97.orig/stage2/disk_io.c	2004-05-23 16:35:24.000000000 +0000
+++ grub-0.97/stage2/disk_io.c	2005-08-31 19:03:35.000000000 +0000
@@ -25,6 +25,7 @@
 #ifdef SUPPORT_NETBOOT
 # define GRUB	1
 # include <etherboot.h>
+# include <grub.h>
 #endif
 
 #ifdef GRUB_UTIL
